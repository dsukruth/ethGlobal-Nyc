"use client";
import {
  SeiNotEnabledInKeplrWalletError,
  Wallet,
  WalletConnectorBase,
  assertPackageVersion,
  cloneObjectWithOverrides,
  logger,
  parseChainId,
  parseCosmosNetworks
} from "./chunk-3OCKXW2Z.js";
import "./chunk-7KMCIXGS.js";
import "./chunk-ASWLBWKD.js";
import "./chunk-MMN2DTB3.js";

// node_modules/@dynamic-labs/cosmos/package.js
var version = "4.26.0";

// node_modules/@dynamic-labs/cosmos/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/cosmos/src/wallet/CosmosWallet.js
var CosmosWallet = class extends Wallet {
  sendBalance(_a) {
    return __awaiter(this, arguments, void 0, function* ({ amount, toAddress }) {
      throw new Error("Not implemented");
    });
  }
  getProvider() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = yield this._connector.getProvider();
      if (!provider) {
        throw new Error("unable to retrieve Cosmos provider");
      }
      try {
        return cloneObjectWithOverrides(provider, {
          sendEthereumTx: (chainId, tx) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.sendEthereumTx(chainId, tx);
          }),
          sendTx: (chainId, tx, mode) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.sendTx(chainId, tx, mode);
          }),
          signAmino: (chainId, signer, signerDoc, signerOperations) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.signAmino(chainId, signer, signerDoc, signerOperations);
          }),
          signArbitrary: (chainId, signer, data) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.signArbitrary(chainId, signer, data);
          }),
          signDirect: (chainId, signer, signDoc, signOptions) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.signDirect(chainId, signer, signDoc, signOptions);
          }),
          signDirectAux: (chainId, signer, signDoc, signOptions) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.signDirectAux(chainId, signer, signDoc, signOptions);
          }),
          signEthereum: (chainId, signer, data, type) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.signEthereum(chainId, signer, data, type);
          }),
          signICNSAdr36: (chainId, contractAddress, owner, username, addressChainIds) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return provider.signICNSAdr36(chainId, contractAddress, owner, username, addressChainIds);
          })
        });
      } catch (error) {
        logger.warn(`Failed to add logic to auto-sync the wallet. Provider might be out of sync for wallet: ${this._connector.name} (${this.address})`, error);
        return provider;
      }
    });
  }
  getOfflineSigner() {
    return __awaiter(this, void 0, void 0, function* () {
      const offlineSigner = yield this._connector.getOfflineSigner();
      if (!offlineSigner) {
        throw new Error("unable to retrieve Cosmos offline signer");
      }
      try {
        return cloneObjectWithOverrides(offlineSigner, {
          signAmino: (signerAddress, signerDoc) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return offlineSigner.signAmino(signerAddress, signerDoc);
          }),
          signDirect: (signerAddress, signDoc) => __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return offlineSigner.signDirect(signerAddress, signDoc);
          })
        });
      } catch (error) {
        logger.warn(`Failed to add logic to auto-sync the wallet. Signer might be out of sync for wallet: ${this._connector.name} (${this.address})`, error);
        return offlineSigner;
      }
    });
  }
};

// node_modules/@dynamic-labs/cosmos/src/connectors/CosmosWalletConnector.js
var DYNAMIC_COSMOS_NETWORK_ID = "dynamic_cosmos_network_id";
var CosmosWalletConnector = class extends WalletConnectorBase {
  constructor(opts) {
    var _a;
    super(opts);
    this.switchNetworkOnlyFromWallet = true;
    this.ChainWallet = CosmosWallet;
    this.connectedChain = "COSMOS";
    this.supportedChains = ["COSMOS"];
    this.cosmosNetworks = opts.cosmosNetworks;
    this._handleAccountChange = this._handleAccountChange.bind(this);
    this.experimentalChainsInfo = (_a = opts.connectionConfig) === null || _a === void 0 ? void 0 : _a.experimentalChainInfo;
    if (this.experimentalChainsInfo) {
      this.addExperimentalChains();
    }
  }
  addExperimentalChains() {
    var _a;
    if (!this.experimentalChainsInfo) {
      return;
    }
    for (const experimentalChain of this.experimentalChainsInfo) {
      const randomChainId = Math.random() * 1e4;
      const chainToNetwork = {
        bech32Prefix: (_a = experimentalChain.bech32Config) === null || _a === void 0 ? void 0 : _a.bech32PrefixAccAddr,
        blockExplorerUrls: [],
        chainId: randomChainId,
        iconUrls: [experimentalChain.chainSymbolImageUrl],
        name: experimentalChain.chainId,
        nativeCurrency: {
          decimals: experimentalChain.currencies[0].coinDecimals,
          name: experimentalChain.currencies[0].coinDenom,
          symbol: experimentalChain.currencies[0].coinDenom
        },
        networkId: randomChainId,
        rpcUrls: [experimentalChain.rpc],
        shortName: experimentalChain.chainName,
        supportedChainIds: [experimentalChain.chainId],
        supportedFeatures: [],
        supportedMethods: [],
        supportedSignMethods: [],
        vanityName: experimentalChain.chainName
      };
      if (!this.cosmosNetworks.find((network) => network.vanityName === chainToNetwork.vanityName)) {
        this.cosmosNetworks.push(chainToNetwork);
      }
    }
  }
  get evmNetworks() {
    return parseCosmosNetworks(this.cosmosNetworks);
  }
  get chainIdMapping() {
    return this.evmNetworks.map((network) => ({
      bech32Prefix: network.bech32Prefix,
      cosmosNetwork: network,
      cosmosNetworkId: network.name,
      dynamicChainId: parseChainId(network.networkId),
      experimental: this.isExperimentalChain(network)
    }));
  }
  isExperimentalChain(cosmosNetwork) {
    var _a, _b;
    return (_b = (_a = this.experimentalChainsInfo) === null || _a === void 0 ? void 0 : _a.some((chain) => chain.chainId === cosmosNetwork.name)) !== null && _b !== void 0 ? _b : false;
  }
  getSelectedChain() {
    const selectedNetwork = this.chainIdMapping.find((mapping) => mapping.cosmosNetworkId === this.getChainId());
    return selectedNetwork === null || selectedNetwork === void 0 ? void 0 : selectedNetwork.cosmosNetwork;
  }
  getNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      return (_a = this.getSelectedChain()) === null || _a === void 0 ? void 0 : _a.chainId;
    });
  }
  getLcdUrl() {
    var _a;
    return (_a = this.getSelectedChain()) === null || _a === void 0 ? void 0 : _a.lcdUrl;
  }
  getDenom() {
    var _a;
    return (_a = this.getSelectedChain()) === null || _a === void 0 ? void 0 : _a.nativeCurrency.denom;
  }
  getBalance(address) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const response = yield fetch(`${this.getLcdUrl()}/cosmos/bank/v1beta1/balances/${address}`).then((res) => res.json());
        const balance = response.balances.reduce((acc, cur) => {
          if (cur.denom === this.getDenom()) {
            return Number(cur.amount) / 1e6;
          }
          return acc;
        }, 0);
        return balance.toString();
      } catch (e) {
        logger.error(e);
        return "0";
      }
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const address = yield this.getAddress();
      return address ? [address] : [];
    });
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      this.setChainId(null);
    });
  }
  getDefaultChainId() {
    if (this.chainIdMapping.length === 0) {
      return "cosmoshub-4";
    }
    if (this.chainIdMapping.find((chain) => chain.cosmosNetworkId === "cosmoshub-4")) {
      return "cosmoshub-4";
    } else {
      return this.chainIdMapping[0].cosmosNetworkId;
    }
  }
  getChainId() {
    const defaultChainId = this.getDefaultChainId();
    const storedChainId = localStorage.getItem(DYNAMIC_COSMOS_NETWORK_ID);
    return storedChainId !== null && storedChainId !== void 0 ? storedChainId : defaultChainId;
  }
  setChainId(chainId) {
    if (!chainId) {
      localStorage.removeItem(DYNAMIC_COSMOS_NETWORK_ID);
    } else {
      localStorage.setItem(DYNAMIC_COSMOS_NETWORK_ID, chainId);
    }
  }
  getAccount() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const wallet = this.getWallet();
      if (!wallet) {
        return void 0;
      } else {
        const accountsList = yield (_a = yield this.getOfflineSigner()) === null || _a === void 0 ? void 0 : _a.getAccounts();
        if (!accountsList || accountsList.length === 0) {
          logger.warn("No accounts found for chain", this.getChainId());
          return void 0;
        }
        const [account] = accountsList;
        return account;
      }
    });
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      yield (_a = this.getWallet()) === null || _a === void 0 ? void 0 : _a.enable(this.chainIdMapping.filter((mapping) => !mapping.experimental).map((mapping) => mapping.cosmosNetworkId));
    });
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.connect();
      const account = yield this.getAccount();
      return account === null || account === void 0 ? void 0 : account.address;
    });
  }
  getProvider() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getWallet();
    });
  }
  getOfflineSigner() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      return (_a = this.getWallet()) === null || _a === void 0 ? void 0 : _a.getOfflineSigner(this.getChainId());
    });
  }
  isInstalledOnBrowser() {
    return typeof this.getWallet() !== "undefined";
  }
  _handleAccountChange() {
    return __awaiter(this, void 0, void 0, function* () {
      const address = yield this.getAddress();
      if (address) {
        this.emit("accountChange", { accounts: [address] });
      }
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const address = yield this.getAddress();
      if (!address)
        throw new Error("No address found");
      const signatureResponse = yield (_a = this.getWallet()) === null || _a === void 0 ? void 0 : _a.signArbitrary(this.getChainId(), address, messageToSign);
      if (!signatureResponse) {
        throw new Error("Could not sign message");
      }
      const chain = this.getSelectedChain();
      if (!chain || !chain.bech32Prefix) {
        throw new Error("Could not get bech32Prefix for chain");
      }
      const signatureWithPrefix = Object.assign(Object.assign({}, signatureResponse), { bech32Prefix: chain.bech32Prefix });
      return JSON.stringify(signatureWithPrefix);
    });
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      return ["https://www.mintscan.io/cosmos/"];
    });
  }
  getEnabledNetworks() {
    return this.evmNetworks;
  }
  supportsNetworkSwitching() {
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  validateActiveWallet(expectedAddress) {
    return __awaiter(this, void 0, void 0, function* () {
      return;
    });
  }
  switchNetwork(_a) {
    return __awaiter(this, arguments, void 0, function* ({ networkChainId }) {
      if (!networkChainId)
        return;
      this.chainIdMapping.forEach((mapping) => {
        if (mapping.dynamicChainId === networkChainId) {
          this.setChainId(mapping.cosmosNetworkId);
          this.emit("chainChange", { chain: networkChainId.toString() });
        }
      });
    });
  }
};

// node_modules/@dynamic-labs/cosmos/src/connectors/KeplrWalletConnector.js
var isSeiNotEnabledError = (error) => {
  if (!error || !Object.prototype.hasOwnProperty.call(error, "message") || typeof error.message !== "string")
    return false;
  return error.message.includes("There is no modular chain info for pacific-1");
};
var KeplrWalletConnector = class extends CosmosWalletConnector {
  constructor() {
    super(...arguments);
    this.name = "Keplr";
    this.overrideKey = "keplr";
  }
  supportsNetworkSwitching() {
    return true;
  }
  getWallet() {
    if (typeof window === "undefined") {
      throw new Error("Keplr is not available");
    }
    return window.keplr;
  }
  connect() {
    const _super = Object.create(null, {
      connect: { get: () => super.connect }
    });
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      try {
        yield _super.connect.call(this);
        if (this.experimentalChainsInfo) {
          for (const chain of this.experimentalChainsInfo) {
            yield (_a = this.getWallet()) === null || _a === void 0 ? void 0 : _a.experimentalSuggestChain(chain);
          }
        }
      } catch (error) {
        if (isSeiNotEnabledError(error)) {
          if (this.cosmosNetworks.length === 1) {
            throw new SeiNotEnabledInKeplrWalletError();
          }
          this.cosmosNetworks = this.cosmosNetworks.filter((network) => network.name !== "pacific-1");
          yield _super.connect.call(this);
        } else {
          throw error;
        }
      }
    });
  }
  setupEventListeners() {
    window.addEventListener("keplr_keystorechange", this._handleAccountChange);
  }
  teardownEventListeners() {
    window.removeEventListener("keplr_keystorechange", this._handleAccountChange);
    this.setChainId(null);
  }
};

// node_modules/@dynamic-labs/cosmos/src/wallet/isCosmosWallet/isCosmosWallet.js
var isCosmosWallet = (wallet) => wallet.chain === "COSMOS";

// node_modules/@dynamic-labs/cosmos/src/connectors/LeapWalletConnector.js
var LeapWalletConnector = class extends CosmosWalletConnector {
  constructor() {
    super(...arguments);
    this.name = "leapcosmos";
    this.overrideKey = "leapcosmos";
  }
  getWallet() {
    if (typeof window === "undefined")
      throw new Error("Leap is not available");
    return window.leap;
  }
  setupEventListeners() {
    window.addEventListener("leap_keystorechange", this._handleAccountChange);
  }
  teardownEventListeners() {
    window.removeEventListener("leap_keystorechange", this._handleAccountChange);
    this.setChainId(null);
  }
};

// node_modules/@dynamic-labs/cosmos/src/connectors/CompassWalletConnector.js
var CompassWalletConnector = class extends CosmosWalletConnector {
  constructor() {
    super(...arguments);
    this.name = "compasscosmos";
    this.overrideKey = "compasscosmos";
  }
  getWallet() {
    if (typeof window === "undefined") {
      throw new Error("Compass is not available");
    }
    return window.compass;
  }
  getChainId() {
    const hasSei = this.chainIdMapping.find((chain) => chain.cosmosNetworkId === "pacific-1");
    if (!hasSei) {
      throw new Error("Sei is not available on this site");
    } else {
      return "pacific-1";
    }
  }
  setupEventListeners() {
    window.addEventListener("leap_keystorechange", this._handleAccountChange);
  }
  teardownEventListeners() {
    window.removeEventListener("leap_keystorechange", this._handleAccountChange);
    this.setChainId(null);
  }
};

// node_modules/@dynamic-labs/cosmos/src/CosmosWalletConnectorsWithConfig.js
var CosmosWalletConnectorsWithConfig = (connectionConfig) => {
  const classWithConfig = (className) => class extends className {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...args) {
      const [opts] = args;
      super(Object.assign(Object.assign({}, opts), { connectionConfig }));
    }
  };
  return () => CosmosWalletConnectors().map(classWithConfig);
};

// node_modules/@dynamic-labs/cosmos/src/index.js
assertPackageVersion("@dynamic-labs/cosmos", version);
var CosmosWalletConnectors = () => [
  KeplrWalletConnector,
  LeapWalletConnector,
  CompassWalletConnector
];
export {
  CosmosWallet,
  CosmosWalletConnectors,
  CosmosWalletConnectorsWithConfig,
  isCosmosWallet
};
//# sourceMappingURL=@dynamic-labs_cosmos.js.map
