"use client";
import {
  A,
  B,
  Contract,
  F,
  M,
  R,
  RpcProvider2,
  S,
  S2,
  T,
  T2,
  U,
  U2,
  W,
  WalletAccount,
  cairo_exports,
  constants_exports,
  l,
  main,
  num_exports,
  q
} from "./chunk-3E3KQOKS.js";
import {
  ChainRpcProviders,
  ProviderChain
} from "./chunk-CLTFP3BU.js";
import {
  DynamicError,
  LogLevel,
  Logger,
  PlatformService,
  Wallet,
  WalletConnectorBase,
  assertPackageVersion,
  isMobile,
  logger,
  retryableFn,
  template,
  wrapMethodWithCallback
} from "./chunk-3OCKXW2Z.js";
import "./chunk-7KMCIXGS.js";
import "./chunk-ASWLBWKD.js";
import {
  __export
} from "./chunk-MMN2DTB3.js";

// node_modules/@dynamic-labs/starknet/package.js
var version = "4.26.0";

// node_modules/@dynamic-labs/starknet/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/starknetkit/dist/index-8edbd361.js
var On = Object.defineProperty;
var Sn = (t, e, r) => e in t ? On(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var Te = (t, e, r) => (Sn(t, typeof e != "symbol" ? e + "" : e, r), r);
var Tr = "https://web.argent.xyz";
var rr = `<svg
    width="32"
    height="28"
    viewBox="0 0 18 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M1.5 0.4375C0.982233 0.4375 0.5625 0.857233 0.5625 1.375V12C0.5625 12.4144 0.72712 12.8118 1.02015 13.1049C1.31317 13.3979 1.7106 13.5625 2.125 13.5625H15.875C16.2894 13.5625 16.6868 13.3979 16.9799 13.1049C17.2729 12.8118 17.4375 12.4144 17.4375 12V1.375C17.4375 0.857233 17.0178 0.4375 16.5 0.4375H1.5ZM2.4375 3.50616V11.6875H15.5625V3.50616L9.63349 8.94108C9.27507 9.26964 8.72493 9.26964 8.36651 8.94108L2.4375 3.50616ZM14.0899 2.3125H3.91013L9 6.97822L14.0899 2.3125Z"
      fill="currentColor"
    />
  </svg>`;
var In = "https://static.hydrogen.argent47.net/webwallet/iframe_whitelist_testnet.json";
var jn = "https://static.argent.net/webwallet/iframe_whitelist_mainnet.json";
var Ln = class extends Error {
  constructor(r, n2) {
    super(r);
    Te(this, "code");
    this.name = "ConnectAndSignSessionError", this.code = n2;
  }
};
var $n = class extends Error {
  constructor(r, n2) {
    super(r);
    Te(this, "code");
    this.name = "WebwalletError", this.code = n2;
  }
};
var Q = constants_exports.NetworkName;
var Mn = Q.SN_SEPOLIA;
function Dn(t) {
  try {
    const { origin: e } = new URL(t);
    if (e.includes("localhost") || e.includes("127.0.0.1"))
      return Mn;
    if (e.includes("hydrogen") || e.includes("sepolia-web.staging"))
      return Q.SN_SEPOLIA;
    if (e.includes("staging"))
      return Q.SN_MAIN;
    if (e.includes("dev") || e.includes("sepolia-web.argent.xyz"))
      return Q.SN_SEPOLIA;
    if (e.includes("argent.xyz"))
      return Q.SN_MAIN;
  } catch {
    console.warn(
      "Could not determine network from target URL, defaulting to mainnet-alpha"
    );
  }
  return Q.SN_MAIN;
}
var Zn = 385;
var Un = 775;
var Wn = 385;
var qn = 440;
var zn = 420;
var Bn = 438;
function Vn(t) {
  return t;
}
function Fn(t) {
  return t.length === 0 ? Vn : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n2, s) => s(n2), r);
  };
}
function Hn(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function nt(t) {
  const e = {
    subscribe(r) {
      let n2 = null, s = false, a = false, i3 = false;
      function o2() {
        if (n2 === null) {
          i3 = true;
          return;
        }
        a || (a = true, typeof n2 == "function" ? n2() : n2 && n2.unsubscribe());
      }
      return n2 = t({
        next(c2) {
          s || r.next?.(c2);
        },
        error(c2) {
          s || (s = true, r.error?.(c2), o2());
        },
        complete() {
          s || (s = true, r.complete?.(), o2());
        }
      }), i3 && o2(), {
        unsubscribe: o2
      };
    },
    pipe(...r) {
      return Fn(r)(e);
    }
  };
  return e;
}
function Er(t) {
  return (e) => {
    let r = 0, n2 = null;
    const s = [];
    function a() {
      n2 || (n2 = e.subscribe({
        next(o2) {
          for (const c2 of s)
            c2.next?.(o2);
        },
        error(o2) {
          for (const c2 of s)
            c2.error?.(o2);
        },
        complete() {
          for (const o2 of s)
            o2.complete?.();
        }
      }));
    }
    function i3() {
      if (r === 0 && n2) {
        const o2 = n2;
        n2 = null, o2.unsubscribe();
      }
    }
    return {
      subscribe(o2) {
        return r++, s.push(o2), a(), {
          unsubscribe() {
            r--, i3();
            const c2 = s.findIndex((u) => u === o2);
            c2 > -1 && s.splice(c2, 1);
          }
        };
      }
    };
  };
}
function Gn(t) {
  return (e) => ({
    subscribe(r) {
      let n2 = 0;
      return e.subscribe({
        next(a) {
          r.next?.(t(a, n2++));
        },
        error(a) {
          r.error?.(a);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function Cr(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n2) {
          t.next?.(n2), r.next?.(n2);
        },
        error(n2) {
          t.error?.(n2), r.error?.(n2);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
var Jn = class Rr extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Rr.prototype);
  }
};
function Or(t) {
  let e;
  return {
    promise: new Promise((n2, s) => {
      let a = false;
      function i3() {
        a || (a = true, s(new Jn("This operation was aborted.")), o2.unsubscribe());
      }
      const o2 = t.subscribe({
        next(c2) {
          a = true, n2(c2), i3();
        },
        error(c2) {
          a = true, s(c2), i3();
        },
        complete() {
          a = true, i3();
        }
      });
      e = i3;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
var Yn = Object.freeze(Object.defineProperty({
  __proto__: null,
  isObservable: Hn,
  map: Gn,
  observable: nt,
  observableToPromise: Or,
  share: Er,
  tap: Cr
}, Symbol.toStringTag, { value: "Module" }));
function Sr(t) {
  return nt((e) => {
    function r(s = 0, a = t.op) {
      const i3 = t.links[s];
      if (!i3)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return i3({
        op: a,
        next(c2) {
          return r(s + 1, c2);
        }
      });
    }
    return r().subscribe(e);
  });
}
function nr(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function Xn(t) {
  return (e) => {
    const r = nr(t.true).map((s) => s(e)), n2 = nr(t.false).map((s) => s(e));
    return (s) => nt((a) => {
      const i3 = t.condition(s.op) ? r : n2;
      return Sr({
        op: s.op,
        links: i3
      }).subscribe(a);
    });
  };
}
function Pr(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r in t) {
    const n2 = t[r];
    e[n2] = r;
  }
  return e;
}
var st = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
Pr(st);
Pr(st);
var Qn = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function Kn(t) {
  return Qn[t] ?? 500;
}
function Ar(t) {
  return Kn(t.code);
}
var Nr = () => {
};
function Ir(t, e) {
  return new Proxy(Nr, {
    get(n2, s) {
      if (!(typeof s != "string" || s === "then"))
        return Ir(t, [
          ...e,
          s
        ]);
    },
    apply(n2, s, a) {
      const i3 = e[e.length - 1] === "apply";
      return t({
        args: i3 ? a.length >= 2 ? a[1] : [] : a,
        path: i3 ? e.slice(0, -1) : e
      });
    }
  });
}
var Zt = (t) => Ir(t, []);
var Ut = (t) => new Proxy(Nr, {
  get(e, r) {
    if (!(typeof r != "string" || r === "then"))
      return t(r);
  }
});
function es(t) {
  const { path: e, error: r, config: n2 } = t, { code: s } = t.error, a = {
    message: r.message,
    code: st[s],
    data: {
      code: s,
      httpStatus: Ar(r)
    }
  };
  return n2.isDev && typeof t.error.stack == "string" && (a.data.stack = t.error.stack), typeof e == "string" && (a.data.path = e), n2.errorFormatter({
    ...t,
    shape: a
  });
}
function sr(t, e) {
  return "error" in e ? {
    ...e,
    error: t.transformer.output.serialize(e.error)
  } : "data" in e.result ? {
    ...e,
    result: {
      ...e.result,
      data: t.transformer.output.serialize(e.result.data)
    }
  } : e;
}
function ts(t, e) {
  return Array.isArray(e) ? e.map((r) => sr(t, r)) : sr(t, e);
}
function rs(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
var ns = class extends Error {
};
function Wt(t) {
  if (t instanceof Error)
    return t;
  const e = typeof t;
  if (!(e === "undefined" || e === "function" || t === null)) {
    if (e !== "object")
      return new Error(String(t));
    if (rs(t)) {
      const r = new ns();
      for (const n2 in t)
        r[n2] = t[n2];
      return r;
    }
  }
}
var ss = Object.freeze(Object.defineProperty({
  __proto__: null,
  createFlatProxy: Ut,
  createRecursiveProxy: Zt,
  getCauseFromUnknown: Wt,
  getErrorShape: es,
  transformTRPCResponse: ts
}, Symbol.toStringTag, { value: "Module" }));
function ar(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function as(t) {
  return t instanceof jr || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function is(t) {
  return ar(t) && ar(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
var jr = class Ee extends Error {
  static from(e, r = {}) {
    const n2 = e;
    return as(n2) ? (r.meta && (n2.meta = {
      ...n2.meta,
      ...r.meta
    }), n2) : is(n2) ? new Ee(n2.error.message, {
      ...r,
      result: n2
    }) : n2 instanceof Error ? new Ee(n2.message, {
      ...r,
      cause: Wt(n2)
    }) : new Ee("Unknown error", {
      ...r,
      cause: n2
    });
  }
  constructor(e, r) {
    const n2 = r?.cause;
    super(e, {
      cause: n2
    }), this.meta = r?.meta, this.cause = n2, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Ee.prototype);
  }
};
function os(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var mt = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function cs(t) {
  const { direction: e, type: r, path: n2, id: s, input: a } = t, i3 = [], o2 = [];
  if (t.colorMode === "ansi") {
    const [h, y] = mt.ansi.regular[r], [k3, T5] = mt.ansi.bold[r], A2 = "\x1B[0m";
    return i3.push(e === "up" ? h : y, e === "up" ? ">>" : "<<", r, e === "up" ? k3 : T5, `#${s}`, n2, A2), e === "up" ? o2.push({
      input: t.input
    }) : o2.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: i3,
      args: o2
    };
  }
  const [c2, u] = mt.css[r], d = `
    background-color: #${e === "up" ? c2 : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return i3.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n2}%c`, "%O"), o2.push(d, `${d}; font-weight: bold;`, `${d}; font-weight: normal;`), e === "up" ? o2.push({
    input: a,
    context: t.context
  }) : o2.push({
    input: a,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: i3,
    args: o2
  };
}
var us = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n2 = r.input, s = os(n2) ? Object.fromEntries(n2) : n2, { parts: a, args: i3 } = cs({
    ...r,
    colorMode: e,
    input: s
  }), o2 = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o2].apply(null, [
    a.join(" ")
  ].concat(i3));
};
function ls(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n2 = us({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: a }) => nt((i3) => {
    e({
      ...s,
      direction: "up"
    }) && n2({
      ...s,
      direction: "up"
    });
    const o2 = Date.now();
    function c2(u) {
      const d = Date.now() - o2;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n2({
        ...s,
        direction: "down",
        elapsedMs: d,
        result: u
      });
    }
    return a(s).pipe(Cr({
      next(u) {
        c2(u);
      },
      error(u) {
        c2(u);
      }
    })).subscribe(i3);
  });
}
var ds = class {
  $request({ type: e, input: r, path: n2, context: s = {} }) {
    return Sr({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n2,
        input: r,
        context: s
      }
    }).pipe(Er());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n2, abort: s } = Or(r);
    return new Promise((i3, o2) => {
      e.signal?.addEventListener("abort", s), n2.then((c2) => {
        i3(c2.result.data);
      }).catch((c2) => {
        o2(jr.from(c2));
      });
    });
  }
  query(e, r, n2) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n2?.context,
      signal: n2?.signal
    });
  }
  mutation(e, r, n2) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n2?.context,
      signal: n2?.signal
    });
  }
  subscription(e, r, n2) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n2?.context
    }).subscribe({
      next(a) {
        a.result.type === "started" ? n2.onStarted?.() : a.result.type === "stopped" ? n2.onStopped?.() : n2.onData?.(a.result.data);
      },
      error(a) {
        n2.onError?.(a);
      },
      complete() {
        n2.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n2 = e.transformer;
      return n2 ? "input" in n2 ? e.transformer : {
        input: n2,
        output: n2
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n2) => r.input.serialize(n2),
        deserialize: (n2) => r.output.deserialize(n2)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n2) => n2(this.runtime));
  }
};
var fs = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var ps = (t) => fs[t];
function hs(t) {
  return Ut((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Zt(({ path: r, args: n2 }) => {
    const s = [
      e,
      ...r
    ], a = ps(s.pop()), i3 = s.join(".");
    return t[a](i3, ...n2);
  }));
}
function ms(t) {
  const e = new ds(t);
  return hs(e);
}
function ys(t) {
  if (t instanceof ye || t instanceof Error && t.name === "TRPCError")
    return t;
  const e = new ye({
    code: "INTERNAL_SERVER_ERROR",
    cause: t
  });
  return t instanceof Error && t.stack && (e.stack = t.stack), e;
}
var ye = class extends Error {
  constructor(e) {
    const r = Wt(e.cause), n2 = e.message ?? r?.message ?? e.code;
    super(n2, {
      cause: r
    }), this.code = e.code, this.name = "TRPCError", this.cause || (this.cause = r);
  }
};
function gs(t) {
  return "input" in t ? t : {
    input: t,
    output: t
  };
}
var Se = {
  _default: true,
  input: {
    serialize: (t) => t,
    deserialize: (t) => t
  },
  output: {
    serialize: (t) => t,
    deserialize: (t) => t
  }
};
var Pe = ({ shape: t }) => t;
function _s(t) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t);
}
var vs = [
  "query",
  "mutation",
  "subscription"
];
function bs(t) {
  return "router" in t._def;
}
var ws = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: Pe,
  transformer: Se
};
var xs = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function Lr(t) {
  return function(r) {
    const n2 = new Set(Object.keys(r).filter((c2) => xs.includes(c2)));
    if (n2.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n2).join(", "));
    const s = _s({});
    function a(c2, u = "") {
      for (const [d, h] of Object.entries(c2 ?? {})) {
        const y = `${u}${d}`;
        if (bs(h)) {
          a(h._def.procedures, `${y}.`);
          continue;
        }
        if (s[y])
          throw new Error(`Duplicate key: ${y}`);
        s[y] = h;
      }
    }
    a(r);
    const i3 = {
      _config: t,
      router: true,
      procedures: s,
      ...ws,
      record: r,
      queries: Object.entries(s).filter((c2) => c2[1]._def.query).reduce((c2, [u, d]) => ({
        ...c2,
        [u]: d
      }), {}),
      mutations: Object.entries(s).filter((c2) => c2[1]._def.mutation).reduce((c2, [u, d]) => ({
        ...c2,
        [u]: d
      }), {}),
      subscriptions: Object.entries(s).filter((c2) => c2[1]._def.subscription).reduce((c2, [u, d]) => ({
        ...c2,
        [u]: d
      }), {})
    }, o2 = {
      ...r,
      _def: i3,
      createCaller(c2) {
        return $r()(o2)(c2);
      },
      getErrorShape(c2) {
        const { path: u, error: d } = c2, { code: h } = c2.error, y = {
          message: d.message,
          code: st[h],
          data: {
            code: h,
            httpStatus: Ar(d)
          }
        };
        return t.isDev && typeof c2.error.stack == "string" && (y.data.stack = c2.error.stack), typeof u == "string" && (y.data.path = u), this._def._config.errorFormatter({
          ...c2,
          shape: y
        });
      }
    };
    return o2;
  };
}
function ks(t) {
  const { type: e, path: r } = t;
  if (!(r in t.procedures) || !t.procedures[r]?._def[e])
    throw new ye({
      code: "NOT_FOUND",
      message: `No "${e}"-procedure on path "${r}"`
    });
  const n2 = t.procedures[r];
  return n2(t);
}
function $r() {
  return function(e) {
    const r = e._def;
    return function(s) {
      return Zt(({ path: i3, args: o2 }) => {
        if (i3.length === 1 && vs.includes(i3[0]))
          return ks({
            procedures: r.procedures,
            path: o2[0],
            rawInput: o2[1],
            ctx: s,
            type: i3[0]
          });
        const c2 = i3.join("."), u = r.procedures[c2];
        let d = "query";
        return u._def.mutation ? d = "mutation" : u._def.subscription && (d = "subscription"), u({
          path: c2,
          rawInput: o2[0],
          ctx: s,
          type: d
        });
      });
    };
  };
}
var ir = typeof window > "u" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
function or(t) {
  const e = t;
  if (typeof e == "function")
    return e;
  if (typeof e.parseAsync == "function")
    return e.parseAsync.bind(e);
  if (typeof e.parse == "function")
    return e.parse.bind(e);
  if (typeof e.validateSync == "function")
    return e.validateSync.bind(e);
  if (typeof e.create == "function")
    return e.create.bind(e);
  if (typeof e.assert == "function")
    return (r) => (e.assert(r), r);
  throw new Error("Could not find a validator fn");
}
function Mr(t, ...e) {
  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
  for (const n2 of e)
    for (const s in n2) {
      if (s in r && r[s] !== n2[s])
        throw new Error(`Duplicate key ${s}`);
      r[s] = n2[s];
    }
  return r;
}
function Ts() {
  function t(r) {
    return {
      _middlewares: r,
      unstable_pipe(n2) {
        const s = "_middlewares" in n2 ? n2._middlewares : [
          n2
        ];
        return t([
          ...r,
          ...s
        ]);
      }
    };
  }
  function e(r) {
    return t([
      r
    ]);
  }
  return e;
}
function cr(t) {
  return t && typeof t == "object" && !Array.isArray(t);
}
function Es(t) {
  const e = async ({ next: r, rawInput: n2, input: s }) => {
    let a;
    try {
      a = await t(n2);
    } catch (o2) {
      throw new ye({
        code: "BAD_REQUEST",
        cause: o2
      });
    }
    const i3 = cr(s) && cr(a) ? {
      ...s,
      ...a
    } : a;
    return r({
      input: i3
    });
  };
  return e._type = "input", e;
}
function Cs(t) {
  const e = async ({ next: r }) => {
    const n2 = await r();
    if (!n2.ok)
      return n2;
    try {
      const s = await t(n2.data);
      return {
        ...n2,
        data: s
      };
    } catch (s) {
      throw new ye({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: s
      });
    }
  };
  return e._type = "output", e;
}
var Dr = "middlewareMarker";
function fe(t, e) {
  const { middlewares: r = [], inputs: n2, meta: s, ...a } = e;
  return Zr({
    ...Mr(t, a),
    inputs: [
      ...t.inputs,
      ...n2 ?? []
    ],
    middlewares: [
      ...t.middlewares,
      ...r
    ],
    meta: t.meta && s ? {
      ...t.meta,
      ...s
    } : s ?? t.meta
  });
}
function Zr(t = {}) {
  const e = {
    inputs: [],
    middlewares: [],
    ...t
  };
  return {
    _def: e,
    input(r) {
      const n2 = or(r);
      return fe(e, {
        inputs: [
          r
        ],
        middlewares: [
          Es(n2)
        ]
      });
    },
    output(r) {
      const n2 = or(r);
      return fe(e, {
        output: r,
        middlewares: [
          Cs(n2)
        ]
      });
    },
    meta(r) {
      return fe(e, {
        meta: r
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(r) {
      return fe(e, r._def);
    },
    use(r) {
      const n2 = "_middlewares" in r ? r._middlewares : [
        r
      ];
      return fe(e, {
        middlewares: n2
      });
    },
    query(r) {
      return yt({
        ...e,
        query: true
      }, r);
    },
    mutation(r) {
      return yt({
        ...e,
        mutation: true
      }, r);
    },
    subscription(r) {
      return yt({
        ...e,
        subscription: true
      }, r);
    }
  };
}
function yt(t, e) {
  const r = fe(t, {
    resolver: e,
    middlewares: [
      async function(s) {
        const a = await e(s);
        return {
          marker: Dr,
          ok: true,
          data: a,
          ctx: s.ctx
        };
      }
    ]
  });
  return Os(r._def);
}
var Rs = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
function Os(t) {
  const e = async function(n2) {
    if (!n2 || !("rawInput" in n2))
      throw new Error(Rs);
    const s = async (i3 = {
      index: 0,
      ctx: n2.ctx
    }) => {
      try {
        const o2 = t.middlewares[i3.index];
        return await o2({
          ctx: i3.ctx,
          type: n2.type,
          path: n2.path,
          rawInput: i3.rawInput ?? n2.rawInput,
          meta: t.meta,
          input: i3.input,
          next(u) {
            const d = u;
            return s({
              index: i3.index + 1,
              ctx: d && "ctx" in d ? {
                ...i3.ctx,
                ...d.ctx
              } : i3.ctx,
              input: d && "input" in d ? d.input : i3.input,
              rawInput: d && "rawInput" in d ? d.rawInput : i3.rawInput
            });
          }
        });
      } catch (o2) {
        return {
          ok: false,
          error: ys(o2),
          marker: Dr
        };
      }
    }, a = await s();
    if (!a)
      throw new ye({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!a.ok)
      throw a.error;
    return a.data;
  };
  return e._def = t, e.meta = t.meta, e;
}
function Ss(...t) {
  const e = Mr({}, ...t.map((a) => a._def.record)), r = t.reduce((a, i3) => {
    if (i3._def._config.errorFormatter && i3._def._config.errorFormatter !== Pe) {
      if (a !== Pe && a !== i3._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return i3._def._config.errorFormatter;
    }
    return a;
  }, Pe), n2 = t.reduce((a, i3) => {
    if (i3._def._config.transformer && i3._def._config.transformer !== Se) {
      if (a !== Se && a !== i3._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return i3._def._config.transformer;
    }
    return a;
  }, Se);
  return Lr({
    errorFormatter: r,
    transformer: n2,
    isDev: t.some((a) => a._def._config.isDev),
    allowOutsideOfServer: t.some((a) => a._def._config.allowOutsideOfServer),
    isServer: t.some((a) => a._def._config.isServer),
    $types: t[0]?._def._config.$types
  })(e);
}
var Je = class _Je {
  context() {
    return new _Je();
  }
  meta() {
    return new _Je();
  }
  create(e) {
    return As()(e);
  }
};
var Ps = new Je();
function As() {
  return function(e) {
    const r = e?.errorFormatter ?? Pe, s = {
      transformer: gs(e?.transformer ?? Se),
      isDev: e?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: e?.allowOutsideOfServer ?? false,
      errorFormatter: r,
      isServer: e?.isServer ?? ir,
      /**
      * @internal
      */
      $types: Ut((a) => {
        throw new Error(`Tried to access "$types.${a}" which is not available at runtime`);
      })
    };
    if (!(e?.isServer ?? ir) && e?.allowOutsideOfServer !== true)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: s,
      /**
      * Builder object for creating procedures
      * @see https://trpc.io/docs/server/procedures
      */
      procedure: Zr({
        meta: e?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      * @see https://trpc.io/docs/server/middlewares
      */
      middleware: Ts(),
      /**
      * Create a router
      * @see https://trpc.io/docs/server/routers
      */
      router: Lr(s),
      /**
      * Merge Routers
      * @see https://trpc.io/docs/server/merging-routers
      */
      mergeRouters: Ss,
      /**
      * Create a server-side caller for a router
      * @see https://trpc.io/docs/server/server-side-calls
      */
      createCallerFactory: $r()
    };
  };
}
var Rt = {};
var at = {};
var be = {};
var S3 = {};
var we = S(Yn);
var qt = {};
var Ur = we;
function Wr(t) {
  return Ur.observable((e) => {
    function r(s = 0, a = t.op) {
      const i3 = t.links[s];
      if (!i3)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return i3({
        op: a,
        next(c2) {
          return r(s + 1, c2);
        }
      });
    }
    return r().subscribe(e);
  });
}
function ur(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function Ns(t) {
  return (e) => {
    const r = ur(t.true).map((s) => s(e)), n2 = ur(t.false).map((s) => s(e));
    return (s) => Ur.observable((a) => {
      const i3 = t.condition(s.op) ? r : n2;
      return Wr({
        op: s.op,
        links: i3
      }).subscribe(a);
    });
  };
}
qt.createChain = Wr;
qt.splitLink = Ns;
var xe = {};
var qr = S(ss);
var ke = {};
function Ot(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function Is(t, e) {
  if ("error" in t) {
    const n2 = e.transformer.deserialize(t.error);
    return {
      ok: false,
      error: {
        ...t,
        error: n2
      }
    };
  }
  return {
    ok: true,
    result: {
      ...t.result,
      ...(!t.result.type || t.result.type === "data") && {
        type: "data",
        data: e.transformer.deserialize(t.result.data)
      }
    }
  };
}
var gt = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function js(t, e) {
  let r;
  try {
    r = Is(t, e);
  } catch {
    throw new gt();
  }
  if (!r.ok && (!Ot(r.error.error) || typeof r.error.error.code != "number"))
    throw new gt();
  if (r.ok && !Ot(r.result))
    throw new gt();
  return r;
}
ke.isObject = Ot;
ke.transformResult = js;
var Ls = qr;
var lr = ke;
function $s(t) {
  return t instanceof zr || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function Ms(t) {
  return lr.isObject(t) && lr.isObject(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
var zr = class Ce extends Error {
  static from(e, r = {}) {
    const n2 = e;
    return $s(n2) ? (r.meta && (n2.meta = {
      ...n2.meta,
      ...r.meta
    }), n2) : Ms(n2) ? new Ce(n2.error.message, {
      ...r,
      result: n2
    }) : n2 instanceof Error ? new Ce(n2.message, {
      ...r,
      cause: Ls.getCauseFromUnknown(n2)
    }) : new Ce("Unknown error", {
      ...r,
      cause: n2
    });
  }
  constructor(e, r) {
    const n2 = r?.cause;
    super(e, {
      cause: n2
    }), this.meta = r?.meta, this.cause = n2, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Ce.prototype);
  }
};
xe.TRPCClientError = zr;
var F2 = {};
var Ds = xe;
var dr = (t) => typeof t == "function";
function Br(t) {
  if (t)
    return t;
  if (typeof window < "u" && dr(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && dr(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function Zs(t) {
  return t || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function Us(t) {
  return {
    url: t.url.toString().replace(/\/$/, ""),
    fetch: t.fetch,
    AbortController: Zs(t.AbortController)
  };
}
function Ws(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n2 = t[r];
    e[r] = n2;
  }
  return e;
}
var qs = {
  query: "GET",
  mutation: "POST"
};
function Vr(t) {
  return "input" in t ? t.runtime.transformer.serialize(t.input) : Ws(t.inputs.map((e) => t.runtime.transformer.serialize(e)));
}
var Fr = (t) => {
  let e = t.url + "/" + t.path;
  const r = [];
  if ("inputs" in t && r.push("batch=1"), t.type === "query") {
    const n2 = Vr(t);
    n2 !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n2))}`);
  }
  return r.length && (e += "?" + r.join("&")), e;
};
var Hr = (t) => {
  if (t.type === "query")
    return;
  const e = Vr(t);
  return e !== void 0 ? JSON.stringify(e) : void 0;
};
var zs = (t) => Jr({
  ...t,
  contentTypeHeader: "application/json",
  getUrl: Fr,
  getBody: Hr
});
async function Gr(t, e) {
  const r = t.getUrl(t), n2 = t.getBody(t), { type: s } = t, a = await t.headers();
  if (s === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const i3 = {
    ...t.contentTypeHeader ? {
      "content-type": t.contentTypeHeader
    } : {},
    ...t.batchModeHeader ? {
      "trpc-batch-mode": t.batchModeHeader
    } : {},
    ...a
  };
  return Br(t.fetch)(r, {
    method: qs[s],
    signal: e?.signal,
    body: n2,
    headers: i3
  });
}
function Jr(t) {
  const e = t.AbortController ? new t.AbortController() : null, r = {};
  let n2 = false;
  return {
    promise: new Promise((i3, o2) => {
      Gr(t, e).then((c2) => (r.response = c2, n2 = true, c2.json())).then((c2) => {
        r.responseJSON = c2, i3({
          json: c2,
          meta: r
        });
      }).catch((c2) => {
        n2 = true, o2(Ds.TRPCClientError.from(c2, {
          meta: r
        }));
      });
    }),
    cancel: () => {
      n2 || e?.abort();
    }
  };
}
F2.fetchHTTPResponse = Gr;
F2.getBody = Hr;
F2.getFetch = Br;
F2.getUrl = Fr;
F2.httpRequest = Jr;
F2.jsonHttpRequester = zs;
F2.resolveHTTPLinkOptions = Us;
var zt = {};
var Bs = we;
var Vs = ke;
var fr = xe;
var St = F2;
var _t = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function vt(t) {
  let e = null, r = null;
  const n2 = () => {
    clearTimeout(r), r = null, e = null;
  };
  function s(o2) {
    const c2 = [
      []
    ];
    let u = 0;
    for (; ; ) {
      const d = o2[u];
      if (!d)
        break;
      const h = c2[c2.length - 1];
      if (d.aborted) {
        d.reject?.(new Error("Aborted")), u++;
        continue;
      }
      if (t.validate(h.concat(d).map((k3) => k3.key))) {
        h.push(d), u++;
        continue;
      }
      if (h.length === 0) {
        d.reject?.(new Error("Input is too big for a single dispatch")), u++;
        continue;
      }
      c2.push([]);
    }
    return c2;
  }
  function a() {
    const o2 = s(e);
    n2();
    for (const c2 of o2) {
      if (!c2.length)
        continue;
      const u = {
        items: c2,
        cancel: _t
      };
      for (const k3 of c2)
        k3.batch = u;
      const d = (k3, T5) => {
        const A2 = u.items[k3];
        A2.resolve?.(T5), A2.batch = null, A2.reject = null, A2.resolve = null;
      }, { promise: h, cancel: y } = t.fetch(u.items.map((k3) => k3.key), d);
      u.cancel = y, h.then((k3) => {
        for (let T5 = 0; T5 < k3.length; T5++) {
          const A2 = k3[T5];
          d(T5, A2);
        }
        for (const T5 of u.items)
          T5.reject?.(new Error("Missing result")), T5.batch = null;
      }).catch((k3) => {
        for (const T5 of u.items)
          T5.reject?.(k3), T5.batch = null;
      });
    }
  }
  function i3(o2) {
    const c2 = {
      aborted: false,
      key: o2,
      batch: null,
      resolve: _t,
      reject: _t
    }, u = new Promise((h, y) => {
      c2.reject = y, c2.resolve = h, e || (e = []), e.push(c2);
    });
    return r || (r = setTimeout(a)), {
      promise: u,
      cancel: () => {
        c2.aborted = true, c2.batch?.items.every((h) => h.aborted) && (c2.batch.cancel(), c2.batch = null);
      }
    };
  }
  return {
    load: i3
  };
}
function Yr(t) {
  return function(r) {
    const n2 = St.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;
    return (a) => {
      const i3 = (h) => {
        const y = (T5) => {
          if (s === 1 / 0)
            return true;
          const A2 = T5.map((H2) => H2.path).join(","), le2 = T5.map((H2) => H2.input);
          return St.getUrl({
            ...n2,
            runtime: a,
            type: h,
            path: A2,
            inputs: le2
          }).length <= s;
        }, k3 = t({
          ...n2,
          runtime: a,
          type: h,
          opts: r
        });
        return {
          validate: y,
          fetch: k3
        };
      }, o2 = vt(i3("query")), c2 = vt(i3("mutation")), u = vt(i3("subscription")), d = {
        query: o2,
        subscription: u,
        mutation: c2
      };
      return ({ op: h }) => Bs.observable((y) => {
        const k3 = d[h.type], { promise: T5, cancel: A2 } = k3.load(h);
        let le2;
        return T5.then(($2) => {
          le2 = $2;
          const H2 = Vs.transformResult($2.json, a);
          if (!H2.ok) {
            y.error(fr.TRPCClientError.from(H2.error, {
              meta: $2.meta
            }));
            return;
          }
          y.next({
            context: $2.meta,
            result: H2.result
          }), y.complete();
        }).catch(($2) => {
          y.error(fr.TRPCClientError.from($2, {
            meta: le2?.meta
          }));
        }), () => {
          A2();
        };
      });
    };
  };
}
var Fs = (t) => (e) => {
  const r = e.map((i3) => i3.path).join(","), n2 = e.map((i3) => i3.input), { promise: s, cancel: a } = St.jsonHttpRequester({
    ...t,
    path: r,
    inputs: n2,
    headers() {
      return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
        opList: e
      }) : t.opts.headers : {};
    }
  });
  return {
    promise: s.then((i3) => (Array.isArray(i3.json) ? i3.json : e.map(() => i3.json)).map((u) => ({
      meta: i3.meta,
      json: u
    }))),
    cancel: a
  };
};
var Hs = Yr(Fs);
zt.createHTTPBatchLink = Yr;
zt.httpBatchLink = Hs;
var it = {};
Object.defineProperty(it, "__esModule", { value: true });
var Gs = we;
var Js = ke;
var pr = xe;
var Xr = F2;
function Qr(t) {
  return (e) => {
    const r = Xr.resolveHTTPLinkOptions(e);
    return (n2) => ({ op: s }) => Gs.observable((a) => {
      const { path: i3, input: o2, type: c2 } = s, { promise: u, cancel: d } = t.requester({
        ...r,
        runtime: n2,
        type: c2,
        path: i3,
        input: o2,
        headers() {
          return e.headers ? typeof e.headers == "function" ? e.headers({
            op: s
          }) : e.headers : {};
        }
      });
      let h;
      return u.then((y) => {
        h = y.meta;
        const k3 = Js.transformResult(y.json, n2);
        if (!k3.ok) {
          a.error(pr.TRPCClientError.from(k3.error, {
            meta: h
          }));
          return;
        }
        a.next({
          context: y.meta,
          result: k3.result
        }), a.complete();
      }).catch((y) => {
        a.error(pr.TRPCClientError.from(y, {
          meta: h
        }));
      }), () => {
        d();
      };
    });
  };
}
var Ys = Qr({
  requester: Xr.jsonHttpRequester
});
it.httpLink = Ys;
it.httpLinkFactory = Qr;
var Bt = {};
Object.defineProperty(Bt, "__esModule", { value: true });
var hr = we;
function Xs(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var bt = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function Qs(t) {
  const { direction: e, type: r, path: n2, id: s, input: a } = t, i3 = [], o2 = [];
  if (t.colorMode === "ansi") {
    const [h, y] = bt.ansi.regular[r], [k3, T5] = bt.ansi.bold[r], A2 = "\x1B[0m";
    return i3.push(e === "up" ? h : y, e === "up" ? ">>" : "<<", r, e === "up" ? k3 : T5, `#${s}`, n2, A2), e === "up" ? o2.push({
      input: t.input
    }) : o2.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: i3,
      args: o2
    };
  }
  const [c2, u] = bt.css[r], d = `
    background-color: #${e === "up" ? c2 : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return i3.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n2}%c`, "%O"), o2.push(d, `${d}; font-weight: bold;`, `${d}; font-weight: normal;`), e === "up" ? o2.push({
    input: a,
    context: t.context
  }) : o2.push({
    input: a,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: i3,
    args: o2
  };
}
var Ks = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n2 = r.input, s = Xs(n2) ? Object.fromEntries(n2) : n2, { parts: a, args: i3 } = Qs({
    ...r,
    colorMode: e,
    input: s
  }), o2 = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o2].apply(null, [
    a.join(" ")
  ].concat(i3));
};
function ea(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n2 = Ks({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: a }) => hr.observable((i3) => {
    e({
      ...s,
      direction: "up"
    }) && n2({
      ...s,
      direction: "up"
    });
    const o2 = Date.now();
    function c2(u) {
      const d = Date.now() - o2;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n2({
        ...s,
        direction: "down",
        elapsedMs: d,
        result: u
      });
    }
    return a(s).pipe(hr.tap({
      next(u) {
        c2(u);
      },
      error(u) {
        c2(u);
      }
    })).subscribe(i3);
  });
}
Bt.loggerLink = ea;
var ot = {};
Object.defineProperty(ot, "__esModule", { value: true });
var ta = we;
var ra = ke;
var Kr = xe;
var na = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);
function sa(t) {
  const { url: e, WebSocket: r = WebSocket, retryDelayMs: n2 = na, onOpen: s, onClose: a } = t;
  if (!r)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let i3 = [];
  const o2 = /* @__PURE__ */ Object.create(null);
  let c2 = 0, u = null, d = null, h = Qt(), y = "connecting";
  function k3() {
    y !== "open" || u || (u = setTimeout(() => {
      u = null, i3.length === 1 ? h.send(JSON.stringify(i3.pop())) : h.send(JSON.stringify(i3)), i3 = [];
    }));
  }
  function T5() {
    if (d !== null || y === "closed")
      return;
    const R3 = n2(c2++);
    le2(R3);
  }
  function A2() {
    y = "connecting";
    const R3 = h;
    h = Qt(), $2(R3);
  }
  function le2(R3) {
    d || (y = "connecting", d = setTimeout(A2, R3));
  }
  function $2(R3) {
    Object.values(o2).some((de2) => de2.ws === R3) || R3.close();
  }
  function H2() {
    Object.values(o2).forEach((R3) => {
      R3.type === "subscription" && R3.callbacks.complete();
    });
  }
  function Xt(R3) {
    i3.some((P3) => P3.id === R3.op.id) || Kt(R3.op, R3.callbacks);
  }
  function Qt() {
    const R3 = typeof e == "function" ? e() : e, P3 = new r(R3);
    clearTimeout(d), d = null, P3.addEventListener("open", () => {
      P3 === h && (c2 = 0, y = "open", s?.(), k3());
    }), P3.addEventListener("error", () => {
      P3 === h && T5();
    });
    const de2 = (j3) => {
      if (j3.method === "reconnect" && P3 === h) {
        y === "open" && a?.(), A2();
        for (const E3 of Object.values(o2))
          E3.type === "subscription" && Xt(E3);
      }
    }, pt2 = (j3) => {
      const E3 = j3.id !== null && o2[j3.id];
      if (E3) {
        if (E3.callbacks.next?.(j3), E3.ws !== h && P3 === h) {
          const G4 = E3.ws;
          E3.ws = h, $2(G4);
        }
        "result" in j3 && j3.result.type === "stopped" && P3 === h && E3.callbacks.complete();
      }
    };
    return P3.addEventListener("message", ({ data: j3 }) => {
      const E3 = JSON.parse(j3);
      "method" in E3 ? de2(E3) : pt2(E3), (P3 !== h || y === "closed") && $2(P3);
    }), P3.addEventListener("close", ({ code: j3 }) => {
      y === "open" && a?.({
        code: j3
      }), h === P3 && T5();
      for (const [E3, G4] of Object.entries(o2))
        if (G4.ws === P3) {
          if (y === "closed") {
            delete o2[E3], G4.callbacks.complete?.();
            continue;
          }
          G4.type === "subscription" ? Xt(G4) : (delete o2[E3], G4.callbacks.error?.(Kr.TRPCClientError.from(new Vt("WebSocket closed prematurely"))));
        }
    }), P3;
  }
  function Kt(R3, P3) {
    const { type: de2, input: pt2, path: j3, id: E3 } = R3, G4 = {
      id: E3,
      method: de2,
      params: {
        input: pt2,
        path: j3
      }
    };
    return o2[E3] = {
      ws: h,
      type: de2,
      callbacks: P3,
      op: R3
    }, i3.push(G4), k3(), () => {
      const Cn = o2[E3]?.callbacks;
      delete o2[E3], i3 = i3.filter((Rn) => Rn.id !== E3), Cn?.complete?.(), h.readyState === r.OPEN && R3.type === "subscription" && (i3.push({
        id: E3,
        method: "subscription.stop"
      }), k3());
    };
  }
  return {
    close: () => {
      y = "closed", a?.(), H2(), $2(h), clearTimeout(d), d = null;
    },
    request: Kt,
    getConnection() {
      return h;
    }
  };
}
var Vt = class _Vt extends Error {
  constructor(e) {
    super(e), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, _Vt.prototype);
  }
};
function aa(t) {
  return (e) => {
    const { client: r } = t;
    return ({ op: n2 }) => ta.observable((s) => {
      const { type: a, path: i3, id: o2, context: c2 } = n2, u = e.transformer.serialize(n2.input), d = r.request({
        type: a,
        path: i3,
        input: u,
        id: o2,
        context: c2
      }, {
        error(h) {
          s.error(h), d();
        },
        complete() {
          s.complete();
        },
        next(h) {
          const y = ra.transformResult(h, e);
          if (!y.ok) {
            s.error(Kr.TRPCClientError.from(y.error));
            return;
          }
          s.next({
            result: y.result
          }), n2.type !== "subscription" && (d(), s.complete());
        }
      });
      return () => {
        d();
      };
    });
  };
}
ot.createWSClient = sa;
ot.wsLink = aa;
Object.defineProperty(S3, "__esModule", { value: true });
var mr = we;
var en = qt;
var tn = xe;
var yr = qr;
var Ae = F2;
var rn = zt;
var Ft = it;
var ia = Bt;
var nn = ot;
var ct = class {
  $request({ type: e, input: r, path: n2, context: s = {} }) {
    return en.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n2,
        input: r,
        context: s
      }
    }).pipe(mr.share());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n2, abort: s } = mr.observableToPromise(r);
    return new Promise((i3, o2) => {
      e.signal?.addEventListener("abort", s), n2.then((c2) => {
        i3(c2.result.data);
      }).catch((c2) => {
        o2(tn.TRPCClientError.from(c2));
      });
    });
  }
  query(e, r, n2) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n2?.context,
      signal: n2?.signal
    });
  }
  mutation(e, r, n2) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n2?.context,
      signal: n2?.signal
    });
  }
  subscription(e, r, n2) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n2?.context
    }).subscribe({
      next(a) {
        a.result.type === "started" ? n2.onStarted?.() : a.result.type === "stopped" ? n2.onStopped?.() : n2.onData?.(a.result.data);
      },
      error(a) {
        n2.onError?.(a);
      },
      complete() {
        n2.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n2 = e.transformer;
      return n2 ? "input" in n2 ? e.transformer : {
        input: n2,
        output: n2
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n2) => r.input.serialize(n2),
        deserialize: (n2) => r.output.deserialize(n2)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n2) => n2(this.runtime));
  }
};
function oa(t) {
  return new ct(t);
}
function ca(t) {
  return new ct(t);
}
var ua = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var sn = (t) => ua[t];
function an(t) {
  return yr.createFlatProxy((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : yr.createRecursiveProxy(({ path: r, args: n2 }) => {
    const s = [
      e,
      ...r
    ], a = sn(s.pop()), i3 = s.join(".");
    return t[a](i3, ...n2);
  }));
}
function la(t) {
  const e = new ct(t);
  return an(e);
}
function da(t) {
  return t.__untypedClient;
}
function fa(t) {
  if (t)
    return t;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function pa(t) {
  const e = t.parse ?? JSON.parse, r = (n2) => {
    if (t.signal?.aborted || !n2 || n2 === "}")
      return;
    const s = n2.indexOf(":"), a = n2.substring(2, s - 1), i3 = n2.substring(s + 1);
    t.onSingle(Number(a), e(i3));
  };
  await ha(t.readableStream, r, t.textDecoder);
}
async function ha(t, e, r) {
  let n2 = "";
  const s = (a) => {
    const o2 = r.decode(a).split(`
`);
    if (o2.length === 1)
      n2 += o2[0];
    else if (o2.length > 1) {
      e(n2 + o2[0]);
      for (let c2 = 1; c2 < o2.length - 1; c2++)
        e(o2[c2]);
      n2 = o2[o2.length - 1];
    }
  };
  "getReader" in t ? await ya(t, s) : await ma(t, s), e(n2);
}
function ma(t, e) {
  return new Promise((r) => {
    t.on("data", e), t.on("end", r);
  });
}
async function ya(t, e) {
  const r = t.getReader();
  let n2 = await r.read();
  for (; !n2.done; )
    e(n2.value), n2 = await r.read();
}
var ga = (t, e) => {
  const r = t.AbortController ? new t.AbortController() : null, n2 = Ae.fetchHTTPResponse({
    ...t,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: Ae.getUrl,
    getBody: Ae.getBody
  }, r), s = () => r?.abort(), a = n2.then(async (i3) => {
    if (!i3.body)
      throw new Error("Received response without body");
    const o2 = {
      response: i3
    };
    return pa({
      readableStream: i3.body,
      onSingle: e,
      parse: (c2) => ({
        json: JSON.parse(c2),
        meta: o2
      }),
      signal: r?.signal,
      textDecoder: t.textDecoder
    });
  });
  return {
    cancel: s,
    promise: a
  };
};
var _a = (t) => {
  const e = fa(t.opts.textDecoder);
  return (r, n2) => {
    const s = r.map((c2) => c2.path).join(","), a = r.map((c2) => c2.input), { cancel: i3, promise: o2 } = ga({
      ...t,
      textDecoder: e,
      path: s,
      inputs: a,
      headers() {
        return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
          opList: r
        }) : t.opts.headers : {};
      }
    }, (c2, u) => {
      n2(c2, u);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: o2.then(() => []),
      cancel: i3
    };
  };
};
var va = rn.createHTTPBatchLink(_a);
var ba = (t) => {
  if ("input" in t) {
    if (!(t.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t.input;
  }
};
var wa = (t) => {
  if (t.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return Ae.httpRequest({
    ...t,
    getUrl() {
      return `${t.url}/${t.path}`;
    },
    getBody: ba
  });
};
var xa = Ft.httpLinkFactory({
  requester: wa
});
S3.splitLink = en.splitLink;
S3.TRPCClientError = tn.TRPCClientError;
S3.getFetch = Ae.getFetch;
S3.httpBatchLink = rn.httpBatchLink;
S3.httpLink = Ft.httpLink;
S3.httpLinkFactory = Ft.httpLinkFactory;
S3.loggerLink = ia.loggerLink;
S3.createWSClient = nn.createWSClient;
S3.wsLink = nn.wsLink;
S3.TRPCUntypedClient = ct;
S3.clientCallTypeToProcedureType = sn;
S3.createTRPCClient = ca;
S3.createTRPCClientProxy = an;
S3.createTRPCProxyClient = la;
S3.createTRPCUntypedClient = oa;
S3.experimental_formDataLink = xa;
S3.getUntypedClient = da;
S3.unstable_httpBatchStreamLink = va;
var ne = {};
var Ht = {};
function ka(t) {
  return t;
}
function Ta(t) {
  return t.length === 0 ? ka : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n2, s) => s(n2), r);
  };
}
function Ea(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Ca(t) {
  const e = {
    subscribe(r) {
      let n2 = null, s = false, a = false, i3 = false;
      function o2() {
        if (n2 === null) {
          i3 = true;
          return;
        }
        a || (a = true, typeof n2 == "function" ? n2() : n2 && n2.unsubscribe());
      }
      return n2 = t({
        next(c2) {
          s || r.next?.(c2);
        },
        error(c2) {
          s || (s = true, r.error?.(c2), o2());
        },
        complete() {
          s || (s = true, r.complete?.(), o2());
        }
      }), i3 && o2(), {
        unsubscribe: o2
      };
    },
    pipe(...r) {
      return Ta(r)(e);
    }
  };
  return e;
}
Ht.isObservable = Ea;
Ht.observable = Ca;
Object.defineProperty(ne, "__esModule", { value: true });
var on = Ht;
function Ra(t) {
  return (e) => {
    let r = 0, n2 = null;
    const s = [];
    function a() {
      n2 || (n2 = e.subscribe({
        next(o2) {
          for (const c2 of s)
            c2.next?.(o2);
        },
        error(o2) {
          for (const c2 of s)
            c2.error?.(o2);
        },
        complete() {
          for (const o2 of s)
            o2.complete?.();
        }
      }));
    }
    function i3() {
      if (r === 0 && n2) {
        const o2 = n2;
        n2 = null, o2.unsubscribe();
      }
    }
    return {
      subscribe(o2) {
        return r++, s.push(o2), a(), {
          unsubscribe() {
            r--, i3();
            const c2 = s.findIndex((u) => u === o2);
            c2 > -1 && s.splice(c2, 1);
          }
        };
      }
    };
  };
}
function Oa(t) {
  return (e) => ({
    subscribe(r) {
      let n2 = 0;
      return e.subscribe({
        next(a) {
          r.next?.(t(a, n2++));
        },
        error(a) {
          r.error?.(a);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function Sa(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n2) {
          t.next?.(n2), r.next?.(n2);
        },
        error(n2) {
          t.error?.(n2), r.error?.(n2);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
var Gt = class _Gt extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, _Gt.prototype);
  }
};
function Pa(t) {
  let e;
  return {
    promise: new Promise((n2, s) => {
      let a = false;
      function i3() {
        a || (a = true, s(new Gt("This operation was aborted.")), o2.unsubscribe());
      }
      const o2 = t.subscribe({
        next(c2) {
          a = true, n2(c2), i3();
        },
        error(c2) {
          a = true, s(c2), i3();
        },
        complete() {
          a = true, i3();
        }
      });
      e = i3;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
ne.isObservable = on.isObservable;
ne.observable = on.observable;
ne.map = Oa;
ne.observableToPromise = Pa;
ne.share = Ra;
ne.tap = Sa;
var q2 = {};
Object.defineProperty(q2, "__esModule", { value: true });
q2.isTRPCRequestWithId = q2.isTRPCRequest = q2.isTRPCResponse = q2.isTRPCMessage = void 0;
function gr(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function Aa(t) {
  return t == null;
}
function cn(t) {
  return !!(gr(t) && "trpc" in t && gr(t.trpc));
}
q2.isTRPCMessage = cn;
function Jt(t) {
  return cn(t) && "id" in t.trpc && !Aa(t.trpc.id);
}
function Na(t) {
  return Jt(t) && ("error" in t.trpc || "result" in t.trpc);
}
q2.isTRPCResponse = Na;
function un(t) {
  return Jt(t) && "method" in t.trpc;
}
q2.isTRPCRequest = un;
function Ia(t) {
  return un(t) && Jt(t);
}
q2.isTRPCRequestWithId = Ia;
Object.defineProperty(be, "__esModule", { value: true });
be.createBaseLink = void 0;
var wt = S3;
var ja = ne;
var La = q2;
var $a = (t) => (e) => ({ op: r }) => (0, ja.observable)((n2) => {
  const s = [], { id: a, type: i3, path: o2 } = r;
  try {
    const c2 = e.transformer.serialize(r.input), u = () => {
      n2.error(new wt.TRPCClientError("Port disconnected prematurely"));
    };
    t.addCloseListener(u), s.push(() => t.removeCloseListener(u));
    const d = (h) => {
      if (!(0, La.isTRPCResponse)(h))
        return;
      const { trpc: y } = h;
      if (a === y.id) {
        if ("error" in y)
          return n2.error(wt.TRPCClientError.from(y));
        n2.next({
          result: Object.assign(Object.assign({}, y.result), (!y.result.type || y.result.type === "data") && {
            type: "data",
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data: e.transformer.deserialize(y.result.data)
          })
        }), (i3 !== "subscription" || y.result.type === "stopped") && n2.complete();
      }
    };
    t.addMessageListener(d), s.push(() => t.removeMessageListener(d)), t.postMessage({
      trpc: {
        id: a,
        jsonrpc: void 0,
        method: i3,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        params: { path: o2, input: c2 }
      }
    });
  } catch (c2) {
    n2.error(new wt.TRPCClientError(c2 instanceof Error ? c2.message : "Unknown error"));
  }
  return () => {
    i3 === "subscription" && t.postMessage({
      trpc: {
        id: a,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), s.forEach((c2) => c2());
  };
});
be.createBaseLink = $a;
Object.defineProperty(at, "__esModule", { value: true });
at.chromeLink = void 0;
var Ma = be;
var Da = (t) => (0, Ma.createBaseLink)({
  postMessage(e) {
    t.port.postMessage(e);
  },
  addMessageListener(e) {
    t.port.onMessage.addListener(e);
  },
  removeMessageListener(e) {
    t.port.onMessage.removeListener(e);
  },
  addCloseListener(e) {
    t.port.onDisconnect.addListener(e);
  },
  removeCloseListener(e) {
    t.port.onDisconnect.removeListener(e);
  }
});
at.chromeLink = Da;
var ut = {};
Object.defineProperty(ut, "__esModule", { value: true });
ut.windowLink = void 0;
var Za = be;
var Ua = (t) => {
  var e;
  const r = /* @__PURE__ */ new Map(), n2 = t.window, s = (e = t.postWindow) !== null && e !== void 0 ? e : n2;
  return (0, Za.createBaseLink)({
    postMessage(a) {
      s.postMessage(a, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(a) {
      const i3 = (o2) => {
        a(o2.data);
      };
      r.set(a, i3), n2.addEventListener("message", i3);
    },
    removeMessageListener(a) {
      const i3 = r.get(a);
      i3 && n2.removeEventListener("message", i3);
    },
    addCloseListener(a) {
      n2.addEventListener("beforeunload", a);
    },
    removeCloseListener(a) {
      n2.removeEventListener("beforeunload", a);
    }
  });
};
ut.windowLink = Ua;
var lt = {};
var dt = {};
Object.defineProperty(dt, "__esModule", { value: true });
dt.TRPC_BROWSER_LOADED_EVENT = void 0;
dt.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(lt, "__esModule", { value: true });
lt.popupLink = void 0;
var Wa = dt;
var qa = be;
var za = (t) => {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  let n2 = null;
  async function s(a) {
    if (!n2 || n2.closed) {
      n2 = t.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((i3) => {
          var o2;
          try {
            (o2 = n2?.addEventListener) === null || o2 === void 0 || o2.call(n2, "load", i3);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((i3) => {
          a.addEventListener("message", (o2) => {
            o2.data === Wa.TRPC_BROWSER_LOADED_EVENT && i3();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((i3) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(i3, 15e3);
        })
      ]);
      try {
        if (!n2.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n2.addEventListener("beforeunload", () => {
          n2 = null;
        });
      } catch {
        const o2 = setInterval(() => {
          n2 && n2.closed && (n2 = null, r.forEach((c2) => {
            c2();
          }), clearInterval(o2));
        }, 1e3);
      }
    }
    return n2;
  }
  return (0, qa.createBaseLink)({
    async postMessage(a) {
      return (await s(t.listenWindow)).postMessage(a, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(a) {
      const i3 = (o2) => {
        a(o2.data);
      };
      e.set(a, i3), t.listenWindow.addEventListener("message", i3);
    },
    removeMessageListener(a) {
      const i3 = e.get(a);
      i3 && t.listenWindow.removeEventListener("message", i3);
    },
    addCloseListener(a) {
      t.listenWindow.addEventListener("beforeunload", a), r.add(a);
    },
    removeCloseListener(a) {
      t.listenWindow.removeEventListener("beforeunload", a), r.delete(a);
    }
  });
};
lt.popupLink = za;
(function(t) {
  var e = A && A.__createBinding || (Object.create ? function(n2, s, a, i3) {
    i3 === void 0 && (i3 = a);
    var o2 = Object.getOwnPropertyDescriptor(s, a);
    (!o2 || ("get" in o2 ? !s.__esModule : o2.writable || o2.configurable)) && (o2 = { enumerable: true, get: function() {
      return s[a];
    } }), Object.defineProperty(n2, i3, o2);
  } : function(n2, s, a, i3) {
    i3 === void 0 && (i3 = a), n2[i3] = s[a];
  }), r = A && A.__exportStar || function(n2, s) {
    for (var a in n2)
      a !== "default" && !Object.prototype.hasOwnProperty.call(s, a) && e(s, n2, a);
  };
  Object.defineProperty(t, "__esModule", { value: true }), r(at, t), r(ut, t), r(lt, t);
})(Rt);
var x;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const a = {};
    for (const i3 of s)
      a[i3] = i3;
    return a;
  }, t.getValidEnumValues = (s) => {
    const a = t.objectKeys(s).filter((o2) => typeof s[s[o2]] != "number"), i3 = {};
    for (const o2 of a)
      i3[o2] = s[o2];
    return t.objectValues(i3);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(a) {
    return s[a];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const a = [];
    for (const i3 in s)
      Object.prototype.hasOwnProperty.call(s, i3) && a.push(i3);
    return a;
  }, t.find = (s, a) => {
    for (const i3 of s)
      if (a(i3))
        return i3;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n2(s, a = " | ") {
    return s.map((i3) => typeof i3 == "string" ? `'${i3}'` : i3).join(a);
  }
  t.joinValues = n2, t.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
})(x || (x = {}));
var Pt;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(Pt || (Pt = {}));
var m = x.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var Y = (t) => {
  switch (typeof t) {
    case "undefined":
      return m.undefined;
    case "string":
      return m.string;
    case "number":
      return isNaN(t) ? m.nan : m.number;
    case "boolean":
      return m.boolean;
    case "function":
      return m.function;
    case "bigint":
      return m.bigint;
    case "symbol":
      return m.symbol;
    case "object":
      return Array.isArray(t) ? m.array : t === null ? m.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? m.promise : typeof Map < "u" && t instanceof Map ? m.map : typeof Set < "u" && t instanceof Set ? m.set : typeof Date < "u" && t instanceof Date ? m.date : m.object;
    default:
      return m.unknown;
  }
};
var f2 = x.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var Ba = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
var L = class _L extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n2) => {
      this.issues = [...this.issues, n2];
    }, this.addIssues = (n2 = []) => {
      this.issues = [...this.issues, ...n2];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const r = e || function(a) {
      return a.message;
    }, n2 = { _errors: [] }, s = (a) => {
      for (const i3 of a.issues)
        if (i3.code === "invalid_union")
          i3.unionErrors.map(s);
        else if (i3.code === "invalid_return_type")
          s(i3.returnTypeError);
        else if (i3.code === "invalid_arguments")
          s(i3.argumentsError);
        else if (i3.path.length === 0)
          n2._errors.push(r(i3));
        else {
          let o2 = n2, c2 = 0;
          for (; c2 < i3.path.length; ) {
            const u = i3.path[c2];
            c2 === i3.path.length - 1 ? (o2[u] = o2[u] || { _errors: [] }, o2[u]._errors.push(r(i3))) : o2[u] = o2[u] || { _errors: [] }, o2 = o2[u], c2++;
          }
        }
    };
    return s(this), n2;
  }
  static assert(e) {
    if (!(e instanceof _L))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, x.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n2 = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n2.push(e(s));
    return { formErrors: n2, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
L.create = (t) => new L(t);
var ge = (t, e) => {
  let r;
  switch (t.code) {
    case f2.invalid_type:
      t.received === m.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case f2.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, x.jsonStringifyReplacer)}`;
      break;
    case f2.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${x.joinValues(t.keys, ", ")}`;
      break;
    case f2.invalid_union:
      r = "Invalid input";
      break;
    case f2.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${x.joinValues(t.options)}`;
      break;
    case f2.invalid_enum_value:
      r = `Invalid enum value. Expected ${x.joinValues(t.options)}, received '${t.received}'`;
      break;
    case f2.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case f2.invalid_return_type:
      r = "Invalid function return type";
      break;
    case f2.invalid_date:
      r = "Invalid date";
      break;
    case f2.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : x.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case f2.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case f2.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case f2.custom:
      r = "Invalid input";
      break;
    case f2.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case f2.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case f2.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, x.assertNever(t);
  }
  return { message: r };
};
var ln = ge;
function Va(t) {
  ln = t;
}
function Ye() {
  return ln;
}
var Xe = (t) => {
  const { data: e, path: r, errorMaps: n2, issueData: s } = t, a = [...r, ...s.path || []], i3 = {
    ...s,
    path: a
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: a,
      message: s.message
    };
  let o2 = "";
  const c2 = n2.filter((u) => !!u).slice().reverse();
  for (const u of c2)
    o2 = u(i3, { data: e, defaultError: o2 }).message;
  return {
    ...s,
    path: a,
    message: o2
  };
};
var Fa = [];
function p(t, e) {
  const r = Ye(), n2 = Xe({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      r,
      // then global override map
      r === ge ? void 0 : ge
      // then global default map
    ].filter((s) => !!s)
  });
  t.common.issues.push(n2);
}
var N = class _N {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n2 = [];
    for (const s of r) {
      if (s.status === "aborted")
        return v;
      s.status === "dirty" && e.dirty(), n2.push(s.value);
    }
    return { status: e.value, value: n2 };
  }
  static async mergeObjectAsync(e, r) {
    const n2 = [];
    for (const s of r) {
      const a = await s.key, i3 = await s.value;
      n2.push({
        key: a,
        value: i3
      });
    }
    return _N.mergeObjectSync(e, n2);
  }
  static mergeObjectSync(e, r) {
    const n2 = {};
    for (const s of r) {
      const { key: a, value: i3 } = s;
      if (a.status === "aborted" || i3.status === "aborted")
        return v;
      a.status === "dirty" && e.dirty(), i3.status === "dirty" && e.dirty(), a.value !== "__proto__" && (typeof i3.value < "u" || s.alwaysSet) && (n2[a.value] = i3.value);
    }
    return { status: e.value, value: n2 };
  }
};
var v = Object.freeze({
  status: "aborted"
});
var he = (t) => ({ status: "dirty", value: t });
var I = (t) => ({ status: "valid", value: t });
var At = (t) => t.status === "aborted";
var Nt = (t) => t.status === "dirty";
var oe = (t) => t.status === "valid";
var Ne = (t) => typeof Promise < "u" && t instanceof Promise;
function Qe(t, e, r, n2) {
  if (r === "a" && !n2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n2 : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n2 : r === "a" ? n2.call(t) : n2 ? n2.value : e.get(t);
}
function dn(t, e, r, n2, s) {
  if (n2 === "m")
    throw new TypeError("Private method is not writable");
  if (n2 === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !s : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n2 === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r), r;
}
var g;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(g || (g = {}));
var Re;
var Oe;
var B2 = class {
  constructor(e, r, n2, s) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = n2, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var _r = (t, e) => {
  if (oe(e))
    return { success: true, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const r = new L(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function b(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n2, description: s } = t;
  if (e && (r || n2))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (i3, o2) => {
    var c2, u;
    const { message: d } = t;
    return i3.code === "invalid_enum_value" ? { message: d ?? o2.defaultError } : typeof o2.data > "u" ? { message: (c2 = d ?? n2) !== null && c2 !== void 0 ? c2 : o2.defaultError } : i3.code !== "invalid_type" ? { message: o2.defaultError } : { message: (u = d ?? r) !== null && u !== void 0 ? u : o2.defaultError };
  }, description: s };
}
var w = class {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Y(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: Y(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new N(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Y(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (Ne(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n2 = this.safeParse(e, r);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  safeParse(e, r) {
    var n2;
    const s = {
      common: {
        issues: [],
        async: (n2 = r?.async) !== null && n2 !== void 0 ? n2 : false,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Y(e)
    }, a = this._parseSync({ data: e, path: s.path, parent: s });
    return _r(s, a);
  }
  "~validate"(e) {
    var r, n2;
    const s = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Y(e)
    };
    if (!this["~standard"].async)
      try {
        const a = this._parseSync({ data: e, path: [], parent: s });
        return oe(a) ? {
          value: a.value
        } : {
          issues: s.common.issues
        };
      } catch (a) {
        !((n2 = (r = a?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n2 === void 0) && n2.includes("encountered") && (this["~standard"].async = true), s.common = {
          issues: [],
          async: true
        };
      }
    return this._parseAsync({ data: e, path: [], parent: s }).then((a) => oe(a) ? {
      value: a.value
    } : {
      issues: s.common.issues
    });
  }
  async parseAsync(e, r) {
    const n2 = await this.safeParseAsync(e, r);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  async safeParseAsync(e, r) {
    const n2 = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: true
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Y(e)
    }, s = this._parse({ data: e, path: n2.path, parent: n2 }), a = await (Ne(s) ? s : Promise.resolve(s));
    return _r(n2, a);
  }
  refine(e, r) {
    const n2 = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, a) => {
      const i3 = e(s), o2 = () => a.addIssue({
        code: f2.custom,
        ...n2(s)
      });
      return typeof Promise < "u" && i3 instanceof Promise ? i3.then((c2) => c2 ? true : (o2(), false)) : i3 ? true : (o2(), false);
    });
  }
  refinement(e, r) {
    return this._refinement((n2, s) => e(n2) ? true : (s.addIssue(typeof r == "function" ? r(n2, s) : r), false));
  }
  _refinement(e) {
    return new W2({
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (r) => this["~validate"](r)
    };
  }
  optional() {
    return z.create(this, this._def);
  }
  nullable() {
    return re.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return U3.create(this);
  }
  promise() {
    return ve.create(this, this._def);
  }
  or(e) {
    return $e.create([this, e], this._def);
  }
  and(e) {
    return Me.create(this, e, this._def);
  }
  transform(e) {
    return new W2({
      ...b(this._def),
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new qe({
      ...b(this._def),
      innerType: this,
      defaultValue: r,
      typeName: _.ZodDefault
    });
  }
  brand() {
    return new Yt({
      typeName: _.ZodBranded,
      type: this,
      ...b(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new ze({
      ...b(this._def),
      innerType: this,
      catchValue: r,
      typeName: _.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Fe.create(this, e);
  }
  readonly() {
    return Be.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var Ha = /^c[^\s-]{8,}$/i;
var Ga = /^[0-9a-z]+$/;
var Ja = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var Ya = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var Xa = /^[a-z0-9_-]{21}$/i;
var Qa = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var Ka = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var ei = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var ti = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var xt;
var ri = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ni = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var si = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ai = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var ii = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var oi = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var fn = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var ci = new RegExp(`^${fn}$`);
function pn(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function ui(t) {
  return new RegExp(`^${pn(t)}$`);
}
function hn(t) {
  let e = `${fn}T${pn(t)}`;
  const r = [];
  return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, new RegExp(`^${e}$`);
}
function li(t, e) {
  return !!((e === "v4" || !e) && ri.test(t) || (e === "v6" || !e) && si.test(t));
}
function di(t, e) {
  if (!Qa.test(t))
    return false;
  try {
    const [r] = t.split("."), n2 = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), s = JSON.parse(atob(n2));
    return !(typeof s != "object" || s === null || !s.typ || !s.alg || e && s.alg !== e);
  } catch {
    return false;
  }
}
function fi(t, e) {
  return !!((e === "v4" || !e) && ni.test(t) || (e === "v6" || !e) && ai.test(t));
}
var Z = class _Z extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== m.string) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f2.invalid_type,
        expected: m.string,
        received: a.parsedType
      }), v;
    }
    const n2 = new N();
    let s;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.too_small,
          minimum: a.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.too_big,
          maximum: a.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "length") {
        const i3 = e.data.length > a.value, o2 = e.data.length < a.value;
        (i3 || o2) && (s = this._getOrReturnCtx(e, s), i3 ? p(s, {
          code: f2.too_big,
          maximum: a.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: a.message
        }) : o2 && p(s, {
          code: f2.too_small,
          minimum: a.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: a.message
        }), n2.dirty());
      } else if (a.kind === "email")
        ei.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "email",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "emoji")
        xt || (xt = new RegExp(ti, "u")), xt.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "emoji",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "uuid")
        Ya.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "uuid",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "nanoid")
        Xa.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "nanoid",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "cuid")
        Ha.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cuid",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "cuid2")
        Ga.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cuid2",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "ulid")
        Ja.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "ulid",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), p(s, {
            validation: "url",
            code: f2.invalid_string,
            message: a.message
          }), n2.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "regex",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), n2.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), n2.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), n2.dirty()) : a.kind === "datetime" ? hn(a).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.invalid_string,
          validation: "datetime",
          message: a.message
        }), n2.dirty()) : a.kind === "date" ? ci.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.invalid_string,
          validation: "date",
          message: a.message
        }), n2.dirty()) : a.kind === "time" ? ui(a).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f2.invalid_string,
          validation: "time",
          message: a.message
        }), n2.dirty()) : a.kind === "duration" ? Ka.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "duration",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty()) : a.kind === "ip" ? li(e.data, a.version) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "ip",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty()) : a.kind === "jwt" ? di(e.data, a.alg) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "jwt",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty()) : a.kind === "cidr" ? fi(e.data, a.version) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cidr",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty()) : a.kind === "base64" ? ii.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "base64",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty()) : a.kind === "base64url" ? oi.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "base64url",
          code: f2.invalid_string,
          message: a.message
        }), n2.dirty()) : x.assertNever(a);
    return { status: n2.value, value: e.data };
  }
  _regex(e, r, n2) {
    return this.refinement((s) => e.test(s), {
      validation: r,
      code: f2.invalid_string,
      ...g.errToObj(n2)
    });
  }
  _addCheck(e) {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...g.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...g.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...g.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...g.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...g.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...g.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...g.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...g.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...g.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...g.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...g.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...g.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...g.errToObj(e) });
  }
  datetime(e) {
    var r, n2;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      local: false,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (r = e?.offset) !== null && r !== void 0 ? r : false,
      local: (n2 = e?.local) !== null && n2 !== void 0 ? n2 : false,
      ...g.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...g.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...g.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...g.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...g.errToObj(r?.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...g.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...g.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...g.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...g.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...g.errToObj(r)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, g.errToObj(e));
  }
  trim() {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
Z.create = (t) => {
  var e;
  return new Z({
    checks: [],
    typeName: _.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : false,
    ...b(t)
  });
};
function pi(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n2 = (e.toString().split(".")[1] || "").length, s = r > n2 ? r : n2, a = parseInt(t.toFixed(s).replace(".", "")), i3 = parseInt(e.toFixed(s).replace(".", ""));
  return a % i3 / Math.pow(10, s);
}
var K = class _K extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== m.number) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f2.invalid_type,
        expected: m.number,
        received: a.parsedType
      }), v;
    }
    let n2;
    const s = new N();
    for (const a of this._def.checks)
      a.kind === "int" ? x.isInteger(e.data) || (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), s.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: false,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: false,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? pi(e.data, a.value) !== 0 && (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.not_finite,
        message: a.message
      }), s.dirty()) : x.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, true, g.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, false, g.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, true, g.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, false, g.toString(r));
  }
  setLimit(e, r, n2, s) {
    return new _K({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n2,
          message: g.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _K({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: g.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: g.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: g.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: g.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: g.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: g.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: g.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: g.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: g.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && x.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n2 of this._def.checks) {
      if (n2.kind === "finite" || n2.kind === "int" || n2.kind === "multipleOf")
        return true;
      n2.kind === "min" ? (r === null || n2.value > r) && (r = n2.value) : n2.kind === "max" && (e === null || n2.value < e) && (e = n2.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
};
K.create = (t) => new K({
  checks: [],
  typeName: _.ZodNumber,
  coerce: t?.coerce || false,
  ...b(t)
});
var ee = class _ee extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== m.bigint)
      return this._getInvalidInput(e);
    let n2;
    const s = new N();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (n2 = this._getOrReturnCtx(e, n2), p(n2, {
        code: f2.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : x.assertNever(a);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    const r = this._getOrReturnCtx(e);
    return p(r, {
      code: f2.invalid_type,
      expected: m.bigint,
      received: r.parsedType
    }), v;
  }
  gte(e, r) {
    return this.setLimit("min", e, true, g.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, false, g.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, true, g.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, false, g.toString(r));
  }
  setLimit(e, r, n2, s) {
    return new _ee({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n2,
          message: g.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _ee({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: g.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: g.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: g.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: g.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: g.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
ee.create = (t) => {
  var e;
  return new ee({
    checks: [],
    typeName: _.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : false,
    ...b(t)
  });
};
var Ie = class extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== m.boolean) {
      const n2 = this._getOrReturnCtx(e);
      return p(n2, {
        code: f2.invalid_type,
        expected: m.boolean,
        received: n2.parsedType
      }), v;
    }
    return I(e.data);
  }
};
Ie.create = (t) => new Ie({
  typeName: _.ZodBoolean,
  coerce: t?.coerce || false,
  ...b(t)
});
var ce = class _ce extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== m.date) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f2.invalid_type,
        expected: m.date,
        received: a.parsedType
      }), v;
    }
    if (isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f2.invalid_date
      }), v;
    }
    const n2 = new N();
    let s;
    for (const a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (s = this._getOrReturnCtx(e, s), p(s, {
        code: f2.too_small,
        message: a.message,
        inclusive: true,
        exact: false,
        minimum: a.value,
        type: "date"
      }), n2.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (s = this._getOrReturnCtx(e, s), p(s, {
        code: f2.too_big,
        message: a.message,
        inclusive: true,
        exact: false,
        maximum: a.value,
        type: "date"
      }), n2.dirty()) : x.assertNever(a);
    return {
      status: n2.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new _ce({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: g.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: g.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
};
ce.create = (t) => new ce({
  checks: [],
  coerce: t?.coerce || false,
  typeName: _.ZodDate,
  ...b(t)
});
var Ke = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.symbol) {
      const n2 = this._getOrReturnCtx(e);
      return p(n2, {
        code: f2.invalid_type,
        expected: m.symbol,
        received: n2.parsedType
      }), v;
    }
    return I(e.data);
  }
};
Ke.create = (t) => new Ke({
  typeName: _.ZodSymbol,
  ...b(t)
});
var je = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.undefined) {
      const n2 = this._getOrReturnCtx(e);
      return p(n2, {
        code: f2.invalid_type,
        expected: m.undefined,
        received: n2.parsedType
      }), v;
    }
    return I(e.data);
  }
};
je.create = (t) => new je({
  typeName: _.ZodUndefined,
  ...b(t)
});
var Le = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.null) {
      const n2 = this._getOrReturnCtx(e);
      return p(n2, {
        code: f2.invalid_type,
        expected: m.null,
        received: n2.parsedType
      }), v;
    }
    return I(e.data);
  }
};
Le.create = (t) => new Le({
  typeName: _.ZodNull,
  ...b(t)
});
var _e = class extends w {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e) {
    return I(e.data);
  }
};
_e.create = (t) => new _e({
  typeName: _.ZodAny,
  ...b(t)
});
var ie = class extends w {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e) {
    return I(e.data);
  }
};
ie.create = (t) => new ie({
  typeName: _.ZodUnknown,
  ...b(t)
});
var X = class extends w {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return p(r, {
      code: f2.invalid_type,
      expected: m.never,
      received: r.parsedType
    }), v;
  }
};
X.create = (t) => new X({
  typeName: _.ZodNever,
  ...b(t)
});
var et = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.undefined) {
      const n2 = this._getOrReturnCtx(e);
      return p(n2, {
        code: f2.invalid_type,
        expected: m.void,
        received: n2.parsedType
      }), v;
    }
    return I(e.data);
  }
};
et.create = (t) => new et({
  typeName: _.ZodVoid,
  ...b(t)
});
var U3 = class _U extends w {
  _parse(e) {
    const { ctx: r, status: n2 } = this._processInputParams(e), s = this._def;
    if (r.parsedType !== m.array)
      return p(r, {
        code: f2.invalid_type,
        expected: m.array,
        received: r.parsedType
      }), v;
    if (s.exactLength !== null) {
      const i3 = r.data.length > s.exactLength.value, o2 = r.data.length < s.exactLength.value;
      (i3 || o2) && (p(r, {
        code: i3 ? f2.too_big : f2.too_small,
        minimum: o2 ? s.exactLength.value : void 0,
        maximum: i3 ? s.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: s.exactLength.message
      }), n2.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (p(r, {
      code: f2.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.minLength.message
    }), n2.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (p(r, {
      code: f2.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.maxLength.message
    }), n2.dirty()), r.common.async)
      return Promise.all([...r.data].map((i3, o2) => s.type._parseAsync(new B2(r, i3, r.path, o2)))).then((i3) => N.mergeArray(n2, i3));
    const a = [...r.data].map((i3, o2) => s.type._parseSync(new B2(r, i3, r.path, o2)));
    return N.mergeArray(n2, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new _U({
      ...this._def,
      minLength: { value: e, message: g.toString(r) }
    });
  }
  max(e, r) {
    return new _U({
      ...this._def,
      maxLength: { value: e, message: g.toString(r) }
    });
  }
  length(e, r) {
    return new _U({
      ...this._def,
      exactLength: { value: e, message: g.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
U3.create = (t, e) => new U3({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _.ZodArray,
  ...b(e)
});
function pe(t) {
  if (t instanceof C) {
    const e = {};
    for (const r in t.shape) {
      const n2 = t.shape[r];
      e[r] = z.create(pe(n2));
    }
    return new C({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof U3 ? new U3({
      ...t._def,
      type: pe(t.element)
    }) : t instanceof z ? z.create(pe(t.unwrap())) : t instanceof re ? re.create(pe(t.unwrap())) : t instanceof V ? V.create(t.items.map((e) => pe(e))) : t;
}
var C = class _C extends w {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = x.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== m.object) {
      const u = this._getOrReturnCtx(e);
      return p(u, {
        code: f2.invalid_type,
        expected: m.object,
        received: u.parsedType
      }), v;
    }
    const { status: n2, ctx: s } = this._processInputParams(e), { shape: a, keys: i3 } = this._getCached(), o2 = [];
    if (!(this._def.catchall instanceof X && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        i3.includes(u) || o2.push(u);
    const c2 = [];
    for (const u of i3) {
      const d = a[u], h = s.data[u];
      c2.push({
        key: { status: "valid", value: u },
        value: d._parse(new B2(s, h, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof X) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const d of o2)
          c2.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: s.data[d] }
          });
      else if (u === "strict")
        o2.length > 0 && (p(s, {
          code: f2.unrecognized_keys,
          keys: o2
        }), n2.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const d of o2) {
        const h = s.data[d];
        c2.push({
          key: { status: "valid", value: d },
          value: u._parse(
            new B2(s, h, s.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const d of c2) {
        const h = await d.key, y = await d.value;
        u.push({
          key: h,
          value: y,
          alwaysSet: d.alwaysSet
        });
      }
      return u;
    }).then((u) => N.mergeObjectSync(n2, u)) : N.mergeObjectSync(n2, c2);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return g.errToObj, new _C({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n2) => {
          var s, a, i3, o2;
          const c2 = (i3 = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, r, n2).message) !== null && i3 !== void 0 ? i3 : n2.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o2 = g.errToObj(e).message) !== null && o2 !== void 0 ? o2 : c2
          } : {
            message: c2
          };
        }
      } : {}
    });
  }
  strip() {
    return new _C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new _C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new _C({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: _.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new _C({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return x.objectKeys(e).forEach((n2) => {
      e[n2] && this.shape[n2] && (r[n2] = this.shape[n2]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n2) => {
      e[n2] || (r[n2] = this.shape[n2]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return pe(this);
  }
  partial(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n2) => {
      const s = this.shape[n2];
      e && !e[n2] ? r[n2] = s : r[n2] = s.optional();
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n2) => {
      if (e && !e[n2])
        r[n2] = this.shape[n2];
      else {
        let a = this.shape[n2];
        for (; a instanceof z; )
          a = a._def.innerType;
        r[n2] = a;
      }
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return mn(x.objectKeys(this.shape));
  }
};
C.create = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strip",
  catchall: X.create(),
  typeName: _.ZodObject,
  ...b(e)
});
C.strictCreate = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strict",
  catchall: X.create(),
  typeName: _.ZodObject,
  ...b(e)
});
C.lazycreate = (t, e) => new C({
  shape: t,
  unknownKeys: "strip",
  catchall: X.create(),
  typeName: _.ZodObject,
  ...b(e)
});
var $e = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n2 = this._def.options;
    function s(a) {
      for (const o2 of a)
        if (o2.result.status === "valid")
          return o2.result;
      for (const o2 of a)
        if (o2.result.status === "dirty")
          return r.common.issues.push(...o2.ctx.common.issues), o2.result;
      const i3 = a.map((o2) => new L(o2.ctx.common.issues));
      return p(r, {
        code: f2.invalid_union,
        unionErrors: i3
      }), v;
    }
    if (r.common.async)
      return Promise.all(n2.map(async (a) => {
        const i3 = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: r.data,
            path: r.path,
            parent: i3
          }),
          ctx: i3
        };
      })).then(s);
    {
      let a;
      const i3 = [];
      for (const c2 of n2) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, d = c2._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !a && (a = { result: d, ctx: u }), u.common.issues.length && i3.push(u.common.issues);
      }
      if (a)
        return r.common.issues.push(...a.ctx.common.issues), a.result;
      const o2 = i3.map((c2) => new L(c2));
      return p(r, {
        code: f2.invalid_union,
        unionErrors: o2
      }), v;
    }
  }
  get options() {
    return this._def.options;
  }
};
$e.create = (t, e) => new $e({
  options: t,
  typeName: _.ZodUnion,
  ...b(e)
});
var J = (t) => t instanceof Ze ? J(t.schema) : t instanceof W2 ? J(t.innerType()) : t instanceof Ue ? [t.value] : t instanceof te ? t.options : t instanceof We ? x.objectValues(t.enum) : t instanceof qe ? J(t._def.innerType) : t instanceof je ? [void 0] : t instanceof Le ? [null] : t instanceof z ? [void 0, ...J(t.unwrap())] : t instanceof re ? [null, ...J(t.unwrap())] : t instanceof Yt || t instanceof Be ? J(t.unwrap()) : t instanceof ze ? J(t._def.innerType) : [];
var ft = class _ft extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.object)
      return p(r, {
        code: f2.invalid_type,
        expected: m.object,
        received: r.parsedType
      }), v;
    const n2 = this.discriminator, s = r.data[n2], a = this.optionsMap.get(s);
    return a ? r.common.async ? a._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : a._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (p(r, {
      code: f2.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n2]
    }), v);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n2) {
    const s = /* @__PURE__ */ new Map();
    for (const a of r) {
      const i3 = J(a.shape[e]);
      if (!i3.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o2 of i3) {
        if (s.has(o2))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o2)}`);
        s.set(o2, a);
      }
    }
    return new _ft({
      typeName: _.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: s,
      ...b(n2)
    });
  }
};
function It(t, e) {
  const r = Y(t), n2 = Y(e);
  if (t === e)
    return { valid: true, data: t };
  if (r === m.object && n2 === m.object) {
    const s = x.objectKeys(e), a = x.objectKeys(t).filter((o2) => s.indexOf(o2) !== -1), i3 = { ...t, ...e };
    for (const o2 of a) {
      const c2 = It(t[o2], e[o2]);
      if (!c2.valid)
        return { valid: false };
      i3[o2] = c2.data;
    }
    return { valid: true, data: i3 };
  } else if (r === m.array && n2 === m.array) {
    if (t.length !== e.length)
      return { valid: false };
    const s = [];
    for (let a = 0; a < t.length; a++) {
      const i3 = t[a], o2 = e[a], c2 = It(i3, o2);
      if (!c2.valid)
        return { valid: false };
      s.push(c2.data);
    }
    return { valid: true, data: s };
  } else
    return r === m.date && n2 === m.date && +t == +e ? { valid: true, data: t } : { valid: false };
}
var Me = class extends w {
  _parse(e) {
    const { status: r, ctx: n2 } = this._processInputParams(e), s = (a, i3) => {
      if (At(a) || At(i3))
        return v;
      const o2 = It(a.value, i3.value);
      return o2.valid ? ((Nt(a) || Nt(i3)) && r.dirty(), { status: r.value, value: o2.data }) : (p(n2, {
        code: f2.invalid_intersection_types
      }), v);
    };
    return n2.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n2.data,
        path: n2.path,
        parent: n2
      }),
      this._def.right._parseAsync({
        data: n2.data,
        path: n2.path,
        parent: n2
      })
    ]).then(([a, i3]) => s(a, i3)) : s(this._def.left._parseSync({
      data: n2.data,
      path: n2.path,
      parent: n2
    }), this._def.right._parseSync({
      data: n2.data,
      path: n2.path,
      parent: n2
    }));
  }
};
Me.create = (t, e, r) => new Me({
  left: t,
  right: e,
  typeName: _.ZodIntersection,
  ...b(r)
});
var V = class _V extends w {
  _parse(e) {
    const { status: r, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== m.array)
      return p(n2, {
        code: f2.invalid_type,
        expected: m.array,
        received: n2.parsedType
      }), v;
    if (n2.data.length < this._def.items.length)
      return p(n2, {
        code: f2.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), v;
    !this._def.rest && n2.data.length > this._def.items.length && (p(n2, {
      code: f2.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), r.dirty());
    const a = [...n2.data].map((i3, o2) => {
      const c2 = this._def.items[o2] || this._def.rest;
      return c2 ? c2._parse(new B2(n2, i3, n2.path, o2)) : null;
    }).filter((i3) => !!i3);
    return n2.common.async ? Promise.all(a).then((i3) => N.mergeArray(r, i3)) : N.mergeArray(r, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new _V({
      ...this._def,
      rest: e
    });
  }
};
V.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new V({
    items: t,
    typeName: _.ZodTuple,
    rest: null,
    ...b(e)
  });
};
var De = class _De extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== m.object)
      return p(n2, {
        code: f2.invalid_type,
        expected: m.object,
        received: n2.parsedType
      }), v;
    const s = [], a = this._def.keyType, i3 = this._def.valueType;
    for (const o2 in n2.data)
      s.push({
        key: a._parse(new B2(n2, o2, n2.path, o2)),
        value: i3._parse(new B2(n2, n2.data[o2], n2.path, o2)),
        alwaysSet: o2 in n2.data
      });
    return n2.common.async ? N.mergeObjectAsync(r, s) : N.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n2) {
    return r instanceof w ? new _De({
      keyType: e,
      valueType: r,
      typeName: _.ZodRecord,
      ...b(n2)
    }) : new _De({
      keyType: Z.create(),
      valueType: e,
      typeName: _.ZodRecord,
      ...b(r)
    });
  }
};
var tt = class extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== m.map)
      return p(n2, {
        code: f2.invalid_type,
        expected: m.map,
        received: n2.parsedType
      }), v;
    const s = this._def.keyType, a = this._def.valueType, i3 = [...n2.data.entries()].map(([o2, c2], u) => ({
      key: s._parse(new B2(n2, o2, n2.path, [u, "key"])),
      value: a._parse(new B2(n2, c2, n2.path, [u, "value"]))
    }));
    if (n2.common.async) {
      const o2 = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c2 of i3) {
          const u = await c2.key, d = await c2.value;
          if (u.status === "aborted" || d.status === "aborted")
            return v;
          (u.status === "dirty" || d.status === "dirty") && r.dirty(), o2.set(u.value, d.value);
        }
        return { status: r.value, value: o2 };
      });
    } else {
      const o2 = /* @__PURE__ */ new Map();
      for (const c2 of i3) {
        const u = c2.key, d = c2.value;
        if (u.status === "aborted" || d.status === "aborted")
          return v;
        (u.status === "dirty" || d.status === "dirty") && r.dirty(), o2.set(u.value, d.value);
      }
      return { status: r.value, value: o2 };
    }
  }
};
tt.create = (t, e, r) => new tt({
  valueType: e,
  keyType: t,
  typeName: _.ZodMap,
  ...b(r)
});
var ue = class _ue extends w {
  _parse(e) {
    const { status: r, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== m.set)
      return p(n2, {
        code: f2.invalid_type,
        expected: m.set,
        received: n2.parsedType
      }), v;
    const s = this._def;
    s.minSize !== null && n2.data.size < s.minSize.value && (p(n2, {
      code: f2.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n2.data.size > s.maxSize.value && (p(n2, {
      code: f2.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.maxSize.message
    }), r.dirty());
    const a = this._def.valueType;
    function i3(c2) {
      const u = /* @__PURE__ */ new Set();
      for (const d of c2) {
        if (d.status === "aborted")
          return v;
        d.status === "dirty" && r.dirty(), u.add(d.value);
      }
      return { status: r.value, value: u };
    }
    const o2 = [...n2.data.values()].map((c2, u) => a._parse(new B2(n2, c2, n2.path, u)));
    return n2.common.async ? Promise.all(o2).then((c2) => i3(c2)) : i3(o2);
  }
  min(e, r) {
    return new _ue({
      ...this._def,
      minSize: { value: e, message: g.toString(r) }
    });
  }
  max(e, r) {
    return new _ue({
      ...this._def,
      maxSize: { value: e, message: g.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
ue.create = (t, e) => new ue({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: _.ZodSet,
  ...b(e)
});
var me = class _me extends w {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.function)
      return p(r, {
        code: f2.invalid_type,
        expected: m.function,
        received: r.parsedType
      }), v;
    function n2(o2, c2) {
      return Xe({
        data: o2,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Ye(),
          ge
        ].filter((u) => !!u),
        issueData: {
          code: f2.invalid_arguments,
          argumentsError: c2
        }
      });
    }
    function s(o2, c2) {
      return Xe({
        data: o2,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Ye(),
          ge
        ].filter((u) => !!u),
        issueData: {
          code: f2.invalid_return_type,
          returnTypeError: c2
        }
      });
    }
    const a = { errorMap: r.common.contextualErrorMap }, i3 = r.data;
    if (this._def.returns instanceof ve) {
      const o2 = this;
      return I(async function(...c2) {
        const u = new L([]), d = await o2._def.args.parseAsync(c2, a).catch((k3) => {
          throw u.addIssue(n2(c2, k3)), u;
        }), h = await Reflect.apply(i3, this, d);
        return await o2._def.returns._def.type.parseAsync(h, a).catch((k3) => {
          throw u.addIssue(s(h, k3)), u;
        });
      });
    } else {
      const o2 = this;
      return I(function(...c2) {
        const u = o2._def.args.safeParse(c2, a);
        if (!u.success)
          throw new L([n2(c2, u.error)]);
        const d = Reflect.apply(i3, this, u.data), h = o2._def.returns.safeParse(d, a);
        if (!h.success)
          throw new L([s(d, h.error)]);
        return h.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new _me({
      ...this._def,
      args: V.create(e).rest(ie.create())
    });
  }
  returns(e) {
    return new _me({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n2) {
    return new _me({
      args: e || V.create([]).rest(ie.create()),
      returns: r || ie.create(),
      typeName: _.ZodFunction,
      ...b(n2)
    });
  }
};
var Ze = class extends w {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
Ze.create = (t, e) => new Ze({
  getter: t,
  typeName: _.ZodLazy,
  ...b(e)
});
var Ue = class extends w {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return p(r, {
        received: r.data,
        code: f2.invalid_literal,
        expected: this._def.value
      }), v;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
Ue.create = (t, e) => new Ue({
  value: t,
  typeName: _.ZodLiteral,
  ...b(e)
});
function mn(t, e) {
  return new te({
    values: t,
    typeName: _.ZodEnum,
    ...b(e)
  });
}
var te = class _te extends w {
  constructor() {
    super(...arguments), Re.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n2 = this._def.values;
      return p(r, {
        expected: x.joinValues(n2),
        received: r.parsedType,
        code: f2.invalid_type
      }), v;
    }
    if (Qe(this, Re, "f") || dn(this, Re, new Set(this._def.values), "f"), !Qe(this, Re, "f").has(e.data)) {
      const r = this._getOrReturnCtx(e), n2 = this._def.values;
      return p(r, {
        received: r.data,
        code: f2.invalid_enum_value,
        options: n2
      }), v;
    }
    return I(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return _te.create(e, {
      ...this._def,
      ...r
    });
  }
  exclude(e, r = this._def) {
    return _te.create(this.options.filter((n2) => !e.includes(n2)), {
      ...this._def,
      ...r
    });
  }
};
Re = /* @__PURE__ */ new WeakMap();
te.create = mn;
var We = class extends w {
  constructor() {
    super(...arguments), Oe.set(this, void 0);
  }
  _parse(e) {
    const r = x.getValidEnumValues(this._def.values), n2 = this._getOrReturnCtx(e);
    if (n2.parsedType !== m.string && n2.parsedType !== m.number) {
      const s = x.objectValues(r);
      return p(n2, {
        expected: x.joinValues(s),
        received: n2.parsedType,
        code: f2.invalid_type
      }), v;
    }
    if (Qe(this, Oe, "f") || dn(this, Oe, new Set(x.getValidEnumValues(this._def.values)), "f"), !Qe(this, Oe, "f").has(e.data)) {
      const s = x.objectValues(r);
      return p(n2, {
        received: n2.data,
        code: f2.invalid_enum_value,
        options: s
      }), v;
    }
    return I(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
Oe = /* @__PURE__ */ new WeakMap();
We.create = (t, e) => new We({
  values: t,
  typeName: _.ZodNativeEnum,
  ...b(e)
});
var ve = class extends w {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.promise && r.common.async === false)
      return p(r, {
        code: f2.invalid_type,
        expected: m.promise,
        received: r.parsedType
      }), v;
    const n2 = r.parsedType === m.promise ? r.data : Promise.resolve(r.data);
    return I(n2.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
ve.create = (t, e) => new ve({
  type: t,
  typeName: _.ZodPromise,
  ...b(e)
});
var W2 = class extends w {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n2 } = this._processInputParams(e), s = this._def.effect || null, a = {
      addIssue: (i3) => {
        p(n2, i3), i3.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n2.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "preprocess") {
      const i3 = s.transform(n2.data, a);
      if (n2.common.async)
        return Promise.resolve(i3).then(async (o2) => {
          if (r.value === "aborted")
            return v;
          const c2 = await this._def.schema._parseAsync({
            data: o2,
            path: n2.path,
            parent: n2
          });
          return c2.status === "aborted" ? v : c2.status === "dirty" || r.value === "dirty" ? he(c2.value) : c2;
        });
      {
        if (r.value === "aborted")
          return v;
        const o2 = this._def.schema._parseSync({
          data: i3,
          path: n2.path,
          parent: n2
        });
        return o2.status === "aborted" ? v : o2.status === "dirty" || r.value === "dirty" ? he(o2.value) : o2;
      }
    }
    if (s.type === "refinement") {
      const i3 = (o2) => {
        const c2 = s.refinement(o2, a);
        if (n2.common.async)
          return Promise.resolve(c2);
        if (c2 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o2;
      };
      if (n2.common.async === false) {
        const o2 = this._def.schema._parseSync({
          data: n2.data,
          path: n2.path,
          parent: n2
        });
        return o2.status === "aborted" ? v : (o2.status === "dirty" && r.dirty(), i3(o2.value), { status: r.value, value: o2.value });
      } else
        return this._def.schema._parseAsync({ data: n2.data, path: n2.path, parent: n2 }).then((o2) => o2.status === "aborted" ? v : (o2.status === "dirty" && r.dirty(), i3(o2.value).then(() => ({ status: r.value, value: o2.value }))));
    }
    if (s.type === "transform")
      if (n2.common.async === false) {
        const i3 = this._def.schema._parseSync({
          data: n2.data,
          path: n2.path,
          parent: n2
        });
        if (!oe(i3))
          return i3;
        const o2 = s.transform(i3.value, a);
        if (o2 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o2 };
      } else
        return this._def.schema._parseAsync({ data: n2.data, path: n2.path, parent: n2 }).then((i3) => oe(i3) ? Promise.resolve(s.transform(i3.value, a)).then((o2) => ({ status: r.value, value: o2 })) : i3);
    x.assertNever(s);
  }
};
W2.create = (t, e, r) => new W2({
  schema: t,
  typeName: _.ZodEffects,
  effect: e,
  ...b(r)
});
W2.createWithPreprocess = (t, e, r) => new W2({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: _.ZodEffects,
  ...b(r)
});
var z = class extends w {
  _parse(e) {
    return this._getType(e) === m.undefined ? I(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
z.create = (t, e) => new z({
  innerType: t,
  typeName: _.ZodOptional,
  ...b(e)
});
var re = class extends w {
  _parse(e) {
    return this._getType(e) === m.null ? I(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
re.create = (t, e) => new re({
  innerType: t,
  typeName: _.ZodNullable,
  ...b(e)
});
var qe = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n2 = r.data;
    return r.parsedType === m.undefined && (n2 = this._def.defaultValue()), this._def.innerType._parse({
      data: n2,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
qe.create = (t, e) => new qe({
  innerType: t,
  typeName: _.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...b(e)
});
var ze = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n2 = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n2.data,
      path: n2.path,
      parent: {
        ...n2
      }
    });
    return Ne(s) ? s.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new L(n2.common.issues);
        },
        input: n2.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new L(n2.common.issues);
        },
        input: n2.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ze.create = (t, e) => new ze({
  innerType: t,
  typeName: _.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...b(e)
});
var rt = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.nan) {
      const n2 = this._getOrReturnCtx(e);
      return p(n2, {
        code: f2.invalid_type,
        expected: m.nan,
        received: n2.parsedType
      }), v;
    }
    return { status: "valid", value: e.data };
  }
};
rt.create = (t) => new rt({
  typeName: _.ZodNaN,
  ...b(t)
});
var hi = Symbol("zod_brand");
var Yt = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n2 = r.data;
    return this._def.type._parse({
      data: n2,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Fe = class _Fe extends w {
  _parse(e) {
    const { status: r, ctx: n2 } = this._processInputParams(e);
    if (n2.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: n2.data,
          path: n2.path,
          parent: n2
        });
        return a.status === "aborted" ? v : a.status === "dirty" ? (r.dirty(), he(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: n2.path,
          parent: n2
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n2.data,
        path: n2.path,
        parent: n2
      });
      return s.status === "aborted" ? v : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n2.path,
        parent: n2
      });
    }
  }
  static create(e, r) {
    return new _Fe({
      in: e,
      out: r,
      typeName: _.ZodPipeline
    });
  }
};
var Be = class extends w {
  _parse(e) {
    const r = this._def.innerType._parse(e), n2 = (s) => (oe(s) && (s.value = Object.freeze(s.value)), s);
    return Ne(r) ? r.then((s) => n2(s)) : n2(r);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Be.create = (t, e) => new Be({
  innerType: t,
  typeName: _.ZodReadonly,
  ...b(e)
});
function yn(t, e = {}, r) {
  return t ? _e.create().superRefine((n2, s) => {
    var a, i3;
    if (!t(n2)) {
      const o2 = typeof e == "function" ? e(n2) : typeof e == "string" ? { message: e } : e, c2 = (i3 = (a = o2.fatal) !== null && a !== void 0 ? a : r) !== null && i3 !== void 0 ? i3 : true, u = typeof o2 == "string" ? { message: o2 } : o2;
      s.addIssue({ code: "custom", ...u, fatal: c2 });
    }
  }) : _e.create();
}
var mi = {
  object: C.lazycreate
};
var _;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(_ || (_ = {}));
var yi = (t, e = {
  message: `Input not instance of ${t.name}`
}) => yn((r) => r instanceof t, e);
var gn = Z.create;
var _n = K.create;
var gi = rt.create;
var _i = ee.create;
var vn = Ie.create;
var vi = ce.create;
var bi = Ke.create;
var wi = je.create;
var xi = Le.create;
var ki = _e.create;
var Ti = ie.create;
var Ei = X.create;
var Ci = et.create;
var Ri = U3.create;
var Oi = C.create;
var Si = C.strictCreate;
var Pi = $e.create;
var Ai = ft.create;
var Ni = Me.create;
var Ii = V.create;
var ji = De.create;
var Li = tt.create;
var $i = ue.create;
var Mi = me.create;
var Di = Ze.create;
var Zi = Ue.create;
var Ui = te.create;
var Wi = We.create;
var qi = ve.create;
var vr = W2.create;
var zi = z.create;
var Bi = re.create;
var Vi = W2.createWithPreprocess;
var Fi = Fe.create;
var Hi = () => gn().optional();
var Gi = () => _n().optional();
var Ji = () => vn().optional();
var Yi = {
  string: (t) => Z.create({ ...t, coerce: true }),
  number: (t) => K.create({ ...t, coerce: true }),
  boolean: (t) => Ie.create({
    ...t,
    coerce: true
  }),
  bigint: (t) => ee.create({ ...t, coerce: true }),
  date: (t) => ce.create({ ...t, coerce: true })
};
var Xi = v;
var l2 = Object.freeze({
  __proto__: null,
  defaultErrorMap: ge,
  setErrorMap: Va,
  getErrorMap: Ye,
  makeIssue: Xe,
  EMPTY_PATH: Fa,
  addIssueToContext: p,
  ParseStatus: N,
  INVALID: v,
  DIRTY: he,
  OK: I,
  isAborted: At,
  isDirty: Nt,
  isValid: oe,
  isAsync: Ne,
  get util() {
    return x;
  },
  get objectUtil() {
    return Pt;
  },
  ZodParsedType: m,
  getParsedType: Y,
  ZodType: w,
  datetimeRegex: hn,
  ZodString: Z,
  ZodNumber: K,
  ZodBigInt: ee,
  ZodBoolean: Ie,
  ZodDate: ce,
  ZodSymbol: Ke,
  ZodUndefined: je,
  ZodNull: Le,
  ZodAny: _e,
  ZodUnknown: ie,
  ZodNever: X,
  ZodVoid: et,
  ZodArray: U3,
  ZodObject: C,
  ZodUnion: $e,
  ZodDiscriminatedUnion: ft,
  ZodIntersection: Me,
  ZodTuple: V,
  ZodRecord: De,
  ZodMap: tt,
  ZodSet: ue,
  ZodFunction: me,
  ZodLazy: Ze,
  ZodLiteral: Ue,
  ZodEnum: te,
  ZodNativeEnum: We,
  ZodPromise: ve,
  ZodEffects: W2,
  ZodTransformer: W2,
  ZodOptional: z,
  ZodNullable: re,
  ZodDefault: qe,
  ZodCatch: ze,
  ZodNaN: rt,
  BRAND: hi,
  ZodBranded: Yt,
  ZodPipeline: Fe,
  ZodReadonly: Be,
  custom: yn,
  Schema: w,
  ZodSchema: w,
  late: mi,
  get ZodFirstPartyTypeKind() {
    return _;
  },
  coerce: Yi,
  any: ki,
  array: Ri,
  bigint: _i,
  boolean: vn,
  date: vi,
  discriminatedUnion: Ai,
  effect: vr,
  enum: Ui,
  function: Mi,
  instanceof: yi,
  intersection: Ni,
  lazy: Di,
  literal: Zi,
  map: Li,
  nan: gi,
  nativeEnum: Wi,
  never: Ei,
  null: xi,
  nullable: Bi,
  number: _n,
  object: Oi,
  oboolean: Ji,
  onumber: Gi,
  optional: zi,
  ostring: Hi,
  pipeline: Fi,
  preprocess: Vi,
  promise: qi,
  record: ji,
  set: $i,
  strictObject: Si,
  string: gn,
  symbol: bi,
  transformer: vr,
  tuple: Ii,
  undefined: wi,
  union: Pi,
  unknown: Ti,
  void: Ci,
  NEVER: Xi,
  ZodIssueCode: f2,
  quotelessJson: Ba,
  ZodError: L
});
var bn = /^0x[0-9a-f]+$/i;
var wn = /^\d+$/;
var Qi = l2.string().min(1, "The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t) => !bn.test(t),
  "The shortString should not be a hex string"
).refine(
  (t) => !wn.test(t),
  "The shortString should not be an integer string"
);
var M2 = l2.union([
  l2.string().regex(
    bn,
    "Only hex, integers and bigint are supported in calldata"
  ),
  l2.string().regex(
    wn,
    "Only hex, integers and bigint are supported in calldata"
  ),
  Qi,
  l2.number().int("Only hex, integers and bigint are supported in calldata"),
  l2.bigint()
]);
var Ve = l2.object({
  contractAddress: l2.string(),
  entrypoint: l2.string(),
  calldata: l2.array(M2.or(l2.array(M2))).optional()
});
var jt = l2.array(Ve).nonempty();
var xn = l2.object({
  types: l2.record(
    l2.array(
      l2.union([
        l2.object({
          name: l2.string(),
          type: l2.literal("merkletree"),
          contains: l2.string()
        }),
        l2.object({
          name: l2.string(),
          type: l2.literal("enum"),
          contains: l2.string()
        }),
        l2.object({
          name: l2.string(),
          type: l2.string()
        })
      ])
    )
  ),
  primaryType: l2.string(),
  domain: l2.record(l2.unknown()),
  message: l2.record(l2.unknown()).or(l2.object({}))
});
var Lt = l2.object({
  type: l2.literal("ERC20"),
  options: l2.object({
    address: l2.string(),
    symbol: l2.string().optional(),
    decimals: l2.number().optional(),
    image: l2.string().optional(),
    name: l2.string().optional()
  })
});
var Ki = l2.union([
  l2.object({
    id: l2.string(),
    chain_id: l2.string(),
    chain_name: l2.string(),
    rpc_urls: l2.array(l2.string()).optional(),
    native_currency: Lt.optional(),
    block_explorer_url: l2.array(l2.string()).optional()
  }),
  l2.object({
    id: l2.string(),
    chainId: l2.string(),
    chainName: l2.string(),
    rpcUrls: l2.array(l2.string()).optional(),
    nativeCurrency: Lt.optional(),
    blockExplorerUrl: l2.array(l2.string()).optional()
  }).transform((t) => ({
    id: t.id,
    chain_id: t.chainId,
    chain_name: t.chainName,
    rpc_urls: t.rpcUrls,
    native_currency: t.nativeCurrency,
    block_explorer_url: t.blockExplorerUrl
  }))
]);
var kt = {
  enable: l2.tuple([
    l2.object({
      starknetVersion: l2.union([l2.literal("v3"), l2.literal("v4"), l2.literal("v5")]).optional()
    }).optional()
  ]).or(l2.tuple([])),
  addStarknetChain: l2.tuple([Ki]),
  switchStarknetChain: l2.tuple([
    l2.object({
      chainId: l2.string()
    })
  ]),
  watchAsset: l2.tuple([Lt]),
  requestAccounts: l2.tuple([
    l2.object({
      silent_mode: l2.boolean().optional()
    })
  ]),
  execute: l2.tuple([
    jt.or(Ve),
    l2.object({
      nonce: M2.optional(),
      maxFee: M2.optional(),
      version: M2.optional()
    }).optional()
  ]),
  signMessage: l2.tuple([xn])
};
l2.tuple([
  jt.or(Ve),
  l2.object({
    nonce: M2.optional(),
    maxFee: M2.optional(),
    version: M2.optional()
  }).optional()
]).or(
  l2.tuple([
    jt.or(Ve),
    l2.array(l2.any()).optional(),
    l2.object({
      nonce: M2.optional(),
      maxFee: M2.optional(),
      version: M2.optional()
    }).optional()
  ])
);
var kn = l2.object({
  contract_address: l2.string(),
  entry_point: l2.string(),
  calldata: l2.array(M2).optional()
}).transform(({ contract_address: t, entry_point: e, calldata: r }) => ({
  contractAddress: t,
  entrypoint: e,
  calldata: r || []
}));
var eo = l2.array(kn).nonempty();
var to = {
  ZERO: 0,
  ONE: 1
};
var ro = l2.object({
  address: l2.string(),
  class_hash: l2.string(),
  salt: l2.string(),
  calldata: l2.array(l2.string()),
  sigdata: l2.array(l2.string()).optional(),
  //version: z.literal([0, 1]),
  version: l2.nativeEnum(to)
  // allow only 0 | 1, workaround since zod doesn't support literals as numbers
});
var no = l2.object({
  callbackData: l2.string().optional(),
  approvalRequests: l2.array(
    l2.object({
      tokenAddress: l2.string(),
      amount: l2.string(),
      spender: l2.string()
    })
  ),
  sessionTypedData: xn
});
var so = l2.object({
  account: l2.string().array().optional(),
  chainId: l2.string().optional(),
  signature: l2.string().array().optional(),
  approvalTransactionHash: l2.string().optional(),
  deploymentPayload: l2.any().optional(),
  approvalRequestsCalls: l2.array(Ve).optional(),
  errorCode: l2.enum([
    "USER_REJECTED",
    "ACCOUNT_NOT_DEPLOYED",
    "NOT_ENOUGH_BALANCE",
    "NOT_ENOUGH_BALANCE_DEPLOYMENT",
    "GENERIC_ERROR"
  ]).optional()
});
var O = Ps.create({
  isServer: false,
  allowOutsideOfServer: true
});
var $t = Tr;
var Mt = "";
var Tn = "";
var Dt = ({
  width: t = 775,
  height: e = 385,
  origin: r,
  location: n2,
  atLeftBottom: s = false
}) => {
  const a = window?.outerWidth ?? window?.innerWidth ?? window?.screen.width ?? 0, i3 = window?.outerHeight ?? window?.innerHeight ?? window?.screen.height ?? 0, o2 = window?.screenLeft ?? window?.screenX ?? 0, c2 = window?.screenTop ?? window?.screenY ?? 0, u = s ? 0 : o2 + a / 2 - t / 2, d = s ? window.screen.availHeight + 10 : c2 + i3 / 2 - e / 2;
  $t = r ?? $t, Mt = n2 ?? Mt, Tn = `width=${t},height=${e},top=${d},left=${u},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;
};
O.router({
  authorize: O.procedure.output(l2.boolean()).mutation(async () => true),
  connect: O.procedure.mutation(async () => ""),
  connectWebwallet: O.procedure.input(
    l2.object({
      theme: l2.enum(["light", "dark", "auto"]).optional()
    })
  ).output(
    l2.object({
      account: l2.string().array().optional(),
      chainId: l2.string().optional()
    })
  ).mutation(async () => ({})),
  connectWebwalletSSO: O.procedure.input(
    l2.object({ token: l2.string(), authorizedPartyId: l2.string().optional() })
  ).output(
    l2.object({
      account: l2.string().array().optional(),
      chainId: l2.string().optional()
    })
  ).mutation(async () => ({})),
  connectAndSignSession: O.procedure.input(no).output(so).mutation(async () => ({})),
  enable: O.procedure.output(l2.string()).mutation(async () => ""),
  execute: O.procedure.input(kt.execute).output(l2.string()).mutation(async () => ""),
  signMessage: O.procedure.input(kt.signMessage).output(l2.string().array()).mutation(async () => []),
  getLoginStatus: O.procedure.output(
    l2.object({
      isLoggedIn: l2.boolean(),
      hasSession: l2.boolean().optional(),
      isPreauthorized: l2.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: true
  })),
  // RPC Messages
  requestAccounts: O.procedure.input(l2.object({ silent_mode: l2.boolean().optional() })).output(l2.string().array()).mutation(async () => []),
  requestChainId: O.procedure.output(l2.string()).mutation(async () => ""),
  signTypedData: O.procedure.input(kt.signMessage).output(l2.string().array()).mutation(async () => []),
  getPermissions: O.procedure.output(l2.array(l2.enum([T.ACCOUNTS]))).mutation(async () => [T.ACCOUNTS]),
  addInvokeTransaction: O.procedure.input(kn.or(eo)).output(l2.string()).mutation(async (t) => ""),
  addStarknetChain: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  watchAsset: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  updateModal: O.procedure.subscription(async () => {
  }),
  deploymentData: O.procedure.output(ro).mutation(async () => ({
    address: "",
    calldata: [],
    version: 0,
    class_hash: "",
    salt: ""
  }))
});
var Tt = ({
  iframe: t
}) => ms({
  links: [
    ls({
      enabled: (e) => typeof window < "u" || e.direction === "down" && e.result instanceof Error
    }),
    Xn({
      condition(e) {
        if (!t && e.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!t;
      },
      true: Rt.windowLink({
        window,
        postWindow: t,
        postOrigin: "*"
      }),
      false: Rt.popupLink({
        listenWindow: window,
        createPopup: () => {
          let e = null;
          const r = document.createElement("button");
          if (r.style.display = "none", r.addEventListener("click", () => {
            e = window.open(
              `${$t}${Mt}`,
              "popup",
              Tn
            );
          }), r.click(), (async () => {
            for (; !e; )
              await new Promise((n2) => setTimeout(n2, 100));
          })(), !e)
            throw new Error("Could not open popup");
          return e;
        },
        postOrigin: "*"
      })
    })
  ]
});
var Ge = [];
var ao = (t, e) => ({
  ...t,
  getLoginStatus: () => e.getLoginStatus.mutate(),
  connectWebwallet: (n2 = {}) => {
    const { theme: s } = n2;
    return e.connectWebwallet.mutate({
      theme: s
    });
  },
  connectAndSignSession: (n2) => e.connectAndSignSession.mutate(n2),
  connectWebwalletSSO: (n2, s) => e.connectWebwalletSSO.mutate({ token: n2, authorizedPartyId: s }),
  async request(n2) {
    switch (n2.type) {
      case "wallet_requestAccounts":
        return e.requestAccounts.mutate(n2.params);
      case "wallet_signTypedData": {
        const s = n2.params, a = s?.primaryType === "Session" && s?.domain.name === "SessionAccount.session";
        Dt({
          width: Wn,
          height: qn,
          location: a ? "/signSessionKeys" : "/signMessage"
        });
        const i3 = Array.isArray(n2.params) ? n2.params : [n2.params];
        return e.signTypedData.mutate(i3);
      }
      case "wallet_getPermissions":
        return e.getPermissions.mutate();
      case "wallet_addInvokeTransaction": {
        const s = n2.params.calls;
        return Dt({
          width: Zn,
          height: Un,
          location: "/review"
        }), { transaction_hash: await e.addInvokeTransaction.mutate(s) };
      }
      case "wallet_requestChainId":
        return await e.requestChainId.mutate();
      case "wallet_addStarknetChain":
        return e.addStarknetChain.mutate(n2.params);
      case "wallet_switchStarknetChain":
        return e.switchStarknetChain.mutate(n2.params);
      case "wallet_watchAsset":
        return e.watchAsset.mutate();
      case "wallet_deploymentData":
        return e.deploymentData.mutate();
      default:
        throw new Error("not implemented");
    }
  },
  on: (n2, s) => {
    if (n2 === "accountsChanged")
      Ge.push({
        type: n2,
        handler: s
      });
    else if (n2 === "networkChanged")
      Ge.push({
        type: n2,
        handler: s
      });
    else
      throw new Error(`Unknwown event: ${n2}`);
  },
  off: (n2, s) => {
    if (n2 !== "accountsChanged" && n2 !== "networkChanged")
      throw new Error(`Unknwown event: ${n2}`);
    const a = Ge.findIndex(
      (i3) => i3.type === n2 && i3.handler === s
    );
    a >= 0 && Ge.splice(a, 1);
  }
});
var io = (t) => {
  t.style.display = "none", t.style.borderRadius = "40px", t.style.inset = "0", t.style.position = "fixed", t.style.top = "50%", t.style.left = "50%", t.style.transform = "translate(-50%, -50%)", t.style.backgroundColor = "transparent", t.style.zIndex = "999999", t.style.height = `${Bn}px`, t.style.width = `${zn}px`;
};
var oo = (t, e) => {
  t.style.display = "block", e.style.display = "block";
};
var co = (t, e) => {
  t.style.display = "none", e.style.display = "none";
};
var uo = (t, e, r) => {
  t.style.width = `${e}px`, t.style.height = `${r}px`;
};
var br = "argent-webwallet-iframe";
var lo = async (t, e) => {
  const r = "argent-webwallet-backdrop", n2 = new URL(t);
  n2.pathname = "/iframes/comms", t = n2.toString();
  const s = document.createElement("iframe");
  s.src = t, s.loading = "eager", s.sandbox.add(
    "allow-scripts",
    "allow-same-origin",
    "allow-forms",
    "allow-top-navigation",
    "allow-popups"
  ), s.allow = "clipboard-write", s.id = br, s.setAttribute("allowtransparency", "true"), s.setAttribute("transparent", "true"), io(s), s.style.display = e ? "block" : "none";
  const a = document.createElement("div");
  a.id = r, a.style.position = "fixed", a.style.inset = "0", a.style.backgroundColor = "rgba(0,0,0,0.5)", a.style.zIndex = "999998", a.style.width = "100dvw", a.style.height = "100dvh", a.style.backdropFilter = "blur(4px)";
  const i3 = document.getElementById(br);
  return i3 && (i3.remove(), document.getElementById(r)?.remove()), window.document.body.appendChild(s), await new Promise((o2, c2) => {
    const u = setTimeout(
      () => c2(new Error("Timeout while loading an iframe")),
      2e4
    );
    s.addEventListener("load", async () => {
      clearTimeout(u), o2();
    });
  }), window.document.body.appendChild(a), { iframe: s, backdrop: a };
};
var Et = async (t, e, r) => {
  const n2 = typeof window < "u" ? window : void 0;
  if (!n2)
    throw new Error("window is not defined");
  const s = ao(
    {
      host: n2.location.origin,
      id: "argentWebWallet",
      icon: "https://www.argent.xyz/favicon.ico",
      name: "Argent Web Wallet",
      version: "1.0.0"
    },
    e
  );
  if (r) {
    const { iframe: a, backdrop: i3 } = r;
    e.updateModal.subscribe(void 0, {
      onData(o2) {
        switch (o2.action) {
          case "show":
            oo(a, i3);
            break;
          case "hide":
            co(a, i3);
            break;
          case "updateSize":
            uo(a, o2.width, o2.height);
            break;
        }
      }
    });
  }
  return s;
};
var wr = "allowed-dapps";
var fo = async (t) => {
  const e = t === constants_exports.NetworkName.SN_MAIN ? jn : In;
  try {
    const n2 = await (await caches.open(wr)).match(e);
    if (n2) {
      const u = parseInt(
        n2.headers.get("X-Cache-Timestamp") ?? "0",
        10
      );
      if (((/* @__PURE__ */ new Date()).getTime() - u) / (1e3 * 60 * 60) < 24)
        return n2.json();
    }
    const s = await fetch(e), a = new Headers(s.headers);
    a.set("X-Cache-Timestamp", (/* @__PURE__ */ new Date()).getTime().toString());
    const i3 = await s.json(), o2 = new Response(JSON.stringify(i3), {
      status: s.status,
      statusText: s.statusText,
      headers: a
    });
    return await (await caches.open(wr)).put(e, o2), i3;
  } catch (r) {
    throw new Error(r);
  }
};
var po = async (t) => new Promise((e) => {
  if (!t)
    return e(false);
  try {
    navigator.webkitTemporaryStorage.queryUsageAndQuota(
      (n2, s) => {
        e(
          Math.round(s / (1024 * 1024)) < Math.round(
            (performance?.memory?.jsHeapSizeLimit ?? 1073741824) / (1024 * 1024)
          ) * 2
        );
      },
      () => e(false)
    );
  } catch {
    e(false);
  }
});
var ho = async (t) => {
  const { userAgent: e } = navigator, r = !!(navigator.vendor && navigator.vendor.indexOf("Google") === 0 && navigator.brave === void 0 && !e.match(/Edg/) && !e.match(/OPR/)), n2 = await po(r);
  if (!r || n2) {
    const i3 = Tt({});
    return await Et(
      t,
      i3,
      void 0
    );
  }
  const s = Dn(t), { allowedDapps: a } = await fo(s);
  if (a.includes(window.location.hostname)) {
    const i3 = "argent-webwallet-backdrop", o2 = "argent-webwallet-iframe", c2 = document.getElementById(i3), u = document.getElementById(o2);
    u && u && c2 && (u.remove(), c2.remove());
    const { iframe: d, backdrop: h } = await lo(t, false), y = Tt({
      iframe: d.contentWindow ?? void 0
    });
    return await Et(
      t,
      y,
      { iframe: d, backdrop: h }
    );
  } else {
    const i3 = Tt({});
    return await Et(
      t,
      i3,
      void 0
    );
  }
};
var En = "webwallet_logout";
var D = null;
var ae = null;
var bo = class extends R {
  constructor(r = {}) {
    super();
    Te(this, "_wallet", null);
    Te(this, "_options");
    this._options = r;
  }
  available() {
    return true;
  }
  async ready() {
    if (this._wallet || await this.ensureWallet(), this._wallet)
      try {
        return (await this._wallet.request({
          type: "wallet_getPermissions"
        })).includes(T.ACCOUNTS);
      } catch {
        return false;
      }
    else
      return this._wallet = null, ae = null, false;
  }
  get id() {
    return this._wallet = D, this._wallet?.id || "argentWebWallet";
  }
  get name() {
    return this._wallet = D, this._wallet?.name || "Argent Web Wallet";
  }
  get icon() {
    return {
      light: rr,
      dark: rr
    };
  }
  get wallet() {
    if (!this._wallet)
      throw new U();
    return this._wallet;
  }
  get title() {
    return "Email";
  }
  get subtitle() {
    return "Powered by Argent";
  }
  async connectAndSignSession({
    callbackData: r,
    approvalRequests: n2,
    sessionTypedData: s
  }) {
    if (this._wallet || await this.ensureWallet(), !this._wallet)
      throw new W();
    try {
      return await this._wallet.connectAndSignSession({
        callbackData: r,
        approvalRequests: n2,
        sessionTypedData: s,
        theme: this._options.theme
      });
    } catch (a) {
      if (a instanceof Error && (a.constructor.name === "TRPCClientError" || a.name === "TRPCClientError")) {
        const i3 = a, o2 = i3.shape.data.webwalletErrorMessage || i3.message, c2 = i3.shape.data.webwalletErrorCode || i3.shape.message;
        throw new Ln(o2, c2);
      }
      throw new Error(a instanceof Error ? a.message : String(a));
    }
  }
  async connect(r = {}) {
    if (this._wallet || await this.ensureWallet(), !this._wallet)
      throw new W();
    try {
      let n2, s;
      if (this._options.ssoToken) {
        const i3 = await this._wallet.connectWebwalletSSO(
          this._options.ssoToken,
          this._options.authorizedPartyId
        );
        n2 = i3.account, s = i3.chainId;
      } else {
        const i3 = await this._wallet.connectWebwallet({
          theme: this._options.theme
        });
        n2 = i3.account, s = i3.chainId;
      }
      if (!n2 || !s)
        return {};
      const a = S2(s);
      return ae = n2[0], {
        account: n2[0],
        chainId: BigInt(a)
      };
    } catch {
      throw new q();
    }
  }
  async request(r) {
    if (this._wallet || await this.ensureWallet(), !this._wallet)
      throw new U();
    try {
      return await this._wallet.request(r);
    } catch (n2) {
      if (n2 instanceof Error && (n2.constructor.name === "TRPCClientError" || n2.name === "TRPCClientError")) {
        const s = n2, a = s.shape.data.webwalletErrorMessage || s.message, i3 = s.shape.data.webwalletErrorCode || s.shape.message;
        throw i3 === "USER_LOGGED_OUT" && (D = null, ae = null, this._wallet = null, document.dispatchEvent(new Event(En))), new $n(a, i3);
      }
      throw new q();
    }
  }
  async disconnect() {
    if (!this.available() && !this._wallet)
      throw new W();
    D = null, ae = null, this._wallet = D, M();
  }
  async account(r) {
    if (this._wallet = D, !this._wallet)
      throw new U();
    if (!ae)
      throw new U();
    return new WalletAccount(r, this._wallet, void 0, ae);
  }
  async chainId() {
    if (!this._wallet)
      throw new U();
    const r = await this._wallet.request({
      type: "wallet_requestChainId"
    }), n2 = S2(r);
    return BigInt(n2);
  }
  async initEventListener(r) {
    if (this._wallet = D, !this._wallet)
      throw new U();
    this._wallet.on("accountsChanged", r);
  }
  async removeEventListener(r) {
    if (this._wallet = D, !this._wallet)
      throw new U();
    this._wallet.off("accountsChanged", r), D = null, ae = null, this._wallet = null;
  }
  async ensureWallet() {
    const r = this._options.url || Tr;
    Dt({
      origin: r,
      location: "/interstitialLogin"
    }), D = await ho(r) ?? null, this._wallet = D;
  }
};

// node_modules/starknetkit/dist/braavosMobile.js
var i = Object.defineProperty;
var l3 = (r, e, t) => e in r ? i(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var n = (r, e, t) => (l3(r, typeof e != "symbol" ? e + "" : e, t), t);
var o = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 32 32" version="1.1">
    <defs>
    <clipPath id="clip1">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    <linearGradient id="linear0" gradientUnits="userSpaceOnUse" x1="-9.552" y1="-6.444" x2="50.240002" y2="41.303001" gradientTransform="matrix(0.666667,0,0,0.666667,0,0)">
      <stop offset="0" style="stop-color:rgb(3.529412%,45.09804%,75.294119%);stop-opacity:1;"/>
      <stop offset="1" style="stop-color:rgb(10.980392%,28.627452%,87.058824%);stop-opacity:1;"/>
    </linearGradient>
    <clipPath id="clip2">
      <path d="M 7 4 L 25 4 L 25 15 L 7 15 Z M 7 4 "/>
    </clipPath>
    <clipPath id="clip3">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    <clipPath id="clip4">
    	<path d="M 6 13 L 26 13 L 26 28 L 6 28 Z M 6 13 "/>
    </clipPath>
    <clipPath id="clip5">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    </defs>
    <g id="surface1">
      <g clip-path="url(#clip1)" clip-rule="nonzero">
        <rect x="0" y="0" width="32" height="32" style="fill:url(#linear0);stroke:none;"/>
      </g>
    	<g clip-path="url(#clip2)" clip-rule="nonzero">
        <g clip-path="url(#clip3)" clip-rule="nonzero">
	        <path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 19.507812 6.320312 C 19.542969 6.378906 19.496094 6.453125 19.425781 6.453125 C 18.027344 6.453125 16.886719 7.5625 16.859375 8.941406 C 16.375 8.851562 15.878906 8.847656 15.390625 8.929688 C 15.359375 7.554688 14.222656 6.453125 12.824219 6.453125 C 12.757812 6.453125 12.710938 6.378906 12.746094 6.320312 C 13.453125 5.128906 14.738281 4.398438 16.125 4.398438 C 17.515625 4.394531 18.800781 5.125 19.507812 6.320312 M 23.65625 14.847656 C 24.132812 14.992188 24.585938 14.574219 24.402344 14.109375 C 23.066406 10.65625 19.109375 9.242188 16.105469 9.242188 C 13.097656 9.242188 9.054688 10.703125 7.804688 14.128906 C 7.632812 14.589844 8.082031 14.996094 8.550781 14.851562 L 15.75 12.648438 C 15.957031 12.582031 16.179688 12.582031 16.386719 12.644531 Z M 23.65625 14.847656 "/>
        </g>
    	</g>
    	<g clip-path="url(#clip4)" clip-rule="nonzero">
        <g clip-path="url(#clip5)" clip-rule="nonzero">
          <path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 7.734375 15.511719 L 15.757812 13.078125 C 15.964844 13.015625 16.183594 13.015625 16.390625 13.078125 L 24.464844 15.511719 C 25.136719 15.714844 25.597656 16.335938 25.597656 17.042969 L 25.597656 24.378906 C 25.566406 26.167969 23.960938 27.605469 22.167969 27.605469 L 19.195312 27.605469 C 19.054688 27.605469 18.917969 27.550781 18.820312 27.449219 C 18.71875 27.347656 18.664062 27.214844 18.664062 27.074219 L 18.664062 24.5 C 18.664062 23.488281 19.261719 22.570312 20.191406 22.164062 C 21.433594 21.621094 22.90625 20.886719 23.183594 19.410156 C 23.269531 18.933594 22.960938 18.472656 22.484375 18.378906 C 21.285156 18.140625 19.953125 18.230469 18.824219 18.734375 C 17.546875 19.308594 17.210938 20.257812 17.085938 21.539062 L 16.9375 22.914062 C 16.890625 23.335938 16.496094 23.65625 16.074219 23.65625 C 15.636719 23.65625 15.308594 23.324219 15.261719 22.886719 L 15.113281 21.539062 C 15.007812 20.441406 14.8125 19.378906 13.683594 18.875 C 12.390625 18.296875 11.09375 18.105469 9.714844 18.378906 C 9.238281 18.472656 8.929688 18.933594 9.015625 19.410156 C 9.296875 20.898438 10.757812 21.617188 12.007812 22.164062 C 12.9375 22.570312 13.535156 23.488281 13.535156 24.5 L 13.535156 27.074219 C 13.535156 27.367188 13.296875 27.605469 13.003906 27.605469 L 10.03125 27.605469 C 8.238281 27.605469 6.628906 26.167969 6.597656 24.378906 L 6.597656 17.039062 C 6.597656 16.335938 7.058594 15.714844 7.734375 15.511719 "/>
        </g>
    	</g>
    </g>
</svg>
`;
var c = class extends R {
  constructor() {
    super();
    n(this, "_wallet", null);
  }
  available() {
    return true;
  }
  async ready() {
    return true;
  }
  get id() {
    return "braavosMobile";
  }
  get name() {
    return "Braavos (mobile)";
  }
  get icon() {
    return {
      dark: o,
      light: o
    };
  }
  get wallet() {
    throw new Error("not implemented");
  }
  async connect(t = {}) {
    return await this.ensureWallet(), {
      account: "",
      chainId: BigInt(0)
    };
  }
  async disconnect() {
    throw new Error("not implemented");
  }
  async account(t) {
    throw new Error("not implemented");
  }
  async chainId() {
    throw new Error("not implemented");
  }
  async request(t) {
    throw new Error("not implemented");
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async initEventListener(t) {
    throw new Error("not implemented");
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async removeEventListener(t) {
    throw new Error("not implemented");
  }
  async ensureWallet() {
    window.open(`https://link.braavos.app/dapp/${window.origin}`, "_blank");
  }
};

// node_modules/starknetkit/dist/starknetkit.js
var Ee2 = Object.defineProperty;
var Pe2 = (t, e, r) => e in t ? Ee2(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var J2 = (t, e, r) => (Pe2(t, typeof e != "symbol" ? e + "" : e, r), r);
var Re2 = () => {
  const t = navigator.userAgent.toLowerCase(), e = /android|webos|iphone|ipad|ipod|blackberry|windows phone/.test(t), r = "ontouchstart" in window || navigator.maxTouchPoints > 0, n2 = window.innerWidth <= 768;
  return e && (r || n2);
};
var Ie2 = ({
  argentMobileOptions: t,
  webWalletUrl: e
}) => {
  const r = typeof window < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : false, n2 = [];
  return r || (n2.push(
    new T2({ options: { id: "argentX" } })
  ), n2.push(
    new T2({ options: { id: "braavos" } })
  ), T2.isWalletInjected("metamask") && n2.push(
    new T2({ options: { id: "metamask" } })
  ), T2.isWalletInjected("fordefi") && n2.push(
    new T2({ options: { id: "fordefi" } })
  ), T2.isWalletInjected("keplr") && n2.push(
    new T2({ options: { id: "keplr" } })
  )), n2.push(new U2(t)), Re2() && n2.push(new c()), n2.push(new bo({ url: e })), n2;
};
var Ve2 = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var be2 = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var M3 = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var F3 = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var P = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
var i2 = class _i2 {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(e, r) {
    const n2 = r.match(e);
    return n2 && n2.length > 0 && n2[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(e, r) {
    const n2 = r.match(e);
    return n2 && n2.length > 1 && n2[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(e, r, n2) {
    if (e.test(r))
      return n2;
  }
  static getWindowsVersionName(e) {
    switch (e) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(e) {
    const r = e.split(".").splice(0, 2).map((n2) => parseInt(n2, 10) || 0);
    if (r.push(0), r[0] === 10)
      switch (r[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(e) {
    const r = e.split(".").splice(0, 2).map((n2) => parseInt(n2, 10) || 0);
    if (r.push(0), !(r[0] === 1 && r[1] < 5)) {
      if (r[0] === 1 && r[1] < 6)
        return "Cupcake";
      if (r[0] === 1 && r[1] >= 6)
        return "Donut";
      if (r[0] === 2 && r[1] < 2)
        return "Eclair";
      if (r[0] === 2 && r[1] === 2)
        return "Froyo";
      if (r[0] === 2 && r[1] > 2)
        return "Gingerbread";
      if (r[0] === 3)
        return "Honeycomb";
      if (r[0] === 4 && r[1] < 1)
        return "Ice Cream Sandwich";
      if (r[0] === 4 && r[1] < 4)
        return "Jelly Bean";
      if (r[0] === 4 && r[1] >= 4)
        return "KitKat";
      if (r[0] === 5)
        return "Lollipop";
      if (r[0] === 6)
        return "Marshmallow";
      if (r[0] === 7)
        return "Nougat";
      if (r[0] === 8)
        return "Oreo";
      if (r[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(e) {
    return e.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(e, r, n2 = false) {
    const o2 = _i2.getVersionPrecision(e), s = _i2.getVersionPrecision(r);
    let d = Math.max(o2, s), h = 0;
    const w2 = _i2.map([e, r], (l4) => {
      const a = d - _i2.getVersionPrecision(l4), g2 = l4 + new Array(a + 1).join(".0");
      return _i2.map(g2.split("."), (y) => new Array(20 - y.length).join("0") + y).reverse();
    });
    for (n2 && (h = d - Math.min(o2, s)), d -= 1; d >= h; ) {
      if (w2[0][d] > w2[1][d])
        return 1;
      if (w2[0][d] === w2[1][d]) {
        if (d === h)
          return 0;
        d -= 1;
      } else if (w2[0][d] < w2[1][d])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(e, r) {
    const n2 = [];
    let o2;
    if (Array.prototype.map)
      return Array.prototype.map.call(e, r);
    for (o2 = 0; o2 < e.length; o2 += 1)
      n2.push(r(e[o2]));
    return n2;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(e, r) {
    let n2, o2;
    if (Array.prototype.find)
      return Array.prototype.find.call(e, r);
    for (n2 = 0, o2 = e.length; n2 < o2; n2 += 1) {
      const s = e[n2];
      if (r(s, n2))
        return s;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(e, ...r) {
    const n2 = e;
    let o2, s;
    if (Object.assign)
      return Object.assign(e, ...r);
    for (o2 = 0, s = r.length; o2 < s; o2 += 1) {
      const d = r[o2];
      typeof d == "object" && d !== null && Object.keys(d).forEach((w2) => {
        n2[w2] = d[w2];
      });
    }
    return e;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(e) {
    return Ve2[e];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(e) {
    return be2[e] || "";
  }
};
var k = /version\/(\d+(\.?_?\d+)+)/i;
var De2 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(t) {
      const e = {
        name: "Googlebot"
      }, r = i2.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, r = i2.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(t) {
      const e = {
        name: "Samsung Internet for Android"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/Whale/i],
    describe(t) {
      const e = {
        name: "NAVER Whale Browser"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(t) {
      const e = {
        name: "MZ Browser"
      }, r = i2.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/focus/i],
    describe(t) {
      const e = {
        name: "Focus"
      }, r = i2.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/swing/i],
    describe(t) {
      const e = {
        name: "Swing"
      }, r = i2.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/coast/i],
    describe(t) {
      const e = {
        name: "Opera Coast"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(t) {
      const e = {
        name: "Opera Touch"
      }, r = i2.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/yabrowser/i],
    describe(t) {
      const e = {
        name: "Yandex Browser"
      }, r = i2.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(t) {
      const e = {
        name: "UC Browser"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(t) {
      const e = {
        name: "Maxthon"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/epiphany/i],
    describe(t) {
      const e = {
        name: "Epiphany"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/puffin/i],
    describe(t) {
      const e = {
        name: "Puffin"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/sleipnir/i],
    describe(t) {
      const e = {
        name: "Sleipnir"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/k-meleon/i],
    describe(t) {
      const e = {
        name: "K-Meleon"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/micromessenger/i],
    describe(t) {
      const e = {
        name: "WeChat"
      }, r = i2.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(t) {
      const e = {
        name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser"
      }, r = i2.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/msie|trident/i],
    describe(t) {
      const e = {
        name: "Internet Explorer"
      }, r = i2.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/\sedg\//i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, r = i2.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, r = i2.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/vivaldi/i],
    describe(t) {
      const e = {
        name: "Vivaldi"
      }, r = i2.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/seamonkey/i],
    describe(t) {
      const e = {
        name: "SeaMonkey"
      }, r = i2.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/sailfish/i],
    describe(t) {
      const e = {
        name: "Sailfish"
      }, r = i2.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/silk/i],
    describe(t) {
      const e = {
        name: "Amazon Silk"
      }, r = i2.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/phantom/i],
    describe(t) {
      const e = {
        name: "PhantomJS"
      }, r = i2.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/slimerjs/i],
    describe(t) {
      const e = {
        name: "SlimerJS"
      }, r = i2.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = {
        name: "BlackBerry"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = {
        name: "WebOS Browser"
      }, r = i2.getFirstMatch(k, t) || i2.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/bada/i],
    describe(t) {
      const e = {
        name: "Bada"
      }, r = i2.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/tizen/i],
    describe(t) {
      const e = {
        name: "Tizen"
      }, r = i2.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/qupzilla/i],
    describe(t) {
      const e = {
        name: "QupZilla"
      }, r = i2.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(t) {
      const e = {
        name: "Firefox"
      }, r = i2.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/electron/i],
    describe(t) {
      const e = {
        name: "Electron"
      }, r = i2.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(t) {
      const e = {
        name: "Miui"
      }, r = i2.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/chromium/i],
    describe(t) {
      const e = {
        name: "Chromium"
      }, r = i2.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) || i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(t) {
      const e = {
        name: "Chrome"
      }, r = i2.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/GSA/i],
    describe(t) {
      const e = {
        name: "Google Search"
      }, r = i2.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Android Browser */
  {
    test(t) {
      const e = !t.test(/like android/i), r = t.test(/android/i);
      return e && r;
    },
    describe(t) {
      const e = {
        name: "Android Browser"
      }, r = i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(t) {
      const e = {
        name: "PlayStation 4"
      }, r = i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(t) {
      const e = {
        name: "Safari"
      }, r = i2.getFirstMatch(k, t);
      return r && (e.version = r), e;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(t) {
      const e = /^(.*)\/(.*) /, r = /^(.*)\/(.*)[ \t]\((.*)/, o2 = t.search("\\(") !== -1 ? r : e;
      return {
        name: i2.getFirstMatch(o2, t),
        version: i2.getSecondMatch(o2, t)
      };
    }
  }
];
var qe2 = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(t) {
      const e = i2.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
      return {
        name: F3.Roku,
        version: e
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(t) {
      const e = i2.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
      return {
        name: F3.WindowsPhone,
        version: e
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(t) {
      const e = i2.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t), r = i2.getWindowsVersionName(e);
      return {
        name: F3.Windows,
        version: e,
        versionName: r
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(t) {
      const e = {
        name: F3.iOS
      }, r = i2.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
      return r && (e.version = r), e;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(t) {
      const e = i2.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(/[_\s]/g, "."), r = i2.getMacOSVersionName(e), n2 = {
        name: F3.MacOS,
        version: e
      };
      return r && (n2.versionName = r), n2;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(t) {
      const e = i2.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t).replace(/[_\s]/g, ".");
      return {
        name: F3.iOS,
        version: e
      };
    }
  },
  /* Android */
  {
    test(t) {
      const e = !t.test(/like android/i), r = t.test(/android/i);
      return e && r;
    },
    describe(t) {
      const e = i2.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t), r = i2.getAndroidVersionName(e), n2 = {
        name: F3.Android,
        version: e
      };
      return r && (n2.versionName = r), n2;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = i2.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t), r = {
        name: F3.WebOS
      };
      return e && e.length && (r.version = e), r;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = i2.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) || i2.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) || i2.getFirstMatch(/\bbb(\d+)/i, t);
      return {
        name: F3.BlackBerry,
        version: e
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(t) {
      const e = i2.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
      return {
        name: F3.Bada,
        version: e
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(t) {
      const e = i2.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: F3.Tizen,
        version: e
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: F3.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: F3.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(t) {
      const e = i2.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: F3.PlayStation4,
        version: e
      };
    }
  }
];
var Ge2 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(t) {
      const e = i2.getFirstMatch(/(can-l01)/i, t) && "Nova", r = {
        type: M3.mobile,
        vendor: "Huawei"
      };
      return e && (r.model = e), r;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: M3.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: M3.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: M3.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: M3.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: M3.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: M3.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(t) {
      const e = t.test(/ipod|iphone/i), r = t.test(/like (ipod|iphone)/i);
      return e && !r;
    },
    describe(t) {
      const e = i2.getFirstMatch(/(ipod|iphone)/i, t);
      return {
        type: M3.mobile,
        vendor: "Apple",
        model: e
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: M3.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: M3.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(t) {
      return t.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: M3.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(t) {
      return t.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: M3.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(t) {
      return t.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: M3.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(t) {
      const e = Number(String(t.getOSVersion()).split(".")[0]);
      return t.getOSName(true) === "android" && e >= 3;
    },
    describe() {
      return {
        type: M3.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(t) {
      return t.getOSName(true) === "android";
    },
    describe() {
      return {
        type: M3.mobile
      };
    }
  },
  /* desktop */
  {
    test(t) {
      return t.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: M3.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(t) {
      return t.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: M3.desktop
      };
    }
  },
  /* Linux */
  {
    test(t) {
      return t.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: M3.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(t) {
      return t.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: M3.tv
      };
    }
  },
  /* Roku */
  {
    test(t) {
      return t.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: M3.tv
      };
    }
  }
];
var Qe2 = [
  /* EdgeHTML */
  {
    test(t) {
      return t.getBrowserName(true) === "microsoft edge";
    },
    describe(t) {
      if (/\sedg\//i.test(t))
        return {
          name: P.Blink
        };
      const r = i2.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
      return {
        name: P.EdgeHTML,
        version: r
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(t) {
      const e = {
        name: P.Trident
      }, r = i2.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Presto */
  {
    test(t) {
      return t.test(/presto/i);
    },
    describe(t) {
      const e = {
        name: P.Presto
      }, r = i2.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Gecko */
  {
    test(t) {
      const e = t.test(/gecko/i), r = t.test(/like gecko/i);
      return e && !r;
    },
    describe(t) {
      const e = {
        name: P.Gecko
      }, r = i2.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: P.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(t) {
      const e = {
        name: P.WebKit
      }, r = i2.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  }
];
var se = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(e, r = false) {
    if (e == null || e === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e, this.parsedResult = {}, r !== true && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(e) {
    return e.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const e = i2.find(De2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n2) => this.test(n2));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(e) {
    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const e = i2.find(qe2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n2) => this.test(n2));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(e) {
    const { name: r } = this.getOS();
    return e ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(e = false) {
    const { type: r } = this.getPlatform();
    return e ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const e = i2.find(Ge2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n2) => this.test(n2));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(e) {
    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const e = i2.find(Qe2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n2) => this.test(n2));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return i2.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(e) {
    const r = {};
    let n2 = 0;
    const o2 = {};
    let s = 0;
    if (Object.keys(e).forEach((h) => {
      const w2 = e[h];
      typeof w2 == "string" ? (o2[h] = w2, s += 1) : typeof w2 == "object" && (r[h] = w2, n2 += 1);
    }), n2 > 0) {
      const h = Object.keys(r), w2 = i2.find(h, (a) => this.isOS(a));
      if (w2) {
        const a = this.satisfies(r[w2]);
        if (a !== void 0)
          return a;
      }
      const l4 = i2.find(
        h,
        (a) => this.isPlatform(a)
      );
      if (l4) {
        const a = this.satisfies(r[l4]);
        if (a !== void 0)
          return a;
      }
    }
    if (s > 0) {
      const h = Object.keys(o2), w2 = i2.find(h, (l4) => this.isBrowser(l4, true));
      if (w2 !== void 0)
        return this.compareVersion(o2[w2]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(e, r = false) {
    const n2 = this.getBrowserName().toLowerCase();
    let o2 = e.toLowerCase();
    const s = i2.getBrowserTypeByAlias(o2);
    return r && s && (o2 = s.toLowerCase()), o2 === n2;
  }
  compareVersion(e) {
    let r = [0], n2 = e, o2 = false;
    const s = this.getBrowserVersion();
    if (typeof s == "string")
      return e[0] === ">" || e[0] === "<" ? (n2 = e.substr(1), e[1] === "=" ? (o2 = true, n2 = e.substr(2)) : r = [], e[0] === ">" ? r.push(1) : r.push(-1)) : e[0] === "=" ? n2 = e.substr(1) : e[0] === "~" && (o2 = true, n2 = e.substr(1)), r.indexOf(
        i2.compareVersions(s, n2, o2)
      ) > -1;
  }
  isOS(e) {
    return this.getOSName(true) === String(e).toLowerCase();
  }
  isPlatform(e) {
    return this.getPlatformType(true) === String(e).toLowerCase();
  }
  isEngine(e) {
    return this.getEngineName(true) === String(e).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(e, r = false) {
    return this.isBrowser(e, r) || this.isOS(e) || this.isPlatform(e);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(e = []) {
    return e.some((r) => this.is(r));
  }
};
var Xe2 = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(e, r = false) {
    if (typeof e != "string")
      throw new Error("UserAgent should be a string");
    return new se(e, r);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(e) {
    return new se(e).getResult();
  }
  static get BROWSER_MAP() {
    return be2;
  }
  static get ENGINE_MAP() {
    return P;
  }
  static get OS_MAP() {
    return F3;
  }
  static get PLATFORMS_MAP() {
    return M3;
  }
};
var ae2 = typeof window < "u" ? window : null;
function He() {
  if (!ae2)
    return null;
  switch (Xe2.getParser(ae2.navigator.userAgent).getBrowserName()?.toLowerCase()) {
    case "firefox":
      return "firefox";
    case "microsoft edge":
      return "edge";
    case "android browser":
    case "chrome":
    case "chromium":
    case "electron":
    case "opera":
    case "vivaldi":
      return "chrome";
    default:
      return null;
  }
}
var Ue2 = typeof global == "object" && global && global.Object === Object && global;
var Ze2 = Ue2;
var Ke2 = typeof self == "object" && self && self.Object === Object && self;
var Ye2 = Ze2 || Ke2 || Function("return this")();
var $e2 = Ye2;
var Je2 = $e2.Symbol;
var Y2 = Je2;
var me2 = Object.prototype;
var et2 = me2.hasOwnProperty;
var tt2 = me2.toString;
var G = Y2 ? Y2.toStringTag : void 0;
function rt2(t) {
  var e = et2.call(t, G), r = t[G];
  try {
    t[G] = void 0;
    var n2 = true;
  } catch {
  }
  var o2 = tt2.call(t);
  return n2 && (e ? t[G] = r : delete t[G]), o2;
}
var nt2 = Object.prototype;
var it2 = nt2.toString;
function ot2(t) {
  return it2.call(t);
}
var st2 = "[object Null]";
var at2 = "[object Undefined]";
var ce2 = Y2 ? Y2.toStringTag : void 0;
function ct2(t) {
  return t == null ? t === void 0 ? at2 : st2 : ce2 && ce2 in Object(t) ? rt2(t) : ot2(t);
}
function lt2(t) {
  return t != null && typeof t == "object";
}
var dt2 = Array.isArray;
var ut2 = dt2;
var ft2 = "[object String]";
function te2(t) {
  return typeof t == "string" || !ut2(t) && lt2(t) && ct2(t) == ft2;
}
var wt2 = ({
  availableConnectors: t,
  installedWallets: e,
  discoveryWallets: r,
  storeVersion: n2,
  customOrder: o2
}) => {
  if (window?.starknet_argentX?.isInAppBrowser)
    return [];
  const h = e.map(
    (a) => t.find((g2) => g2.id === a.id)
  );
  return (o2 ? t : [
    ...t.filter((a) => h.includes(a)),
    ...t.filter((a) => !h.includes(a))
  ]).map((a) => {
    const g2 = e.find((f3) => f3.id === a.id);
    if (g2) {
      const f3 = g2.id === "argentX" ? { light: l, dark: l } : te2(g2.icon) ? { light: g2.icon, dark: g2.icon } : g2.icon;
      return {
        name: g2.name,
        id: g2.id,
        icon: f3,
        connector: a
      };
    }
    const y = r.filter(
      (f3) => !!f3.downloads[n2]
    ).find((f3) => f3.id === a.id);
    if (y) {
      const { downloads: f3 } = y, b2 = y.id === "argentX" ? l : y.icon;
      return {
        name: y.name,
        id: y.id,
        icon: { light: b2, dark: b2 },
        connector: a,
        download: f3[n2]
      };
    }
    return !a || !a.id || !a.name ? null : {
      name: a.name,
      id: a.id,
      icon: a.icon,
      connector: a,
      title: "title" in a && te2(a.title) ? a.title : void 0,
      subtitle: "subtitle" in a && te2(a.subtitle) ? a.subtitle : void 0
    };
  }).filter((a) => a !== null);
};
function R2() {
}
function ve2(t) {
  return t();
}
function le() {
  return /* @__PURE__ */ Object.create(null);
}
function j(t) {
  t.forEach(ve2);
}
function ye2(t) {
  return typeof t == "function";
}
function ke2(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}
var U4;
function _e2(t, e) {
  return t === e ? true : (U4 || (U4 = document.createElement("a")), U4.href = e, t === U4.href);
}
function gt2(t) {
  return Object.keys(t).length === 0;
}
function _2(t, e) {
  t.appendChild(e);
}
function W3(t, e, r) {
  t.insertBefore(e, r || null);
}
function E(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function ht(t, e) {
  for (let r = 0; r < t.length; r += 1)
    t[r] && t[r].d(e);
}
function B3(t) {
  return document.createElement(t);
}
function I2(t) {
  return document.createTextNode(t);
}
function z2() {
  return I2(" ");
}
function xe2() {
  return I2("");
}
function O2(t, e, r, n2) {
  return t.addEventListener(e, r, n2), () => t.removeEventListener(e, r, n2);
}
function p2(t, e, r) {
  r == null ? t.removeAttribute(e) : t.getAttribute(e) !== r && t.setAttribute(e, r);
}
function pt(t) {
  return Array.from(t.childNodes);
}
function $(t, e) {
  e = "" + e, t.data !== e && (t.data = /** @type {string} */
  e);
}
function Me2(t, e, r, n2) {
  r == null ? t.style.removeProperty(e) : t.style.setProperty(e, r, n2 ? "important" : "");
}
var X2;
function Q2(t) {
  X2 = t;
}
function bt2() {
  if (!X2)
    throw new Error("Function called outside component initialization");
  return X2;
}
function mt2(t) {
  bt2().$$.on_mount.push(t);
}
var D2 = [];
var de = [];
var q3 = [];
var ue2 = [];
var vt2 = Promise.resolve();
var ne2 = false;
function yt2() {
  ne2 || (ne2 = true, vt2.then(Se2));
}
function ie2(t) {
  q3.push(t);
}
var re2 = /* @__PURE__ */ new Set();
var V2 = 0;
function Se2() {
  if (V2 !== 0)
    return;
  const t = X2;
  do {
    try {
      for (; V2 < D2.length; ) {
        const e = D2[V2];
        V2++, Q2(e), kt2(e.$$);
      }
    } catch (e) {
      throw D2.length = 0, V2 = 0, e;
    }
    for (Q2(null), D2.length = 0, V2 = 0; de.length; )
      de.pop()();
    for (let e = 0; e < q3.length; e += 1) {
      const r = q3[e];
      re2.has(r) || (re2.add(r), r());
    }
    q3.length = 0;
  } while (D2.length);
  for (; ue2.length; )
    ue2.pop()();
  ne2 = false, re2.clear(), Q2(t);
}
function kt2(t) {
  if (t.fragment !== null) {
    t.update(), j(t.before_update);
    const e = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(ie2);
  }
}
function _t2(t) {
  const e = [], r = [];
  q3.forEach((n2) => t.indexOf(n2) === -1 ? e.push(n2) : r.push(n2)), r.forEach((n2) => n2()), q3 = e;
}
var K2 = /* @__PURE__ */ new Set();
var T3;
function Be2() {
  T3 = {
    r: 0,
    c: [],
    p: T3
    // parent group
  };
}
function Fe2() {
  T3.r || j(T3.c), T3 = T3.p;
}
function L2(t, e) {
  t && t.i && (K2.delete(t), t.i(e));
}
function H(t, e, r, n2) {
  if (t && t.o) {
    if (K2.has(t))
      return;
    K2.add(t), T3.c.push(() => {
      K2.delete(t), n2 && (r && t.d(1), n2());
    }), t.o(e);
  } else
    n2 && n2();
}
function fe2(t) {
  return t?.length !== void 0 ? t : Array.from(t);
}
function xt2(t) {
  t && t.c();
}
function Ce2(t, e, r) {
  const { fragment: n2, after_update: o2 } = t.$$;
  n2 && n2.m(e, r), ie2(() => {
    const s = t.$$.on_mount.map(ve2).filter(ye2);
    t.$$.on_destroy ? t.$$.on_destroy.push(...s) : j(s), t.$$.on_mount = [];
  }), o2.forEach(ie2);
}
function Ae2(t, e) {
  const r = t.$$;
  r.fragment !== null && (_t2(r.after_update), j(r.on_destroy), r.fragment && r.fragment.d(e), r.on_destroy = r.fragment = null, r.ctx = []);
}
function Mt2(t, e) {
  t.$$.dirty[0] === -1 && (D2.push(t), yt2(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function Oe2(t, e, r, n2, o2, s, d = null, h = [-1]) {
  const w2 = X2;
  Q2(t);
  const l4 = t.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: R2,
    not_equal: o2,
    bound: le(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (w2 ? w2.$$.context : [])),
    // everything else
    callbacks: le(),
    dirty: h,
    skip_bound: false,
    root: e.target || w2.$$.root
  };
  d && d(l4.root);
  let a = false;
  if (l4.ctx = r ? r(t, e.props || {}, (g2, y, ...f3) => {
    const b2 = f3.length ? f3[0] : y;
    return l4.ctx && o2(l4.ctx[g2], l4.ctx[g2] = b2) && (!l4.skip_bound && l4.bound[g2] && l4.bound[g2](b2), a && Mt2(t, g2)), y;
  }) : [], l4.update(), a = true, j(l4.before_update), l4.fragment = n2 ? n2(l4.ctx) : false, e.target) {
    if (e.hydrate) {
      const g2 = pt(e.target);
      l4.fragment && l4.fragment.l(g2), g2.forEach(E);
    } else
      l4.fragment && l4.fragment.c();
    e.intro && L2(t.$$.fragment), Ce2(t, e.target, e.anchor), Se2();
  }
  Q2(w2);
}
var Ne2 = class {
  constructor() {
    J2(this, "$$");
    J2(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    Ae2(this, 1), this.$destroy = R2;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, r) {
    if (!ye2(r))
      return R2;
    const n2 = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return n2.push(r), () => {
      const o2 = n2.indexOf(r);
      o2 !== -1 && n2.splice(o2, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !gt2(e) && (this.$$.skip_bound = true, this.$$set(e), this.$$.skip_bound = false);
  }
};
var St2 = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(St2);
function Bt2(t) {
  let e, r, n2, o2, s, d = (
    /*wallet*/
    (t[0].title ?? /*wallet*/
    t[0].name) + ""
  ), h, w2, l4, a = (
    /*wallet*/
    (t[0].subtitle ?? "") + ""
  ), g2, y, f3, b2;
  function x2(v2, u) {
    return (
      /*loadingItem*/
      v2[2] === /*wallet*/
      v2[0]?.id ? Ot2 : (
        /*isSvg*/
        v2[4] ? At2 : Ct
      )
    );
  }
  let m2 = x2(t), c2 = m2(t);
  return {
    c() {
      e = B3("li"), r = B3("span"), n2 = z2(), o2 = B3("div"), s = B3("p"), h = I2(d), w2 = z2(), l4 = B3("p"), g2 = I2(a), y = z2(), c2.c(), p2(r, "class", "w-8 h-8"), p2(s, "class", "font-semibold text-base p"), p2(l4, "class", "l2 p"), Me2(l4, "text-align", "center"), p2(o2, "class", "flex flex-col justify-center items-center"), p2(e, "class", `flex flex-row-reverse justify-between items-center 
            p-3 rounded-md cursor-pointer shadow-list-item 
            dark:shadow-none dark:bg-neutral-800 dark:text-white 
          hover:bg-neutral-100 dark:hover:bg-neutral-700 
          focus:outline-none focus:ring-2 
        focus:ring-neutral-200 dark:focus:ring-neutral-700 
          transition-colors`), p2(e, "role", "button"), p2(e, "tabindex", "0");
    },
    m(v2, u) {
      W3(v2, e, u), _2(e, r), _2(e, n2), _2(e, o2), _2(o2, s), _2(s, h), _2(o2, w2), _2(o2, l4), _2(l4, g2), _2(e, y), c2.m(e, null), f3 || (b2 = [
        O2(
          e,
          "click",
          /*click_handler_1*/
          t[8]
        ),
        O2(
          e,
          "keyup",
          /*keyup_handler_1*/
          t[9]
        )
      ], f3 = true);
    },
    p(v2, u) {
      u & /*wallet*/
      1 && d !== (d = /*wallet*/
      (v2[0].title ?? /*wallet*/
      v2[0].name) + "") && $(h, d), u & /*wallet*/
      1 && a !== (a = /*wallet*/
      (v2[0].subtitle ?? "") + "") && $(g2, a), m2 === (m2 = x2(v2)) && c2 ? c2.p(v2, u) : (c2.d(1), c2 = m2(v2), c2 && (c2.c(), c2.m(e, null)));
    },
    d(v2) {
      v2 && E(e), c2.d(), f3 = false, j(b2);
    }
  };
}
function Ft2(t) {
  let e, r, n2, o2, s, d, h = (
    /*wallet*/
    t[0].name + ""
  ), w2, l4, a, g2, y, f3, b2, x2, m2;
  return {
    c() {
      e = B3("a"), r = B3("li"), n2 = B3("span"), o2 = z2(), s = B3("p"), d = I2("Install "), w2 = I2(h), l4 = z2(), a = B3("img"), p2(n2, "class", "w-8 h-8"), p2(s, "class", "font-semibold text-base p"), p2(a, "alt", g2 = /*wallet*/
      t[0].name), _e2(a.src, y = /*icon*/
      t[3]) || p2(a, "src", y), p2(a, "class", "w-8 h-8 rounded-full"), p2(r, "class", `flex flex-row-reverse justify-between items-center 
              p-3 rounded-md cursor-pointer shadow-list-item 
              dark:shadow-none dark:bg-neutral-800 dark:text-white 
            hover:bg-neutral-100 dark:hover:bg-neutral-700`), p2(e, "aria-label", f3 = /*wallet*/
      t[0].name + " download link"), p2(e, "href", b2 = /*wallet*/
      t[0].download), p2(e, "target", "_blank"), p2(e, "rel", "noopener noreferrer"), p2(e, "class", `rounded-md focus:outline-none  focus:ring-2 
    focus:ring-neutral-200  dark:focus:ring-neutral-700 transition-colors`);
    },
    m(c2, v2) {
      W3(c2, e, v2), _2(e, r), _2(r, n2), _2(r, o2), _2(r, s), _2(s, d), _2(s, w2), _2(r, l4), _2(r, a), x2 || (m2 = [
        O2(
          r,
          "click",
          /*click_handler*/
          t[6]
        ),
        O2(
          r,
          "keyup",
          /*keyup_handler*/
          t[7]
        )
      ], x2 = true);
    },
    p(c2, v2) {
      v2 & /*wallet*/
      1 && h !== (h = /*wallet*/
      c2[0].name + "") && $(w2, h), v2 & /*wallet*/
      1 && g2 !== (g2 = /*wallet*/
      c2[0].name) && p2(a, "alt", g2), v2 & /*wallet*/
      1 && f3 !== (f3 = /*wallet*/
      c2[0].name + " download link") && p2(e, "aria-label", f3), v2 & /*wallet*/
      1 && b2 !== (b2 = /*wallet*/
      c2[0].download) && p2(e, "href", b2);
    },
    d(c2) {
      c2 && E(e), x2 = false, j(m2);
    }
  };
}
function Ct(t) {
  let e, r, n2;
  return {
    c() {
      e = B3("img"), p2(e, "alt", r = /*wallet*/
      t[0]?.name), _e2(e.src, n2 = /*icon*/
      t[3]) || p2(e, "src", n2), p2(e, "class", "w-8 h-8 rounded");
    },
    m(o2, s) {
      W3(o2, e, s);
    },
    p(o2, s) {
      s & /*wallet*/
      1 && r !== (r = /*wallet*/
      o2[0]?.name) && p2(e, "alt", r);
    },
    d(o2) {
      o2 && E(e);
    }
  };
}
function At2(t) {
  let e;
  return {
    c() {
      e = B3("div"), Me2(e, "position", "relative");
    },
    m(r, n2) {
      W3(r, e, n2), e.innerHTML = /*icon*/
      t[3];
    },
    p: R2,
    d(r) {
      r && E(e);
    }
  };
}
function Ot2(t) {
  let e;
  return {
    c() {
      e = B3("div"), e.innerHTML = '<svg aria-hidden="true" class="w-8 h-8 text-neutral-300 animate-spin dark:text-neutral-600 fill-neutral-600 dark:fill-neutral-300" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"></path><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"></path></svg> <span class="sr-only">Loading...</span>', p2(e, "role", "status");
    },
    m(r, n2) {
      W3(r, e, n2);
    },
    p: R2,
    d(r) {
      r && E(e);
    }
  };
}
function Nt2(t) {
  let e;
  function r(s, d) {
    return (
      /*wallet*/
      s[0].download ? Ft2 : Bt2
    );
  }
  let n2 = r(t), o2 = n2(t);
  return {
    c() {
      o2.c(), e = xe2();
    },
    m(s, d) {
      o2.m(s, d), W3(s, e, d);
    },
    p(s, [d]) {
      n2 === (n2 = r(s)) && o2 ? o2.p(s, d) : (o2.d(1), o2 = n2(s), o2 && (o2.c(), o2.m(e.parentNode, e)));
    },
    i: R2,
    o: R2,
    d(s) {
      s && E(e), o2.d(s);
    }
  };
}
function Et2(t, e, r) {
  let { wallet: n2 } = e, { theme: o2 = null } = e, { cb: s = async () => {
  } } = e, { loadingItem: d = false } = e;
  const h = typeof n2.icon == "string" ? n2.icon : o2 === "dark" ? n2.icon.dark : n2.icon.light, w2 = h?.startsWith("<svg"), l4 = () => {
    s(null);
  }, a = (f3) => {
    f3.key === "Enter" && s(null);
  }, g2 = async () => {
    s(n2.connector);
  }, y = async (f3) => {
    f3.key === "Enter" && s(n2.connector);
  };
  return t.$$set = (f3) => {
    "wallet" in f3 && r(0, n2 = f3.wallet), "theme" in f3 && r(5, o2 = f3.theme), "cb" in f3 && r(1, s = f3.cb), "loadingItem" in f3 && r(2, d = f3.loadingItem);
  }, [
    n2,
    s,
    d,
    h,
    w2,
    o2,
    l4,
    a,
    g2,
    y
  ];
}
var Pt2 = class extends Ne2 {
  constructor(e) {
    super(), Oe2(this, e, Et2, Nt2, ke2, {
      wallet: 0,
      theme: 5,
      cb: 1,
      loadingItem: 2
    });
  }
};
function we2(t, e, r) {
  const n2 = t.slice();
  return n2[16] = e[r], n2;
}
function ge2(t) {
  let e, r, n2, o2, s, d, h, w2, l4, a, g2, y, f3, b2, x2, m2 = fe2(
    /*modalWallets*/
    t[1]
  ), c2 = [];
  for (let u = 0; u < m2.length; u += 1)
    c2[u] = he2(we2(t, m2, u));
  const v2 = (u) => H(c2[u], 1, 1, () => {
    c2[u] = null;
  });
  return {
    c() {
      e = B3("div"), r = B3("main"), n2 = B3("header"), o2 = B3("h2"), o2.textContent = "Connect to", s = z2(), d = B3("h1"), h = I2(
        /*dappName*/
        t[0]
      ), w2 = z2(), l4 = B3("span"), l4.innerHTML = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.77275 3.02275C9.99242 2.80308 9.99242 2.44692 9.77275 2.22725C9.55308 2.00758 9.19692 2.00758 8.97725 2.22725L6 5.20451L3.02275 2.22725C2.80308 2.00758 2.44692 2.00758 2.22725 2.22725C2.00758 2.44692 2.00758 2.80308 2.22725 3.02275L5.20451 6L2.22725 8.97725C2.00758 9.19692 2.00758 9.55308 2.22725 9.77275C2.44692 9.99242 2.80308 9.99242 3.02275 9.77275L6 6.79549L8.97725 9.77275C9.19692 9.99242 9.55308 9.99242 9.77275 9.77275C9.99242 9.55308 9.99242 9.19692 9.77275 8.97725L6.79549 6L9.77275 3.02275Z" fill="currentColor"></path></svg>', a = z2(), g2 = B3("ul");
      for (let u = 0; u < c2.length; u += 1)
        c2[u].c();
      p2(o2, "class", "text-sm text-gray-400 font-semibold"), p2(d, "class", `text-xl font-semibold mb-6 
                  max-w-[240px] overflow-hidden 
                  whitespace-nowrap text-ellipsis`), p2(l4, "class", `absolute top-0 right-0 p-2 cursor-pointer
                  rounded-full bg-neutral-100 dark:bg-neutral-800
                  text-neutral-400 dark:text-white
                  hover:bg-neutral-100 dark:hover:bg-neutral-700
                  focus:outline-none focus:ring-2
                focus:ring-neutral-200 dark:focus:ring-neutral-700
                  transition-colors`), p2(l4, "role", "button"), p2(l4, "tabindex", "0"), p2(l4, "aria-label", "Close"), p2(n2, "class", "flex items-center justify-center flex-col mb-2 relative"), p2(g2, "class", "flex flex-col gap-3"), p2(r, "role", "dialog"), p2(r, "class", `rounded-3xl shadow-modal dark:shadow-none 
              w-full max-w-[380px] z-50 
              mx-6 p-6 pb-8 text-center 
              bg-slate-50 dark:bg-neutral-900 
            text-neutral-900 dark:text-white`), p2(e, "part", "starknetkit-modal"), p2(e, "class", y = `modal-font backdrop-blur-sm fixed inset-0 flex items-center 
            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/
      t[4]}`);
    },
    m(u, C3) {
      W3(u, e, C3), _2(e, r), _2(r, n2), _2(n2, o2), _2(n2, s), _2(n2, d), _2(d, h), _2(n2, w2), _2(n2, l4), _2(r, a), _2(r, g2);
      for (let S4 = 0; S4 < c2.length; S4 += 1)
        c2[S4] && c2[S4].m(g2, null);
      f3 = true, b2 || (x2 = [
        O2(
          l4,
          "click",
          /*click_handler*/
          t[8]
        ),
        O2(
          l4,
          "keyup",
          /*keyup_handler*/
          t[9]
        ),
        O2(r, "click", Lt2),
        O2(r, "keyup", jt2),
        O2(
          e,
          "click",
          /*click_handler_2*/
          t[10]
        ),
        O2(
          e,
          "keyup",
          /*keyup_handler_2*/
          t[11]
        )
      ], b2 = true);
    },
    p(u, C3) {
      if ((!f3 || C3 & /*dappName*/
      1) && $(
        h,
        /*dappName*/
        u[0]
      ), C3 & /*modalWallets, loadingItem, cb, theme*/
      78) {
        m2 = fe2(
          /*modalWallets*/
          u[1]
        );
        let S4;
        for (S4 = 0; S4 < m2.length; S4 += 1) {
          const oe2 = we2(u, m2, S4);
          c2[S4] ? (c2[S4].p(oe2, C3), L2(c2[S4], 1)) : (c2[S4] = he2(oe2), c2[S4].c(), L2(c2[S4], 1), c2[S4].m(g2, null));
        }
        for (Be2(), S4 = m2.length; S4 < c2.length; S4 += 1)
          v2(S4);
        Fe2();
      }
      (!f3 || C3 & /*darkModeControlClass*/
      16 && y !== (y = `modal-font backdrop-blur-sm fixed inset-0 flex items-center 
            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/
      u[4]}`)) && p2(e, "class", y);
    },
    i(u) {
      if (!f3) {
        for (let C3 = 0; C3 < m2.length; C3 += 1)
          L2(c2[C3]);
        f3 = true;
      }
    },
    o(u) {
      c2 = c2.filter(Boolean);
      for (let C3 = 0; C3 < c2.length; C3 += 1)
        H(c2[C3]);
      f3 = false;
    },
    d(u) {
      u && E(e), ht(c2, u), b2 = false, j(x2);
    }
  };
}
function he2(t) {
  let e, r;
  return e = new Pt2({
    props: {
      wallet: (
        /*wallet*/
        t[16]
      ),
      loadingItem: (
        /*loadingItem*/
        t[3]
      ),
      cb: (
        /*cb*/
        t[6]
      ),
      theme: (
        /*theme*/
        t[2]
      )
    }
  }), {
    c() {
      xt2(e.$$.fragment);
    },
    m(n2, o2) {
      Ce2(e, n2, o2), r = true;
    },
    p(n2, o2) {
      const s = {};
      o2 & /*modalWallets*/
      2 && (s.wallet = /*wallet*/
      n2[16]), o2 & /*loadingItem*/
      8 && (s.loadingItem = /*loadingItem*/
      n2[3]), o2 & /*theme*/
      4 && (s.theme = /*theme*/
      n2[2]), e.$set(s);
    },
    i(n2) {
      r || (L2(e.$$.fragment, n2), r = true);
    },
    o(n2) {
      H(e.$$.fragment, n2), r = false;
    },
    d(n2) {
      Ae2(e, n2);
    }
  };
}
function zt2(t) {
  let e, r, n2 = !/*isInAppBrowser*/
  t[5] && /*modalWallets*/
  t[1].length > 1 && ge2(t);
  return {
    c() {
      n2 && n2.c(), e = xe2();
    },
    m(o2, s) {
      n2 && n2.m(o2, s), W3(o2, e, s), r = true;
    },
    p(o2, [s]) {
      !/*isInAppBrowser*/
      o2[5] && /*modalWallets*/
      o2[1].length > 1 ? n2 ? (n2.p(o2, s), s & /*modalWallets*/
      2 && L2(n2, 1)) : (n2 = ge2(o2), n2.c(), L2(n2, 1), n2.m(e.parentNode, e)) : n2 && (Be2(), H(n2, 1, 1, () => {
        n2 = null;
      }), Fe2());
    },
    i(o2) {
      r || (L2(n2), r = true);
    },
    o(o2) {
      H(n2), r = false;
    },
    d(o2) {
      o2 && E(e), n2 && n2.d(o2);
    }
  };
}
var Lt2 = (t) => t.stopPropagation();
var jt2 = (t) => {
  t.stopPropagation();
};
function Wt2(t, e, r) {
  let { dappName: n2 = window?.document.title ?? "" } = e, { modalWallets: o2 } = e, { callback: s = async () => {
  } } = e, { theme: d = null } = e, h = false, l4 = window?.starknet_argentX?.isInAppBrowser;
  const g2 = navigator.userAgent.toLowerCase().includes("braavos"), y = (u) => {
    r(3, h = u);
  };
  let f3 = async (u) => {
    y(u?.id ?? false);
    try {
      await s(u ?? null);
    } finally {
      y(false);
    }
  }, b2 = d === "dark" ? "dark" : "";
  mt2(async () => {
    if (d === "dark" || d === null && window.matchMedia("(prefers-color-scheme: dark)").matches ? r(4, b2 = "dark") : r(4, b2 = ""), l4 && window?.starknet_argentX) {
      try {
        s(new T2({ options: { id: "argentX" } }));
      } catch {
      }
      return;
    }
    if (g2 && window?.starknet_braavos) {
      try {
        s(new T2({ options: { id: "braavos" } }));
      } catch {
      }
      return;
    }
    if (o2.length === 1)
      try {
        const [u] = o2;
        await s(u.connector);
      } catch (u) {
        console.error(u);
      }
  });
  const x2 = () => f3(null), m2 = (u) => {
    u.key === "Enter" && f3(null);
  }, c2 = () => f3(null), v2 = (u) => {
    u.key === "Escape" && f3(null);
  };
  return t.$$set = (u) => {
    "dappName" in u && r(0, n2 = u.dappName), "modalWallets" in u && r(1, o2 = u.modalWallets), "callback" in u && r(7, s = u.callback), "theme" in u && r(2, d = u.theme);
  }, [
    n2,
    o2,
    d,
    h,
    b2,
    l4,
    f3,
    s,
    x2,
    m2,
    c2,
    v2
  ];
}
var Tt2 = class extends Ne2 {
  constructor(e) {
    super(), Oe2(this, e, Wt2, zt2, ke2, {
      dappName: 0,
      modalWallets: 1,
      callback: 7,
      theme: 2
    });
  }
};
var Rt2 = `@import"https://fonts.googleapis.com/css2?family=Barlow:wght@500;600&display=swap";.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{inset:0}.right-0{right:0}.top-0{top:0}.z-50{z-index:50}.z-\\[9999\\]{z-index:9999}.mx-6{margin-left:1.5rem;margin-right:1.5rem}.mb-2{margin-bottom:.5rem}.mb-6{margin-bottom:1.5rem}.block{display:block}.inline{display:inline}.flex{display:flex}.h-8{height:2rem}.w-8{width:2rem}.w-full{width:100%}.max-w-\\[240px\\]{max-width:240px}.max-w-\\[380px\\]{max-width:380px}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-pointer{cursor:pointer}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-3{gap:.75rem}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.rounded{border-radius:.25rem}.rounded-3xl{border-radius:1.5rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.border{border-width:1px}.bg-black\\/25{background-color:#00000040}.bg-neutral-100{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity, 1))}.bg-slate-50{--tw-bg-opacity: 1;background-color:rgb(248 250 252 / var(--tw-bg-opacity, 1))}.fill-neutral-600{fill:#525252}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-6{padding:1.5rem}.pb-8{padding-bottom:2rem}.text-center{text-align:center}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-semibold{font-weight:600}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-neutral-300{--tw-text-opacity: 1;color:rgb(212 212 212 / var(--tw-text-opacity, 1))}.text-neutral-400{--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity, 1))}.text-neutral-900{--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity, 1))}.shadow-list-item{--tw-shadow: 0px 2px 12px rgba(0, 0, 0, .12);--tw-shadow-colored: 0px 2px 12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-modal{--tw-shadow: 0px 4px 20px rgba(0, 0, 0, .5);--tw-shadow-colored: 0px 4px 20px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-sm{--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.modal-font{font-family:Barlow,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;text-size-adjust:100%;font-feature-settings:"kern"}.l2{color:#8c8c8c;font-size:12px;font-weight:500;line-height:14px;letter-spacing:0em;text-align:left}.p{margin:0}.hover\\:bg-neutral-100:hover{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity, 1))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-neutral-200:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(229 229 229 / var(--tw-ring-opacity, 1))}.dark\\:bg-neutral-800:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(38 38 38 / var(--tw-bg-opacity, 1))}.dark\\:bg-neutral-900:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity, 1))}.dark\\:fill-neutral-300:is(.dark *){fill:#d4d4d4}.dark\\:text-neutral-600:is(.dark *){--tw-text-opacity: 1;color:rgb(82 82 82 / var(--tw-text-opacity, 1))}.dark\\:text-white:is(.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.dark\\:shadow-none:is(.dark *){--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.dark\\:hover\\:bg-neutral-700:hover:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(64 64 64 / var(--tw-bg-opacity, 1))}.dark\\:focus\\:ring-neutral-700:focus:is(.dark *){--tw-ring-opacity: 1;--tw-ring-color: rgb(64 64 64 / var(--tw-ring-opacity, 1))}
`;
var N2 = null;
var It2 = async ({
  modalMode: t = "canAsk",
  storeVersion: e = He(),
  modalTheme: r,
  dappName: n2,
  resultType: o2 = "wallet",
  ...s
}) => {
  const { webWalletUrl: d = Tr, argentMobileOptions: h } = s, { connectors: w2 } = s;
  N2 = null;
  const l4 = !w2 || w2.length === 0 ? Ie2({
    argentMobileOptions: h,
    webWalletUrl: d
  }) : w2, a = localStorage.getItem("starknetLastConnectedWallet");
  if (t === "neverAsk")
    try {
      const b2 = l4.find((m2) => m2.id === a) ?? null;
      let x2 = null;
      return b2 && o2 === "wallet" && (x2 = await b2.connect()), {
        connector: b2,
        wallet: b2?.wallet ?? null,
        connectorData: x2
      };
    } catch (b2) {
      throw M(), new Error(b2);
    }
  const g2 = await main.getAvailableWallets(s);
  if (t === "canAsk" && a && ((await main.getAuthorizedWallets(s)).find((m2) => m2.id === a) ?? g2.length === 1 ? g2[0] : void 0)) {
    const m2 = l4.find((v2) => v2.id === a);
    let c2 = null;
    return o2 === "wallet" && (c2 = await m2?.connect() ?? null), m2 && (N2 = m2), {
      connector: N2,
      connectorData: c2,
      wallet: m2?.wallet ?? null
    };
  }
  const y = wt2({
    availableConnectors: l4,
    installedWallets: g2,
    discoveryWallets: await main.getDiscoveryWallets(s),
    storeVersion: e,
    customOrder: w2 ? w2?.length > 0 : false
  }), f3 = () => {
    const b2 = "starknetkit-modal-container", x2 = document.getElementById(b2);
    if (x2) {
      if (x2.shadowRoot)
        return x2.shadowRoot;
      x2.remove();
    }
    const m2 = document.createElement("div");
    m2.id = b2, document.body.appendChild(m2);
    const c2 = m2.attachShadow({ mode: "open" });
    return c2.innerHTML = `<style>${Rt2}</style>`, c2;
  };
  return new Promise((b2, x2) => {
    const m2 = new Tt2({
      target: f3(),
      props: {
        dappName: n2,
        callback: async (c2) => {
          try {
            if (N2 = c2, o2 === "wallet") {
              const v2 = await c2?.connect() ?? null;
              c2 !== null && F(c2.id), b2({
                connector: c2,
                connectorData: v2,
                wallet: c2?.wallet ?? null
              });
            } else
              b2({
                connector: c2,
                wallet: null,
                connectorData: null
              });
          } catch (v2) {
            x2(v2);
          } finally {
            setTimeout(() => m2.$destroy());
          }
        },
        theme: r === "system" ? null : r ?? null,
        modalWallets: y
      }
    });
  });
};
var $t2 = async (t = {}) => (M(), N2 && await N2.disconnect(), N2 = null, main.disconnect(t));

// node_modules/@dynamic-labs/starknet/src/constants.js
var ETH_STARKNET_ADDRESS = "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";

// node_modules/@dynamic-labs/starknet/src/ethereumContractAbi.js
var ETH_CONTRACT_ABI = [
  {
    members: [
      {
        name: "low",
        offset: 0,
        type: "felt"
      },
      {
        name: "high",
        offset: 1,
        type: "felt"
      }
    ],
    name: "Uint256",
    size: 2,
    type: "struct"
  },
  {
    data: [
      {
        name: "from_",
        type: "felt"
      },
      {
        name: "to",
        type: "felt"
      },
      {
        name: "value",
        type: "Uint256"
      }
    ],
    keys: [],
    name: "Transfer",
    type: "event"
  },
  {
    data: [
      {
        name: "owner",
        type: "felt"
      },
      {
        name: "spender",
        type: "felt"
      },
      {
        name: "value",
        type: "Uint256"
      }
    ],
    keys: [],
    name: "Approval",
    type: "event"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "name",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "symbol",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "totalSupply",
        type: "Uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "decimals",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "account",
        type: "felt"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "Uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "owner",
        type: "felt"
      },
      {
        name: "spender",
        type: "felt"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "remaining",
        type: "Uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "permittedMinter",
    outputs: [
      {
        name: "minter",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "initialized",
    outputs: [
      {
        name: "res",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "get_version",
    outputs: [
      {
        name: "version",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "get_identity",
    outputs: [
      {
        name: "identity",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "init_vector_len",
        type: "felt"
      },
      {
        name: "init_vector",
        type: "felt*"
      }
    ],
    name: "initialize",
    outputs: [],
    type: "function"
  },
  {
    inputs: [
      {
        name: "recipient",
        type: "felt"
      },
      {
        name: "amount",
        type: "Uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "success",
        type: "felt"
      }
    ],
    type: "function"
  },
  {
    inputs: [
      {
        name: "sender",
        type: "felt"
      },
      {
        name: "recipient",
        type: "felt"
      },
      {
        name: "amount",
        type: "Uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "success",
        type: "felt"
      }
    ],
    type: "function"
  },
  {
    inputs: [
      {
        name: "spender",
        type: "felt"
      },
      {
        name: "amount",
        type: "Uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "success",
        type: "felt"
      }
    ],
    type: "function"
  },
  {
    inputs: [
      {
        name: "spender",
        type: "felt"
      },
      {
        name: "added_value",
        type: "Uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [
      {
        name: "success",
        type: "felt"
      }
    ],
    type: "function"
  },
  {
    inputs: [
      {
        name: "spender",
        type: "felt"
      },
      {
        name: "subtracted_value",
        type: "Uint256"
      }
    ],
    name: "decreaseAllowance",
    outputs: [
      {
        name: "success",
        type: "felt"
      }
    ],
    type: "function"
  },
  {
    inputs: [
      {
        name: "recipient",
        type: "felt"
      },
      {
        name: "amount",
        type: "Uint256"
      }
    ],
    name: "permissionedMint",
    outputs: [],
    type: "function"
  },
  {
    inputs: [
      {
        name: "account",
        type: "felt"
      },
      {
        name: "amount",
        type: "Uint256"
      }
    ],
    name: "permissionedBurn",
    outputs: [],
    type: "function"
  }
];

// node_modules/@dynamic-labs/starknet/src/utils/convertors.js
var defaultTypedData = {
  primaryType: "Message",
  types: {
    Message: [
      {
        name: "message",
        type: "felt"
      }
    ],
    StarkNetDomain: [
      {
        name: "name",
        type: "felt"
      },
      {
        name: "chainId",
        type: "felt"
      },
      {
        name: "version",
        type: "felt"
      }
    ]
  }
};
var formatTypedDataMessage = (inputMessage, chainId = constants_exports.StarknetChainId.SN_MAIN) => {
  let nonce, domain;
  try {
    const { nonce: parsedNonce, domain: parsedDomain } = JSON.parse(inputMessage);
    nonce = parsedNonce;
    domain = parsedDomain;
  } catch (e) {
    nonce = inputMessage;
    domain = "domain";
  }
  const message = {
    message: nonce.substring(0, 31)
  };
  return Object.assign(Object.assign({}, defaultTypedData), { domain: {
    chainId,
    name: domain.substring(0, 31),
    version: "0.0.1"
  }, message });
};

// node_modules/@dynamic-labs/starknet/src/wallet/StarknetWallet.js
var StarknetWallet = class extends Wallet {
  /**
   * Sends the native balance of the wallet to the given address.
   * @param amount - The amount of balance to send (in Starknet ETH).
   * @param toAddress - The address to send the balance to.
   * @returns The signature of the sent transaction.
   */
  sendBalance(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ amount, toAddress, token }) {
      yield this._connector.connect();
      const account = yield this._connector.getWalletAccount();
      if (!account) {
        throw new Error("unable to retrieve Starknet wallet account");
      }
      const contract = new Contract(ETH_CONTRACT_ABI, (token === null || token === void 0 ? void 0 : token.address) || ETH_STARKNET_ADDRESS, account);
      const transfer = yield contract.invoke("transfer", [
        toAddress,
        cairo_exports.uint256(Number(amount) * Math.pow(10, (token === null || token === void 0 ? void 0 : token.decimals) || 18))
      ]);
      return transfer === null || transfer === void 0 ? void 0 : transfer.transaction_hash;
    });
  }
  getWalletAccount() {
    return __awaiter(this, void 0, void 0, function* () {
      const account = yield this._connector.getWalletAccount();
      if (!account) {
        throw new Error("unable to retrieve Starknet wallet account");
      }
      wrapMethodWithCallback(account, "signMessage", (originalSignMessage, typedData) => __awaiter(this, void 0, void 0, function* () {
        yield this.sync();
        return originalSignMessage(typedData);
      }));
      return account;
    });
  }
  getProvider() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = yield this._connector.getProvider();
      wrapMethodWithCallback(provider, "callContract", (originalCallContract, call, blockIdentifier) => __awaiter(this, void 0, void 0, function* () {
        yield this.sync();
        return originalCallContract(call, blockIdentifier);
      }));
      wrapMethodWithCallback(provider, "deployAccountContract", (originalDeployAccountContract, payload, details) => __awaiter(this, void 0, void 0, function* () {
        yield this.sync();
        return originalDeployAccountContract(payload, details);
      }));
      return provider;
    });
  }
};

// node_modules/@dynamic-labs/starknet/src/StarknetWalletConnector.js
var StarknetWalletConnector = class extends WalletConnectorBase {
  constructor(name2, id, key, opts) {
    var _a2, _b;
    super(opts);
    this.ChainWallet = StarknetWallet;
    this.connectedChain = "STARK";
    this.supportedChains = ["STARK"];
    this.switchNetworkOnlyFromWallet = true;
    this.canSetEventListeners = true;
    this.name = name2;
    this.id = id;
    this.overrideKey = key;
    this.starknetNetworks = opts.starknetNetworks;
    this.chainRpcProviders = opts.chainRpcProviders;
    (_a2 = this.chainRpcProviders) === null || _a2 === void 0 ? void 0 : _a2.registerStarknetProviders();
    this.walletBookWallet = (_b = opts.walletBook.wallets) === null || _b === void 0 ? void 0 : _b[id];
    this.logger = new Logger(this.name);
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getAddress();
    });
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      if ((_a2 = this.walletData) === null || _a2 === void 0 ? void 0 : _a2.account) {
        return this.walletData.account;
      }
      this.logger.debug("[getAddress] Prompting new connection");
      const { wallet, data: data2 } = yield this.prompt({
        silently: false
      });
      this.logger.debug(`[getAddress] Connection returned account: ${data2 === null || data2 === void 0 ? void 0 : data2.account}, wallet: ${wallet}`);
      if (!wallet || !data2) {
        return void 0;
      }
      this.wallet = wallet;
      this.walletData = data2;
      this.setupEventListeners();
      return this.walletData.account;
    });
  }
  /**
   * returns starknet wallet network id
   */
  getNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      if (!((_a2 = this.walletData) === null || _a2 === void 0 ? void 0 : _a2.chainId)) {
        return void 0;
      }
      return num_exports.toHex(this.walletData.chainId);
    });
  }
  getBalance(address) {
    return __awaiter(this, void 0, void 0, function* () {
      const wallet = yield this.getWalletAccount();
      if (!wallet) {
        this.logger.error("Could not find provider for getting balance");
        return void 0;
      }
      const contract = new Contract(ETH_CONTRACT_ABI, ETH_STARKNET_ADDRESS, wallet);
      try {
        const { balance } = yield contract.balanceOf(address);
        return (Number(cairo_exports.uint256(balance.low).low) / 1e18).toFixed(6);
      } catch (error2) {
        this.logger.error(error2);
        throw new DynamicError("Something went wrong");
      }
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      const [walletAddress, chainId] = yield Promise.all([
        this.getAddress(),
        this.getNetwork()
      ]);
      const assertions = [
        [walletAddress, "No address for wallet"],
        [chainId, "No chainId for wallet"],
        [this.wallet, "No wallet provider"]
      ];
      for (const [value, message] of assertions) {
        if (!value) {
          this.logger.error(`[signMessage] ${message}. Make sure \`connect\` was called first`);
          return void 0;
        }
      }
      const encodedMessage = formatTypedDataMessage(messageToSign, chainId);
      const signature = yield this.wallet.request({
        params: encodedMessage,
        type: "wallet_signTypedData"
      });
      return signature === null || signature === void 0 ? void 0 : signature.join(",");
    });
  }
  getWalletAccount() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.wallet) {
        return void 0;
      }
      return new WalletAccount(yield this.getProvider(), this.wallet);
    });
  }
  getProvider() {
    return __awaiter(this, void 0, void 0, function* () {
      const rpcUrl = yield this.resolveRpcUrl();
      this.logger.debug(`[getProvider] using rpcUrl: ${rpcUrl}`);
      return new RpcProvider2({ nodeUrl: rpcUrl });
    });
  }
  isInstalledOnBrowser() {
    return Boolean(window[`starknet_${this.id}`]);
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      this.teardownEventListeners();
      this.wallet = void 0;
      this.walletData = void 0;
    });
  }
  setupEventListeners() {
    if (!this.canSetEventListeners)
      return;
    if (!this.wallet) {
      this.logger.debug("[setupEventListeners] Not connected, returning early");
      return;
    }
    this.handleAccountChange = (accounts) => __awaiter(this, void 0, void 0, function* () {
      var _a2;
      this.logger.debug(`[accountsChanged] Received argument: ${accounts === null || accounts === void 0 ? void 0 : accounts.toString()}`);
      if (!accounts || accounts[0] === null) {
        this.emit("disconnect");
        return;
      }
      const [address] = accounts;
      if (address) {
        this.walletData = {
          account: address,
          chainId: (_a2 = this.walletData) === null || _a2 === void 0 ? void 0 : _a2.chainId
        };
        this.emit("accountChange", { accounts: [address.toString()] });
      }
    });
    this.handleNetworkChange = (chainId) => __awaiter(this, void 0, void 0, function* () {
      var _b;
      this.logger.debug(`[networkChanged] Received argument: ${chainId === null || chainId === void 0 ? void 0 : chainId.toString()}`);
      if (!chainId) {
        this.emit("disconnect");
        return;
      }
      this.walletData = {
        account: (_b = this.walletData) === null || _b === void 0 ? void 0 : _b.account,
        chainId: BigInt(chainId)
      };
      this.emit("chainChange", { chain: chainId });
    });
    this.logger.debug("[setupEventListeners] Setting up accountsChanged and networkChanged");
    this.wallet.on("accountsChanged", this.handleAccountChange);
    this.wallet.on("networkChanged", this.handleNetworkChange);
  }
  teardownEventListeners() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2, _b;
      if (!this.canSetEventListeners)
        return;
      if (this.handleAccountChange) {
        (_a2 = this.wallet) === null || _a2 === void 0 ? void 0 : _a2.off("accountsChanged", this.handleAccountChange);
        this.handleAccountChange = void 0;
      }
      if (this.handleNetworkChange) {
        (_b = this.wallet) === null || _b === void 0 ? void 0 : _b.off("networkChanged", this.handleNetworkChange);
        this.handleNetworkChange = void 0;
      }
    });
  }
  resolveRpcUrl() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      const chainId = yield this.getNetwork();
      if (!chainId) {
        this.logger.warn("[resolveRpcUrl] `getNetwork` returned undefined");
        return void 0;
      }
      const networkConfig = this.starknetNetworks.find((config) => config.chainId === chainId);
      if (!networkConfig) {
        this.logger.warn(`[resolveRpcUrl] Network configuration for chainId \`${chainId}\` is not found in starknetNetworks`);
        return void 0;
      }
      return ((_a2 = networkConfig.privateCustomerRpcUrls) === null || _a2 === void 0 ? void 0 : _a2[0]) || networkConfig.rpcUrls[0];
    });
  }
  mapChainIdToNetworkName(chainIdOrNetworkName) {
    if (chainIdOrNetworkName === constants_exports.StarknetChainId.SN_MAIN || chainIdOrNetworkName === constants_exports.NetworkName.SN_MAIN) {
      return constants_exports.NetworkName.SN_MAIN;
    } else if (chainIdOrNetworkName === constants_exports.StarknetChainId.SN_SEPOLIA || chainIdOrNetworkName === constants_exports.NetworkName.SN_SEPOLIA) {
      return constants_exports.NetworkName.SN_SEPOLIA;
    } else {
      this.logger.error("Unknown chainId", chainIdOrNetworkName);
      return void 0;
    }
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2, _b;
      const currentNetwork = yield this.getNetwork();
      return (_b = (_a2 = this.starknetNetworks.find((network) => network.chainId.toString() === (currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.toString()))) === null || _a2 === void 0 ? void 0 : _a2.blockExplorerUrls) !== null && _b !== void 0 ? _b : [];
    });
  }
  getEnabledNetworks() {
    return this.starknetNetworks;
  }
};

// node_modules/@dynamic-labs/starknet/src/wallets/argent/base.js
var ArgentBase = class extends StarknetWalletConnector {
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      if ((_a2 = this.walletData) === null || _a2 === void 0 ? void 0 : _a2.account) {
        return [this.walletData.account];
      }
      let data2;
      let wallet;
      this.logger.debug("[getConnectedAccounts] No existing account, attempting to silently connect");
      try {
        ({ data: data2, wallet } = yield this.prompt({
          silently: true
        }));
      } catch (error2) {
        this.logger.debug(`[getConnectedAccounts] Silent connect errored out: ${error2}`);
        return [];
      }
      this.logger.debug(`[getConnectedAccounts] Connect returned account: ${data2 === null || data2 === void 0 ? void 0 : data2.account}`);
      if (!(data2 === null || data2 === void 0 ? void 0 : data2.account) || !wallet) {
        return [];
      }
      this.walletData = data2;
      this.wallet = wallet;
      this.setupEventListeners();
      return [data2.account];
    });
  }
  endSession() {
    const _super = Object.create(null, {
      endSession: { get: () => super.endSession }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super.endSession.call(this);
      yield $t2();
    });
  }
};

// node_modules/@dynamic-labs/starknet/src/wallets/argent/injected/argentx.js
var ArgentX = class extends ArgentBase {
  constructor(opts) {
    super("Ready Wallet (formerly Argent)", "argentX", "argentx", opts);
    this.overrideKey = "argentx";
  }
  prompt() {
    return __awaiter(this, void 0, void 0, function* () {
      const { connectorData, wallet } = yield It2({
        connectors: [new T2({ options: { id: this.id } })],
        modalMode: "canAsk"
      });
      return {
        data: {
          account: connectorData === null || connectorData === void 0 ? void 0 : connectorData.account,
          chainId: connectorData === null || connectorData === void 0 ? void 0 : connectorData.chainId
        },
        wallet: wallet !== null && wallet !== void 0 ? wallet : void 0
      };
    });
  }
};

// node_modules/@dynamic-labs/starknet/src/wallets/argent/argentMobile/argentMobile.js
var ArgentMobile = class extends ArgentBase {
  constructor(opts) {
    super("Ready", "argentXMobile", "argentxmobile", opts);
    this.canConnectViaCustodialService = true;
    this.overrideKey = "argentxmobile";
    this.projectId = opts.projectId;
    this.appName = opts.appName;
    this.appLogoUrls = opts.appLogoUrl ? [opts.appLogoUrl] : void 0;
  }
  isInstalledOnBrowser() {
    return false;
  }
  filter() {
    return super.filter() && !B();
  }
  prompt(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const { connectorData, wallet } = yield It2({
        connectors: [
          new U2({
            chainId: this.getNetworkName() || constants_exports.NetworkName.SN_MAIN,
            dappName: this.appName,
            icons: this.appLogoUrls,
            projectId: this.projectId,
            rpcUrl: this.getNodeUrl(),
            // TODO: use PlatformService
            url: window.location.hostname
          })
        ],
        modalMode: options.silently ? "neverAsk" : "canAsk"
      });
      return {
        data: {
          account: connectorData === null || connectorData === void 0 ? void 0 : connectorData.account,
          chainId: connectorData === null || connectorData === void 0 ? void 0 : connectorData.chainId
        },
        wallet: wallet !== null && wallet !== void 0 ? wallet : void 0
      };
    });
  }
  getNetworkName() {
    const [network] = this.starknetNetworks;
    if (!network) {
      return void 0;
    }
    return this.mapChainIdToNetworkName(network.chainId);
  }
  getNodeUrl() {
    var _a2;
    const [network] = this.starknetNetworks;
    if (!network) {
      return void 0;
    }
    return ((_a2 = network.privateCustomerRpcUrls) === null || _a2 === void 0 ? void 0 : _a2[0]) || network.rpcUrls[0];
  }
};

// node_modules/@dynamic-labs/starknet/src/wallets/argent/webwallet/webwallet.js
var WebWallet = class extends ArgentBase {
  constructor(opts) {
    super("Argent X - Web (Deprecated)", "argentWebWallet", "argentxweb", opts);
    this.overrideKey = "argentxweb";
    this.canConnectViaCustodialService = true;
    this.disconnectHandler = () => {
    };
  }
  isInstalledOnBrowser() {
    return false;
  }
  prompt(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const { connectorData, wallet } = yield It2({
        connectors: [new bo({ url: "https://web.argent.xyz" })],
        modalMode: options.silently ? "neverAsk" : "canAsk"
      });
      return {
        data: {
          account: connectorData === null || connectorData === void 0 ? void 0 : connectorData.account,
          chainId: connectorData === null || connectorData === void 0 ? void 0 : connectorData.chainId
        },
        wallet: wallet !== null && wallet !== void 0 ? wallet : void 0
      };
    });
  }
  setupEventListeners() {
    super.setupEventListeners();
    this.disconnectHandler = () => {
      logger.debug("[WebWallet] on logout");
      this.endSession();
      this.emit("disconnect");
    };
    document.addEventListener(En, this.disconnectHandler);
  }
  teardownEventListeners() {
    const _super = Object.create(null, {
      teardownEventListeners: { get: () => super.teardownEventListeners }
    });
    return __awaiter(this, void 0, void 0, function* () {
      _super.teardownEventListeners.call(this);
      if (this.disconnectHandler) {
        document.removeEventListener(En, this.disconnectHandler);
      }
    });
  }
};

// node_modules/@starknet-io/get-starknet-core/dist/core.js
var te3 = Object.defineProperty;
var ne3 = (t, e, n2) => e in t ? te3(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var _3 = (t, e, n2) => (ne3(t, typeof e != "symbol" ? e + "" : e, n2), n2);
var K3 = (t, e, n2) => {
  if (!e.has(t))
    throw TypeError("Cannot " + n2);
};
var N3 = (t, e, n2) => (K3(t, e, "read from private field"), n2 ? n2.call(t) : e.get(t));
var T4 = (t, e, n2) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, n2);
};
var B4 = (t, e, n2, r) => (K3(t, e, "write to private field"), r ? r.call(t, n2) : e.set(t, n2), n2);
var E2 = (t, e, n2) => (K3(t, e, "access private method"), n2);
var generateUID = () => `${Date.now()}-${Math.floor(Math.random() * 8999999999999) + 1e12}`;
var shuffle = (t) => {
  for (let e = t.length - 1; e > 0; e--) {
    const n2 = Math.floor(Math.random() * (e + 1));
    [t[e], t[n2]] = [t[n2], t[e]];
  }
  return t;
};
var pipe$1 = (...t) => (e) => t.reduce((n2, r) => n2.then(r), Promise.resolve(e));
function ensureKeysArray(t) {
  return Object.keys(t);
}
var ssrSafeWindow = typeof window < "u" ? window : null;
function getBuilderId() {
  return typeof FEDERATION_BUILD_IDENTIFIER < "u" ? FEDERATION_BUILD_IDENTIFIER : "";
}
function isDebugMode$1() {
  return Boolean("");
}
function isBrowserEnv$1() {
  return typeof window < "u";
}
var LOG_CATEGORY$1 = "[ Federation Runtime ]";
function assert(t, e) {
  t || error(e);
}
function error(t) {
  throw t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, t) : new Error(`${LOG_CATEGORY$1}: ${t}`);
}
function warn$1(t) {
  t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, console.warn(t)) : console.warn(`${LOG_CATEGORY$1}: ${t}`);
}
function addUniqueItem(t, e) {
  return t.findIndex((n2) => n2 === e) === -1 && t.push(e), t;
}
function getFMId(t) {
  return "version" in t && t.version ? `${t.name}:${t.version}` : "entry" in t && t.entry ? `${t.name}:${t.entry}` : `${t.name}`;
}
function isRemoteInfoWithEntry(t) {
  return typeof t.entry < "u";
}
function isPureRemoteEntry(t) {
  return !t.entry.includes(".json") && t.entry.includes(".js");
}
function safeToString$1(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return "";
  }
}
function isObject(t) {
  return t && typeof t == "object";
}
var objectToString = Object.prototype.toString;
function isPlainObject(t) {
  return objectToString.call(t) === "[object Object]";
}
function _extends$1$1() {
  return _extends$1$1 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends$1$1.apply(this, arguments);
}
function _object_without_properties_loose$1(t, e) {
  if (t == null)
    return {};
  var n2 = {}, r = Object.keys(t), o2, s;
  for (s = 0; s < r.length; s++)
    o2 = r[s], !(e.indexOf(o2) >= 0) && (n2[o2] = t[o2]);
  return n2;
}
var nativeGlobal = (() => {
  try {
    return new Function("return this")();
  } catch {
    return globalThis;
  }
})();
var Global = nativeGlobal;
function definePropertyGlobalVal(t, e, n2) {
  Object.defineProperty(t, e, {
    value: n2,
    configurable: false,
    writable: true
  });
}
function includeOwnProperty(t, e) {
  return Object.hasOwnProperty.call(t, e);
}
includeOwnProperty(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__") || definePropertyGlobalVal(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__", {});
var globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;
function setGlobalDefaultVal(t) {
  var e, n2, r, o2, s, i3;
  includeOwnProperty(t, "__VMOK__") && !includeOwnProperty(t, "__FEDERATION__") && definePropertyGlobalVal(t, "__FEDERATION__", t.__VMOK__), includeOwnProperty(t, "__FEDERATION__") || (definePropertyGlobalVal(t, "__FEDERATION__", {
    __GLOBAL_PLUGIN__: [],
    __INSTANCES__: [],
    moduleInfo: {},
    __SHARE__: {},
    __MANIFEST_LOADING__: {},
    __PRELOADED_MAP__: /* @__PURE__ */ new Map()
  }), definePropertyGlobalVal(t, "__VMOK__", t.__FEDERATION__));
  var a;
  (a = (e = t.__FEDERATION__).__GLOBAL_PLUGIN__) != null || (e.__GLOBAL_PLUGIN__ = []);
  var c2;
  (c2 = (n2 = t.__FEDERATION__).__INSTANCES__) != null || (n2.__INSTANCES__ = []);
  var l4;
  (l4 = (r = t.__FEDERATION__).moduleInfo) != null || (r.moduleInfo = {});
  var u;
  (u = (o2 = t.__FEDERATION__).__SHARE__) != null || (o2.__SHARE__ = {});
  var d;
  (d = (s = t.__FEDERATION__).__MANIFEST_LOADING__) != null || (s.__MANIFEST_LOADING__ = {});
  var h;
  (h = (i3 = t.__FEDERATION__).__PRELOADED_MAP__) != null || (i3.__PRELOADED_MAP__ = /* @__PURE__ */ new Map());
}
setGlobalDefaultVal(globalThis);
setGlobalDefaultVal(nativeGlobal);
function getGlobalFederationInstance(t, e) {
  const n2 = getBuilderId();
  return globalThis.__FEDERATION__.__INSTANCES__.find((r) => !!(n2 && r.options.id === getBuilderId() || r.options.name === t && !r.options.version && !e || r.options.name === t && e && r.options.version === e));
}
function setGlobalFederationInstance(t) {
  globalThis.__FEDERATION__.__INSTANCES__.push(t);
}
function getGlobalFederationConstructor() {
  return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
}
function setGlobalFederationConstructor(t, e = isDebugMode$1()) {
  e && (globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = t, globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = "0.1.2");
}
function getInfoWithoutType(t, e) {
  if (typeof e == "string") {
    if (t[e])
      return {
        value: t[e],
        key: e
      };
    {
      const r = Object.keys(t);
      for (const o2 of r) {
        const [s, i3] = o2.split(":"), a = `${s}:${e}`, c2 = t[a];
        if (c2)
          return {
            value: c2,
            key: a
          };
      }
      return {
        value: void 0,
        key: e
      };
    }
  } else
    throw new Error("key must be string");
}
var getGlobalSnapshot = () => nativeGlobal.__FEDERATION__.moduleInfo;
var getTargetSnapshotInfoByModuleInfo = (t, e) => {
  const n2 = getFMId(t), r = getInfoWithoutType(e, n2).value;
  if (r && !r.version && "version" in t && t.version && (r.version = t.version), r)
    return r;
  if ("version" in t && t.version) {
    const { version: o2 } = t, s = _object_without_properties_loose$1(t, [
      "version"
    ]), i3 = getFMId(s), a = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, i3).value;
    if ((a == null ? void 0 : a.version) === o2)
      return a;
  }
};
var getGlobalSnapshotInfoByModuleInfo = (t) => getTargetSnapshotInfoByModuleInfo(t, nativeGlobal.__FEDERATION__.moduleInfo);
var setGlobalSnapshotInfoByModuleInfo = (t, e) => {
  const n2 = getFMId(t);
  return nativeGlobal.__FEDERATION__.moduleInfo[n2] = e, nativeGlobal.__FEDERATION__.moduleInfo;
};
var addGlobalSnapshot = (t) => (nativeGlobal.__FEDERATION__.moduleInfo = _extends$1$1({}, nativeGlobal.__FEDERATION__.moduleInfo, t), () => {
  const e = Object.keys(t);
  for (const n2 of e)
    delete nativeGlobal.__FEDERATION__.moduleInfo[n2];
});
var getRemoteEntryExports = (t, e) => {
  const n2 = e || `__FEDERATION_${t}:custom__`, r = globalThis[n2];
  return {
    remoteEntryKey: n2,
    entryExports: r
  };
};
var getGlobalHostPlugins = () => nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;
var getPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.get(t);
var setPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.set(t, true);
var DEFAULT_SCOPE = "default";
var DEFAULT_REMOTE_TYPE = "global";
var buildIdentifier = "[0-9A-Za-z-]+";
var build = `(?:\\+(${buildIdentifier}(?:\\.${buildIdentifier})*))`;
var numericIdentifier = "0|[1-9]\\d*";
var numericIdentifierLoose = "[0-9]+";
var nonNumericIdentifier = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
var preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;
var preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\.${preReleaseIdentifierLoose})*))`;
var preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;
var preRelease = `(?:-(${preReleaseIdentifier}(?:\\.${preReleaseIdentifier})*))`;
var xRangeIdentifier = `${numericIdentifier}|x|X|\\*`;
var xRangePlain = `[v=\\s]*(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;
var hyphenRange = `^\\s*(${xRangePlain})\\s+-\\s+(${xRangePlain})\\s*$`;
var mainVersionLoose = `(${numericIdentifierLoose})\\.(${numericIdentifierLoose})\\.(${numericIdentifierLoose})`;
var loosePlain = `[v=\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;
var gtlt = "((?:<|>)?=?)";
var comparatorTrim = `(\\s*)${gtlt}\\s*(${loosePlain}|${xRangePlain})`;
var loneTilde = "(?:~>?)";
var tildeTrim = `(\\s*)${loneTilde}\\s+`;
var loneCaret = "(?:\\^)";
var caretTrim = `(\\s*)${loneCaret}\\s+`;
var star = "(<|>)?=?\\s*\\*";
var caret = `^${loneCaret}${xRangePlain}$`;
var mainVersion = `(${numericIdentifier})\\.(${numericIdentifier})\\.(${numericIdentifier})`;
var fullPlain = `v?${mainVersion}${preRelease}?${build}?`;
var tilde = `^${loneTilde}${xRangePlain}$`;
var xRange = `^${gtlt}\\s*${xRangePlain}$`;
var comparator = `^${gtlt}\\s*(${fullPlain})$|^$`;
var gte0 = "^\\s*>=\\s*0.0.0\\s*$";
function parseRegex(t) {
  return new RegExp(t);
}
function isXVersion(t) {
  return !t || t.toLowerCase() === "x" || t === "*";
}
function pipe(...t) {
  return (e) => t.reduce((n2, r) => r(n2), e);
}
function extractComparator(t) {
  return t.match(parseRegex(comparator));
}
function combineVersion(t, e, n2, r) {
  const o2 = `${t}.${e}.${n2}`;
  return r ? `${o2}-${r}` : o2;
}
function parseHyphen(t) {
  return t.replace(parseRegex(hyphenRange), (e, n2, r, o2, s, i3, a, c2, l4, u, d, h) => (isXVersion(r) ? n2 = "" : isXVersion(o2) ? n2 = `>=${r}.0.0` : isXVersion(s) ? n2 = `>=${r}.${o2}.0` : n2 = `>=${n2}`, isXVersion(l4) ? c2 = "" : isXVersion(u) ? c2 = `<${Number(l4) + 1}.0.0-0` : isXVersion(d) ? c2 = `<${l4}.${Number(u) + 1}.0-0` : h ? c2 = `<=${l4}.${u}.${d}-${h}` : c2 = `<=${c2}`, `${n2} ${c2}`.trim()));
}
function parseComparatorTrim(t) {
  return t.replace(parseRegex(comparatorTrim), "$1$2$3");
}
function parseTildeTrim(t) {
  return t.replace(parseRegex(tildeTrim), "$1~");
}
function parseCaretTrim(t) {
  return t.replace(parseRegex(caretTrim), "$1^");
}
function parseCarets(t) {
  return t.trim().split(/\s+/).map((e) => e.replace(parseRegex(caret), (n2, r, o2, s, i3) => isXVersion(r) ? "" : isXVersion(o2) ? `>=${r}.0.0 <${Number(r) + 1}.0.0-0` : isXVersion(s) ? r === "0" ? `>=${r}.${o2}.0 <${r}.${Number(o2) + 1}.0-0` : `>=${r}.${o2}.0 <${Number(r) + 1}.0.0-0` : i3 ? r === "0" ? o2 === "0" ? `>=${r}.${o2}.${s}-${i3} <${r}.${o2}.${Number(s) + 1}-0` : `>=${r}.${o2}.${s}-${i3} <${r}.${Number(o2) + 1}.0-0` : `>=${r}.${o2}.${s}-${i3} <${Number(r) + 1}.0.0-0` : r === "0" ? o2 === "0" ? `>=${r}.${o2}.${s} <${r}.${o2}.${Number(s) + 1}-0` : `>=${r}.${o2}.${s} <${r}.${Number(o2) + 1}.0-0` : `>=${r}.${o2}.${s} <${Number(r) + 1}.0.0-0`)).join(" ");
}
function parseTildes(t) {
  return t.trim().split(/\s+/).map((e) => e.replace(parseRegex(tilde), (n2, r, o2, s, i3) => isXVersion(r) ? "" : isXVersion(o2) ? `>=${r}.0.0 <${Number(r) + 1}.0.0-0` : isXVersion(s) ? `>=${r}.${o2}.0 <${r}.${Number(o2) + 1}.0-0` : i3 ? `>=${r}.${o2}.${s}-${i3} <${r}.${Number(o2) + 1}.0-0` : `>=${r}.${o2}.${s} <${r}.${Number(o2) + 1}.0-0`)).join(" ");
}
function parseXRanges(t) {
  return t.split(/\s+/).map((e) => e.trim().replace(parseRegex(xRange), (n2, r, o2, s, i3, a) => {
    const c2 = isXVersion(o2), l4 = c2 || isXVersion(s), u = l4 || isXVersion(i3);
    return r === "=" && u && (r = ""), a = "", c2 ? r === ">" || r === "<" ? "<0.0.0-0" : "*" : r && u ? (l4 && (s = 0), i3 = 0, r === ">" ? (r = ">=", l4 ? (o2 = Number(o2) + 1, s = 0, i3 = 0) : (s = Number(s) + 1, i3 = 0)) : r === "<=" && (r = "<", l4 ? o2 = Number(o2) + 1 : s = Number(s) + 1), r === "<" && (a = "-0"), `${r + o2}.${s}.${i3}${a}`) : l4 ? `>=${o2}.0.0${a} <${Number(o2) + 1}.0.0-0` : u ? `>=${o2}.${s}.0${a} <${o2}.${Number(s) + 1}.0-0` : n2;
  })).join(" ");
}
function parseStar(t) {
  return t.trim().replace(parseRegex(star), "");
}
function parseGTE0(t) {
  return t.trim().replace(parseRegex(gte0), "");
}
function compareAtom(t, e) {
  return t = Number(t) || t, e = Number(e) || e, t > e ? 1 : t === e ? 0 : -1;
}
function comparePreRelease(t, e) {
  const { preRelease: n2 } = t, { preRelease: r } = e;
  if (n2 === void 0 && Boolean(r))
    return 1;
  if (Boolean(n2) && r === void 0)
    return -1;
  if (n2 === void 0 && r === void 0)
    return 0;
  for (let o2 = 0, s = n2.length; o2 <= s; o2++) {
    const i3 = n2[o2], a = r[o2];
    if (i3 !== a)
      return i3 === void 0 && a === void 0 ? 0 : i3 ? a ? compareAtom(i3, a) : -1 : 1;
  }
  return 0;
}
function compareVersion(t, e) {
  return compareAtom(t.major, e.major) || compareAtom(t.minor, e.minor) || compareAtom(t.patch, e.patch) || comparePreRelease(t, e);
}
function eq(t, e) {
  return t.version === e.version;
}
function compare(t, e) {
  switch (t.operator) {
    case "":
    case "=":
      return eq(t, e);
    case ">":
      return compareVersion(t, e) < 0;
    case ">=":
      return eq(t, e) || compareVersion(t, e) < 0;
    case "<":
      return compareVersion(t, e) > 0;
    case "<=":
      return eq(t, e) || compareVersion(t, e) > 0;
    case void 0:
      return true;
    default:
      return false;
  }
}
function parseComparatorString(t) {
  return pipe(
    parseCarets,
    parseTildes,
    parseXRanges,
    parseStar
  )(t);
}
function parseRange(t) {
  return pipe(
    parseHyphen,
    parseComparatorTrim,
    parseTildeTrim,
    parseCaretTrim
  )(t.trim()).split(/\s+/).join(" ");
}
function satisfy(t, e) {
  if (!t)
    return false;
  const o2 = parseRange(e).split(" ").map((h) => parseComparatorString(h)).join(" ").split(/\s+/).map((h) => parseGTE0(h)), s = extractComparator(t);
  if (!s)
    return false;
  const [, i3, , a, c2, l4, u] = s, d = {
    operator: i3,
    version: combineVersion(a, c2, l4, u),
    major: a,
    minor: c2,
    patch: l4,
    preRelease: u == null ? void 0 : u.split(".")
  };
  for (const h of o2) {
    const M4 = extractComparator(h);
    if (!M4)
      return false;
    const [, I3, , m2, g2, p3, v2] = M4, y = {
      operator: I3,
      version: combineVersion(m2, g2, p3, v2),
      major: m2,
      minor: g2,
      patch: p3,
      preRelease: v2 == null ? void 0 : v2.split(".")
    };
    if (!compare(y, d))
      return false;
  }
  return true;
}
function _extends$6() {
  return _extends$6 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends$6.apply(this, arguments);
}
function formatShare(t, e) {
  let n2;
  return "get" in t ? n2 = t.get : n2 = () => Promise.resolve(t.lib), _extends$6({
    deps: [],
    useIn: [],
    from: e,
    loading: null
  }, t, {
    shareConfig: _extends$6({
      requiredVersion: `^${t.version}`,
      singleton: false,
      eager: false,
      strictVersion: false
    }, t.shareConfig),
    get: n2,
    loaded: "lib" in t ? true : void 0,
    scope: Array.isArray(t.scope) ? t.scope : [
      "default"
    ],
    strategy: t.strategy || "version-first"
  });
}
function formatShareConfigs(t, e) {
  return t ? Object.keys(t).reduce((n2, r) => (n2[r] = formatShare(t[r], e), n2), {}) : {};
}
function versionLt(t, e) {
  const n2 = (r) => {
    if (!Number.isNaN(Number(r))) {
      const s = r.split(".");
      let i3 = r;
      for (let a = 0; a < 3 - s.length; a++)
        i3 += ".0";
      return i3;
    }
    return r;
  };
  return !!satisfy(n2(t), `<=${n2(e)}`);
}
var findVersion = (t, e, n2, r) => {
  const o2 = t[e][n2], s = r || function(i3, a) {
    return versionLt(i3, a);
  };
  return Object.keys(o2).reduce((i3, a) => !i3 || s(i3, a) || i3 === "0" ? a : i3, 0);
};
var isLoaded = (t) => Boolean(t.loaded) || typeof t.lib == "function";
function findSingletonVersionOrderByVersion(t, e, n2) {
  const r = t[e][n2];
  return findVersion(t, e, n2, function(s, i3) {
    return !isLoaded(r[s]) && versionLt(s, i3);
  });
}
function findSingletonVersionOrderByLoaded(t, e, n2) {
  const r = t[e][n2];
  return findVersion(t, e, n2, function(s, i3) {
    return isLoaded(r[i3]) ? isLoaded(r[s]) ? Boolean(versionLt(s, i3)) : true : isLoaded(r[s]) ? false : versionLt(s, i3);
  });
}
function getFindShareFunction(t) {
  return t === "loaded-first" ? findSingletonVersionOrderByLoaded : findSingletonVersionOrderByVersion;
}
function getRegisteredShare(t, e, n2, r) {
  if (!t)
    return;
  const { shareConfig: o2, scope: s = DEFAULT_SCOPE, strategy: i3 } = n2, a = Array.isArray(s) ? s : [
    s
  ];
  for (const c2 of a)
    if (o2 && t[c2] && t[c2][e]) {
      const { requiredVersion: l4 } = o2, d = getFindShareFunction(i3)(t, c2, e), h = () => {
        if (o2.singleton) {
          if (typeof l4 == "string" && !satisfy(d, l4)) {
            const m2 = `Version ${d} from ${d && t[c2][e][d].from} of shared singleton module ${e} does not satisfy the requirement of ${n2.from} which needs ${l4})`;
            o2.strictVersion ? error(m2) : warn$1(m2);
          }
          return t[c2][e][d];
        } else {
          if (l4 === false || l4 === "*" || satisfy(d, l4))
            return t[c2][e][d];
          for (const [m2, g2] of Object.entries(t[c2][e]))
            if (satisfy(m2, l4))
              return g2;
        }
      }, M4 = {
        shareScopeMap: t,
        scope: c2,
        pkgName: e,
        version: d,
        GlobalFederation: Global.__FEDERATION__,
        resolver: h
      };
      return (r.emit(M4) || M4).resolver();
    }
}
function getGlobalShareScope() {
  return Global.__FEDERATION__.__SHARE__;
}
function _define_property$3(t, e, n2) {
  return e in t ? Object.defineProperty(t, e, {
    value: n2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t[e] = n2, t;
}
var MANIFEST_EXT = ".json";
var BROWSER_LOG_KEY = "FEDERATION_DEBUG";
var BROWSER_LOG_VALUE = "1";
var NameTransformSymbol = {
  AT: "@",
  HYPHEN: "-",
  SLASH: "/"
};
var _obj;
var NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, "scope_"), _define_property$3(_obj, NameTransformSymbol.HYPHEN, "_"), _define_property$3(_obj, NameTransformSymbol.SLASH, "__"), _obj);
var _obj1;
_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH);
var SEPARATOR = ":";
function isBrowserEnv() {
  return typeof window < "u";
}
function isDebugMode() {
  return typeof process < "u" && process.env && process.env.FEDERATION_DEBUG ? Boolean(process.env.FEDERATION_DEBUG) : typeof FEDERATION_DEBUG < "u" && Boolean(FEDERATION_DEBUG);
}
function _array_like_to_array$2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n2 = 0, r = new Array(e); n2 < e; n2++)
    r[n2] = t[n2];
  return r;
}
function _array_without_holes(t) {
  if (Array.isArray(t))
    return _array_like_to_array$2(t);
}
function _class_call_check(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(t, e) {
  for (var n2 = 0; n2 < e.length; n2++) {
    var r = e[n2];
    r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(t, r.key, r);
  }
}
function _create_class(t, e, n2) {
  return e && _defineProperties(t.prototype, e), n2 && _defineProperties(t, n2), t;
}
function _define_property$2(t, e, n2) {
  return e in t ? Object.defineProperty(t, e, {
    value: n2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t[e] = n2, t;
}
function _iterable_to_array$1(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(t) {
  return _array_without_holes(t) || _iterable_to_array$1(t) || _unsupported_iterable_to_array$2(t) || _non_iterable_spread();
}
function _unsupported_iterable_to_array$2(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return _array_like_to_array$2(t, e);
    var n2 = Object.prototype.toString.call(t).slice(8, -1);
    if (n2 === "Object" && t.constructor && (n2 = t.constructor.name), n2 === "Map" || n2 === "Set")
      return Array.from(n2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _array_like_to_array$2(t, e);
  }
}
function safeToString(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return "";
  }
}
var DEBUG_LOG = "[ FEDERATION DEBUG ]";
function safeGetLocalStorageItem() {
  try {
    if (typeof window < "u" && window.localStorage)
      return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;
  } catch {
    return typeof document < "u";
  }
  return false;
}
var Logger2 = (function() {
  function t(e) {
    _class_call_check(this, t), _define_property$2(this, "enable", false), _define_property$2(this, "identifier", void 0), this.identifier = e || DEBUG_LOG, isBrowserEnv() && safeGetLocalStorageItem() ? this.enable = true : isDebugMode() && (this.enable = true);
  }
  return _create_class(t, [
    {
      key: "info",
      value: function(e, n2) {
        if (this.enable) {
          var r = safeToString(n2) || "";
          isBrowserEnv() ? console.info("%c ".concat(this.identifier, ": ").concat(e, " ").concat(r), "color:#3300CC") : console.info("\x1B[34m%s", "".concat(this.identifier, ": ").concat(e, " ").concat(r ? `
`.concat(r) : ""));
        }
      }
    },
    {
      key: "logOriginalInfo",
      value: function() {
        for (var n2 = arguments.length, r = new Array(n2), o2 = 0; o2 < n2; o2++)
          r[o2] = arguments[o2];
        if (this.enable)
          if (isBrowserEnv()) {
            var s;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (s = console).log.apply(s, _to_consumable_array(r));
          } else {
            var i3;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (i3 = console).log.apply(i3, _to_consumable_array(r));
          }
      }
    }
  ]), t;
})();
var LOG_CATEGORY = "[ Federation Runtime ]";
new Logger2();
var composeKeyWithSeparator = function() {
  for (var e = arguments.length, n2 = new Array(e), r = 0; r < e; r++)
    n2[r] = arguments[r];
  return n2.length ? n2.reduce(function(o2, s) {
    return s ? o2 ? "".concat(o2).concat(SEPARATOR).concat(s) : s : o2;
  }, "") : "";
};
var getResourceUrl = function(t, e) {
  if ("getPublicPath" in t) {
    var n2 = new Function(t.getPublicPath)();
    return "".concat(n2).concat(e);
  } else
    return "publicPath" in t ? "".concat(t.publicPath).concat(e) : (console.warn("Can not get resource url, if in debug mode, please ignore", t, e), "");
};
var warn = function(t) {
  console.warn("".concat(LOG_CATEGORY, ": ").concat(t));
};
function _define_property$1(t, e, n2) {
  return e in t ? Object.defineProperty(t, e, {
    value: n2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t[e] = n2, t;
}
function _object_spread$1(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n2 = arguments[e] != null ? arguments[e] : {}, r = Object.keys(n2);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n2).filter(function(o2) {
      return Object.getOwnPropertyDescriptor(n2, o2).enumerable;
    }))), r.forEach(function(o2) {
      _define_property$1(t, o2, n2[o2]);
    });
  }
  return t;
}
function ownKeys(t, e) {
  var n2 = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o2) {
      return Object.getOwnPropertyDescriptor(t, o2).enumerable;
    })), n2.push.apply(n2, r);
  }
  return n2;
}
function _object_spread_props(t, e) {
  return e = e != null ? e : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : ownKeys(Object(e)).forEach(function(n2) {
    Object.defineProperty(t, n2, Object.getOwnPropertyDescriptor(e, n2));
  }), t;
}
var simpleJoinRemoteEntry = function(t, e) {
  if (!t)
    return e;
  var n2 = function(o2) {
    if (o2 === ".")
      return "";
    if (o2.startsWith("./"))
      return o2.replace("./", "");
    if (o2.startsWith("/")) {
      var s = o2.slice(1);
      return s.endsWith("/") ? s.slice(0, -1) : s;
    }
    return o2;
  }, r = n2(t);
  return r ? r.endsWith("/") ? "".concat(r).concat(e) : "".concat(r, "/").concat(e) : e;
};
function generateSnapshotFromManifest(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2, r, o2 = e.remotes, s = o2 === void 0 ? {} : o2, i3 = e.overrides, a = i3 === void 0 ? {} : i3, c2 = e.version, l4, u = function() {
    return "publicPath" in t.metaData ? t.metaData.publicPath : t.metaData.getPublicPath;
  }, d = Object.keys(a), h = {};
  if (!Object.keys(s).length) {
    var M4;
    h = ((M4 = t.remotes) === null || M4 === void 0 ? void 0 : M4.reduce(function(A2, W4) {
      var H2, $2 = W4.federationContainerName;
      return d.includes($2) ? H2 = a[$2] : "version" in W4 ? H2 = W4.version : H2 = W4.entry, A2[$2] = {
        matchedVersion: H2
      }, A2;
    }, {})) || {};
  }
  Object.keys(s).forEach(function(A2) {
    return h[A2] = {
      matchedVersion: d.includes(A2) ? a[A2] : s[A2]
    };
  });
  var I3 = t.metaData, m2 = I3.remoteEntry, g2 = m2.path, p3 = m2.name, v2 = m2.type, y = I3.types, S4 = I3.buildInfo.buildVersion, R3 = I3.globalName, x2 = t.exposes, O3 = {
    version: c2 || "",
    buildVersion: S4,
    globalName: R3,
    remoteEntry: simpleJoinRemoteEntry(g2, p3),
    remoteEntryType: v2,
    remoteTypes: simpleJoinRemoteEntry(y.path, y.name),
    remoteTypesZip: y.zip || "",
    remoteTypesAPI: y.api || "",
    remotesInfo: h,
    shared: t == null ? void 0 : t.shared.map(function(A2) {
      return {
        assets: A2.assets,
        sharedName: A2.name
      };
    }),
    modules: x2 == null ? void 0 : x2.map(function(A2) {
      return {
        moduleName: A2.name,
        modulePath: A2.path,
        assets: A2.assets
      };
    })
  };
  if (!((n2 = t.metaData) === null || n2 === void 0) && n2.prefetchInterface) {
    var L3 = t.metaData.prefetchInterface;
    O3 = _object_spread_props(_object_spread$1({}, O3), {
      prefetchInterface: L3
    });
  }
  if (!((r = t.metaData) === null || r === void 0) && r.prefetchEntry) {
    var D3 = t.metaData.prefetchEntry, b2 = D3.path, w2 = D3.name, U5 = D3.type;
    O3 = _object_spread_props(_object_spread$1({}, O3), {
      prefetchEntry: simpleJoinRemoteEntry(b2, w2),
      prefetchEntryType: U5
    });
  }
  return "publicPath" in t.metaData ? l4 = _object_spread_props(_object_spread$1({}, O3), {
    publicPath: u()
  }) : l4 = _object_spread_props(_object_spread$1({}, O3), {
    getPublicPath: u()
  }), l4;
}
function isManifestProvider(t) {
  return !!("remoteEntry" in t && t.remoteEntry.includes(MANIFEST_EXT));
}
function asyncGeneratorStep$1(t, e, n2, r, o2, s, i3) {
  try {
    var a = t[s](i3), c2 = a.value;
  } catch (l4) {
    n2(l4);
    return;
  }
  a.done ? e(c2) : Promise.resolve(c2).then(r, o2);
}
function _async_to_generator$1(t) {
  return function() {
    var e = this, n2 = arguments;
    return new Promise(function(r, o2) {
      var s = t.apply(e, n2);
      function i3(c2) {
        asyncGeneratorStep$1(s, r, o2, i3, a, "next", c2);
      }
      function a(c2) {
        asyncGeneratorStep$1(s, r, o2, i3, a, "throw", c2);
      }
      i3(void 0);
    });
  };
}
function _instanceof(t, e) {
  return e != null && typeof Symbol < "u" && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;
}
function _ts_generator$1(t, e) {
  var n2, r, o2, s, i3 = {
    label: 0,
    sent: function() {
      if (o2[0] & 1)
        throw o2[1];
      return o2[1];
    },
    trys: [],
    ops: []
  };
  return s = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(l4) {
    return function(u) {
      return c2([
        l4,
        u
      ]);
    };
  }
  function c2(l4) {
    if (n2)
      throw new TypeError("Generator is already executing.");
    for (; i3; )
      try {
        if (n2 = 1, r && (o2 = l4[0] & 2 ? r.return : l4[0] ? r.throw || ((o2 = r.return) && o2.call(r), 0) : r.next) && !(o2 = o2.call(r, l4[1])).done)
          return o2;
        switch (r = 0, o2 && (l4 = [
          l4[0] & 2,
          o2.value
        ]), l4[0]) {
          case 0:
          case 1:
            o2 = l4;
            break;
          case 4:
            return i3.label++, {
              value: l4[1],
              done: false
            };
          case 5:
            i3.label++, r = l4[1], l4 = [
              0
            ];
            continue;
          case 7:
            l4 = i3.ops.pop(), i3.trys.pop();
            continue;
          default:
            if (o2 = i3.trys, !(o2 = o2.length > 0 && o2[o2.length - 1]) && (l4[0] === 6 || l4[0] === 2)) {
              i3 = 0;
              continue;
            }
            if (l4[0] === 3 && (!o2 || l4[1] > o2[0] && l4[1] < o2[3])) {
              i3.label = l4[1];
              break;
            }
            if (l4[0] === 6 && i3.label < o2[1]) {
              i3.label = o2[1], o2 = l4;
              break;
            }
            if (o2 && i3.label < o2[2]) {
              i3.label = o2[2], i3.ops.push(l4);
              break;
            }
            o2[2] && i3.ops.pop(), i3.trys.pop();
            continue;
        }
        l4 = e.call(t, i3);
      } catch (u) {
        l4 = [
          6,
          u
        ], r = 0;
      } finally {
        n2 = o2 = 0;
      }
    if (l4[0] & 5)
      throw l4[1];
    return {
      value: l4[0] ? l4[1] : void 0,
      done: true
    };
  }
}
function safeWrapper(t, e) {
  return _safeWrapper.apply(this, arguments);
}
function _safeWrapper() {
  return _safeWrapper = _async_to_generator$1(function(t, e) {
    var n2, r;
    return _ts_generator$1(this, function(o2) {
      switch (o2.label) {
        case 0:
          return o2.trys.push([
            0,
            2,
            ,
            3
          ]), [
            4,
            t()
          ];
        case 1:
          return n2 = o2.sent(), [
            2,
            n2
          ];
        case 2:
          return r = o2.sent(), !e && warn(r), [
            2
          ];
        case 3:
          return [
            2
          ];
      }
    });
  }), _safeWrapper.apply(this, arguments);
}
function isStaticResourcesEqual(t, e) {
  var n2 = /^(https?:)?\/\//i, r = t.replace(n2, "").replace(/\/$/, ""), o2 = e.replace(n2, "").replace(/\/$/, "");
  return r === o2;
}
function createScript(t, e, n2, r) {
  for (var o2 = null, s = true, i3 = document.getElementsByTagName("script"), a = 0; a < i3.length; a++) {
    var c2 = i3[a], l4 = c2.getAttribute("src");
    if (l4 && isStaticResourcesEqual(l4, t)) {
      o2 = c2, s = false;
      break;
    }
  }
  if (!o2 && (o2 = document.createElement("script"), o2.type = "text/javascript", o2.src = t, r)) {
    var u = r(t);
    _instanceof(u, HTMLScriptElement) && (o2 = u);
  }
  n2 && Object.keys(n2).forEach(function(h) {
    o2 && (h === "async" || h === "defer" ? o2[h] = n2[h] : o2.setAttribute(h, n2[h]));
  });
  var d = function(h, M4) {
    if (o2 && (o2.onerror = null, o2.onload = null, safeWrapper(function() {
      o2 != null && o2.parentNode && o2.parentNode.removeChild(o2);
    }), h)) {
      var I3 = h(M4);
      return e(), I3;
    }
    e();
  };
  return o2.onerror = d.bind(null, o2.onerror), o2.onload = d.bind(null, o2.onload), {
    script: o2,
    needAttach: s
  };
}
function createLink(t, e) {
  for (var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 ? arguments[3] : void 0, o2 = null, s = true, i3 = document.getElementsByTagName("link"), a = 0; a < i3.length; a++) {
    var c2 = i3[a], l4 = c2.getAttribute("href"), u = c2.getAttribute("ref");
    if (l4 && isStaticResourcesEqual(l4, t) && u === n2.ref) {
      o2 = c2, s = false;
      break;
    }
  }
  if (!o2 && (o2 = document.createElement("link"), o2.setAttribute("href", t), r)) {
    var d = r(t);
    _instanceof(d, HTMLLinkElement) && (o2 = d);
  }
  n2 && Object.keys(n2).forEach(function(M4) {
    o2 && o2.setAttribute(M4, n2[M4]);
  });
  var h = function(M4, I3) {
    if (o2 && (o2.onerror = null, o2.onload = null, safeWrapper(function() {
      o2 != null && o2.parentNode && o2.parentNode.removeChild(o2);
    }), M4)) {
      var m2 = M4(I3);
      return e(), m2;
    }
    e();
  };
  return o2.onerror = h.bind(null, o2.onerror), o2.onload = h.bind(null, o2.onload), {
    link: o2,
    needAttach: s
  };
}
function loadScript(t, e) {
  var n2 = e.attrs, r = e.createScriptHook;
  return new Promise(function(o2, s) {
    var i3 = createScript(t, o2, n2, r), a = i3.script, c2 = i3.needAttach;
    c2 && document.getElementsByTagName("head")[0].appendChild(a);
  });
}
function _array_like_to_array(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n2 = 0, r = new Array(e); n2 < e; n2++)
    r[n2] = t[n2];
  return r;
}
function _array_with_holes(t) {
  if (Array.isArray(t))
    return t;
}
function asyncGeneratorStep(t, e, n2, r, o2, s, i3) {
  try {
    var a = t[s](i3), c2 = a.value;
  } catch (l4) {
    n2(l4);
    return;
  }
  a.done ? e(c2) : Promise.resolve(c2).then(r, o2);
}
function _async_to_generator(t) {
  return function() {
    var e = this, n2 = arguments;
    return new Promise(function(r, o2) {
      var s = t.apply(e, n2);
      function i3(c2) {
        asyncGeneratorStep(s, r, o2, i3, a, "next", c2);
      }
      function a(c2) {
        asyncGeneratorStep(s, r, o2, i3, a, "throw", c2);
      }
      i3(void 0);
    });
  };
}
function _iterable_to_array_limit(t, e) {
  var n2 = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n2 != null) {
    var r = [], o2 = true, s = false, i3, a;
    try {
      for (n2 = n2.call(t); !(o2 = (i3 = n2.next()).done) && (r.push(i3.value), !(e && r.length === e)); o2 = true)
        ;
    } catch (c2) {
      s = true, a = c2;
    } finally {
      try {
        !o2 && n2.return != null && n2.return();
      } finally {
        if (s)
          throw a;
      }
    }
    return r;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(t, e) {
  return _array_with_holes(t) || _iterable_to_array_limit(t, e) || _unsupported_iterable_to_array(t, e) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return _array_like_to_array(t, e);
    var n2 = Object.prototype.toString.call(t).slice(8, -1);
    if (n2 === "Object" && t.constructor && (n2 = t.constructor.name), n2 === "Map" || n2 === "Set")
      return Array.from(n2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _array_like_to_array(t, e);
  }
}
function _ts_generator(t, e) {
  var n2, r, o2, s, i3 = {
    label: 0,
    sent: function() {
      if (o2[0] & 1)
        throw o2[1];
      return o2[1];
    },
    trys: [],
    ops: []
  };
  return s = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(l4) {
    return function(u) {
      return c2([
        l4,
        u
      ]);
    };
  }
  function c2(l4) {
    if (n2)
      throw new TypeError("Generator is already executing.");
    for (; i3; )
      try {
        if (n2 = 1, r && (o2 = l4[0] & 2 ? r.return : l4[0] ? r.throw || ((o2 = r.return) && o2.call(r), 0) : r.next) && !(o2 = o2.call(r, l4[1])).done)
          return o2;
        switch (r = 0, o2 && (l4 = [
          l4[0] & 2,
          o2.value
        ]), l4[0]) {
          case 0:
          case 1:
            o2 = l4;
            break;
          case 4:
            return i3.label++, {
              value: l4[1],
              done: false
            };
          case 5:
            i3.label++, r = l4[1], l4 = [
              0
            ];
            continue;
          case 7:
            l4 = i3.ops.pop(), i3.trys.pop();
            continue;
          default:
            if (o2 = i3.trys, !(o2 = o2.length > 0 && o2[o2.length - 1]) && (l4[0] === 6 || l4[0] === 2)) {
              i3 = 0;
              continue;
            }
            if (l4[0] === 3 && (!o2 || l4[1] > o2[0] && l4[1] < o2[3])) {
              i3.label = l4[1];
              break;
            }
            if (l4[0] === 6 && i3.label < o2[1]) {
              i3.label = o2[1], o2 = l4;
              break;
            }
            if (o2 && i3.label < o2[2]) {
              i3.label = o2[2], i3.ops.push(l4);
              break;
            }
            o2[2] && i3.ops.pop(), i3.trys.pop();
            continue;
        }
        l4 = e.call(t, i3);
      } catch (u) {
        l4 = [
          6,
          u
        ], r = 0;
      } finally {
        n2 = o2 = 0;
      }
    if (l4[0] & 5)
      throw l4[1];
    return {
      value: l4[0] ? l4[1] : void 0,
      done: true
    };
  }
}
function importNodeModule(t) {
  if (!t)
    throw new Error("import specifier is required");
  var e = new Function("name", "return import(name)");
  return e(t).then(function(n2) {
    return n2.default;
  }).catch(function(n2) {
    throw console.error("Error importing module ".concat(t, ":"), n2), n2;
  });
}
function createScriptNode(url, cb, attrs, createScriptHook) {
  if (createScriptHook) {
    var hookResult = createScriptHook(url);
    hookResult && typeof hookResult == "object" && "url" in hookResult && (url = hookResult.url);
  }
  var urlObj;
  try {
    urlObj = new URL(url);
  } catch (t) {
    console.error("Error constructing URL:", t), cb(new Error("Invalid URL: ".concat(t)));
    return;
  }
  var getFetch = (function() {
    var t = _async_to_generator(function() {
      var e;
      return _ts_generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return typeof fetch > "u" ? [
              4,
              importNodeModule("node-fetch")
            ] : [
              3,
              2
            ];
          case 1:
            return e = n2.sent(), [
              2,
              (e == null ? void 0 : e.default) || e
            ];
          case 2:
            return [
              2,
              fetch
            ];
          case 3:
            return [
              2
            ];
        }
      });
    });
    return function() {
      return t.apply(this, arguments);
    };
  })();
  console.log("fetching", urlObj.href), getFetch().then(function(f) {
    f(urlObj.href).then(function(t) {
      return t.text();
    }).then((function() {
      var _ref = _async_to_generator(function(data) {
        var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;
        return _ts_generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                Promise.all([
                  importNodeModule("path"),
                  importNodeModule("vm")
                ])
              ];
            case 1:
              _ref = _sliced_to_array.apply(void 0, [
                _state.sent(),
                2
              ]), path = _ref[0], vm = _ref[1], scriptContext = {
                exports: {},
                module: {
                  exports: {}
                }
              }, urlDirname = urlObj.pathname.split("/").slice(0, -1).join("/"), filename = path.basename(urlObj.pathname);
              try {
                if (script = new vm.Script("(function(exports, module, require, __dirname, __filename) {".concat(data, `
})`), filename), script.runInThisContext()(scriptContext.exports, scriptContext.module, eval("require"), urlDirname, filename), exportedInterface = scriptContext.module.exports || scriptContext.exports, attrs && exportedInterface && attrs.globalName)
                  return container = exportedInterface[attrs.globalName] || exportedInterface, cb(void 0, container), [
                    2
                  ];
                cb(void 0, exportedInterface);
              } catch (t) {
                cb(new Error("Script execution error: ".concat(t)));
              }
              return [
                2
              ];
          }
        });
      });
      return function(t) {
        return _ref.apply(this, arguments);
      };
    })()).catch(function(t) {
      cb(t);
    });
  });
}
function loadScriptNode(t, e) {
  return new Promise(function(n2, r) {
    createScriptNode(t, function(o2, s) {
      if (o2)
        r(o2);
      else {
        var i3, a, c2 = (e == null || (i3 = e.attrs) === null || i3 === void 0 ? void 0 : i3.globalName) || "__FEDERATION_".concat(e == null || (a = e.attrs) === null || a === void 0 ? void 0 : a.name, ":custom__"), l4 = globalThis[c2] = s;
        n2(l4);
      }
    }, e.attrs, e.createScriptHook);
  });
}
function matchRemoteWithNameAndExpose(t, e) {
  for (const n2 of t) {
    const r = e.startsWith(n2.name);
    let o2 = e.replace(n2.name, "");
    if (r) {
      if (o2.startsWith("/")) {
        const a = n2.name;
        return o2 = `.${o2}`, {
          pkgNameOrAlias: a,
          expose: o2,
          remote: n2
        };
      } else if (o2 === "")
        return {
          pkgNameOrAlias: n2.name,
          expose: ".",
          remote: n2
        };
    }
    const s = n2.alias && e.startsWith(n2.alias);
    let i3 = n2.alias && e.replace(n2.alias, "");
    if (n2.alias && s) {
      if (i3 && i3.startsWith("/")) {
        const a = n2.alias;
        return i3 = `.${i3}`, {
          pkgNameOrAlias: a,
          expose: i3,
          remote: n2
        };
      } else if (i3 === "")
        return {
          pkgNameOrAlias: n2.alias,
          expose: ".",
          remote: n2
        };
    }
  }
}
function matchRemote(t, e) {
  for (const n2 of t)
    if (e === n2.name || n2.alias && e === n2.alias)
      return n2;
}
function registerPlugins(t, e) {
  const n2 = getGlobalHostPlugins();
  n2.length > 0 && n2.forEach((r) => {
    t != null && t.find((o2) => o2.name !== r.name) && t.push(r);
  }), t && t.length > 0 && t.forEach((r) => {
    e.forEach((o2) => {
      o2.applyPlugin(r);
    });
  });
}
function _extends$5() {
  return _extends$5 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends$5.apply(this, arguments);
}
async function loadEsmEntry({ entry: t, remoteEntryExports: e }) {
  return new Promise((n2, r) => {
    try {
      e ? n2(e) : new Function("callbacks", `import("${t}").then(callbacks[0]).catch(callbacks[1])`)([
        n2,
        r
      ]);
    } catch (o2) {
      r(o2);
    }
  });
}
async function loadEntryScript({ name: t, globalName: e, entry: n2, createScriptHook: r }) {
  const { entryExports: o2 } = getRemoteEntryExports(t, e);
  return o2 || (typeof document > "u" ? loadScriptNode(n2, {
    attrs: {
      name: t,
      globalName: e
    },
    createScriptHook: r
  }).then(() => {
    const { remoteEntryKey: s, entryExports: i3 } = getRemoteEntryExports(t, e);
    return assert(i3, `
        Unable to use the ${t}'s '${n2}' URL with ${s}'s globalName to get remoteEntry exports.
        Possible reasons could be:

        1. '${n2}' is not the correct URL, or the remoteEntry resource or name is incorrect.

        2. ${s} cannot be used to get remoteEntry exports in the window object.
      `), i3;
  }).catch((s) => s) : loadScript(n2, {
    attrs: {},
    createScriptHook: r
  }).then(() => {
    const { remoteEntryKey: s, entryExports: i3 } = getRemoteEntryExports(t, e);
    return assert(i3, `
      Unable to use the ${t}'s '${n2}' URL with ${s}'s globalName to get remoteEntry exports.
      Possible reasons could be:

      1. '${n2}' is not the correct URL, or the remoteEntry resource or name is incorrect.

      2. ${s} cannot be used to get remoteEntry exports in the window object.
    `), i3;
  }).catch((s) => s));
}
function getRemoteEntryUniqueKey(t) {
  const { entry: e, name: n2 } = t;
  return composeKeyWithSeparator(n2, e);
}
async function getRemoteEntry({ remoteEntryExports: t, remoteInfo: e, createScriptHook: n2 }) {
  const { entry: r, name: o2, type: s, entryGlobalName: i3 } = e, a = getRemoteEntryUniqueKey(e);
  return t || (globalLoading[a] || (s === "esm" ? globalLoading[a] = loadEsmEntry({
    entry: r,
    remoteEntryExports: t
  }) : globalLoading[a] = loadEntryScript({
    name: o2,
    globalName: i3,
    entry: r,
    createScriptHook: n2
  })), globalLoading[a]);
}
function getRemoteInfo(t) {
  return _extends$5({}, t, {
    entry: "entry" in t ? t.entry : "",
    type: t.type || DEFAULT_REMOTE_TYPE,
    entryGlobalName: t.entryGlobalName || t.name,
    shareScope: t.shareScope || DEFAULT_SCOPE
  });
}
function _extends$4() {
  return _extends$4 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends$4.apply(this, arguments);
}
var Module = class {
  async getEntry() {
    if (this.remoteEntryExports)
      return this.remoteEntryExports;
    const e = await getRemoteEntry({
      remoteInfo: this.remoteInfo,
      remoteEntryExports: this.remoteEntryExports,
      createScriptHook: (n2) => {
        const r = this.host.loaderHook.lifecycle.createScript.emit({
          url: n2
        });
        if (typeof document > "u" || r instanceof HTMLScriptElement)
          return r;
      }
    });
    return assert(e, `remoteEntryExports is undefined 
 ${safeToString$1(this.remoteInfo)}`), this.remoteEntryExports = e, this.remoteEntryExports;
  }
  async get(e, n2) {
    const { loadFactory: r = true } = n2 || {
      loadFactory: true
    }, o2 = await this.getEntry();
    if (!this.inited) {
      const a = this.host.shareScopeMap, c2 = this.remoteInfo.shareScope || "default";
      a[c2] || (a[c2] = {});
      const l4 = a[c2], u = [], d = {
        version: this.remoteInfo.version || ""
      };
      Object.defineProperty(d, "hostId", {
        value: this.host.options.id || this.host.name,
        enumerable: false
      });
      const h = await this.host.hooks.lifecycle.beforeInitContainer.emit({
        shareScope: l4,
        remoteEntryInitOptions: d,
        initScope: u,
        remoteInfo: this.remoteInfo,
        origin: this.host
      });
      await o2.init(h.shareScope, h.initScope, h.remoteEntryInitOptions), await this.host.hooks.lifecycle.initContainer.emit(_extends$4({}, h, {
        remoteEntryExports: o2
      }));
    }
    this.lib = o2, this.inited = true;
    const s = await o2.get(e);
    return assert(s, `${getFMId(this.remoteInfo)} remote don't export ${e}.`), r ? await s() : s;
  }
  constructor({ remoteInfo: e, host: n2 }) {
    this.inited = false, this.lib = void 0, this.remoteInfo = e, this.host = n2;
  }
};
var SyncHook = class {
  on(e) {
    typeof e == "function" && this.listeners.add(e);
  }
  once(e) {
    const n2 = this;
    this.on(function r(...o2) {
      return n2.remove(r), e.apply(null, o2);
    });
  }
  emit(...e) {
    let n2;
    return this.listeners.size > 0 && this.listeners.forEach((r) => {
      n2 = r(...e);
    }), n2;
  }
  remove(e) {
    this.listeners.delete(e);
  }
  removeAll() {
    this.listeners.clear();
  }
  constructor(e) {
    this.type = "", this.listeners = /* @__PURE__ */ new Set(), e && (this.type = e);
  }
};
var AsyncHook = class extends SyncHook {
  emit(...e) {
    let n2;
    const r = Array.from(this.listeners);
    if (r.length > 0) {
      let o2 = 0;
      const s = (i3) => i3 === false ? false : o2 < r.length ? Promise.resolve(r[o2++].apply(null, e)).then(s) : i3;
      n2 = s();
    }
    return Promise.resolve(n2);
  }
};
function checkReturnData(t, e) {
  if (!isObject(e))
    return false;
  if (t !== e) {
    for (const n2 in t)
      if (!(n2 in e))
        return false;
  }
  return true;
}
var SyncWaterfallHook = class extends SyncHook {
  emit(e) {
    isObject(e) || error(`The data for the "${this.type}" hook should be an object.`);
    for (const n2 of this.listeners)
      try {
        const r = n2(e);
        if (checkReturnData(e, r))
          e = r;
        else {
          this.onerror(`A plugin returned an unacceptable value for the "${this.type}" type.`);
          break;
        }
      } catch (r) {
        warn$1(r), this.onerror(r);
      }
    return e;
  }
  constructor(e) {
    super(), this.onerror = error, this.type = e;
  }
};
var AsyncWaterfallHook = class extends SyncHook {
  emit(e) {
    isObject(e) || error(`The response data for the "${this.type}" hook must be an object.`);
    const n2 = Array.from(this.listeners);
    if (n2.length > 0) {
      let r = 0;
      const o2 = (i3) => (warn$1(i3), this.onerror(i3), e), s = (i3) => {
        if (checkReturnData(e, i3)) {
          if (e = i3, r < n2.length)
            try {
              return Promise.resolve(n2[r++](e)).then(s, o2);
            } catch (a) {
              return o2(a);
            }
        } else
          this.onerror(`A plugin returned an incorrect value for the "${this.type}" type.`);
        return e;
      };
      return Promise.resolve(s(e));
    }
    return Promise.resolve(e);
  }
  constructor(e) {
    super(), this.onerror = error, this.type = e;
  }
};
var PluginSystem = class {
  applyPlugin(e) {
    assert(isPlainObject(e), "Plugin configuration is invalid.");
    const n2 = e.name;
    assert(n2, "A name must be provided by the plugin."), this.registerPlugins[n2] || (this.registerPlugins[n2] = e, Object.keys(this.lifecycle).forEach((r) => {
      const o2 = e[r];
      o2 && this.lifecycle[r].on(o2);
    }));
  }
  removePlugin(e) {
    assert(e, "A name is required.");
    const n2 = this.registerPlugins[e];
    assert(n2, `The plugin "${e}" is not registered.`), Object.keys(n2).forEach((r) => {
      r !== "name" && this.lifecycle[r].remove(n2[r]);
    });
  }
  inherit({ lifecycle: e, registerPlugins: n2 }) {
    Object.keys(e).forEach((r) => {
      assert(!this.lifecycle[r], `The hook "${r}" has a conflict and cannot be inherited.`), this.lifecycle[r] = e[r];
    }), Object.keys(n2).forEach((r) => {
      assert(!this.registerPlugins[r], `The plugin "${r}" has a conflict and cannot be inherited.`), this.applyPlugin(n2[r]);
    });
  }
  constructor(e) {
    this.registerPlugins = {}, this.lifecycle = e, this.lifecycleKeys = Object.keys(e);
  }
};
function _extends$3() {
  return _extends$3 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends$3.apply(this, arguments);
}
function defaultPreloadArgs(t) {
  return _extends$3({
    resourceCategory: "sync",
    share: true,
    depsRemote: true,
    prefetchInterface: false
  }, t);
}
function formatPreloadArgs(t, e) {
  return e.map((n2) => {
    const r = matchRemote(t, n2.nameOrAlias);
    return assert(r, `Unable to preload ${n2.nameOrAlias} as it is not included in ${!r && safeToString$1({
      remoteInfo: r,
      remotes: t
    })}`), {
      remote: r,
      preloadConfig: defaultPreloadArgs(n2)
    };
  });
}
function normalizePreloadExposes(t) {
  return t ? t.map((e) => e === "." ? e : e.startsWith("./") ? e.replace("./", "") : e) : [];
}
function preloadAssets(t, e, n2) {
  const { cssAssets: r, jsAssetsWithoutEntry: o2, entryAssets: s } = n2;
  if (e.options.inBrowser) {
    s.forEach((a) => {
      const { moduleInfo: c2 } = a, l4 = e.moduleCache.get(t.name);
      getRemoteEntry(l4 ? {
        remoteInfo: c2,
        remoteEntryExports: l4.remoteEntryExports,
        createScriptHook: (u) => {
          const d = e.loaderHook.lifecycle.createScript.emit({
            url: u
          });
          if (d instanceof HTMLScriptElement)
            return d;
        }
      } : {
        remoteInfo: c2,
        remoteEntryExports: void 0,
        createScriptHook: (u) => {
          const d = e.loaderHook.lifecycle.createScript.emit({
            url: u
          });
          if (d instanceof HTMLScriptElement)
            return d;
        }
      });
    });
    const i3 = document.createDocumentFragment();
    r.forEach((a) => {
      const { link: c2, needAttach: l4 } = createLink(a, () => {
      }, {
        rel: "preload",
        as: "style"
      }, (u) => {
        const d = e.loaderHook.lifecycle.createLink.emit({
          url: u
        });
        if (d instanceof HTMLLinkElement)
          return d;
      });
      l4 && i3.appendChild(c2);
    }), o2.forEach((a) => {
      const { link: c2, needAttach: l4 } = createLink(a, () => {
      }, {
        rel: "preload",
        as: "script"
      }, (u) => {
        const d = e.loaderHook.lifecycle.createLink.emit({
          url: u
        });
        if (d instanceof HTMLLinkElement)
          return d;
      });
      l4 && document.head.appendChild(c2);
    }), document.head.appendChild(i3);
  }
}
function _extends$2() {
  return _extends$2 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends$2.apply(this, arguments);
}
function assignRemoteInfo(t, e) {
  (!("remoteEntry" in e) || !e.remoteEntry) && error(`The attribute remoteEntry of ${name} must not be undefined.`);
  const { remoteEntry: n2 } = e, r = getResourceUrl(e, n2);
  t.type = e.remoteEntryType, t.entryGlobalName = e.globalName, t.entry = r, t.version = e.version, t.buildVersion = e.buildVersion;
}
function snapshotPlugin() {
  return {
    name: "snapshot-plugin",
    async afterResolve(t) {
      const { remote: e, pkgNameOrAlias: n2, expose: r, origin: o2, remoteInfo: s } = t;
      if (!isRemoteInfoWithEntry(e) || !isPureRemoteEntry(e)) {
        const { remoteSnapshot: i3, globalSnapshot: a } = await o2.snapshotHandler.loadRemoteSnapshotInfo(e);
        assignRemoteInfo(s, i3);
        const c2 = {
          remote: e,
          preloadConfig: {
            nameOrAlias: n2,
            exposes: [
              r
            ],
            resourceCategory: "sync",
            share: false,
            depsRemote: false
          }
        }, l4 = await o2.hooks.lifecycle.generatePreloadAssets.emit({
          origin: o2,
          preloadOptions: c2,
          remoteInfo: s,
          remote: e,
          remoteSnapshot: i3,
          globalSnapshot: a
        });
        return l4 && preloadAssets(s, o2, l4), _extends$2({}, t, {
          remoteSnapshot: i3
        });
      }
      return t;
    }
  };
}
function splitId(t) {
  const e = t.split(":");
  return e.length === 1 ? {
    name: e[0],
    version: void 0
  } : e.length === 2 ? {
    name: e[0],
    version: e[1]
  } : {
    name: e[1],
    version: e[2]
  };
}
function traverseModuleInfo(t, e, n2, r, o2 = {}, s) {
  const i3 = getFMId(e), { value: a } = getInfoWithoutType(t, i3), c2 = s || a;
  if (c2 && !isManifestProvider(c2) && (n2(c2, e, r), c2.remotesInfo)) {
    const l4 = Object.keys(c2.remotesInfo);
    for (const u of l4) {
      if (o2[u])
        continue;
      o2[u] = true;
      const d = splitId(u), h = c2.remotesInfo[u];
      traverseModuleInfo(t, {
        name: d.name,
        version: h.matchedVersion
      }, n2, false, o2, void 0);
    }
  }
}
function generatePreloadAssets(t, e, n2, r, o2) {
  const s = [], i3 = [], a = [], c2 = /* @__PURE__ */ new Set(), l4 = /* @__PURE__ */ new Set(), { options: u } = t, { preloadConfig: d } = e, { depsRemote: h } = d;
  traverseModuleInfo(r, n2, (g2, p3, v2) => {
    let y;
    if (v2)
      y = d;
    else if (Array.isArray(h)) {
      const D3 = h.find((b2) => b2.nameOrAlias === p3.name || b2.nameOrAlias === p3.alias);
      if (!D3)
        return;
      y = defaultPreloadArgs(D3);
    } else if (h === true)
      y = d;
    else
      return;
    const S4 = getResourceUrl(g2, "remoteEntry" in g2 ? g2.remoteEntry : "");
    S4 && a.push({
      name: p3.name,
      moduleInfo: {
        name: p3.name,
        entry: S4,
        type: "remoteEntryType" in g2 ? g2.remoteEntryType : "global",
        entryGlobalName: "globalName" in g2 ? g2.globalName : p3.name,
        shareScope: "",
        version: "version" in g2 ? g2.version : void 0
      },
      url: S4
    });
    let R3 = "modules" in g2 ? g2.modules : [];
    const x2 = normalizePreloadExposes(y.exposes);
    if (x2.length && "modules" in g2) {
      var O3;
      R3 = g2 == null || (O3 = g2.modules) == null ? void 0 : O3.reduce((D3, b2) => ((x2 == null ? void 0 : x2.indexOf(b2.moduleName)) !== -1 && D3.push(b2), D3), []);
    }
    function L3(D3) {
      const b2 = D3.map((w2) => getResourceUrl(g2, w2));
      return y.filter ? b2.filter(y.filter) : b2;
    }
    if (R3) {
      const D3 = R3.length;
      for (let b2 = 0; b2 < D3; b2++) {
        const w2 = R3[b2], U5 = `${p3.name}/${w2.moduleName}`;
        t.hooks.lifecycle.handlePreloadModule.emit({
          id: w2.moduleName === "." ? p3.name : U5,
          name: p3.name,
          remoteSnapshot: g2,
          preloadConfig: y,
          remote: p3,
          origin: t
        }), !getPreloaded(U5) && (y.resourceCategory === "all" ? (s.push(...L3(w2.assets.css.async)), s.push(...L3(w2.assets.css.sync)), i3.push(...L3(w2.assets.js.async)), i3.push(...L3(w2.assets.js.sync))) : (y.resourceCategory = "sync") && (s.push(...L3(w2.assets.css.sync)), i3.push(...L3(w2.assets.js.sync))), setPreloaded(U5));
      }
    }
  }, true, {}, o2), o2.shared && o2.shared.forEach((g2) => {
    var p3;
    const v2 = (p3 = u.shared) == null ? void 0 : p3[g2.sharedName];
    if (!v2)
      return;
    const y = getRegisteredShare(t.shareScopeMap, g2.sharedName, v2, t.hooks.lifecycle.resolveShare);
    y && typeof y.lib == "function" && (g2.assets.js.sync.forEach((S4) => {
      c2.add(S4);
    }), g2.assets.css.sync.forEach((S4) => {
      l4.add(S4);
    }));
  });
  const I3 = i3.filter((g2) => !c2.has(g2));
  return {
    cssAssets: s.filter((g2) => !l4.has(g2)),
    jsAssetsWithoutEntry: I3,
    entryAssets: a
  };
}
var generatePreloadAssetsPlugin = function() {
  return {
    name: "generate-preload-assets-plugin",
    async generatePreloadAssets(t) {
      const { origin: e, preloadOptions: n2, remoteInfo: r, remote: o2, globalSnapshot: s, remoteSnapshot: i3 } = t;
      return isRemoteInfoWithEntry(o2) && isPureRemoteEntry(o2) ? {
        cssAssets: [],
        jsAssetsWithoutEntry: [],
        entryAssets: [
          {
            name: o2.name,
            url: o2.entry,
            moduleInfo: {
              name: r.name,
              entry: o2.entry,
              type: "global",
              entryGlobalName: "",
              shareScope: ""
            }
          }
        ]
      } : (assignRemoteInfo(r, i3), generatePreloadAssets(e, n2, r, s, i3));
    }
  };
};
function _extends$1() {
  return _extends$1 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends$1.apply(this, arguments);
}
var SnapshotHandler = class {
  async loadSnapshot(e) {
    const { options: n2 } = this.HostInstance, { hostGlobalSnapshot: r, remoteSnapshot: o2, globalSnapshot: s } = this.getGlobalRemoteInfo(e), { remoteSnapshot: i3, globalSnapshot: a } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: n2,
      moduleInfo: e,
      hostGlobalSnapshot: r,
      remoteSnapshot: o2,
      globalSnapshot: s
    });
    return {
      remoteSnapshot: i3,
      globalSnapshot: a
    };
  }
  async loadRemoteSnapshotInfo(e) {
    const { options: n2 } = this.HostInstance;
    await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
      options: n2,
      moduleInfo: e
    });
    let r = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    });
    r || (r = {
      version: this.HostInstance.options.version || "",
      remoteEntry: "",
      remotesInfo: {}
    }, addGlobalSnapshot({
      [this.HostInstance.options.name]: r
    })), r && "remotesInfo" in r && !getInfoWithoutType(r.remotesInfo, e.name).value && ("version" in e || "entry" in e) && (r.remotesInfo = _extends$1({}, r == null ? void 0 : r.remotesInfo, {
      [e.name]: {
        matchedVersion: "version" in e ? e.version : e.entry
      }
    }));
    const { hostGlobalSnapshot: o2, remoteSnapshot: s, globalSnapshot: i3 } = this.getGlobalRemoteInfo(e), { remoteSnapshot: a, globalSnapshot: c2 } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: n2,
      moduleInfo: e,
      hostGlobalSnapshot: o2,
      remoteSnapshot: s,
      globalSnapshot: i3
    });
    if (a)
      if (isManifestProvider(a)) {
        const l4 = await this.getManifestJson(a.remoteEntry, e, {}), u = setGlobalSnapshotInfoByModuleInfo(_extends$1({}, e, {
          entry: a.remoteEntry
        }), l4);
        return {
          remoteSnapshot: l4,
          globalSnapshot: u
        };
      } else {
        const { remoteSnapshot: l4 } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
          options: this.HostInstance.options,
          moduleInfo: e,
          remoteSnapshot: a,
          from: "global"
        });
        return {
          remoteSnapshot: l4,
          globalSnapshot: c2
        };
      }
    else if (isRemoteInfoWithEntry(e)) {
      const l4 = await this.getManifestJson(e.entry, e, {}), u = setGlobalSnapshotInfoByModuleInfo(e, l4), { remoteSnapshot: d } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: e,
        remoteSnapshot: l4,
        from: "global"
      });
      return {
        remoteSnapshot: d,
        globalSnapshot: u
      };
    } else
      error(`
          Cannot get remoteSnapshot with the name: '${e.name}', version: '${e.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:

          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.

          2. The remote '${e.name}' version '${e.version}' is not released.

          The transformed module info: ${JSON.stringify(c2)}
        `);
  }
  getGlobalRemoteInfo(e) {
    const n2 = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    }), r = n2 && "remotesInfo" in n2 && n2.remotesInfo && getInfoWithoutType(n2.remotesInfo, e.name).value;
    return r && r.matchedVersion ? {
      hostGlobalSnapshot: n2,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e.name,
        version: r.matchedVersion
      })
    } : {
      hostGlobalSnapshot: void 0,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e.name,
        version: "version" in e ? e.version : void 0
      })
    };
  }
  async getManifestJson(e, n2, r) {
    const o2 = async () => {
      let i3 = this.manifestCache.get(e);
      if (i3)
        return i3;
      try {
        let a = await this.loaderHook.lifecycle.fetch.emit(e, {});
        return (!a || !(a instanceof Response)) && (a = await fetch(e, {})), i3 = await a.json(), assert(i3.metaData && i3.exposes && i3.shared, `${e} is not a federation manifest`), this.manifestCache.set(e, i3), i3;
      } catch (a) {
        error(`Failed to get manifestJson for ${n2.name}. The manifest URL is ${e}. Please ensure that the manifestUrl is accessible.
          
 Error message:
          
 ${a}`);
      }
    }, s = async () => {
      const i3 = await o2(), a = generateSnapshotFromManifest(i3, {
        version: e
      }), { remoteSnapshot: c2 } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: n2,
        manifestJson: i3,
        remoteSnapshot: a,
        manifestUrl: e,
        from: "manifest"
      });
      return c2;
    };
    return this.manifestLoading[e] || (this.manifestLoading[e] = s().then((i3) => i3)), this.manifestLoading[e];
  }
  constructor(e) {
    this.loadingHostSnapshot = null, this.manifestCache = /* @__PURE__ */ new Map(), this.hooks = new PluginSystem({
      beforeLoadRemoteSnapshot: new AsyncHook("beforeLoadRemoteSnapshot"),
      loadSnapshot: new AsyncWaterfallHook("loadGlobalSnapshot"),
      loadRemoteSnapshot: new AsyncWaterfallHook("loadRemoteSnapshot")
    }), this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__, this.HostInstance = e, this.loaderHook = e.loaderHook;
  }
};
function _extends() {
  return _extends = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (t[r] = n2[r]);
    }
    return t;
  }, _extends.apply(this, arguments);
}
function _object_without_properties_loose(t, e) {
  if (t == null)
    return {};
  var n2 = {}, r = Object.keys(t), o2, s;
  for (s = 0; s < r.length; s++)
    o2 = r[s], !(e.indexOf(o2) >= 0) && (n2[o2] = t[o2]);
  return n2;
}
var FederationHost = class {
  _setGlobalShareScopeMap() {
    const e = getGlobalShareScope(), n2 = this.options.id || this.options.name;
    n2 && !e[n2] && (e[n2] = this.shareScopeMap);
  }
  initOptions(e) {
    this.registerPlugins(e.plugins);
    const n2 = this.formatOptions(this.options, e);
    return this.options = n2, n2;
  }
  async loadShare(e, n2) {
    var r;
    const o2 = Object.assign({}, (r = this.options.shared) == null ? void 0 : r[e], n2);
    o2 != null && o2.scope && await Promise.all(o2.scope.map(async (l4) => {
      await Promise.all(this.initializeSharing(l4, o2.strategy));
    }));
    const s = await this.hooks.lifecycle.beforeLoadShare.emit({
      pkgName: e,
      shareInfo: o2,
      shared: this.options.shared,
      origin: this
    }), { shareInfo: i3 } = s;
    assert(i3, `Cannot find ${e} Share in the ${this.options.name}. Please ensure that the ${e} Share parameters have been injected`);
    const a = getRegisteredShare(this.shareScopeMap, e, i3, this.hooks.lifecycle.resolveShare), c2 = (l4) => {
      l4.useIn || (l4.useIn = []), addUniqueItem(l4.useIn, this.options.name);
    };
    if (a && a.lib)
      return c2(a), a.lib;
    if (a && a.loading && !a.loaded) {
      const l4 = await a.loading;
      return a.loaded = true, a.lib || (a.lib = l4), c2(a), l4;
    } else if (a) {
      const u = (async () => {
        const d = await a.get();
        i3.lib = d, i3.loaded = true, c2(i3);
        const h = getRegisteredShare(this.shareScopeMap, e, i3, this.hooks.lifecycle.resolveShare);
        return h && (h.lib = d, h.loaded = true), d;
      })();
      return this.setShared({
        pkgName: e,
        loaded: false,
        shared: a,
        from: this.options.name,
        lib: null,
        loading: u
      }), u;
    } else {
      if (n2)
        return false;
      const u = (async () => {
        const d = await i3.get();
        i3.lib = d, i3.loaded = true, c2(i3);
        const h = getRegisteredShare(this.shareScopeMap, e, i3, this.hooks.lifecycle.resolveShare);
        return h && (h.lib = d, h.loaded = true), d;
      })();
      return this.setShared({
        pkgName: e,
        loaded: false,
        shared: i3,
        from: this.options.name,
        lib: null,
        loading: u
      }), u;
    }
  }
  loadShareSync(e, n2) {
    var r;
    const o2 = Object.assign({}, (r = this.options.shared) == null ? void 0 : r[e], n2);
    o2 != null && o2.scope && o2.scope.forEach((a) => {
      this.initializeSharing(a, o2.strategy);
    });
    const s = getRegisteredShare(this.shareScopeMap, e, o2, this.hooks.lifecycle.resolveShare), i3 = (a) => {
      a.useIn || (a.useIn = []), addUniqueItem(a.useIn, this.options.name);
    };
    if (s) {
      if (typeof s.lib == "function")
        return i3(s), s.loaded || (s.loaded = true, s.from === this.options.name && (o2.loaded = true)), s.lib;
      if (typeof s.get == "function") {
        const a = s.get();
        if (!(a instanceof Promise))
          return i3(s), this.setShared({
            pkgName: e,
            loaded: true,
            from: this.options.name,
            lib: a,
            shared: s
          }), a;
      }
    }
    if (o2.lib)
      return o2.loaded || (o2.loaded = true), o2.lib;
    if (o2.get) {
      const a = o2.get();
      if (a instanceof Promise)
        throw new Error(`
        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e} share was not registered with the 'lib' attribute.

      `);
      return o2.lib = a, this.setShared({
        pkgName: e,
        loaded: true,
        from: this.options.name,
        lib: o2.lib,
        shared: o2
      }), o2.lib;
    }
    throw new Error(`
        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e} share was not registered with the 'lib' attribute.

      `);
  }
  initRawContainer(e, n2, r) {
    const o2 = getRemoteInfo({
      name: e,
      entry: n2
    }), s = new Module({
      host: this,
      remoteInfo: o2
    });
    return s.remoteEntryExports = r, this.moduleCache.set(e, s), s;
  }
  async _getRemoteModuleAndOptions(e) {
    const n2 = await this.hooks.lifecycle.beforeRequest.emit({
      id: e,
      options: this.options,
      origin: this
    }), { id: r } = n2, o2 = matchRemoteWithNameAndExpose(this.options.remotes, r);
    assert(o2, `
        Unable to locate ${r} in ${this.options.name}. Potential reasons for failure include:

        1. ${r} was not included in the 'remotes' parameter of ${this.options.name || "the host"}.

        2. ${r} could not be found in the 'remotes' of ${this.options.name} with either 'name' or 'alias' attributes.
        3. ${r} is not online, injected, or loaded.
        4. ${r}  cannot be accessed on the expected.
        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${r}.
      `);
    const { remote: s } = o2, i3 = getRemoteInfo(s), a = await this.hooks.lifecycle.afterResolve.emit(_extends({
      id: r
    }, o2, {
      options: this.options,
      origin: this,
      remoteInfo: i3
    })), { remote: c2, expose: l4 } = a;
    assert(c2 && l4, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${r}.`);
    let u = this.moduleCache.get(c2.name);
    const d = {
      host: this,
      remoteInfo: i3
    };
    return u || (u = new Module(d), this.moduleCache.set(c2.name, u)), {
      module: u,
      moduleOptions: d,
      remoteMatchInfo: a
    };
  }
  async loadRemote(e, n2) {
    try {
      const { loadFactory: r = true } = n2 || {
        loadFactory: true
      }, { module: o2, moduleOptions: s, remoteMatchInfo: i3 } = await this._getRemoteModuleAndOptions(e), { pkgNameOrAlias: a, remote: c2, expose: l4, id: u } = i3, d = await o2.get(l4, n2), h = await this.hooks.lifecycle.onLoad.emit({
        id: u,
        pkgNameOrAlias: a,
        expose: l4,
        exposeModule: r ? d : void 0,
        exposeModuleFactory: r ? void 0 : d,
        remote: c2,
        options: s,
        moduleInstance: o2,
        origin: this
      });
      return typeof h == "function" ? h : d;
    } catch (r) {
      const { from: o2 = "runtime" } = n2 || {
        from: "runtime"
      }, s = await this.hooks.lifecycle.errorLoadRemote.emit({
        id: e,
        error: r,
        from: o2,
        origin: this
      });
      if (!s)
        throw r;
      return s;
    }
  }
  async preloadRemote(e) {
    await this.hooks.lifecycle.beforePreloadRemote.emit({
      preloadOptions: e,
      options: this.options,
      origin: this
    });
    const n2 = formatPreloadArgs(this.options.remotes, e);
    await Promise.all(n2.map(async (r) => {
      const { remote: o2 } = r, s = getRemoteInfo(o2), { globalSnapshot: i3, remoteSnapshot: a } = await this.snapshotHandler.loadRemoteSnapshotInfo(o2), c2 = await this.hooks.lifecycle.generatePreloadAssets.emit({
        origin: this,
        preloadOptions: r,
        remote: o2,
        remoteInfo: s,
        globalSnapshot: i3,
        remoteSnapshot: a
      });
      !c2 || preloadAssets(s, this, c2);
    }));
  }
  initializeSharing(e = DEFAULT_SCOPE, n2) {
    const r = this.shareScopeMap, o2 = this.options.name;
    r[e] || (r[e] = {});
    const s = r[e], i3 = (u, d) => {
      var h;
      const { version: M4, eager: I3 } = d;
      s[u] = s[u] || {};
      const m2 = s[u], g2 = m2[M4], p3 = Boolean(g2 && (g2.eager || ((h = g2.shareConfig) == null ? void 0 : h.eager)));
      (!g2 || g2.strategy !== "loaded-first" && !g2.loaded && (Boolean(!I3) !== !p3 ? I3 : o2 > g2.from)) && (m2[M4] = d);
    }, a = [], c2 = (u) => u && u.init && u.init(r[e]), l4 = async (u) => {
      const { module: d } = await this._getRemoteModuleAndOptions(u);
      if (d.getEntry) {
        const h = await d.getEntry();
        d.inited || (c2(h), d.inited = true);
      }
    };
    return Object.keys(this.options.shared).forEach((u) => {
      const d = this.options.shared[u];
      d.scope.includes(e) && i3(u, d);
    }), n2 === "version-first" && this.options.remotes.forEach((u) => {
      u.shareScope === e && a.push(l4(u.name));
    }), a;
  }
  initShareScopeMap(e, n2) {
    this.shareScopeMap[e] = n2, this.hooks.lifecycle.initContainerShareScopeMap.emit({
      shareScope: n2,
      options: this.options,
      origin: this
    });
  }
  formatOptions(e, n2) {
    const r = formatShareConfigs(n2.shared || {}, n2.name), o2 = _extends({}, e.shared, r), { userOptions: s, options: i3 } = this.hooks.lifecycle.beforeInit.emit({
      origin: this,
      userOptions: n2,
      options: e,
      shareInfo: o2
    }), c2 = (s.remotes || []).reduce((h, M4) => (this.registerRemote(M4, h, {
      force: false
    }), h), i3.remotes);
    Object.keys(r).forEach((h) => {
      const M4 = r[h];
      !getRegisteredShare(this.shareScopeMap, h, M4, this.hooks.lifecycle.resolveShare) && M4 && M4.lib && this.setShared({
        pkgName: h,
        lib: M4.lib,
        get: M4.get,
        loaded: true,
        shared: M4,
        from: n2.name
      });
    });
    const u = [
      ...i3.plugins
    ];
    s.plugins && s.plugins.forEach((h) => {
      u.includes(h) || u.push(h);
    });
    const d = _extends({}, e, n2, {
      plugins: u,
      remotes: c2,
      shared: o2
    });
    return this.hooks.lifecycle.init.emit({
      origin: this,
      options: d
    }), d;
  }
  registerPlugins(e) {
    registerPlugins(e, [
      this.hooks,
      this.snapshotHandler.hooks,
      this.loaderHook
    ]);
  }
  setShared({ pkgName: e, shared: n2, from: r, lib: o2, loading: s, loaded: i3, get: a }) {
    const { version: c2, scope: l4 = "default" } = n2, u = _object_without_properties_loose(n2, [
      "version",
      "scope"
    ]);
    (Array.isArray(l4) ? l4 : [
      l4
    ]).forEach((h) => {
      this.shareScopeMap[h] || (this.shareScopeMap[h] = {}), this.shareScopeMap[h][e] || (this.shareScopeMap[h][e] = {}), !this.shareScopeMap[h][e][c2] && (this.shareScopeMap[h][e][c2] = _extends({
        version: c2,
        scope: [
          "default"
        ]
      }, u, {
        lib: o2,
        loaded: i3,
        loading: s
      }), a && (this.shareScopeMap[h][e][c2].get = a));
    });
  }
  removeRemote(e) {
    const { name: n2 } = e, r = this.options.remotes.findIndex((s) => s.name === n2);
    r !== -1 && this.options.remotes.splice(r, 1);
    const o2 = this.moduleCache.get(e.name);
    if (o2) {
      const s = o2.remoteInfo.entryGlobalName;
      globalThis[s] && delete globalThis[s];
      const i3 = getRemoteEntryUniqueKey(o2.remoteInfo);
      globalLoading[i3] && delete globalLoading[i3], this.moduleCache.delete(e.name);
    }
  }
  registerRemote(e, n2, r) {
    const o2 = () => {
      if (e.alias) {
        const i3 = n2.find((a) => {
          var c2;
          return e.alias && (a.name.startsWith(e.alias) || ((c2 = a.alias) == null ? void 0 : c2.startsWith(e.alias)));
        });
        assert(!i3, `The alias ${e.alias} of remote ${e.name} is not allowed to be the prefix of ${i3 && i3.name} name or alias`);
      }
      "entry" in e && isBrowserEnv$1() && !e.entry.startsWith("http") && (e.entry = new URL(e.entry, window.location.origin).href), e.shareScope || (e.shareScope = DEFAULT_SCOPE), e.type || (e.type = DEFAULT_REMOTE_TYPE);
    }, s = n2.find((i3) => i3.name === e.name);
    if (!s)
      o2(), n2.push(e);
    else {
      const i3 = [
        `The remote "${e.name}" is already registered.`,
        r != null && r.force ? "Hope you have known that OVERRIDE it may have some unexpected errors" : 'If you want to merge the remote, you can set "force: true".'
      ];
      r != null && r.force && (this.removeRemote(s), o2(), n2.push(e)), warn$1(i3.join(" "));
    }
  }
  registerRemotes(e, n2) {
    e.forEach((r) => {
      this.registerRemote(r, this.options.remotes, {
        force: n2 == null ? void 0 : n2.force
      });
    });
  }
  constructor(e) {
    this.hooks = new PluginSystem({
      beforeInit: new SyncWaterfallHook("beforeInit"),
      init: new SyncHook(),
      beforeRequest: new AsyncWaterfallHook("beforeRequest"),
      afterResolve: new AsyncWaterfallHook("afterResolve"),
      beforeInitContainer: new AsyncWaterfallHook("beforeInitContainer"),
      initContainerShareScopeMap: new AsyncWaterfallHook("initContainer"),
      initContainer: new AsyncWaterfallHook("initContainer"),
      onLoad: new AsyncHook("onLoad"),
      handlePreloadModule: new SyncHook("handlePreloadModule"),
      errorLoadRemote: new AsyncHook("errorLoadRemote"),
      beforeLoadShare: new AsyncWaterfallHook("beforeLoadShare"),
      loadShare: new AsyncHook(),
      resolveShare: new SyncWaterfallHook("resolveShare"),
      beforePreloadRemote: new AsyncHook(),
      generatePreloadAssets: new AsyncHook("generatePreloadAssets"),
      afterPreloadRemote: new AsyncHook()
    }), this.version = "0.1.2", this.moduleCache = /* @__PURE__ */ new Map(), this.loaderHook = new PluginSystem({
      getModuleInfo: new SyncHook(),
      createScript: new SyncHook(),
      createLink: new SyncHook(),
      fetch: new AsyncHook("fetch")
    });
    const n2 = {
      id: getBuilderId(),
      name: e.name,
      plugins: [
        snapshotPlugin(),
        generatePreloadAssetsPlugin()
      ],
      remotes: [],
      shared: {},
      inBrowser: isBrowserEnv$1()
    };
    this.name = e.name, this.options = n2, this.shareScopeMap = {}, this._setGlobalShareScopeMap(), this.snapshotHandler = new SnapshotHandler(this), this.registerPlugins([
      ...n2.plugins,
      ...e.plugins || []
    ]), this.options = this.formatOptions(n2, e);
  }
};
var FederationInstance = null;
function init(t) {
  const e = getGlobalFederationInstance(t.name, t.version);
  if (e)
    return e.initOptions(t), FederationInstance || (FederationInstance = e), e;
  {
    const n2 = getGlobalFederationConstructor() || FederationHost;
    return FederationInstance = new n2(t), setGlobalFederationInstance(FederationInstance), FederationInstance;
  }
}
function loadRemote(...t) {
  return assert(FederationInstance, "Please call init first"), FederationInstance.loadRemote.apply(FederationInstance, t);
}
setGlobalFederationConstructor(FederationHost);
function __awaiter2(t, e, n2, r) {
  function o2(s) {
    return s instanceof n2 ? s : new n2(function(i3) {
      i3(s);
    });
  }
  return new (n2 || (n2 = Promise))(function(s, i3) {
    function a(u) {
      try {
        l4(r.next(u));
      } catch (d) {
        i3(d);
      }
    }
    function c2(u) {
      try {
        l4(r.throw(u));
      } catch (d) {
        i3(d);
      }
    }
    function l4(u) {
      u.done ? s(u.value) : o2(u.value).then(a, c2);
    }
    l4((r = r.apply(t, e || [])).next());
  });
}
function __generator(t, e) {
  var n2 = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, o2, s, i3;
  return i3 = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (i3[Symbol.iterator] = function() {
    return this;
  }), i3;
  function a(l4) {
    return function(u) {
      return c2([l4, u]);
    };
  }
  function c2(l4) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n2; )
      try {
        if (r = 1, o2 && (s = l4[0] & 2 ? o2.return : l4[0] ? o2.throw || ((s = o2.return) && s.call(o2), 0) : o2.next) && !(s = s.call(o2, l4[1])).done)
          return s;
        switch (o2 = 0, s && (l4 = [l4[0] & 2, s.value]), l4[0]) {
          case 0:
          case 1:
            s = l4;
            break;
          case 4:
            return n2.label++, { value: l4[1], done: false };
          case 5:
            n2.label++, o2 = l4[1], l4 = [0];
            continue;
          case 7:
            l4 = n2.ops.pop(), n2.trys.pop();
            continue;
          default:
            if (s = n2.trys, !(s = s.length > 0 && s[s.length - 1]) && (l4[0] === 6 || l4[0] === 2)) {
              n2 = 0;
              continue;
            }
            if (l4[0] === 3 && (!s || l4[1] > s[0] && l4[1] < s[3])) {
              n2.label = l4[1];
              break;
            }
            if (l4[0] === 6 && n2.label < s[1]) {
              n2.label = s[1], s = l4;
              break;
            }
            if (s && n2.label < s[2]) {
              n2.label = s[2], n2.ops.push(l4);
              break;
            }
            s[2] && n2.ops.pop(), n2.trys.pop();
            continue;
        }
        l4 = e.call(t, n2);
      } catch (u) {
        l4 = [6, u], o2 = 0;
      } finally {
        r = s = 0;
      }
    if (l4[0] & 5)
      throw l4[1];
    return { value: l4[0] ? l4[1] : void 0, done: true };
  }
}
var E_CANCELED = new Error("request for lock canceled");
var Semaphore = (function() {
  function t(e, n2) {
    n2 === void 0 && (n2 = E_CANCELED), this._value = e, this._cancelError = n2, this._queue = [], this._weightedWaiters = [];
  }
  return t.prototype.acquire = function(e, n2) {
    var r = this;
    if (e === void 0 && (e = 1), n2 === void 0 && (n2 = 0), e <= 0)
      throw new Error("invalid weight ".concat(e, ": must be positive"));
    return new Promise(function(o2, s) {
      var i3 = { resolve: o2, reject: s, weight: e, priority: n2 }, a = findIndexFromEnd(r._queue, function(c2) {
        return n2 <= c2.priority;
      });
      a === -1 && e <= r._value ? r._dispatchItem(i3) : r._queue.splice(a + 1, 0, i3);
    });
  }, t.prototype.runExclusive = function(e) {
    return __awaiter2(this, arguments, void 0, function(n2, r, o2) {
      var s, i3, a;
      return r === void 0 && (r = 1), o2 === void 0 && (o2 = 0), __generator(this, function(c2) {
        switch (c2.label) {
          case 0:
            return [4, this.acquire(r, o2)];
          case 1:
            s = c2.sent(), i3 = s[0], a = s[1], c2.label = 2;
          case 2:
            return c2.trys.push([2, , 4, 5]), [4, n2(i3)];
          case 3:
            return [2, c2.sent()];
          case 4:
            return a(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, t.prototype.waitForUnlock = function(e, n2) {
    var r = this;
    if (e === void 0 && (e = 1), n2 === void 0 && (n2 = 0), e <= 0)
      throw new Error("invalid weight ".concat(e, ": must be positive"));
    return this._couldLockImmediately(e, n2) ? Promise.resolve() : new Promise(function(o2) {
      r._weightedWaiters[e - 1] || (r._weightedWaiters[e - 1] = []), insertSorted(r._weightedWaiters[e - 1], { resolve: o2, priority: n2 });
    });
  }, t.prototype.isLocked = function() {
    return this._value <= 0;
  }, t.prototype.getValue = function() {
    return this._value;
  }, t.prototype.setValue = function(e) {
    this._value = e, this._dispatchQueue();
  }, t.prototype.release = function(e) {
    if (e === void 0 && (e = 1), e <= 0)
      throw new Error("invalid weight ".concat(e, ": must be positive"));
    this._value += e, this._dispatchQueue();
  }, t.prototype.cancel = function() {
    var e = this;
    this._queue.forEach(function(n2) {
      return n2.reject(e._cancelError);
    }), this._queue = [];
  }, t.prototype._dispatchQueue = function() {
    for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value; )
      this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();
  }, t.prototype._dispatchItem = function(e) {
    var n2 = this._value;
    this._value -= e.weight, e.resolve([n2, this._newReleaser(e.weight)]);
  }, t.prototype._newReleaser = function(e) {
    var n2 = this, r = false;
    return function() {
      r || (r = true, n2.release(e));
    };
  }, t.prototype._drainUnlockWaiters = function() {
    if (this._queue.length === 0)
      for (var e = this._value; e > 0; e--) {
        var n2 = this._weightedWaiters[e - 1];
        !n2 || (n2.forEach(function(s) {
          return s.resolve();
        }), this._weightedWaiters[e - 1] = []);
      }
    else
      for (var r = this._queue[0].priority, e = this._value; e > 0; e--) {
        var n2 = this._weightedWaiters[e - 1];
        if (!!n2) {
          var o2 = n2.findIndex(function(a) {
            return a.priority <= r;
          });
          (o2 === -1 ? n2 : n2.splice(0, o2)).forEach(function(a) {
            return a.resolve();
          });
        }
      }
  }, t.prototype._couldLockImmediately = function(e, n2) {
    return (this._queue.length === 0 || this._queue[0].priority < n2) && e <= this._value;
  }, t;
})();
function insertSorted(t, e) {
  var n2 = findIndexFromEnd(t, function(r) {
    return e.priority <= r.priority;
  });
  t.splice(n2 + 1, 0, e);
}
function findIndexFromEnd(t, e) {
  for (var n2 = t.length - 1; n2 >= 0; n2--)
    if (e(t[n2]))
      return n2;
  return -1;
}
var Mutex = (function() {
  function t(e) {
    this._semaphore = new Semaphore(1, e);
  }
  return t.prototype.acquire = function() {
    return __awaiter2(this, arguments, void 0, function(e) {
      var n2, r;
      return e === void 0 && (e = 0), __generator(this, function(o2) {
        switch (o2.label) {
          case 0:
            return [4, this._semaphore.acquire(1, e)];
          case 1:
            return n2 = o2.sent(), r = n2[1], [2, r];
        }
      });
    });
  }, t.prototype.runExclusive = function(e, n2) {
    return n2 === void 0 && (n2 = 0), this._semaphore.runExclusive(function() {
      return e();
    }, 1, n2);
  }, t.prototype.isLocked = function() {
    return this._semaphore.isLocked();
  }, t.prototype.waitForUnlock = function(e) {
    return e === void 0 && (e = 0), this._semaphore.waitForUnlock(1, e);
  }, t.prototype.release = function() {
    this._semaphore.isLocked() && this._semaphore.release();
  }, t.prototype.cancel = function() {
    return this._semaphore.cancel();
  }, t;
})();
function isMetaMaskProvider(t) {
  return t !== null && typeof t == "object" && t.hasOwnProperty("isMetaMask") && t.hasOwnProperty("request");
}
function detectMetaMaskProvider(t, { timeout: e = 3e3 } = {}) {
  let n2 = false;
  return new Promise((r) => {
    const o2 = (s) => {
      const { info: i3, provider: a } = s.detail;
      (i3.rdns === "io.metamask" || i3.rdns === "io.metamask.flask") && isMetaMaskProvider(a) && (r(a), n2 = true);
    };
    typeof t.addEventListener == "function" && t.addEventListener(
      "eip6963:announceProvider",
      o2
    ), setTimeout(() => {
      n2 || r(null);
    }, e), typeof t.dispatchEvent == "function" && t.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
async function waitForMetaMaskProvider(t, e = {}) {
  const { timeout: n2 = 3e3, retries: r = 0 } = e;
  let o2 = null;
  try {
    o2 = await detectMetaMaskProvider(t, { timeout: n2 });
  } catch {
  }
  return o2 || (r === 0 ? null : (o2 = await waitForMetaMaskProvider({ timeout: n2, retries: r - 1 }), o2));
}
async function detectMetamaskSupport(t) {
  return await waitForMetaMaskProvider(t, { retries: 3 });
}
var Q3;
var q4;
var C2;
var G3;
var Y3;
var J3;
var MetaMaskVirtualWallet = class {
  constructor() {
    T4(this, Q3);
    T4(this, C2);
    T4(this, Y3);
    _3(this, "id", "metamask");
    _3(this, "name", "MetaMask");
    _3(this, "icon", "data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4=");
    _3(this, "windowKey", "starknet_metamask");
    _3(this, "provider", null);
    _3(this, "swo", null);
    _3(this, "lock");
    _3(this, "version", "v2.0.0");
    this.lock = new Mutex();
  }
  async loadWallet(e) {
    return await E2(this, C2, G3).call(this, e), this;
  }
  async hasSupport(e) {
    return this.provider = await detectMetamaskSupport(e), this.provider !== null;
  }
  async request(e) {
    return E2(this, C2, G3).call(this).then((n2) => n2.request(
      e
    ));
  }
  on(e, n2) {
    E2(this, C2, G3).call(this).then(
      (r) => r.on(e, n2)
    );
  }
  off(e, n2) {
    E2(this, C2, G3).call(this).then(
      (r) => r.off(e, n2)
    );
  }
};
Q3 = /* @__PURE__ */ new WeakSet(), q4 = async function(e) {
  this.provider || (this.provider = await detectMetamaskSupport(e)), await init({
    name: "MetaMaskStarknetSnapWallet",
    remotes: [
      {
        name: "MetaMaskStarknetSnapWallet",
        alias: "MetaMaskStarknetSnapWallet",
        entry: `https://snaps.consensys.io/starknet/get-starknet/v1/remoteEntry.js?ts=${Date.now()}`
      }
    ]
  });
  const n2 = await loadRemote("MetaMaskStarknetSnapWallet/index");
  if (!n2)
    throw new Error("Failed to load MetaMask Wallet");
  return new n2.MetaMaskSnapWallet(
    this.provider,
    "*"
  );
}, C2 = /* @__PURE__ */ new WeakSet(), G3 = async function(e = window) {
  return this.lock.runExclusive(async () => (this.swo || (this.swo = await E2(this, Q3, q4).call(this, e), E2(this, Y3, J3).call(this)), this.swo));
}, Y3 = /* @__PURE__ */ new WeakSet(), J3 = function() {
  this.swo && (this.version = this.swo.version, this.name = this.swo.name, this.id = this.swo.id, this.icon = this.swo.icon);
};
var metaMaskVirtualWallet = new MetaMaskVirtualWallet();
var X3;
var Z2;
var wallets = [
  {
    id: "argentX",
    name: "Argent X",
    icon: "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/argent-x",
      edge: "https://microsoftedge.microsoft.com/addons/detail/argent-x/ajcicjlkibolbeaaagejfhnofogocgcj"
    }
  },
  {
    id: "braavos",
    name: "Braavos",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc",
      ios: `https://link.braavos.app/dapp/${(X3 = ssrSafeWindow == null ? void 0 : ssrSafeWindow.location) == null ? void 0 : X3.host}`,
      android: `https://link.braavos.app/dapp/${(Z2 = ssrSafeWindow == null ? void 0 : ssrSafeWindow.location) == null ? void 0 : Z2.host}`
    }
  },
  {
    id: metaMaskVirtualWallet.id,
    name: metaMaskVirtualWallet.name,
    icon: metaMaskVirtualWallet.icon,
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/ether-metamask/",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm?hl=en-US"
    }
  },
  {
    id: "okxwallet",
    name: "OKX Wallet",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/mcohilncbfahbmgdjkbpemcciiolgcge",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/okexwallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/%E6%AC%A7%E6%98%93-web3-%E9%92%B1%E5%8C%85/pbpjkcldjiffchgbbndmhojiacbgflha",
      safari: "https://apps.apple.com/us/app/okx-wallet/id6463797825"
    }
  },
  {
    id: "keplr",
    name: "Keplr",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACPfSURBVHgBzV0L0B9VdT9nvy/vB6nVOg4GEx/VER3A1iqo9aMzFgWtoOhgsYaHYNV2lNEqxAdfmKHTakuDTge1FJK2tqOtGqoWFWti8TFSxGDriFSbIK+qgB95h+Tb09397+49r3t3/99/LT0zm//e9917fud3zr27SRB+EbKd1gAcOhFg/kSYmjoBiJ4JhMsB6LHFJetS+wfoAowOQOKnumGVUfSX+23Ba0uRfFaGsh6pNKDqP2PzQN5TbNxqjAeqi2CuWLuvAuU74eT1O+AXIAhDSaX0g+fBFL6ymHShfFhT5RvdknNLzsTIb+cChmzb2OJqJY8aQG9gaAUXaXLbOH0gL4mXmXHC/HYUv1thEWyDk9bPwQAyOQC2H1wHGb29uNtQdLcmFJBv2AsFAPVQJDQPlFBYFACpso7+kFm17g/9sUgr3QFWNI3VtQWO0KaCGXbDBLJwAFSKz2cLjtvglhNFGmr6NomgxEQdT1kYK8N0uzBwH3bosHJo3EKkD1ZG0X6ctAFEW6cAAiwYCAsDwM2HL4e8tHpa45a7NN2UUaxBmFAPmpdt+rGDq0zdrpP2I6yRig06ANHNHuAwjxlzFp67fhOMKeMBoLT6Kby+GHMGmklySVosJAO+ajK9LX6Uxl51eyqZp/tYvVcPbRklynQ7au913aaeBwLRz+6CDU4dhw2yvhVh++EzIcPvBOXXc+SXJz3LMVYeEblOYxKZMx/kF4V70aZPv+q+7ceUmaivHTu0hDSWqzwRWa4rAsTtcOuuM6Gn9APAzYfeVszsM8UAazoVCgDj1DELneqrBgrq/ilyKUFwFE2R8cX8UABD1OmaOx87pkw137gxoP9ssq91xfUZ+Pddl0MP6QbAVwt/Pw+boY+MCQzsquNY6VhCHUoGNeY4fUKjVLR9JdIC8IkxkTrqkerVPsNsHxCk17RUPtFstJw6tE2RfNAPl35Cs7XrSHcGhWPHADBWIJj25XJ8ipbJcUmlZR01Fs+bh0vg+eujBhwHQOnzoaD9pFAi25ZhD2XzPKmHNAAQyC/zHbCelFNGicBPpxP8jZFA0El37xyaHA8oqm8uBGfB89Zv84p8AJTRPuD24m4dpKSLAdhPPGKv8wx4+1l8dO/vtVWL1PvQKMIIxOtFo3VKKy9y4JNmkboflef2N5K5gglO8nYHfgxAhfJHwQQkL9EmXgfHqNcnLkBSwWAPEUFfrG3Xs6k8b+dg66N6RpS7DNMvAp+vwTXrB2Lt7dqugWm4HhyxANhe+P2U5fcBQy0mYh+nntOmL0BcoMREK8vNr8uiCgnKkAEixIO5Zo41IOKKrgPNWFvw1liuVDWHvNi+f/NHs6BErmdJ/Tnugt5Clhl5mVPdUnCkLnMhfVwC8hUz5c69qifm4vYBLrWT285Jq7aUdAOM4ut02ycAkLECilgGb1+1naNcugLJAPPF1iFlid7FxmjH6VO3R99d2zdOwa2k+gNpNVGGcObc5vPRExZvKFwxjahLil1olGf7qd0DgWIXjM+5Hbusg2syxMvVU9RSWv/R/tbvWyUflMZoQ9YwE6vfhxHK1ensy3HC6FlypG56ixZnBDJ1bf/2OwPeU8Qyeh6n5kDrGxZoGSA7CrMiqPEubjFdF5tTnzbGkrkoy+L5HgslGSbyPG4QR85YTp7PABi10sbqTTBIym8T2jnpvsV8EEwQ6EhG8Ha+ZtXHHHjk8M+hr1D7R1TQK1ftumIAtI1Nuo+Vpw+GAHod8rR5qXSqX5mOWzixcpanrIM8RhL9yP6UzM0fLljg1PVzIwY4cujMTovuQBVQD2tnc+zy2ynG6NoGdjJBbO5QWxdoa4aoj9fHwl46jIMBX6Tqt8+j/DwEixcswNsTJNYSwxVkzaIlcF55UwEAc9wwFgA8ZUQnYOt2AcN1b4mybvCh7IN6UH8zLx2ggVcnnY66BqpnxdcILDCaZ3Dn3/RK/nNJAGN7EUy9slkTwBsPeXZhJE3JuoicNn47jJhllwvoVe5RuaJ5Mz7avgCHTZutnBqzy0U0eXblKGIlRuaOHMnXT8ONB2d6Bo+9JeaeTJ2By9pyXslbQ8RRAUU6oI68sdOlpkikkSQIRxoPL4dadmgUSqHzURH5ukaOiqQS1kxPw4nTWfkFL/WDTEr6xR5xBY6v9NGqoFeJEu08BdcrHoDLFr7KQ9np2Glv/EKRSAYoCJQED0GDX2Q5wOYKajAuoW55N5UXAKA8m1mI+jvbUL+6CwGEKFdKQlHDmYRrNWBAgYMzAbZWG5IIZIASGpGTZ+eFdXEPGsf6yZs1wEUnTBeJYzrbmZyOwWgMBRZy7YlL4A1rp2Eh8m8PzsNp39yfrOMqE5i76FK0l1d0+tHjV8Hrj10KQ8h39x2Bk2/5WRisZCQ2HrXKU7GCmKDM6SpCmC9cQA7rus25n3TFEgMNY8U8mErEXIK2UOZvEdK0vvEpKwZT/l2H5uGc2x8S7KDHQzFPaDOC21LlvDCqF1xTmt06sX1JAMk0h8nqDAaICOOgp2BWiB20GZvfZU9bARufuhyGkFL5p9/6INx9KHdezTb7EwfhdQxAKV9LXqaQddOdf3Uu0ndKMIEet58eYIsKBeuIWT7P8sow0UazxGW/unw45R8slP/tB+HHxW87mAoMUbOBmZ4T/Y4h0ykAjSPj+Pxx23aOrQOvUmKgAMdVeaxXBwicJc5duwQ2Pm0Y5T98lODlheXfUyi/sXxyqF9s/2KULgJhgLRPlDKNOSxIJqJ/VGUTMIDxgaQsGsaZq7Q03u7Zx0zDNSesgiGkVP4ZtxSWfyAHHnsYP68WBhNl4NQEVZMzc3M3PZSv71O3nYAecxIXULdHM5Zfry1DVpHS8z5u+RR8/uTOzVJvOffbP4fv7Tka37K2WU5+m9Of+jFxNz3pKeBCqX9S2hd9eXSfGqu1NpTbKrS3xy2fhs+dshqOWTTMjN/63T3w9QcfsSwIvrI9RWOPOn3FBoEdgj0QM57SaTIwELjbz9Y1CDfgLzKKotFN2efaFVPwuResLkDQ/2/QpWTj9/bCP9x9UG4x7UwgrsT+9E88Va0DgbfJmx4jXpAt3WETZThem7HEYYCkwgnc7TLPO2YxwudeOJzy//TO/fDRXQeqIcLcmoHNDE0ZueWx9s7alm8BHYabyAXELDpeFmk3qRsa0wWkqLdRzmdfdMxgyv/AD/bDBwsA8LDDzmYhjFDXEeBN1FUgL2V6nMVfqL+vymI0HWPDvlK6gJx3qG4JBPLdOSj5y+euLKL+KRhCKuXfsb+eQ+phVZlQFgoqT0vsYcnNMjFAWslxIupL8UNbP+/DuoDE+CY+GMm7j18Gr3vSYhhCPvajg/Bn39+/YIvXRI9Obuvr2fOknILGz1guIAkOitdDb2ToZpQ+gqxrFJEPq2OsyVJ++QDvKpT/rmcugyHkE3cdgvfdvq+w/BBUsgFHWzyMW7ws8IHbMoMoGy+oFgzQ2/r1AkdamMlBhDUmdQEx9xJJe2UXP31pBYAh5BsPHIG33bqX+fwI9VcgAIguQKVQC4aktH0mK7V3CwsCo0EXQ2sPl4A0iebNsGYMce9F/rWc8+QlcOVJwxzxfm9uHs7/+sMOKBNb0Ja71cKaJrVyqWMr1rms4el7BoHUL6p3wJqyxDZvoF2ATuvAS4OgzH72L0/Blc8ZxvLv3p/Dq3fMwd4jsfUKGvLjIzU5cpuCH9WS2vz3k+4gMNKZmx1jBow9sGy3YMnB3eM2/jIGwrUrM9j6opWweoBTvlL5Z29/GPYeptbvV2M5oAuTJVtu6tQZ3ikOF17f61MUBul2AWQjUlccJccUjBEqXpDUMYAOsqIgqBf3uJUIn3nJquK0b/K9fqn813zlYbh3/zx7nsaeO/bwVRWKzlvWg3jMYILM2GgouhrvbWDKr8diRHTyqudldDEBA3Dl60+/YiA4rrD8T79k5WDKf+2/KuXrSL2OzsEtr6HClIuReiEvZjYUtf5Yi44YgEwSI/Vic9KBHjpbtElZoF1bh/Kb8Zo6q4sj3utnVlT0P6nsKXz9a7/8MNyzb/RaF1Nb3fYolsRcRb0u6mfZsnM1mhc7RCTxMigR+EWsWhUn66EpmEB4n6RcDFusMvtDL1wOz3rM5Kd8lfJvKix/b171G+iVfV6uwc7+hORxjZ/y2k26hNYFJIIC36ezQxVj3Y5FMCsQljuBYP1dBbbjgutTr3j+MnjpcYtgCLlo+174/oPz7nd8Md9vlOvRvicC1F3BHiWTuotpo8y+lBz17baOuCWHIYaIATzLZ+l3PGcpXHT8EhhC3vn1/fCt+4+MLF8xdgAitidzdcpnBU37VP+BDnNG1lNm9tAea1MwQI/V96iM2j9kFTYzTET/VXpCy9f9mMOeOv8dv7a0AsAQcsUtB+BT/3UYmtM9d0wBCt/3G8OJWQ7PoQ7r9PrukM6DID53t8wJUPSzSLTKv7SZ6r+XlG35OQDJeV307MUVAIaQq79zELb85yFBx9jhkxF4XT5pv36b79I7hngnsRGId2wXeox3AayOg2jZ3qe9NOoXLsiBxeZ52vpFsOmUYU75rr7tYAWACtA84FV/d6/ZiiaftfmXP7hleOuRUmaXtWtdu9ba4xzAt/IIgiMTEqDRwdoA4sUAzyqOeDfPDKf8D912cOTzXcrn/5SL3RLz8wkNDLHArnVTXNkOQHoDopZ+L4NUoOi5q0AK4UmNFXj5zQNOIDoGWLsqg2tftgJWL5mcYq7/j8Pw4VsPyrknAk7sEfwhv0kCo+4PIK3sCbbWvT8KxWYkPQEFDr5Ioh6SzUfmRhYq5ZB5mFep/E+eWZzyrZpc+Z/6wSNw5TcOmICPK5UrQdO8LjfH5R7tq/VzrR57Wjp248EFAEZHBp+2sQuNZA5kmroY67OntBZZXE88plD+WYXyV0+u/HKPf+lX9tf/hg60IBBKM0qH5FYU2bt6Ga+Q7ENXaOqxcUU+RMSNA6TEXYBAIEVHCdbAKK8pY/my7uhmcjXV/RYgXr0U4dozVgym/Ndv2xuOqVvF1kzAx3Zjgjgz+FtVBxie23DcgJOMZzq69oNAdFpRpLhRpqH80BxVQ5zAZxmprf+q314Gxz9u8vP98mj39z69F/YVr3UzV3HsX/5Cct2BOYl0QCHSAO62D2MKj+QDqDFNphX/HIBsD+gkRgMpCxeKl44sgITES5pJdwOXzyyF054y+RHvvXtq5R+i4JoSikT2Sdc4ls/7AkgDw+tL5IsOrIi+HVExgKVx25NUZJXWflDeKP9PJg8mAMDJa6eqa1Iplf+GT+2F+/bkYlGxy7qhiQ9AKCpm+e5a6TYAFgiNLaWAwCcVEV083ee7PI9SxL+pKw291a4J/PjHJej3+2hIpfx/rJWP2u+Dq1hUAPHKYuWectHz95ohmnyAxOt3nQFJSW4DvUFa6zZ5jdhPoMVJnWEFGuxAaCGyp/D1Gz7JLF9t9bjiW4tnrBVYQIqXj2OUJ9Ns/FT9UC+OgvRBkLZstRuwL3sUMJyI37iDR1v5nyiUP1e/0/don8Ac77b1HIYw7Vm5Trf16zw3Jqg7cllAVJaCrJ5fOJL4OUCkN49iWlZwJsb/QUSJ9kS88X8k77nxAPzgJ/PGvyOApG6eX2Y0ZcyHx2IFnQaQykHzKhj6uwMAP45ICgpg9NoGJg9/qP3D+RKHVD0Ir0b5xB8FFii/3r3jf45WZwiefxfWD5D09a2ylQFYJkD/lbhj+bFX596HIcbae4Oh/MeiSwCoC+ehOl4dXaq83raN8qm6qkWkum19VS9F2nqhHa/flj8KAFhVvCfY8rpVcOzqrJpDVs8nq+fE58fvm3q6LMtZ+ypd/8PMObtYm0zUleNnTV7RJiN5NX1lug/TNugCKX6FD0I0XLR/Nwl1IoaqTPh6aJnC97OPAgIKObY4Ov7wq1bCBX8/2vsLyua/nrU7ZdzCOXUbt8AeV7AF4Ni7gSrfNXXGEInlzaqOaut1Lb2x3PaqmYFknbYNYw3OAMgYAdu6MGIEePTk6Y+fgut+d1X15jBlKfwKLIDqitfNTFsYWXRj2YRifQwLGUu2rICCLSRDGJZoruiDardQKT0ovqH7AJYRMCTdw0jBRKG+6P/R3QI2UoLg2nNXVZ+Me/Ru6D8HV+GZqhdLY94oXbqczOmrAUqj6Ky9wKX+Biyesl2AejGAVToJpQsrdhTfx+pFjPD/BARXnb0y6ddDmVQAt9A4CLiF2jqZUlxbt7LuiDUbhTuxQtclqZ7EFVN6UHRQPHDFp6zeAwUsXO64fx6+f/88DCG//qRpmH3FingQSMFydVnMelv3kPt1Mt13zkDCrTfX1uwFh77VZ6kL60geGmW2SrRKh1ZxdX2+EMzqgS2Asfq2HiubgAH2FMHbH358P9z78xyGkFecsBhmf2eFQ//oAEJZsirLcnQZRLKDVbi2+Ma6W4t2ACKAwi8OQkIDnGgMwJXeBnQ0UiJnAREcEsn8PFg9VzaqsknjgPsemofzrt07GAheXoDg8lesgNjauL7U/MYBwxnFA4Z2N0gWSJnDKC1QuILreIFfgrmiMYB4QMkQyJQIudoViLYUKJ9NPjBFzQiTSN3vfQ/lcP6AIDjjxMXwxt9c5isuB0PPoUzuCDKKW73IF+5EKY8snTcMk+UIOr7IHHCaqwEEKL/fXto1kKN4kooP9yRcBOigESQoJpEqfqjHvv/BHC74WHG2PxAI3jizFN744hoE4ARtpC8UytTKDb4bbKDYKLTD/4vtn1Kmr/AI9bcuIMEAMuADq/hcKr5hA7sbgPb8AEw+THwQxK3y/oIJLhwQBBcWILhwZpmlaQDDbD6FB+WiVm4uleqCh7T/t0wQ+mt2DfJswmOFpAuoJj8PMuBzjoa14jkbiLgh4iJaMMEE4ix6yQSX/M0+2Nvvf8PrlAsKEJRXbHdQLS4gWKrnQZhVbuMyLBMEV4COq8hUfCAOkhQr6CNhuwtw6B+aq6Z/swVkwDCgYFRv3EDbnkLw1/Q7gQj3U4995z1H4eKP7B0MBOefurS6hPVQ3OJH1tVY97juAMUOQlpveMfgsgCrZ+g+V+8mmnMA7xI+us3jAJFlwbrDwZBemPZUkEAywaQAaINNuRO5896j8KZr9gwGgvMKAJw3sxQs7aNRBDr5zfsDz2K5xWdkAWb8PmmLtkfBaOo4l97zy32+WlhB7aBiAgpRPXGrp+BCCMwZwKT/VFz7QiaXTNMo6M575+GqGw7AULLht5bC2ScvERQe/LwCgYkDwFV8AIV1IXrHIGMIeXCURRSOFGeF6DeB3jvm8L6awLwbbxO1IpDi79Rrv88/rVqwKOtqxuFf4Hz+lsNV3vvPWQFDyFtOXwb7DxLcdNsjclwIz1jFBM380CsPec1bRPkmEsX3EqFMfQdQj1Gl1bcCqdiqKRt9ENIRhYlPt7gy63RYeFIgYACpG9h8GMAFKCWwqxnjXwoQlD75vQOB4I9evbwa98u3HbEgYArwlOoqGqSSuUq08k1Z8wdZVXaotvx7ARRVgPtRaGPFlYRTPPcLWoKAFNbOWsGEboDCLyI4ChldJRM84ZcyuPC0Yf7W8DvPXl6A6iB8+duP+B+PAgchGoYSytfMIfItSMI9CmPUdUDUtyVj/YcRozIydc1XsvyvSCtAhIVijDCJ/gmES0GS8x39/f2Qvu4Lo7/pe8FAIHjTy5fCrvvmYdf981bxag58vaq/VAJ6DR2GwKBgzRyhTp0v1hE7rb8sN+8C+Nl+CN5U9C+2exBe9DSBIIA5OWy2Z+L7AD7egoVE0Kd3MPyVdpN3/Y0H4fovHoQhZMVShD+5eAU85QlTIZKv14ef3aMO3kgHfF4gh87BUNgpiLMBE+SpMckPDjPgR778DEAp0L4QIrGft9E/2F0EA5moN4FUFuPswVGN1cydg2DLF4YDwR9ftAKe3IIAROQtlQRW+Y1CnQMgpLB70DsFAYhcbTnNhe6VgTr4QXbxMv5CSCyuOCCSdTWrCOXzwyeYQJwxtNXJvADaLQUItt44EAiWIVx5cQCBVnQzPn9LGBSrLdwHiGYC8W0Ce2bzIanaRsqTQHVUKA6EnPyWEbhbiB3wcErWboIrblIhClSfx6xf543qlwD44i2PwBBSguDSDcvgV4pAs6F1CQKb1m8BAzBip4XOsS8HRf1hiKdwvRajgyClcO9wJ5z1M0bglt+Ape2HjJsQ4NBtJwSBfDAC8ckZgXNULK8P/N0++NJAICiVf8XvL69+o0xAMYrW1oxuHXtSKNmAuxOPETgzRF4Hg/kuwGUEQanE3AUYyvfoH5irmESQHMYhAP1No11gaOf7wb/dBzd9azgQbHrzcni8AAE6vtuCI+4KGDu0v5HXx8S/J9Ag0i6gUaa6+CLqKF+k2Y7A+9QLybbnjDGY8sm3LB6feGXBHQB85J/2w3/fM8z3hY8rlH/5m2NM4LgCBxwyKPR3ArZfZweQg/92MHd2AeaNoFIoGAVDS/tim9fSv1YEmLyJ4wBHuT4o1GtrVbb/AMG7rt4zHAgeg/D+N6fdgWUCT9mJdC4BYdmAMYL7QQhJWnQ/BqnuLUBQvDACNx7gfr/px7y9m1AaBRrQUowVKFJGcKAAwaWbhwXBe9/CQeBTsssE0AUGSCievx2044W3gWLhyFI8W9SUu/B//X5MX0NI2SfUDwksluFj1L8tG2hg1HXKFz1Xfmwv/OShHIaQEgTveesyWLlMWXvzbsADI3QEgDCqk0HcDRhXQDYYzbQC2rNzT8kqyPKULH99cBhWmEQobukcCLbMAUEe8n76QA7v+Ys98NMHhwHBYwsQXFaAoDw0atY46grAugV7VuDFDd5BkWQY831g6xdzbalkYwLQ0T65jBC7tCsRY00g2DGmPgrWtN+CEzgQAH5WgOC9m4cDwXHHZnDpHywdgUAoawSKkVVbKpdWa1nD21FkAhTy7IAbo38OIBTmpzllBn9PCTYg8W2gYJIJpH351GHt0IJPPhN/Bg2KBgTvK5jgZwOC4N0tCOxcpc9mbAGS8vl2L27pum/rCvxPwtj+3rNYewIYgjmP8mOAGWQXQBHaB3DB5oOEDGB4+oECBO+/au9gIFhbgOCcVy1ulZUBRIErlaqVz+YLUMcUGJgEAngyVSfUjVI+WMv3joUTlwSBBdEg7wIgNhc+jlIsOCAweSSA8ECh/A9cs6/aJQwhp/zGFJx/7hJB+RiNA/wj5fBMXf4fAWPvBLQFxZSoF9ZjBzfqhyYPJO3za0JxT/rEAkllgqNgrvSYm7jr7nnYVDDBUCA4+XlTsOHcxc6cOX2jejaUVk/xj0hjShduwQv8YoEaZwYc81fcK2VMJFx5RBBnJRJj6zwNertLGN2XILjiz/fCUFKC4DWvXhQUCRbEbkxAUvkcIPotoa3DyooH3u1ZPTp5niLdxQa58CiYILKrmFTacSnQOTgWLhSsqB+00lUf9f2PCxB8dMtwXxqfOjMNp58+zeicWzFjBYi4AbIuhFt9iAVQX7vLfyZubqTRkbDP/UIe+xYJeT7VeaoMdV/8vv58zC1boAhKbC8KH03Vcxt9ikWj7/NI1eV56PTJ84o/bv7GI1X64vOH+V/HGwB88fPzzazDuoJe28AEIVXfI69X35G/xsVT7y6Cw/nbMWL1bcPmXm8RAaJM4ZWjYgnk/S9YSLKO+vXdQqQNYxFxD4xB2P3XChB8/JPDfFBSyssKELz0jGlh8dbaI+cCAGaL6AWGgiHy/OGseKW406VwABsQ6bRSZnpRWT1w6i5QAm0z5bDf0RheGdk0gOMinGdjc/7STYdh22cPw1Dy0tOnAgj0BZHL1LUHQ55rAMId0zngzoyU1slShvnyl6Vj4rkCYBNvZM/+HO776Xy0fUr27a8nQe0foAiwnjuNbuqfoHRFp8hA1bqFhIso/rjhnw9V9y84ZbEaPS6YSD/1aRncRPVXxsjmRz71hzz2J/rz4HmLpvKduG5m15psesmuIr3Gq9Tmad+CctHMwOoX0VlkZGlWnqGth6pepTjeDmsKFG0w5LM8Xcek2X1m8oMSwj3KOl66XYtYHQBQ9SUArLLl3yaSoOe/tsZINl2TYbZ7x/q5Auw7Y9G/jgOi9B6heoz1BX7fyPLRqR/GIvC3dqB2IHo8SrsCfWYAcm7YsQayL5AuVdM58XroUH1sO4c9KV+eBag2O8o5jf5PJMpvcM8DYLSlEucAwO75r8oX5wcQ+gvbNCetFRgBA0/LQyevPjlgIqU4smNqcLC2QnnqXgNDKpqxB0HEv7vKkuWij0h9J1+u7fzWFgB5fmRLkTmnAxyMKMSz+CgLEFtQ3Z/pvwnmNIiYYsAfpwGDzzAeOLwzgcAC4OQZxUMcCEbJntJArrWsLykf1TomlQ8g3IB3wdKpbdAAYOQG8q3tbBxlcaoW9M7y3bYAUQWio0itqFGaAiM5fcrfUE8zhQUPBwaFcfXYoMbQz9z2EQGCkzdqg37dpr+YwgEiSsZ2HVNXcQC0ZXYzzpV12/9mK4fpzRA5yxcW2Ty5dgcgT/hSCtMg8KzaWnejFP4iSS2+AA654IjRLweB159v5WT6cEHi5MVo35ajVTQHQ9sO3efyrnmETc10WgDs3vGE3QUMtoIW9RDIHyhxL3wmB4UBiV3wuHWrcYAilg2tQtH0TfLZmOW3z8jrseqBtkkCBdSCewpI5ZEcW5eDUqqpp0ACrL1mkuJ4ecvsR3B380ziP9qbh/lZ5LEAG7BdDAUE9PIBXEsWymFWaRgF4sxh5iP6CGNxANq5BK0KyoUwL48BWrCQbMfn4wJB5RlWaMvQdRVCycz6gXwlx/sAODIVrL8UAYAiFthdLObVYmYeGNRDg14MDwzk1ImAJSjOWSmlKM/ivb5QK1gwB5m6fLymHJ3n5n256+PVB3BZIZRhWDOSoNd169rmAgDDMDnRJm79AMqgGnnqi+/eXjSYMf9tCWvRDtKkEUUdrMsWknYPfrC2glRdVi+L5MfSmXfAg/WHGTwPMHIwNHrDljoQAq8viNeXOwFO8+weffp39LZ7419l61URuP/X6jQePb/4Ea6glZYOQ3r0GywWDa3ruvIXY1Zt6vboUyccJmiExwg8NhCflEFiTvwZmoS2fgLr35Xlo1fGWFNavQoKHRfguITdeARPBUdcANxRuALK6Hyehx4Q2H0zIVB5DTVDT1Dwh5V9gPXtjrjBHuhFjIHYWg9XgrwnoTTpEqxitSEZZXvP0tZBoVT3eVQ7nl/M9JLLtkjqbyT6vy3/aMdx24jwEr3OGEO/p8iExQswgO3Tt2w2XlUWwKTHG6XJmQdZVmjmq8qE8kDuNjQQBUCbbK1wXYc/k2KF6DMDuFs/DyB15U0b/xq3QUSS/932D29+4uZiDTeBY/3Jew8kGkg8EWMHSPQtWIHMYsu+nc7IB2mUaUi2bccin/lilg9OHjplmkUA4pauJew0aNNl107NQkI6/7/1H35t7SyWINCKid0n8jymAFL5dabew7t9eQN6IHRcDjptkfz+uFW7lqyUjo5yXZ9f5aFsCw6LJIwHI78EdMll16WVX0onAEq5swBBcUpwVtHtbnM6qBYee1ovn2y8rnr6SD+h3BschOLCHC3di04pbX1cXJB6Fh5bm4iSfdqHliF0//XvHOV41sbrpjZDD+kFgFLuvHn9tmxq/tQRCEA+gHgKiitIC7N+jNVXykqCBqQ7kP6QlKJ5G9uXl5e8F2mPUfw2xuJTcwMHyBwQ5SveHE/auCXu87v67yXPeOFds8XG+fK2E2STQp7HPoRo6tS/sX08r8t/Rx9moO3D1BmN2/ccoK0H3pkAqnbe3r9Jh7Lmr3G19I7+fj9jtXg5APoflMTv54qA9+rLtnRTvpbeDMDljq89qQDA/PoCclurjJTlQsQ3R9jBixMMPZtxpBWhx0LuL7kW6QpnmQgbua5Al3fWw7Y8ZZ2BBXDLI4QnLUT5vJ8FyzNmdq3DPJstrOaVxZzX8M/DpNWjYgeInvjpOpmyWvAYAsPiZq61g3P6J63bsoG1/Axi+d5p3uhhsohFC+aA0IanQbSDJrf8imvrPGSbZyP7+74yMQAaKb8tXA5TZxYdbiiumapzAQAIx8WuYiDqBlpqb8vRAoClFwYApSg256BYHwCZUOSkAJC/DAAFzcPO4u6Go5BtKRQ/BwPIYADQ8qyZXTMZZCcW+4UXF6OsyZDWFQ+8DqKKWTgAMhcI4wHAKLatE+wuCoC6LK5cDwCoACbKdxd9FgrGncUrnNtHv9M7h1I6l/8FAVO2ym5DPSIAAAAASUVORK5CYII=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/keplr",
      edge: "https://microsoftedge.microsoft.com/addons/detail/keplr/ocodgmmffbkkeecmadcijjhkmeohinei"
    }
  },
  {
    id: "fordefi",
    name: "Fordefi",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle"
    }
  }
];
var z3;
var j2;
var P2;
var V3;
var ee2;
var k2;
var F4;
var LocalStorageWrapper = class {
  constructor(e) {
    T4(this, V3);
    T4(this, k2);
    T4(this, z3, false);
    T4(this, j2, void 0);
    T4(this, P2, void 0);
    _3(this, "value");
    B4(this, P2, e), E2(this, k2, F4).call(this);
  }
  set(e) {
    return !N3(this, z3) && !E2(this, k2, F4).call(this) ? false : (this.delete(), this.value = e, e && (B4(this, j2, `${N3(this, P2)}-${generateUID()}`), localStorage.setItem(N3(this, j2), e)), true);
  }
  get() {
    return E2(this, V3, ee2).call(this), this.value;
  }
  delete() {
    return !N3(this, z3) && !E2(this, k2, F4).call(this) ? false : (this.value = null, N3(this, j2) && localStorage.removeItem(N3(this, j2)), true);
  }
};
z3 = /* @__PURE__ */ new WeakMap(), j2 = /* @__PURE__ */ new WeakMap(), P2 = /* @__PURE__ */ new WeakMap(), V3 = /* @__PURE__ */ new WeakSet(), ee2 = function() {
  this.value && this.set(this.value);
}, k2 = /* @__PURE__ */ new WeakSet(), F4 = function() {
  try {
    !N3(this, z3) && typeof window < "u" && (B4(this, j2, Object.keys(localStorage).find(
      (e) => e.startsWith(N3(this, P2))
    )), B4(this, z3, true), N3(this, j2) && this.set(localStorage.getItem(N3(this, j2))));
  } catch (e) {
    console.warn(e);
  }
  return N3(this, z3);
};
var Permission = {
  ACCOUNTS: "accounts"
};
function filterBy(t, e) {
  var n2, r;
  if ((n2 = e == null ? void 0 : e.include) != null && n2.length) {
    const o2 = new Set(e.include);
    return t.filter((s) => o2.has(s.id));
  }
  if ((r = e == null ? void 0 : e.exclude) != null && r.length) {
    const o2 = new Set(e.exclude);
    return t.filter((s) => !o2.has(s.id));
  }
  return t;
}
var filterByAuthorized = async (t) => {
  const e = await Promise.all(
    t.map(async (n2) => {
      try {
        return (await n2.request({
          type: "wallet_getPermissions"
        })).includes(Permission.ACCOUNTS);
      } catch {
        return false;
      }
    })
  );
  return t.filter((n2, r) => e[r]);
};
var virtualWalletKeys = ensureKeysArray({
  id: true,
  name: true,
  icon: true,
  windowKey: true,
  loadWallet: true,
  hasSupport: true
});
var fullWalletKeys = ensureKeysArray({
  id: true,
  name: true,
  version: true,
  icon: true,
  request: true,
  on: true,
  off: true
});
function createWalletGuard(t) {
  return function(n2) {
    return n2 !== null && typeof n2 == "object" && t.every((r) => r in n2);
  };
}
var isFullWallet = createWalletGuard(fullWalletKeys);
var isVirtualWallet = createWalletGuard(virtualWalletKeys);
function isWalletObject(t) {
  try {
    return isFullWallet(t) || isVirtualWallet(t);
  } catch {
  }
  return false;
}
function scanObjectForWallets(t, e) {
  return Object.values(
    Object.getOwnPropertyNames(t).reduce((n2, r) => {
      if (r.startsWith("starknet")) {
        const o2 = t[r];
        e(o2) && !n2[o2.id] && (n2[o2.id] = o2);
      }
      return n2;
    }, {})
  );
}
var sortBy = (t, e) => {
  if (e && Array.isArray(e)) {
    t.sort((r, o2) => e.indexOf(r.id) - e.indexOf(o2.id));
    const n2 = t.length - e.length;
    return [
      ...t.slice(n2),
      ...shuffle(t.slice(0, n2))
    ];
  } else
    return shuffle(t);
};
var virtualWallets = [metaMaskVirtualWallet];
function initiateVirtualWallets(t) {
  virtualWallets.forEach(async (e) => {
    e.windowKey in t || await e.hasSupport(t) && (t[e.windowKey] = e);
  });
}
var virtualWalletsMap = {};
async function resolveVirtualWallet(t, e) {
  let n2 = virtualWalletsMap[e.id];
  return n2 || (n2 = await e.loadWallet(t), virtualWalletsMap[e.id] = n2), n2;
}
var defaultOptions = {
  windowObject: ssrSafeWindow != null ? ssrSafeWindow : {},
  isWalletObject,
  storageFactoryImplementation: (t) => new LocalStorageWrapper(t)
};
function getStarknet(t = {}) {
  const { storageFactoryImplementation: e, windowObject: n2, isWalletObject: r } = {
    ...defaultOptions,
    ...t
  }, o2 = e("gsw-last");
  return initiateVirtualWallets(n2), {
    getAvailableWallets: async (s = {}) => {
      const i3 = scanObjectForWallets(
        n2,
        r
      );
      return pipe$1(
        (a) => filterBy(a, s),
        (a) => sortBy(a, s.sort)
      )(i3);
    },
    getAuthorizedWallets: async (s = {}) => {
      const i3 = scanObjectForWallets(
        n2,
        r
      );
      return pipe$1(
        (a) => filterByAuthorized(a),
        (a) => filterBy(a, s),
        (a) => sortBy(a, s.sort)
      )(i3);
    },
    getDiscoveryWallets: async (s = {}) => pipe$1(
      (i3) => filterBy(i3, s),
      (i3) => sortBy(i3, s.sort)
    )(wallets),
    getLastConnectedWallet: async () => {
      const s = o2.get(), a = scanObjectForWallets(n2, r).find(
        (l4) => l4.id === s
      ), [c2] = await filterByAuthorized(
        a ? [a] : []
      );
      return c2 || (o2.delete(), null);
    },
    discoverVirtualWallets: async (s = []) => {
      const i3 = new Set(s), a = i3.size > 0 ? virtualWallets.filter(
        (c2) => i3.has(c2.name) || i3.has(c2.id)
      ) : virtualWallets;
      await Promise.all(
        a.map(async (c2) => {
          await c2.hasSupport(n2) && (n2[c2.windowKey] = c2);
        })
      );
    },
    enable: async (s, i3) => {
      let a;
      if (isVirtualWallet(s))
        a = await resolveVirtualWallet(n2, s);
      else if (isFullWallet(s))
        a = s;
      else
        throw new Error("Invalid wallet object");
      await a.request({
        type: "wallet_requestAccounts",
        params: {
          silent_mode: i3 == null ? void 0 : i3.silent_mode
        }
      });
      const c2 = await a.request({
        type: "wallet_getPermissions"
      });
      if (!(c2 != null && c2.includes(Permission.ACCOUNTS)))
        throw new Error("Failed to connect to wallet");
      return o2.set(a.id), a;
    },
    disconnect: async ({ clearLastWallet: s } = {}) => {
      s && o2.delete();
    }
  };
}
var main2 = getStarknet();

// node_modules/@starknet-io/types-js/dist/esm/wallet-api/index.js
var wallet_api_exports = {};
__export(wallet_api_exports, {
  Permission: () => Permission2,
  TypedDataRevision: () => TypedDataRevision
});

// node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js
var Permission2 = {
  ACCOUNTS: "accounts"
};

// node_modules/@starknet-io/types-js/dist/esm/wallet-api/typedData.js
var TypedDataRevision = {
  ACTIVE: "1",
  LEGACY: "0"
};

// node_modules/@dynamic-labs/starknet/src/wallets/injected/injected.js
var Injected = class extends StarknetWalletConnector {
  constructor(name2, id, key, props) {
    super(name2, id, key, props);
  }
  prompt(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const wallet = this.getWindowWallet();
      if (!wallet) {
        throw new DynamicError("No wallet available to send RPC requests to");
      }
      this.logger.debug("[prompt] Sending wallet_requestAccounts with silent_mode:", options.silently);
      const accounts = yield wallet.request({
        params: {
          silent_mode: options.silently
        },
        type: "wallet_requestAccounts"
      });
      this.logger.debug("[prompt] Received from wallet_requestAccounts:", accounts);
      if (accounts.length === 0) {
        return {
          data: {
            account: void 0,
            chainId: void 0
          },
          wallet
        };
      }
      const [account] = accounts;
      this.logger.debug("[prompt] Sending wallet_requestChaindId");
      const chainId = yield wallet.request({
        type: "wallet_requestChainId"
      });
      this.logger.debug("[prompt] Received from wallet_requestChainId:", chainId);
      return {
        data: {
          account,
          chainId: BigInt(chainId)
        },
        wallet
      };
    });
  }
  getAddress() {
    const _super = Object.create(null, {
      getAddress: { get: () => super.getAddress }
    });
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      if (this.isInstalledOnBrowser()) {
        return _super.getAddress.call(this);
      }
      const inAppBrowserBase = (_a2 = this.walletBookWallet.mobile) === null || _a2 === void 0 ? void 0 : _a2.inAppBrowser;
      if (!inAppBrowserBase || !isMobile()) {
        return void 0;
      }
      const inAppBrowserTemplate = template(inAppBrowserBase);
      const deepLink = inAppBrowserTemplate({
        // TODO: use PlatformService
        encodedDappURI: window.location.toString().replace(/http(s)?:\/\//, "")
      });
      PlatformService.openURL(deepLink);
      return void 0;
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      if ((_a2 = this.walletData) === null || _a2 === void 0 ? void 0 : _a2.account) {
        this.logger.debug("[getConnectedAccounts] Found existing account:", this.walletData.account);
        return [this.walletData.account];
      }
      const wallet = this.getWindowWallet();
      if (!wallet) {
        return [];
      }
      const silently = yield this.shouldPromptSilently(wallet);
      let data2;
      this.logger.debug("[getConnectedAccounts] No existing account, attempting to connect with silent mode:", silently);
      try {
        ({ data: data2 } = yield this.prompt({
          silently
        }));
      } catch (error2) {
        this.logger.debug(`[getConnectedAccounts] Silent connect errored out: ${error2}`);
        return [];
      }
      this.logger.debug(`[getConnectedAccounts] Connect returned account: ${data2 === null || data2 === void 0 ? void 0 : data2.account}`);
      if (!(data2 === null || data2 === void 0 ? void 0 : data2.account)) {
        return [];
      }
      this.walletData = data2;
      this.wallet = wallet;
      this.setupEventListeners();
      return [data2.account];
    });
  }
  shouldPromptSilently(wallet) {
    return __awaiter(this, void 0, void 0, function* () {
      let silently = true;
      try {
        const permissions = yield wallet.request({
          type: "wallet_getPermissions"
        });
        if (permissions.includes(wallet_api_exports.Permission.ACCOUNTS)) {
          this.logger.debug("[getConnectedAccounts] Received `accounts` permission from wallet_getPermissions");
          silently = false;
        }
      } catch (error2) {
        this.logger.debug("[getConnectedAccounts] `wallet_getPermissions` threw error:", error2);
      }
      return silently;
    });
  }
  getWindowWallet() {
    this.logger.debug("[getWindowWallet] Looking for wallet from window:", this.id);
    const wallet = window[`starknet_${this.id}`];
    this.logger.debug("[getWindowWallet] Lookup result:", wallet);
    return wallet;
  }
};

// node_modules/@dynamic-labs/starknet/src/wallets/injected/metamask.js
var logger2 = new Logger("MetaMask Starknet Snap", LogLevel.INFO);
var MetaMask = class extends Injected {
  constructor(opts) {
    super("MetaMask Starknet", "metamask", "metamaskstarknet", opts);
    this.overrideKey = "metamaskstarknet";
    main2.discoverVirtualWallets().then(() => {
      main2.getAvailableWallets().then((wallets2) => {
        const metaMaskProvider = wallets2.find((wallet) => wallet.id === "metamask");
        if (metaMaskProvider) {
          this.provider = metaMaskProvider.provider;
        }
      });
    });
  }
  getNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.provider) {
        logger2.error("[getNetwork] - No provider found, returning undefined");
        return void 0;
      }
      try {
        logger2.info("[getNetwork] - trying to fetch network using provider");
        const result = yield this.provider.request({
          method: "wallet_invokeSnap",
          params: {
            request: {
              method: "starkNet_getCurrentNetwork",
              params: {}
            },
            snapId: "npm:@consensys/starknet-snap"
          }
        });
        if (!("chainId" in result) || typeof result.chainId !== "string") {
          logger2.error(`[getNetwork] - result.chainId should be a string, but got: ${// eslint-disable-next-line @typescript-eslint/no-explicit-any
          result.chainId}`);
          return void 0;
        }
        if (result.chainId !== this.currentChainId) {
          const resultChainName = this.mapChainIdToNetworkName(result.chainId);
          const currentChainName = this.currentChainId ? this.mapChainIdToNetworkName(this.currentChainId) : void 0;
          logger2.info(`[getNetwork] - emitting chainChange event. got chainId: ${result.chainId} (${resultChainName}). current chainId: ${this.currentChainId} (${currentChainName})`);
          this.emit("chainChange", { chain: result.chainId });
        }
        this.currentChainId = result.chainId;
        return this.currentChainId;
      } catch (e) {
        logger2.error("[getNetwork] - network fetch request failed, returning undefined", e);
        return void 0;
      }
    });
  }
  setupEventListeners() {
    if (this.intervalId) {
      return;
    }
    this.intervalId = setInterval(() => {
      this.getNetwork().then((chainId) => {
        if (!chainId) {
          return;
        }
        const resultChainName = this.mapChainIdToNetworkName(chainId);
        const currentChainName = this.currentChainId ? this.mapChainIdToNetworkName(this.currentChainId) : void 0;
        logger2.info(`[setupEventListeners] - got network: ${chainId} (${resultChainName}). current network: ${this.currentChainId} (${currentChainName})`);
        if (chainId !== this.currentChainId) {
          logger2.info(`[setupEventListeners] - emitting chainChange event: ${chainId}`);
          this.emit("chainChange", { chain: chainId });
          this.currentChainId = chainId;
        }
      });
    }, 5e3);
  }
  teardownEventListeners() {
    return __awaiter(this, void 0, void 0, function* () {
      clearInterval(this.intervalId);
      this.intervalId = void 0;
    });
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      this.teardownEventListeners();
    });
  }
};

// node_modules/@dynamic-labs/starknet/src/wallets/injected/fetchStarknetInjectedWalletConnectors.js
var filteredStarknetWalletKeysOverrides = [
  // TODO(starknet-v6): Remove once these wallets support v6
  "bitgetstarknet",
  // Braavos has its own connector to implement specific logic
  "braavos"
];
var fetchStarknetInjectedWalletConnectors = ({ walletBook }) => {
  var _a2;
  return Object.entries((_a2 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a2 !== void 0 ? _a2 : {}).filter(([key, wallet]) => {
    var _a3;
    return ((_a3 = wallet.injectedConfig) === null || _a3 === void 0 ? void 0 : _a3.find((config) => config.chain === "starknet")) && !filteredStarknetWalletKeysOverrides.includes(key);
  }).map(([key, wallet]) => {
    var _a3, _b, _c;
    const name2 = wallet.shortName || wallet.name;
    const walletConnectorFallback = Boolean(wallet.walletConnect);
    const id = (_c = (_b = (_a3 = wallet.injectedConfig) === null || _a3 === void 0 ? void 0 : _a3[0].windowLocations) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : key;
    return class extends Injected {
      constructor(props) {
        super(name2, id, key, Object.assign({ name: name2, overrideKey: key, walletBookWallet: wallet, walletConnectorFallback }, props));
      }
    };
  });
};

// node_modules/@dynamic-labs/starknet/src/wallets/injected/braavos.js
var Braavos = class extends Injected {
  constructor(opts) {
    super("Braavos", "braavos", "braavos", opts);
    this.overrideKey = "braavos";
  }
  /**
   * Adds a timeout for getConnectedAccounts request to prevent
   * the SDK from becoming unresponsive when Braavos is locked and does not prompt
   * the user to unlock
   * If getConnectedAccounts() doesn't resolve within 3 seconds, the operation
   * will timeout and return an empty array.
   */
  getConnectedAccounts() {
    return retryableFn(() => super.getConnectedAccounts(), {
      fallbackValue: [],
      maxRetries: 0,
      retryStrategy: "timeout-only",
      timeoutMs: 3e3
    });
  }
};

// node_modules/@dynamic-labs/starknet-core/package.js
var version2 = "4.26.0";

// node_modules/@dynamic-labs/starknet-core/src/index.js
assertPackageVersion("@dynamic-labs/starknet-core", version2);
ChainRpcProviders.getStarknetRpcProviderByChainId = (config, chainId) => {
  var _a2;
  const rpcProviders = ChainRpcProviders.getProviders(config);
  const provider = (_a2 = rpcProviders["starknet"]) === null || _a2 === void 0 ? void 0 : _a2.find((rpcProvider) => rpcProvider.chainId === chainId);
  return provider;
};
ChainRpcProviders.registerStarknetProviders = () => {
  ChainRpcProviders.registerChainProviders(ProviderChain.STARKNET, (config) => {
    const rpcProviders = {};
    if (config === null || config === void 0 ? void 0 : config.starknet) {
      const networks = config.starknet;
      rpcProviders.starknet = ChainRpcProviders.createProviderFromConfig(networks);
    }
    return rpcProviders.starknet;
  });
};
ChainRpcProviders.createProviderFromConfig = (networks) => networks.map((network) => {
  var _a2;
  const rpcUrl = ((_a2 = network.privateCustomerRpcUrls) === null || _a2 === void 0 ? void 0 : _a2[0]) || network.rpcUrls[0];
  const provider = new RpcProvider2({ nodeUrl: rpcUrl });
  return {
    chainId: network.chainId.toString(),
    chainName: network.name,
    provider
  };
});

// node_modules/@dynamic-labs/starknet/src/wallet/isStarknetWallet/isStarknetWallet.js
var isStarknetWallet = (wallet) => wallet.chain === "STARK";

// node_modules/@dynamic-labs/starknet/src/index.js
assertPackageVersion("@dynamic-labs/starknet", version);
var StarknetWalletConnectors = (props) => [
  ...fetchStarknetInjectedWalletConnectors(props),
  ArgentX,
  ArgentMobile,
  WebWallet,
  MetaMask,
  Braavos
];
export {
  Injected as StarknetInjectedConnector,
  StarknetWallet,
  StarknetWalletConnector,
  StarknetWalletConnectors,
  isStarknetWallet
};
/*! Bundled license information:

starknetkit/dist/index-8edbd361.js:
  (* istanbul ignore if -- @preserve *)
  (* istanbul ignore next -- @preserve *)

starknetkit/dist/starknetkit.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=@dynamic-labs_starknet.js.map
