"use client";
import {
  A,
  C,
  E,
  IEvents,
  Po,
  Qe,
  Qo,
  bases,
  detect,
  f,
  f2,
  h,
  i,
  import_pino,
  k,
  o,
  r,
  require_cjs,
  safeJsonParse,
  safeJsonStringify,
  sn,
  y
} from "./chunk-7LDNJXG6.js";
import {
  BaseError as BaseError4,
  LruMap as LruMap3,
  concat as concat3,
  defineFormatter as defineFormatter3,
  from as from3,
  fromBoolean as fromBoolean3,
  fromBytes as fromBytes3,
  fromNumber as fromNumber3,
  fromString as fromString5,
  fromString2 as fromString6,
  hexToNumber as hexToNumber4,
  numberToHex as numberToHex3,
  padLeft as padLeft3,
  padRight as padRight3,
  size as size4
} from "./chunk-JLWIU2JG.js";
import "./chunk-NLVDELCC.js";
import {
  BaseError as BaseError2,
  LruMap,
  concat,
  defineFormatter,
  from,
  fromBoolean,
  fromBytes,
  fromNumber,
  fromString,
  fromString2,
  hexToNumber as hexToNumber2,
  numberToHex,
  padLeft,
  padRight,
  size
} from "./chunk-AEIXCMMU.js";
import "./chunk-7UPZ3VNB.js";
import {
  BaseError as BaseError3,
  LruMap as LruMap2,
  checksumAddress,
  concat as concat2,
  defineFormatter as defineFormatter2,
  from as from2,
  fromBoolean as fromBoolean2,
  fromBytes as fromBytes2,
  fromNumber as fromNumber2,
  fromString as fromString3,
  fromString2 as fromString4,
  hexToBigInt,
  hexToNumber as hexToNumber3,
  isHex as isHex2,
  keccak256,
  numberToHex as numberToHex2,
  padLeft as padLeft2,
  padRight as padRight2,
  size as size2,
  size2 as size3,
  toHex as toHex2
} from "./chunk-TMJKLRZE.js";
import "./chunk-SLBBKXV3.js";
import {
  EthereumWallet,
  EthereumWalletConnector,
  ViemUiTransaction,
  chainsMap,
  createConnector,
  createViemUiTransaction,
  createWalletClientWithUiConfirmation,
  getOrMapViemChain,
  isEthereumWallet,
  normalizeRpcError,
  toAccount
} from "./chunk-OLQ7JTI2.js";
import "./chunk-7QD6I5VC.js";
import {
  createWalletClient,
  custom,
  hashAuthorization,
  hashMessage,
  hashTypedData,
  http,
  parseSignature,
  serializeSignature
} from "./chunk-2GMVM6OQ.js";
import "./chunk-QBLAU726.js";
import {
  erc20Abi,
  isAddressEqual
} from "./chunk-DCMJYQTG.js";
import {
  serializeTransaction
} from "./chunk-AMQQR5YV.js";
import {
  BaseError,
  formatEther,
  getAddress,
  hexToNumber,
  isAddress,
  isHex,
  toBytes,
  toHex
} from "./chunk-LT6CZIRE.js";
import {
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  payloadId
} from "./chunk-T6AHRGBG.js";
import {
  require_u64,
  require_utils
} from "./chunk-YMTSYZVI.js";
import {
  require_events
} from "./chunk-2YULO2GZ.js";
import {
  ApiKeyStamper,
  IframeStamper,
  TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS,
  TurnkeyActivityConsensusNeededError,
  TurnkeyActivityError,
  TurnkeyClient,
  TurnkeyWalletConnectorBase,
  TurnkeyWalletConnectorInfo,
  WebauthnStamper,
  assertActivityCompleted,
  assertNonNull,
  findTurnkeyVerifiedCredentialsWithSmartWalletRef,
  logger as logger2
} from "./chunk-EIQVUX5X.js";
import "./chunk-HVT2ELN7.js";
import "./chunk-SZETIQFQ.js";
import "./chunk-GX5ZUNPE.js";
import "./chunk-6K54Z4X6.js";
import "./chunk-N6237SYY.js";
import {
  sha256
} from "./chunk-LVMHB5EJ.js";
import {
  keccak_256
} from "./chunk-7GOJWEZH.js";
import "./chunk-4IDULAJH.js";
import "./chunk-OK6ZKALG.js";
import "./chunk-ZTXWSXNR.js";
import "./chunk-CLTFP3BU.js";
import {
  base32
} from "./chunk-YWDJ7V5D.js";
import {
  WaasExportHandler,
  withDynamicWaas
} from "./chunk-LJCLW4HL.js";
import "./chunk-R5R4E5YD.js";
import {
  bytesToHex
} from "./chunk-D6PPKFIJ.js";
import {
  DynamicError,
  Eip6963ProviderSingleton,
  ErrorCode,
  GetAddressCancelledError,
  Logger,
  MFAAction,
  MetaMaskError,
  PlatformEventsService,
  PlatformService,
  ProviderLookup,
  StorageService,
  assertPackageVersion,
  createEventTimeline,
  eventListenerHandlers,
  findWalletBookWallet,
  getDeepLink,
  getProvidersFromWindow,
  getRpcUrlForChain,
  handleMobileWalletRedirect,
  isMobile,
  isSameAddress,
  listenToEip6963Events,
  logger,
  parseEvmNetworks,
  parseIntSafe,
  performPlatformSpecificConnectionMethod,
  require_buffer,
  retryableFn,
  sanitizeName,
  template,
  walletConnectorEvents
} from "./chunk-3OCKXW2Z.js";
import {
  import_index
} from "./chunk-7KMCIXGS.js";
import "./chunk-ASWLBWKD.js";
import {
  __commonJS,
  __export,
  __glob,
  __require,
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name) {
      const res = getFromWindow(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow;
    function getLocation2() {
      return getFromWindow("location");
    }
    exports.getLocation = getLocation2;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e9) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i6 = 0; i6 < links.length; i6++) {
          const link = links[i6];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i6 = 0; i6 < metaTags.length; i6++) {
          const tag = metaTags[i6];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url2 = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url: url2,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/blakejs/util.js
var require_util = __commonJS({
  "node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex8(bytes) {
      return Array.prototype.map.call(bytes, function(n4) {
        return (n4 < 16 ? "0" : "") + n4.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size10) {
      let msg = "\n" + label + " = ";
      for (let i6 = 0; i6 < arr.length; i6 += 2) {
        if (size10 === 32) {
          msg += uint32ToHex(arr[i6]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i6 + 1]).toUpperCase();
        } else if (size10 === 64) {
          msg += uint32ToHex(arr[i6 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i6]).toUpperCase();
        } else throw new Error("Invalid size " + size10);
        if (i6 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i6 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N8, M7) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N8);
      for (let i6 = 0; i6 < N8; i6++) {
        input[i6] = i6 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i6 = 0; i6 < M7; i6++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms3 = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms3 + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N8 / (1 << 20) / (ms3 / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex: toHex8,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v8, a4, b5) {
      const o0 = v8[a4] + v8[b5];
      let o1 = v8[a4 + 1] + v8[b5 + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v8[a4] = o0;
      v8[a4 + 1] = o1;
    }
    function ADD64AC(v8, a4, b0, b1) {
      let o0 = v8[a4] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v8[a4 + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v8[a4] = o0;
      v8[a4 + 1] = o1;
    }
    function B2B_GET32(arr, i6) {
      return arr[i6] ^ arr[i6 + 1] << 8 ^ arr[i6 + 2] << 16 ^ arr[i6 + 3] << 24;
    }
    function B2B_G(a4, b5, c6, d5, ix, iy) {
      const x0 = m5[ix];
      const x1 = m5[ix + 1];
      const y0 = m5[iy];
      const y1 = m5[iy + 1];
      ADD64AA(v7, a4, b5);
      ADD64AC(v7, a4, x0, x1);
      let xor0 = v7[d5] ^ v7[a4];
      let xor1 = v7[d5 + 1] ^ v7[a4 + 1];
      v7[d5] = xor1;
      v7[d5 + 1] = xor0;
      ADD64AA(v7, c6, d5);
      xor0 = v7[b5] ^ v7[c6];
      xor1 = v7[b5 + 1] ^ v7[c6 + 1];
      v7[b5] = xor0 >>> 24 ^ xor1 << 8;
      v7[b5 + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v7, a4, b5);
      ADD64AC(v7, a4, y0, y1);
      xor0 = v7[d5] ^ v7[a4];
      xor1 = v7[d5 + 1] ^ v7[a4 + 1];
      v7[d5] = xor0 >>> 16 ^ xor1 << 16;
      v7[d5 + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v7, c6, d5);
      xor0 = v7[b5] ^ v7[c6];
      xor1 = v7[b5 + 1] ^ v7[c6 + 1];
      v7[b5] = xor1 >>> 31 ^ xor0 << 1;
      v7[b5 + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x5) {
        return x5 * 2;
      })
    );
    var v7 = new Uint32Array(32);
    var m5 = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i6 = 0;
      for (i6 = 0; i6 < 16; i6++) {
        v7[i6] = ctx.h[i6];
        v7[i6 + 16] = BLAKE2B_IV32[i6];
      }
      v7[24] = v7[24] ^ ctx.t;
      v7[25] = v7[25] ^ ctx.t / 4294967296;
      if (last) {
        v7[28] = ~v7[28];
        v7[29] = ~v7[29];
      }
      for (i6 = 0; i6 < 32; i6++) {
        m5[i6] = B2B_GET32(ctx.b, 4 * i6);
      }
      for (i6 = 0; i6 < 12; i6++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i6 * 16 + 0], SIGMA82[i6 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i6 * 16 + 2], SIGMA82[i6 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i6 * 16 + 4], SIGMA82[i6 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i6 * 16 + 6], SIGMA82[i6 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i6 * 16 + 8], SIGMA82[i6 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i6 * 16 + 10], SIGMA82[i6 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i6 * 16 + 12], SIGMA82[i6 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i6 * 16 + 14], SIGMA82[i6 * 16 + 15]);
      }
      for (i6 = 0; i6 < 16; i6++) {
        ctx.h[i6] = ctx.h[i6] ^ v7[i6] ^ v7[i6 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i6 = 0; i6 < 16; i6++) {
        ctx.h[i6] = BLAKE2B_IV32[i6] ^ B2B_GET32(parameterBlock, i6 * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i6 = 0; i6 < input.length; i6++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i6];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i6 = 0; i6 < ctx.outlen; i6++) {
        out[i6] = ctx.h[i6 >> 2] >> 8 * (i6 & 3);
      }
      return out;
    }
    function blake2b(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module.exports = {
      blake2b,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v8, i6) {
      return v8[i6] ^ v8[i6 + 1] << 8 ^ v8[i6 + 2] << 16 ^ v8[i6 + 3] << 24;
    }
    function B2S_G(a4, b5, c6, d5, x5, y8) {
      v7[a4] = v7[a4] + v7[b5] + x5;
      v7[d5] = ROTR32(v7[d5] ^ v7[a4], 16);
      v7[c6] = v7[c6] + v7[d5];
      v7[b5] = ROTR32(v7[b5] ^ v7[c6], 12);
      v7[a4] = v7[a4] + v7[b5] + y8;
      v7[d5] = ROTR32(v7[d5] ^ v7[a4], 8);
      v7[c6] = v7[c6] + v7[d5];
      v7[b5] = ROTR32(v7[b5] ^ v7[c6], 7);
    }
    function ROTR32(x5, y8) {
      return x5 >>> y8 ^ x5 << 32 - y8;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v7 = new Uint32Array(16);
    var m5 = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i6 = 0;
      for (i6 = 0; i6 < 8; i6++) {
        v7[i6] = ctx.h[i6];
        v7[i6 + 8] = BLAKE2S_IV[i6];
      }
      v7[12] ^= ctx.t;
      v7[13] ^= ctx.t / 4294967296;
      if (last) {
        v7[14] = ~v7[14];
      }
      for (i6 = 0; i6 < 16; i6++) {
        m5[i6] = B2S_GET32(ctx.b, 4 * i6);
      }
      for (i6 = 0; i6 < 10; i6++) {
        B2S_G(0, 4, 8, 12, m5[SIGMA[i6 * 16 + 0]], m5[SIGMA[i6 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m5[SIGMA[i6 * 16 + 2]], m5[SIGMA[i6 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m5[SIGMA[i6 * 16 + 4]], m5[SIGMA[i6 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m5[SIGMA[i6 * 16 + 6]], m5[SIGMA[i6 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m5[SIGMA[i6 * 16 + 8]], m5[SIGMA[i6 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m5[SIGMA[i6 * 16 + 10]], m5[SIGMA[i6 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m5[SIGMA[i6 * 16 + 12]], m5[SIGMA[i6 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m5[SIGMA[i6 * 16 + 14]], m5[SIGMA[i6 * 16 + 15]]);
      }
      for (i6 = 0; i6 < 8; i6++) {
        ctx.h[i6] ^= v7[i6] ^ v7[i6 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i6 = 0; i6 < input.length; i6++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i6];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i6 = 0; i6 < ctx.outlen; i6++) {
        out[i6] = ctx.h[i6 >> 2] >> 8 * (i6 & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s(input, key, outlen);
      return util.toHex(output);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name) {
      const res = getFromWindow(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow;
    function getLocation2() {
      return getFromWindow("location");
    }
    exports.getLocation = getLocation2;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs4();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e9) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i6 = 0; i6 < links.length; i6++) {
          const link = links[i6];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i6 = 0; i6 < metaTags.length; i6++) {
          const tag = metaTags[i6];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url2 = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url: url2,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name) {
      const res = getFromWindow(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow;
    function getLocation2() {
      return getFromWindow("location");
    }
    exports.getLocation = getLocation2;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs6();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e9) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i6 = 0; i6 < links.length; i6++) {
          const link = links[i6];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i6 = 0; i6 < metaTags.length; i6++) {
          const tag = metaTags[i6];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url2 = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url: url2,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
    exports.keccakP = keccakP;
    var _u64_ts_1 = require_u64();
    var utils_ts_1 = require_utils();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    for (let round = 0, R6 = _1n, x5 = 1, y8 = 0; round < 24; round++) {
      [x5, y8] = [y8, (2 * x5 + 3 * y8) % 5];
      SHA3_PI.push(2 * (5 * y8 + x5));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t4 = _0n;
      for (let j6 = 0; j6 < 7; j6++) {
        R6 = (R6 << _1n ^ (R6 >> _7n) * _0x71n) % _256n;
        if (R6 & _2n)
          t4 ^= _1n << (_1n << BigInt(j6)) - _1n;
      }
      _SHA3_IOTA.push(t4);
    }
    var IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
    var SHA3_IOTA_H = IOTAS[0];
    var SHA3_IOTA_L = IOTAS[1];
    var rotlH = (h7, l6, s3) => s3 > 32 ? (0, _u64_ts_1.rotlBH)(h7, l6, s3) : (0, _u64_ts_1.rotlSH)(h7, l6, s3);
    var rotlL = (h7, l6, s3) => s3 > 32 ? (0, _u64_ts_1.rotlBL)(h7, l6, s3) : (0, _u64_ts_1.rotlSL)(h7, l6, s3);
    function keccakP(s3, rounds = 24) {
      const B7 = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x5 = 0; x5 < 10; x5++)
          B7[x5] = s3[x5] ^ s3[x5 + 10] ^ s3[x5 + 20] ^ s3[x5 + 30] ^ s3[x5 + 40];
        for (let x5 = 0; x5 < 10; x5 += 2) {
          const idx1 = (x5 + 8) % 10;
          const idx0 = (x5 + 2) % 10;
          const B0 = B7[idx0];
          const B1 = B7[idx0 + 1];
          const Th2 = rotlH(B0, B1, 1) ^ B7[idx1];
          const Tl2 = rotlL(B0, B1, 1) ^ B7[idx1 + 1];
          for (let y8 = 0; y8 < 50; y8 += 10) {
            s3[x5 + y8] ^= Th2;
            s3[x5 + y8 + 1] ^= Tl2;
          }
        }
        let curH = s3[2];
        let curL = s3[3];
        for (let t4 = 0; t4 < 24; t4++) {
          const shift = SHA3_ROTL[t4];
          const Th2 = rotlH(curH, curL, shift);
          const Tl2 = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t4];
          curH = s3[PI];
          curL = s3[PI + 1];
          s3[PI] = Th2;
          s3[PI + 1] = Tl2;
        }
        for (let y8 = 0; y8 < 50; y8 += 10) {
          for (let x5 = 0; x5 < 10; x5++)
            B7[x5] = s3[y8 + x5];
          for (let x5 = 0; x5 < 10; x5++)
            s3[y8 + x5] ^= ~B7[(x5 + 2) % 10] & B7[(x5 + 4) % 10];
        }
        s3[0] ^= SHA3_IOTA_H[round];
        s3[1] ^= SHA3_IOTA_L[round];
      }
      (0, utils_ts_1.clean)(B7);
    }
    var Keccak = class _Keccak extends utils_ts_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        (0, utils_ts_1.anumber)(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i6 = 0; i6 < take; i6++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
      }
      _cloneInto(to6) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to6 || (to6 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to6.state32.set(this.state32);
        to6.pos = this.pos;
        to6.posOut = this.posOut;
        to6.finished = this.finished;
        to6.rounds = rounds;
        to6.suffix = suffix;
        to6.outputLen = outputLen;
        to6.enableXOF = enableXOF;
        to6.destroyed = this.destroyed;
        return to6;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = (() => gen(6, 144, 224 / 8))();
    exports.sha3_256 = (() => gen(6, 136, 256 / 8))();
    exports.sha3_384 = (() => gen(6, 104, 384 / 8))();
    exports.sha3_512 = (() => gen(6, 72, 512 / 8))();
    exports.keccak_224 = (() => gen(1, 144, 224 / 8))();
    exports.keccak_256 = (() => gen(1, 136, 256 / 8))();
    exports.keccak_384 = (() => gen(1, 104, 384 / 8))();
    exports.keccak_512 = (() => gen(1, 72, 512 / 8))();
    var genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = (() => genShake(31, 168, 128 / 8))();
    exports.shake256 = (() => genShake(31, 136, 256 / 8))();
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs
var require_util2 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs"(exports, module) {
    var { keccak_256: keccak_2562 } = require_sha3();
    function zeros(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    }
    function bitLengthFromBigInt(num) {
      return num.toString(2).length;
    }
    function bufferBEFromBigInt(num, length) {
      let hex = num.toString(16);
      if (hex.length % 2 !== 0) hex = "0" + hex;
      const byteArray = hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16));
      while (byteArray.length < length) {
        byteArray.unshift(0);
      }
      return Buffer.from(byteArray);
    }
    function twosFromBigInt(value2, width) {
      const isNegative = value2 < 0n;
      let result;
      if (isNegative) {
        const mask = (1n << BigInt(width)) - 1n;
        result = (~value2 & mask) + 1n;
      } else {
        result = value2;
      }
      result &= (1n << BigInt(width)) - 1n;
      return result;
    }
    function setLength(msg, length, right) {
      const buf = zeros(length);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer(v7) {
      if (!Buffer.isBuffer(v7)) {
        if (Array.isArray(v7)) {
          v7 = Buffer.from(v7);
        } else if (typeof v7 === "string") {
          if (isHexString2(v7)) {
            v7 = Buffer.from(padToEven(stripHexPrefix(v7)), "hex");
          } else {
            v7 = Buffer.from(v7);
          }
        } else if (typeof v7 === "number") {
          v7 = intToBuffer(v7);
        } else if (v7 === null || v7 === void 0) {
          v7 = Buffer.allocUnsafe(0);
        } else if (typeof v7 === "bigint") {
          v7 = bufferBEFromBigInt(v7);
        } else if (v7.toArray) {
          v7 = Buffer.from(v7.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v7;
    }
    function bufferToHex(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a4, bits) {
      a4 = toBuffer(a4);
      if (!bits) bits = 256;
      if (bits !== 256) {
        throw new Error("unsupported");
      }
      return Buffer.from(keccak_2562(new Uint8Array(a4)));
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString2(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros,
      setLength,
      setLengthRight,
      isHexString: isHexString2,
      stripHexPrefix,
      toBuffer,
      bufferToHex,
      keccak,
      bitLengthFromBigInt,
      bufferBEFromBigInt,
      twosFromBigInt
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs
var require_abi = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs"(exports, module) {
    var util = require_util2();
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function parseTypeN(type) {
      return Number.parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
    }
    function parseTypeNxM(type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [Number.parseInt(tmp[1], 10), Number.parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : Number.parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type = typeof arg;
      if (type === "string" || type === "number") {
        return BigInt(arg);
      } else if (type === "bigint") {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type, arg) {
      var size10, num, ret, i6;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", new Buffer(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size10 = parseTypeArray(type);
        if (size10 !== "dynamic" && size10 !== 0 && arg.length > size10) {
          throw new Error("Elements exceed array size: " + size10);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i6 in arg) {
          ret.push(encodeSingle(type, arg[i6]));
        }
        if (size10 === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = new Buffer(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size10 = parseTypeN(type);
        if (size10 < 1 || size10 > 32) {
          throw new Error("Invalid bytes<N> width: " + size10);
        }
        return util.setLengthRight(arg, 32);
      } else if (type.startsWith("uint")) {
        size10 = parseTypeN(type);
        if (size10 % 8 || size10 < 8 || size10 > 256) {
          throw new Error("Invalid uint<N> width: " + size10);
        }
        num = parseNumber(arg);
        const bitLength = util.bitLengthFromBigInt(num);
        if (bitLength > size10) {
          throw new Error("Supplied uint exceeds width: " + size10 + " vs " + bitLength);
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return util.bufferBEFromBigInt(num, 32);
      } else if (type.startsWith("int")) {
        size10 = parseTypeN(type);
        if (size10 % 8 || size10 < 8 || size10 > 256) {
          throw new Error("Invalid int<N> width: " + size10);
        }
        num = parseNumber(arg);
        const bitLength = util.bitLengthFromBigInt(num);
        if (bitLength > size10) {
          throw new Error("Supplied int exceeds width: " + size10 + " vs " + bitLength);
        }
        const twos = util.twosFromBigInt(num, 256);
        return util.bufferBEFromBigInt(twos, 32);
      } else if (type.startsWith("ufixed")) {
        size10 = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num * BigInt(2) ** BigInt(size10[1]));
      } else if (type.startsWith("fixed")) {
        size10 = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg) * BigInt(2) ** BigInt(size10[1]));
      }
      throw new Error("Unsupported or invalid type: " + type);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function isArray(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data = [];
      var headLength = 32 * types.length;
      for (var i6 in types) {
        var type = elementaryName(types[i6]);
        var value2 = values[i6];
        var cur = encodeSingle(type, value2);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size10, num;
      var ret = [];
      for (var i6 = 0; i6 < types.length; i6++) {
        var type = elementaryName(types[i6]);
        var value2 = values[i6];
        if (type === "bytes") {
          ret.push(value2);
        } else if (type === "string") {
          ret.push(new Buffer(value2, "utf8"));
        } else if (type === "bool") {
          ret.push(new Buffer(value2 ? "01" : "00", "hex"));
        } else if (type === "address") {
          ret.push(util.setLength(value2, 20));
        } else if (type.startsWith("bytes")) {
          size10 = parseTypeN(type);
          if (size10 < 1 || size10 > 32) {
            throw new Error("Invalid bytes<N> width: " + size10);
          }
          ret.push(util.setLengthRight(value2, size10));
        } else if (type.startsWith("uint")) {
          size10 = parseTypeN(type);
          if (size10 % 8 || size10 < 8 || size10 > 256) {
            throw new Error("Invalid uint<N> width: " + size10);
          }
          num = parseNumber(value2);
          const bitLength = util.bitLengthFromBigInt(num);
          if (bitLength > size10) {
            throw new Error("Supplied uint exceeds width: " + size10 + " vs " + bitLength);
          }
          ret.push(util.bufferBEFromBigInt(num, size10 / 8));
        } else if (type.startsWith("int")) {
          size10 = parseTypeN(type);
          if (size10 % 8 || size10 < 8 || size10 > 256) {
            throw new Error("Invalid int<N> width: " + size10);
          }
          num = parseNumber(value2);
          const bitLength = util.bitLengthFromBigInt(num);
          if (bitLength > size10) {
            throw new Error("Supplied int exceeds width: " + size10 + " vs " + bitLength);
          }
          const twos = util.twosFromBigInt(num, size10);
          ret.push(util.bufferBEFromBigInt(twos, size10 / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return Buffer.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util.keccak(solidityPack(types, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs
var require_eth_eip712_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs"(exports, module) {
    var util = require_util2();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      /**
       * Encodes an object by encoding and concatenating each of its members
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of an object
       */
      encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name, type, value2) => {
            if (types[type] !== void 0) {
              return ["bytes32", value2 == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type, value2, types, useV4))];
            }
            if (value2 === void 0)
              throw new Error(`missing value for field ${name} of type ${type}`);
            if (type === "bytes") {
              return ["bytes32", util.keccak(value2)];
            }
            if (type === "string") {
              if (typeof value2 === "string") {
                value2 = Buffer.from(value2, "utf8");
              }
              return ["bytes32", util.keccak(value2)];
            }
            if (type.lastIndexOf("]") === type.length - 1) {
              const parsedType = type.slice(0, type.lastIndexOf("["));
              const typeValuePairs = value2.map((item) => encodeField(name, parsedType, item));
              return ["bytes32", util.keccak(abi.rawEncode(
                typeValuePairs.map(([type2]) => type2),
                typeValuePairs.map(([, value3]) => value3)
              ))];
            }
            return [type, value2];
          };
          for (const field of types[primaryType]) {
            const [type, value2] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type);
            encodedValues.push(value2);
          }
        } else {
          for (const field of types[primaryType]) {
            let value2 = data[field.name];
            if (value2 !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value2 = util.keccak(value2);
                encodedValues.push(value2);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value2 === "string") {
                  value2 = Buffer.from(value2, "utf8");
                }
                value2 = util.keccak(value2);
                encodedValues.push(value2);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value2 = util.keccak(this.encodeData(field.type, value2, types, useV4));
                encodedValues.push(value2);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value2);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      /**
       * Encodes the type of an object by encoding a comma delimited list of its members
       *
       * @param {string} primaryType - Root type to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of the type of an object
       */
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
          const children = types[type];
          if (!children) {
            throw new Error("No type definition specified: " + type);
          }
          result += type + "(" + types[type].map(({ name, type: type2 }) => type2 + " " + name).join(",") + ")";
        }
        return result;
      },
      /**
       * Finds all types within a type definition object
       *
       * @param {string} primaryType - Root type
       * @param {Object} types - Type definitions
       * @param {Array} results - current set of accumulated types
       * @returns {Array} - Set of all types found in the type definition
       */
      findTypeDependencies(primaryType, types, results = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results.includes(primaryType) || types[primaryType] === void 0) {
          return results;
        }
        results.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results)) {
            !results.includes(dep) && results.push(dep);
          }
        }
        return results;
      },
      /**
       * Hashes an object
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to hash
       * @param {Object} types - Type definitions
       * @returns {Buffer} - Hash of an object
       */
      hashStruct(primaryType, data, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types, useV4));
      },
      /**
       * Hashes the type of an object
       *
       * @param {string} primaryType - Root type to hash
       * @param {Object} types - Type definitions
       * @returns {string} - Hash of an object
       */
      hashType(primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types));
      },
      /**
       * Removes properties from a message object that are not defined per EIP-712
       *
       * @param {Object} data - typed message object
       * @returns {Object} - typed message object with only allowed fields
       */
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
          data[key] && (sanitizedData[key] = data[key]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      /**
       * Returns the hash of a typed message as per EIP-712 for signing
       *
       * @param {Object} typedData - Types message data to sign
       * @returns {string} - sha3 hash for signing
       */
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts2 = [Buffer.from("1901", "hex")];
        parts2.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts2.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer.concat(parts2));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length) throw error;
      const data = typedData.map(function(e9) {
        return e9.type === "bytes" ? util.toBuffer(e9.value) : e9.value;
      });
      const types = typedData.map(function(e9) {
        return e9.type;
      });
      const schema = typedData.map(function(e9) {
        if (!e9.name) throw error;
        return e9.type + " " + e9.name;
      });
      return abi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          abi.soliditySHA3(types, data)
        ]
      );
    }
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = (function() {
      function F8() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F8.prototype = __global__;
      return new F8();
    })();
    (function(globalThis2) {
      var irrelevant = (function(exports2) {
        var g3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g3,
          iterable: "Symbol" in g3 && "iterator" in Symbol,
          blob: "FileReader" in g3 && "Blob" in g3 && (function() {
            try {
              new Blob();
              return true;
            } catch (e9) {
              return false;
            }
          })(),
          formData: "FormData" in g3,
          arrayBuffer: "ArrayBuffer" in g3
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value2, name) {
              this.append(name, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value2) {
          name = normalizeName(name);
          value2 = normalizeValue(value2);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value2) {
          this.map[normalizeName(name)] = normalizeValue(value2);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push([name, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars2 = new Array(view.length);
          for (var i6 = 0; i6 < view.length; i6++) {
            chars2[i6] = String.fromCharCode(view[i6]);
          }
          return chars2.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode7);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request3(input, options) {
          if (!(this instanceof Request3)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request3) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || (function() {
            if ("AbortController" in g3) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          })();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request3.prototype.clone = function() {
          return new Request3(this, { body: this._bodyInit });
        };
        function decode7(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value2 = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts2 = line.split(":");
            var key = parts2.shift().trim();
            if (key) {
              var value2 = parts2.join(":").trim();
              try {
                headers.append(key, value2);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request3.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url2, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url2 } });
        };
        exports2.DOMException = g3.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request3(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url2) {
              try {
                return url2 === "" && g3.location.href ? g3.location.href : url2;
              } catch (e9) {
                return url2;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g3.Headers && init.headers instanceof g3.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value2, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value2);
                }
              });
            } else {
              request.headers.forEach(function(value2, name) {
                xhr.setRequestHeader(name, value2);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g3.fetch) {
          g3.fetch = fetch2;
          g3.Headers = Headers2;
          g3.Request = Request3;
          g3.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request3;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        return exports2;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s3 = 1e3;
    var m5 = s3 * 60;
    var h7 = m5 * 60;
    var d5 = h7 * 24;
    var w6 = d5 * 7;
    var y8 = d5 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n4 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n4 * y8;
        case "weeks":
        case "week":
        case "w":
          return n4 * w6;
        case "days":
        case "day":
        case "d":
          return n4 * d5;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n4 * h7;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n4 * m5;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n4 * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n4;
        default:
          return void 0;
      }
    }
    function fmtShort(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d5) {
        return Math.round(ms3 / d5) + "d";
      }
      if (msAbs >= h7) {
        return Math.round(ms3 / h7) + "h";
      }
      if (msAbs >= m5) {
        return Math.round(ms3 / m5) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms3 / s3) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d5) {
        return plural(ms3, msAbs, d5, "day");
      }
      if (msAbs >= h7) {
        return plural(ms3, msAbs, h7, "hour");
      }
      if (msAbs >= m5) {
        return plural(ms3, msAbs, m5, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms3, msAbs, s3, "second");
      }
      return ms3 + " ms";
    }
    function plural(ms3, msAbs, n4, name) {
      var isPlural = msAbs >= n4 * 1.5;
      return Math.round(ms3 / n4) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i6 = 0; i6 < namespace.length; i6++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i6);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v7) => {
            enableOverride = v7;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns3 of split) {
          if (ns3[0] === "-") {
            createDebug.skips.push(ns3.slice(1));
          } else {
            createDebug.names.push(ns3);
          }
        }
      }
      function matchesTemplate(search, template2) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template2.length && (template2[templateIndex] === search[searchIndex] || template2[templateIndex] === "*")) {
            if (template2[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template2.length && template2[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template2.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns3 of createDebug.names) {
          if (matchesTemplate(name, ns3)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m5;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m5 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m5[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c6 = "color: " + this.color;
      args.splice(1, 0, c6, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c6);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r6;
      try {
        r6 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r6 && typeof process !== "undefined" && "env" in process) {
        r6 = process.env.DEBUG;
      }
      return r6;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v7) {
      try {
        return JSON.stringify(v7);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/openapi-fetch/dist/cjs/index.cjs
var require_cjs8 = __commonJS({
  "node_modules/openapi-fetch/dist/cjs/index.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to6, from16, except, desc) => {
      if (from16 && typeof from16 === "object" || typeof from16 === "function") {
        for (let key of __getOwnPropNames(from16))
          if (!__hasOwnProp.call(to6, key) && key !== except)
            __defProp(to6, key, { get: () => from16[key], enumerable: !(desc = __getOwnPropDesc(from16, key)) || desc.enumerable });
      }
      return to6;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      createFinalURL: () => createFinalURL,
      createPathBasedClient: () => createPathBasedClient,
      createQuerySerializer: () => createQuerySerializer,
      default: () => createClient4,
      defaultBodySerializer: () => defaultBodySerializer,
      defaultPathSerializer: () => defaultPathSerializer,
      mergeHeaders: () => mergeHeaders,
      randomID: () => randomID,
      removeTrailingSlash: () => removeTrailingSlash,
      serializeArrayParam: () => serializeArrayParam,
      serializeObjectParam: () => serializeObjectParam,
      serializePrimitiveParam: () => serializePrimitiveParam,
      wrapAsPathBasedClient: () => wrapAsPathBasedClient
    });
    module.exports = __toCommonJS(index_exports);
    var PATH_PARAM_RE = /\{[^{}]+\}/g;
    var supportsRequestInitExt = () => {
      return typeof process === "object" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;
    };
    function randomID() {
      return Math.random().toString(36).slice(2, 11);
    }
    function createClient4(clientOptions) {
      let {
        baseUrl = "",
        Request: CustomRequest = globalThis.Request,
        fetch: baseFetch = globalThis.fetch,
        querySerializer: globalQuerySerializer,
        bodySerializer: globalBodySerializer,
        headers: baseHeaders,
        requestInitExt = void 0,
        ...baseOptions
      } = { ...clientOptions };
      requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;
      baseUrl = removeTrailingSlash(baseUrl);
      const middlewares = [];
      async function coreFetch(schemaPath, fetchOptions) {
        const {
          baseUrl: localBaseUrl,
          fetch: fetch2 = baseFetch,
          Request: Request3 = CustomRequest,
          headers,
          params = {},
          parseAs = "json",
          querySerializer: requestQuerySerializer,
          bodySerializer = globalBodySerializer ?? defaultBodySerializer,
          body,
          ...init
        } = fetchOptions || {};
        let finalBaseUrl = baseUrl;
        if (localBaseUrl) {
          finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;
        }
        let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);
        if (requestQuerySerializer) {
          querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer({
            ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
            ...requestQuerySerializer
          });
        }
        const serializedBody = body === void 0 ? void 0 : bodySerializer(
          body,
          // Note: we declare mergeHeaders() both here and below because its a bit of a chicken-or-egg situation:
          // bodySerializer() needs all headers so we arent dropping ones set by the user, however,
          // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,
          // setting the content-type at the very beginning to be overwritten.
          // Lastly, based on the way headers work, its not a simplepresent-or-not check becauase null intentionally un-sets headers.
          mergeHeaders(baseHeaders, headers, params.header)
        );
        const finalHeaders = mergeHeaders(
          // with no body, we should not to set Content-Type
          serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression
          serializedBody instanceof FormData ? {} : {
            "Content-Type": "application/json"
          },
          baseHeaders,
          headers,
          params.header
        );
        const requestInit = {
          redirect: "follow",
          ...baseOptions,
          ...init,
          body: serializedBody,
          headers: finalHeaders
        };
        let id2;
        let options;
        let request = new CustomRequest(
          createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),
          requestInit
        );
        let response;
        for (const key in init) {
          if (!(key in request)) {
            request[key] = init[key];
          }
        }
        if (middlewares.length) {
          id2 = randomID();
          options = Object.freeze({
            baseUrl: finalBaseUrl,
            fetch: fetch2,
            parseAs,
            querySerializer,
            bodySerializer
          });
          for (const m5 of middlewares) {
            if (m5 && typeof m5 === "object" && typeof m5.onRequest === "function") {
              const result = await m5.onRequest({
                request,
                schemaPath,
                params,
                options,
                id: id2
              });
              if (result) {
                if (result instanceof CustomRequest) {
                  request = result;
                } else if (result instanceof Response) {
                  response = result;
                  break;
                } else {
                  throw new Error("onRequest: must return new Request() or Response() when modifying the request");
                }
              }
            }
          }
        }
        if (!response) {
          try {
            response = await fetch2(request, requestInitExt);
          } catch (error2) {
            let errorAfterMiddleware = error2;
            if (middlewares.length) {
              for (let i6 = middlewares.length - 1; i6 >= 0; i6--) {
                const m5 = middlewares[i6];
                if (m5 && typeof m5 === "object" && typeof m5.onError === "function") {
                  const result = await m5.onError({
                    request,
                    error: errorAfterMiddleware,
                    schemaPath,
                    params,
                    options,
                    id: id2
                  });
                  if (result) {
                    if (result instanceof Response) {
                      errorAfterMiddleware = void 0;
                      response = result;
                      break;
                    }
                    if (result instanceof Error) {
                      errorAfterMiddleware = result;
                      continue;
                    }
                    throw new Error("onError: must return new Response() or instance of Error");
                  }
                }
              }
            }
            if (errorAfterMiddleware) {
              throw errorAfterMiddleware;
            }
          }
          if (middlewares.length) {
            for (let i6 = middlewares.length - 1; i6 >= 0; i6--) {
              const m5 = middlewares[i6];
              if (m5 && typeof m5 === "object" && typeof m5.onResponse === "function") {
                const result = await m5.onResponse({
                  request,
                  response,
                  schemaPath,
                  params,
                  options,
                  id: id2
                });
                if (result) {
                  if (!(result instanceof Response)) {
                    throw new Error("onResponse: must return new Response() when modifying the response");
                  }
                  response = result;
                }
              }
            }
          }
        }
        if (response.status === 204 || request.method === "HEAD" || response.headers.get("Content-Length") === "0") {
          return response.ok ? { data: void 0, response } : { error: void 0, response };
        }
        if (response.ok) {
          if (parseAs === "stream") {
            return { data: response.body, response };
          }
          return { data: await response[parseAs](), response };
        }
        let error = await response.text();
        try {
          error = JSON.parse(error);
        } catch {
        }
        return { error, response };
      }
      return {
        request(method, url2, init) {
          return coreFetch(url2, { ...init, method: method.toUpperCase() });
        },
        /** Call a GET endpoint */
        GET(url2, init) {
          return coreFetch(url2, { ...init, method: "GET" });
        },
        /** Call a PUT endpoint */
        PUT(url2, init) {
          return coreFetch(url2, { ...init, method: "PUT" });
        },
        /** Call a POST endpoint */
        POST(url2, init) {
          return coreFetch(url2, { ...init, method: "POST" });
        },
        /** Call a DELETE endpoint */
        DELETE(url2, init) {
          return coreFetch(url2, { ...init, method: "DELETE" });
        },
        /** Call a OPTIONS endpoint */
        OPTIONS(url2, init) {
          return coreFetch(url2, { ...init, method: "OPTIONS" });
        },
        /** Call a HEAD endpoint */
        HEAD(url2, init) {
          return coreFetch(url2, { ...init, method: "HEAD" });
        },
        /** Call a PATCH endpoint */
        PATCH(url2, init) {
          return coreFetch(url2, { ...init, method: "PATCH" });
        },
        /** Call a TRACE endpoint */
        TRACE(url2, init) {
          return coreFetch(url2, { ...init, method: "TRACE" });
        },
        /** Register middleware */
        use(...middleware) {
          for (const m5 of middleware) {
            if (!m5) {
              continue;
            }
            if (typeof m5 !== "object" || !("onRequest" in m5 || "onResponse" in m5 || "onError" in m5)) {
              throw new Error("Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`");
            }
            middlewares.push(m5);
          }
        },
        /** Unregister middleware */
        eject(...middleware) {
          for (const m5 of middleware) {
            const i6 = middlewares.indexOf(m5);
            if (i6 !== -1) {
              middlewares.splice(i6, 1);
            }
          }
        }
      };
    }
    var PathCallForwarder = class {
      constructor(client, url2) {
        this.client = client;
        this.url = url2;
      }
      GET = (init) => {
        return this.client.GET(this.url, init);
      };
      PUT = (init) => {
        return this.client.PUT(this.url, init);
      };
      POST = (init) => {
        return this.client.POST(this.url, init);
      };
      DELETE = (init) => {
        return this.client.DELETE(this.url, init);
      };
      OPTIONS = (init) => {
        return this.client.OPTIONS(this.url, init);
      };
      HEAD = (init) => {
        return this.client.HEAD(this.url, init);
      };
      PATCH = (init) => {
        return this.client.PATCH(this.url, init);
      };
      TRACE = (init) => {
        return this.client.TRACE(this.url, init);
      };
    };
    var PathClientProxyHandler = class {
      constructor() {
        this.client = null;
      }
      // Assume the property is an URL.
      get(coreClient, url2) {
        const forwarder = new PathCallForwarder(coreClient, url2);
        this.client[url2] = forwarder;
        return forwarder;
      }
    };
    function wrapAsPathBasedClient(coreClient) {
      const handler = new PathClientProxyHandler();
      const proxy = new Proxy(coreClient, handler);
      function Client() {
      }
      Client.prototype = proxy;
      const client = new Client();
      handler.client = client;
      return client;
    }
    function createPathBasedClient(clientOptions) {
      return wrapAsPathBasedClient(createClient4(clientOptions));
    }
    function serializePrimitiveParam(name, value2, options) {
      if (value2 === void 0 || value2 === null) {
        return "";
      }
      if (typeof value2 === "object") {
        throw new Error(
          "Deeply-nested arrays/objects arent supported. Provide your own `querySerializer()` to handle these."
        );
      }
      return `${name}=${options?.allowReserved === true ? value2 : encodeURIComponent(value2)}`;
    }
    function serializeObjectParam(name, value2, options) {
      if (!value2 || typeof value2 !== "object") {
        return "";
      }
      const values = [];
      const joiner = {
        simple: ",",
        label: ".",
        matrix: ";"
      }[options.style] || "&";
      if (options.style !== "deepObject" && options.explode === false) {
        for (const k8 in value2) {
          values.push(k8, options.allowReserved === true ? value2[k8] : encodeURIComponent(value2[k8]));
        }
        const final2 = values.join(",");
        switch (options.style) {
          case "form": {
            return `${name}=${final2}`;
          }
          case "label": {
            return `.${final2}`;
          }
          case "matrix": {
            return `;${name}=${final2}`;
          }
          default: {
            return final2;
          }
        }
      }
      for (const k8 in value2) {
        const finalName = options.style === "deepObject" ? `${name}[${k8}]` : k8;
        values.push(serializePrimitiveParam(finalName, value2[k8], options));
      }
      const final = values.join(joiner);
      return options.style === "label" || options.style === "matrix" ? `${joiner}${final}` : final;
    }
    function serializeArrayParam(name, value2, options) {
      if (!Array.isArray(value2)) {
        return "";
      }
      if (options.explode === false) {
        const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options.style] || ",";
        const final = (options.allowReserved === true ? value2 : value2.map((v7) => encodeURIComponent(v7))).join(joiner2);
        switch (options.style) {
          case "simple": {
            return final;
          }
          case "label": {
            return `.${final}`;
          }
          case "matrix": {
            return `;${name}=${final}`;
          }
          // case "spaceDelimited":
          // case "pipeDelimited":
          default: {
            return `${name}=${final}`;
          }
        }
      }
      const joiner = { simple: ",", label: ".", matrix: ";" }[options.style] || "&";
      const values = [];
      for (const v7 of value2) {
        if (options.style === "simple" || options.style === "label") {
          values.push(options.allowReserved === true ? v7 : encodeURIComponent(v7));
        } else {
          values.push(serializePrimitiveParam(name, v7, options));
        }
      }
      return options.style === "label" || options.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
    }
    function createQuerySerializer(options) {
      return function querySerializer(queryParams) {
        const search = [];
        if (queryParams && typeof queryParams === "object") {
          for (const name in queryParams) {
            const value2 = queryParams[name];
            if (value2 === void 0 || value2 === null) {
              continue;
            }
            if (Array.isArray(value2)) {
              if (value2.length === 0) {
                continue;
              }
              search.push(
                serializeArrayParam(name, value2, {
                  style: "form",
                  explode: true,
                  ...options?.array,
                  allowReserved: options?.allowReserved || false
                })
              );
              continue;
            }
            if (typeof value2 === "object") {
              search.push(
                serializeObjectParam(name, value2, {
                  style: "deepObject",
                  explode: true,
                  ...options?.object,
                  allowReserved: options?.allowReserved || false
                })
              );
              continue;
            }
            search.push(serializePrimitiveParam(name, value2, options));
          }
        }
        return search.join("&");
      };
    }
    function defaultPathSerializer(pathname, pathParams) {
      let nextURL = pathname;
      for (const match of pathname.match(PATH_PARAM_RE) ?? []) {
        let name = match.substring(1, match.length - 1);
        let explode = false;
        let style = "simple";
        if (name.endsWith("*")) {
          explode = true;
          name = name.substring(0, name.length - 1);
        }
        if (name.startsWith(".")) {
          style = "label";
          name = name.substring(1);
        } else if (name.startsWith(";")) {
          style = "matrix";
          name = name.substring(1);
        }
        if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {
          continue;
        }
        const value2 = pathParams[name];
        if (Array.isArray(value2)) {
          nextURL = nextURL.replace(match, serializeArrayParam(name, value2, { style, explode }));
          continue;
        }
        if (typeof value2 === "object") {
          nextURL = nextURL.replace(match, serializeObjectParam(name, value2, { style, explode }));
          continue;
        }
        if (style === "matrix") {
          nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value2)}`);
          continue;
        }
        nextURL = nextURL.replace(match, style === "label" ? `.${encodeURIComponent(value2)}` : encodeURIComponent(value2));
      }
      return nextURL;
    }
    function defaultBodySerializer(body, headers) {
      if (body instanceof FormData) {
        return body;
      }
      if (headers) {
        const contentType = headers.get instanceof Function ? headers.get("Content-Type") ?? headers.get("content-type") : headers["Content-Type"] ?? headers["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          return new URLSearchParams(body).toString();
        }
      }
      return JSON.stringify(body);
    }
    function createFinalURL(pathname, options) {
      let finalURL = `${options.baseUrl}${pathname}`;
      if (options.params?.path) {
        finalURL = defaultPathSerializer(finalURL, options.params.path);
      }
      let search = options.querySerializer(options.params.query ?? {});
      if (search.startsWith("?")) {
        search = search.substring(1);
      }
      if (search) {
        finalURL += `?${search}`;
      }
      return finalURL;
    }
    function mergeHeaders(...allHeaders) {
      const finalHeaders = new Headers();
      for (const h7 of allHeaders) {
        if (!h7 || typeof h7 !== "object") {
          continue;
        }
        const iterator = h7 instanceof Headers ? h7.entries() : Object.entries(h7);
        for (const [k8, v7] of iterator) {
          if (v7 === null) {
            finalHeaders.delete(k8);
          } else if (Array.isArray(v7)) {
            for (const v22 of v7) {
              finalHeaders.append(k8, v22);
            }
          } else if (v7 !== void 0) {
            finalHeaders.set(k8, v7);
          }
        }
      }
      return finalHeaders;
    }
    function removeTrailingSlash(url2) {
      if (url2.endsWith("/")) {
        return url2.substring(0, url2.length - 1);
      }
      return url2;
    }
  }
});

// node_modules/@metamask/sdk-analytics/dist/index.js
var require_dist = __commonJS({
  "node_modules/@metamask/sdk-analytics/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to6, from16, except, desc) => {
      if (from16 && typeof from16 === "object" || typeof from16 === "function") {
        for (let key of __getOwnPropNames(from16))
          if (!__hasOwnProp.call(to6, key) && key !== except)
            __defProp(to6, key, { get: () => from16[key], enumerable: !(desc = __getOwnPropDesc(from16, key)) || desc.enumerable });
      }
      return to6;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      analytics: () => analytics
    });
    module.exports = __toCommonJS(index_exports);
    var import_openapi_fetch = __toESM2(require_cjs8());
    var Sender = class {
      constructor(options) {
        this.batch = [];
        this.maxTimeoutMs = 3e4;
        this.timeoutId = null;
        this.isSending = false;
        this.batchSize = options.batchSize;
        this.baseTimeoutMs = options.baseTimeoutMs;
        this.currentTimeoutMs = options.baseTimeoutMs;
        this.sendFn = options.sendFn;
      }
      enqueue(item) {
        this.batch.push(item);
        this.schedule();
      }
      schedule() {
        if (this.batch.length > 0 && !this.timeoutId) {
          this.timeoutId = setTimeout(() => {
            this.timeoutId = null;
            this.flush();
          }, this.currentTimeoutMs);
        }
      }
      async flush() {
        if (this.isSending || this.batch.length === 0) {
          return;
        }
        this.isSending = true;
        const current = [...this.batch.slice(0, this.batchSize)];
        this.batch = this.batch.slice(this.batchSize);
        try {
          await this.sendFn(current);
          this.currentTimeoutMs = this.baseTimeoutMs;
        } catch (error) {
          console.error("Sender: Failed to send batch", error);
          this.batch = [...current, ...this.batch];
          this.currentTimeoutMs = Math.min(
            this.currentTimeoutMs * 2,
            this.maxTimeoutMs
          );
        } finally {
          this.isSending = false;
          this.schedule();
        }
      }
    };
    var sender_default = Sender;
    var Analytics = class {
      constructor(baseUrl) {
        this.enabled = false;
        this.properties = {};
        const client2 = (0, import_openapi_fetch.default)({ baseUrl });
        const sendFn = async (batch) => {
          const res = await client2.POST("/v1/events", { body: batch });
          if (res.response.status !== 200) {
            throw new Error(res.error);
          }
        };
        this.sender = new sender_default({ batchSize: 100, baseTimeoutMs: 200, sendFn });
      }
      enable() {
        this.enabled = true;
      }
      setGlobalProperty(key, value2) {
        this.properties[key] = value2;
      }
      track(name, properties) {
        if (!this.enabled) {
          return;
        }
        const event = {
          name,
          ...this.properties,
          ...properties
        };
        this.sender.enqueue(event);
      }
    };
    var analytics_default = Analytics;
    var endpoint;
    var _a4;
    if (typeof process !== "undefined" && process.env) {
      endpoint = (_a4 = process.env.METAMASK_ANALYTICS_ENDPOINT) != null ? _a4 : process.env.NEXT_PUBLIC_METAMASK_ANALYTICS_ENDPOINT;
    }
    var METAMASK_ANALYTICS_ENDPOINT = endpoint != null ? endpoint : "https://mm-sdk-analytics.api.cx.metamask.io/";
    var client = new analytics_default(METAMASK_ANALYTICS_ENDPOINT);
    var analytics = client;
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module) {
    !(function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e9 = new Error(errorMsg);
          e9.name = "MaxListenersExceededWarning";
          e9.emitter = this;
          e9.count = count;
          process.emitWarning(e9);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray2 = function(a4, b5, c6) {
        var n4 = arguments.length;
        switch (n4) {
          case 0:
            return [];
          case 1:
            return [a4];
          case 2:
            return [a4, b5];
          case 3:
            return [a4, b5, c6];
          default:
            var arr = new Array(n4);
            while (n4--) {
              arr[n4] = arguments[n4];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for (var i6 = 0; i6 < len; i6++) {
          key = keys[i6];
          obj[key] = i6 < valuesCount ? values[i6] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on7, off;
        if (options.on || options.off) {
          on7 = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on7 = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on7 = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on7 = target.on;
          off = target.off;
        }
        if (!on7 && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on7 !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on7;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray2.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i6;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler) return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i6 = events.length;
            while (i6-- > 0) {
              event = events[i6];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options) return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value2;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i6 = 0; i6 < length; i6++) {
          option = keys[i6];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value2 = options[option];
          if (value2 !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value2, reject) : value2;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value2, reject) {
        if (typeof value2 !== "function" || !value2.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value2;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v7, reject) {
            if (typeof v7 === firstType) {
              return v7;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v7, reject) {
            var kind = typeof v7;
            if (kind === firstType || kind === secondType) return v7;
            reject(message);
          };
        }
        return function(v7, reject) {
          var kind = typeof v7;
          var i6 = len;
          while (i6-- > 0) {
            if (kind === types[i6]) return v7;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value2, reject2) {
              value2 *= 1;
              if (typeof value2 !== "number" || value2 < 0 || !Number.isFinite(value2)) {
                reject2("timeout must be a positive number");
              }
              return value2;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value2) {
            cleanup();
            resolve(value2);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i6 = 1; i6 < length; i6++) {
              callbacks[i6](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i6 = 0; i6 < len; i6++) {
          if (observers[i6]._target === observer) return i6;
        }
        return -1;
      }
      function searchListenerTree(handlers, type, tree, i6, typeLength) {
        if (!tree) {
          return null;
        }
        if (i6 === 0) {
          var kind = typeof type;
          if (kind === "string") {
            var ns3, n4, l6 = 0, j6 = 0, delimiter = this.delimiter, dl2 = delimiter.length;
            if ((n4 = type.indexOf(delimiter)) !== -1) {
              ns3 = new Array(5);
              do {
                ns3[l6++] = type.slice(j6, n4);
                j6 = n4 + dl2;
              } while ((n4 = type.indexOf(delimiter, j6)) !== -1);
              ns3[l6++] = type.slice(j6);
              type = ns3;
              typeLength = l6;
            } else {
              type = [type];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type.length;
          } else {
            type = [type];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i6], nextType = type[i6 + 1], branches, _listeners;
        if (i6 === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n4 = branches.length;
            while (n4-- > 0) {
              branch = branches[n4];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type, tree[branch], i6 + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i6 + 1 === typeLength || i6 + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n4 = branches.length;
            while (n4-- > 0) {
              branch = branches[n4];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type, tree[branch], i6, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i6 + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i6, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type, tree[currentType], i6 + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i6 + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i6 < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n4 = branches.length;
            while (n4-- > 0) {
              branch = branches[n4];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i6 + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i6 + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i6 + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener, prepend) {
        var len = 0, j6 = 0, i6, delimiter = this.delimiter, dl2 = delimiter.length, ns3;
        if (typeof type === "string") {
          if ((i6 = type.indexOf(delimiter)) !== -1) {
            ns3 = new Array(5);
            do {
              ns3[len++] = type.slice(j6, i6);
              j6 = i6 + dl2;
            } while ((i6 = type.indexOf(delimiter, j6)) !== -1);
            ns3[len++] = type.slice(j6);
          } else {
            ns3 = [type];
            len = 1;
          }
        } else {
          ns3 = type;
          len = type.length;
        }
        if (len > 1) {
          for (i6 = 0; i6 + 1 < len; i6++) {
            if (ns3[i6] === "**" && ns3[i6 + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name;
        for (i6 = 0; i6 < len; i6++) {
          name = ns3[i6];
          tree = tree[name] || (tree[name] = {});
          if (i6 === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i6 = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i6-- > 0) {
          branchName = branches[i6];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root;
          } else {
            path = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i6 = keys.length;
        var obj, key, flag;
        while (i6-- > 0) {
          key = keys[i6];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick2 = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick2 || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick2 && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick2 ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick2 ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter2(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter2.EventEmitter2 = EventEmitter2;
      EventEmitter2.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i6 = 0; i6 < len; i6++) {
            event = keys[i6];
            observer.subscribe(
              event,
              events2[event] || event,
              isSingleReducer ? reducers : reducers && reducers[event]
            );
          }
        }
        isArray(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
      };
      EventEmitter2.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i6 = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i6-- > 0) {
          observer = observers[i6];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter2.prototype.delimiter = ".";
      EventEmitter2.prototype.setMaxListeners = function(n4) {
        if (n4 !== undefined2) {
          this._maxListeners = n4;
          if (!this._conf) this._conf = {};
          this._conf.maxListeners = n4;
        }
      };
      EventEmitter2.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter2.prototype.event = "";
      EventEmitter2.prototype.once = function(event, fn6, options) {
        return this._once(event, fn6, false, options);
      };
      EventEmitter2.prototype.prependOnceListener = function(event, fn6, options) {
        return this._once(event, fn6, true, options);
      };
      EventEmitter2.prototype._once = function(event, fn6, prepend, options) {
        return this._many(event, 1, fn6, prepend, options);
      };
      EventEmitter2.prototype.many = function(event, ttl, fn6, options) {
        return this._many(event, ttl, fn6, false, options);
      };
      EventEmitter2.prototype.prependMany = function(event, ttl, fn6, options) {
        return this._many(event, ttl, fn6, true, options);
      };
      EventEmitter2.prototype._many = function(event, ttl, fn6, prepend, options) {
        var self2 = this;
        if (typeof fn6 !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn6.apply(this, arguments);
        }
        listener._origin = fn6;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter2.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], ns3, wildcard = this.wildcard;
        var args, l6, i6, j6, containsSymbol;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns3 = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l6 = type.length;
              if (symbolsSupported) {
                for (i6 = 0; i6 < l6; i6++) {
                  if (typeof type[i6] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var al2 = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i6 = 0, l6 = handler.length; i6 < l6; i6++) {
            this.event = type;
            switch (al2) {
              case 1:
                handler[i6].call(this, type);
                break;
              case 2:
                handler[i6].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i6].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i6].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns3, this.listenerTree, 0, l6);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al2) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al2 - 1);
                for (j6 = 1; j6 < al2; j6++) args[j6 - 1] = arguments[j6];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al2 > 3) {
            args = new Array(al2 - 1);
            for (j6 = 1; j6 < al2; j6++) args[j6 - 1] = arguments[j6];
          }
          for (i6 = 0, l6 = handler.length; i6 < l6; i6++) {
            this.event = type;
            switch (al2) {
              case 1:
                handler[i6].call(this);
                break;
              case 2:
                handler[i6].call(this, arguments[1]);
                break;
              case 3:
                handler[i6].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i6].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter2.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns3, containsSymbol;
        var args, l6, i6, j6;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns3 = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l6 = type.length;
              if (symbolsSupported) {
                for (i6 = 0; i6 < l6; i6++) {
                  if (typeof type[i6] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al2 = arguments.length;
        var handler;
        if (this._all) {
          for (i6 = 0, l6 = this._all.length; i6 < l6; i6++) {
            this.event = type;
            switch (al2) {
              case 1:
                promises.push(this._all[i6].call(this, type));
                break;
              case 2:
                promises.push(this._all[i6].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i6].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i6].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns3, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al2) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al2 - 1);
              for (j6 = 1; j6 < al2; j6++) args[j6 - 1] = arguments[j6];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al2 > 3) {
            args = new Array(al2 - 1);
            for (j6 = 1; j6 < al2; j6++) args[j6 - 1] = arguments[j6];
          }
          for (i6 = 0, l6 = handler.length; i6 < l6; i6++) {
            this.event = type;
            switch (al2) {
              case 1:
                promises.push(handler[i6].call(this));
                break;
              case 2:
                promises.push(handler[i6].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i6].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i6].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter2.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
      };
      EventEmitter2.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
      };
      EventEmitter2.prototype.onAny = function(fn6) {
        return this._onAny(fn6, false);
      };
      EventEmitter2.prototype.prependAny = function(fn6) {
        return this._onAny(fn6, true);
      };
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prototype._onAny = function(fn6, prepend) {
        if (typeof fn6 !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn6);
        } else {
          this._all.push(fn6);
        }
        return this;
      };
      EventEmitter2.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type, listener, prepend);
          return returnValue;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return returnValue;
      };
      EventEmitter2.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns3 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns3, this.listenerTree, 0);
          if (!leafs) return this;
        } else {
          if (!this._events[type]) return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray(handlers)) {
            var position = -1;
            for (var i6 = 0, length = handlers.length; i6 < length; i6++) {
              if (handlers[i6] === listener || handlers[i6].listener && handlers[i6].listener === listener || handlers[i6]._origin && handlers[i6]._origin === listener) {
                position = i6;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter2.prototype.offAny = function(fn6) {
        var i6 = 0, l6 = 0, fns;
        if (fn6 && this._all && this._all.length > 0) {
          fns = this._all;
          for (i6 = 0, l6 = fns.length; i6 < l6; i6++) {
            if (fn6 === fns[i6]) {
              fns.splice(i6, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn6);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i6 = 0, l6 = fns.length; i6 < l6; i6++)
              this.emit("removeListenerAny", fns[i6]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter2.prototype.removeListener = EventEmitter2.prototype.off;
      EventEmitter2.prototype.removeAllListeners = function(type) {
        if (type === undefined2) {
          !this._events || init.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i6;
          if (!leafs) return this;
          for (i6 = 0; i6 < leafs.length; i6++) {
            leaf = leafs[i6];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter2.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i6;
        var listenerTree;
        if (type === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i6 = keys.length;
          allListeners = [];
          while (i6-- > 0) {
            listeners = _events[keys[i6]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree) return [];
            var handlers = [];
            var ns3 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns3, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter2.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter2.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter2.prototype.hasListeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns3 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns3, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
      };
      EventEmitter2.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter2.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type = typeof options;
        if (type === "number") {
          options = { timeout: options };
        } else if (type === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter = options.filter;
            if (filter && !filter.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
            } else {
              resolve(toArray2.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray2.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name, handler);
            });
            emitter.addEventListener(
              name,
              handler,
              { once: true }
            );
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray2.apply(null, arguments));
          };
          var errorListener;
          if (name !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name, eventListener);
          });
          emitter.once(name, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter2.prototype;
      Object.defineProperties(EventEmitter2, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n4) {
            if (typeof n4 !== "number" || n4 < 0 || Number.isNaN(n4)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n4;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter2;
        });
      } else if (typeof exports === "object") {
        module.exports = EventEmitter2;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter2;
      }
    })();
  }
});

// node_modules/@dynamic-labs/ethereum/src/polyfills.js
var import_buffer = __toESM(require_buffer(), 1);
if (typeof window !== "undefined") {
  window.global = globalThis;
  Object.assign(window, { Buffer: import_buffer.Buffer });
}

// node_modules/@dynamic-labs/ethereum/package.js
var version = "4.26.0";

// node_modules/@dynamic-labs/ethereum/_virtual/_tslib.js
function __rest(s3, e9) {
  var t4 = {};
  for (var p7 in s3) if (Object.prototype.hasOwnProperty.call(s3, p7) && e9.indexOf(p7) < 0)
    t4[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p7 = Object.getOwnPropertySymbols(s3); i6 < p7.length; i6++) {
      if (e9.indexOf(p7[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i6]))
        t4[p7[i6]] = s3[p7[i6]];
    }
  return t4;
}
function __awaiter(thisArg, _arguments, P6, generator) {
  function adopt(value2) {
    return value2 instanceof P6 ? value2 : new P6(function(resolve) {
      resolve(value2);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e9) {
        reject(e9);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e9) {
        reject(e9);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/ethereum/src/ethProviderHelper.js
var EthProviderHelper = class {
  constructor(connector) {
    this.walletBookWallet = findWalletBookWallet(connector.walletBook, connector.key);
    this.connector = connector;
  }
  getInstalledProvider() {
    const eip6963Provider = this.getEip6963Provider();
    if (eip6963Provider) {
      return eip6963Provider;
    }
    const injectedProvider = this.getInjectedProvider();
    return injectedProvider;
  }
  getInjectedProvider() {
    const config = this.getInjectedConfig();
    if (!config || !config.extensionLocators || !config.extensionLocators.length)
      return void 0;
    const provider = this.installedProviderLookup(config.extensionLocators);
    return provider;
  }
  getEip6963Provider() {
    const { rdns } = this.connector.metadata;
    if (!rdns) {
      return void 0;
    }
    return this.eip6963ProviderLookup(rdns);
  }
  getInjectedConfig() {
    var _a4;
    const injectedConfig = (_a4 = this.walletBookWallet) === null || _a4 === void 0 ? void 0 : _a4.injectedConfig;
    return injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.find((c6) => c6.chain === "evm");
  }
  installedProviders() {
    const config = this.getInjectedConfig();
    if (!config)
      return [];
    const providers = [];
    if (config.windowLocations) {
      for (const windowLocation of config.windowLocations) {
        const foundProviders = getProvidersFromWindow(windowLocation);
        if (foundProviders && foundProviders.length)
          providers.push(...foundProviders);
      }
    }
    if (window.ethereum) {
      if (!window.ethereum.providers || !window.ethereum.providers.length) {
        providers.push(window.ethereum);
      } else {
        window.ethereum.providers.forEach((p7) => providers.push(p7));
      }
    }
    return providers;
  }
  installedProviderLookup(extensionLocators) {
    const allInstalledProviders = this.installedProviders();
    return ProviderLookup(allInstalledProviders, extensionLocators);
  }
  eip6963ProviderLookup(rdns) {
    var _a4;
    const { providers } = Eip6963ProviderSingleton.get();
    return (_a4 = providers.find((provider) => {
      var _a5;
      return ((_a5 = provider === null || provider === void 0 ? void 0 : provider.info) === null || _a5 === void 0 ? void 0 : _a5.rdns) === rdns;
    })) === null || _a4 === void 0 ? void 0 : _a4.provider;
  }
  isInstalledHelper() {
    return this.findProvider() !== void 0;
  }
  findProvider() {
    const provider = this.connector.findProvider();
    return provider;
  }
  findWalletClient(chainId) {
    const provider = this.findProvider();
    if (!provider) {
      return void 0;
    }
    return createWalletClient({
      account: this.connector.getActiveAccount(),
      chain: chainId ? chainsMap[chainId] : this.connector.getActiveChain(),
      transport: custom({
        request: (args) => provider.request(args).catch(normalizeRpcError)
      }, this.connector.providersConfig.httpTransportConfig)
    });
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      const client = this.findWalletClient();
      if (!client) {
        return Promise.resolve(void 0);
      }
      return this.getAddressWithProvider(client);
    });
  }
  getAddressWithProvider(client) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const [lowercaseAddress] = yield client.requestAddresses();
        const publicAddress = getAddress(lowercaseAddress);
        this.connector.setActiveAccount(publicAddress);
        return publicAddress;
      } catch (err) {
        logger.error(err);
        return Promise.reject(err);
      }
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      const walletAddress = yield this.getAddress();
      if (!walletAddress) {
        return Promise.resolve(void 0);
      }
      const client = this.findWalletClient();
      if (!client) {
        return Promise.resolve(void 0);
      }
      const signedMessage = yield client.signMessage({
        account: walletAddress,
        message: messageToSign
      });
      return signedMessage;
    });
  }
  _setupEventListeners(walletConnector) {
    const web3Provider = this.findProvider();
    if (!web3Provider) {
      logger.warn("Provider not found", {
        connector: walletConnector
      });
      return {
        tearDownEventListeners: () => {
        }
      };
    }
    if (!web3Provider.on) {
      logger.warn("Provider does not support event listeners", {
        connector: walletConnector,
        provider: web3Provider
      });
      return {
        tearDownEventListeners: () => {
        }
      };
    }
    const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(walletConnector);
    web3Provider.on("accountsChanged", handleAccountChange);
    web3Provider.on("chainChanged", handleChainChange);
    web3Provider.on("disconnect", handleDisconnect);
    const tearDownEventListeners = () => {
      const web3Provider2 = this.findProvider();
      if (!web3Provider2) {
        return;
      }
      if (handleAccountChange) {
        web3Provider2.removeListener("accountsChanged", handleAccountChange);
      }
      if (handleChainChange) {
        web3Provider2.removeListener("chainChanged", handleChainChange);
      }
      if (handleDisconnect) {
        web3Provider2.removeListener("disconnect", handleDisconnect);
      }
    };
    return {
      tearDownEventListeners
    };
  }
};

// node_modules/@dynamic-labs/ethereum/src/utils/logger.js
var logger3 = new Logger("@dynamic-labs/ethereum");

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var import_events6 = __toESM(require_events());

// node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber2(count);
}

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
  size: 32
});

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@walletconnect/ethereum-provider/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@walletconnect/ethereum-provider/node_modules/ox/_esm/core/Hash.js
function keccak2563(value2, options = {}) {
  const { as: as3 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value2));
  if (as3 === "Bytes")
    return bytes;
  return fromBytes(bytes);
}

// node_modules/@walletconnect/ethereum-provider/node_modules/ox/_esm/core/internal/lru.js
var LruMap4 = class extends Map {
  constructor(size10) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size10;
  }
  get(key) {
    const value2 = super.get(key);
    if (super.has(key) && value2 !== void 0) {
      this.delete(key);
      super.set(key, value2);
    }
    return value2;
  }
  set(key, value2) {
    super.set(key, value2);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap4(8192)
};
var checksum = caches.checksum;

// node_modules/@walletconnect/ethereum-provider/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value2, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value2))
    throw new InvalidAddressError2({
      address: value2,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value2.toLowerCase() === value2)
      return;
    if (checksum2(value2) !== value2)
      throw new InvalidAddressError2({
        address: value2,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2563(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i6 = 0; i6 < 40; i6 += 2) {
    if (hash[i6 >> 1] >> 4 >= 8 && characters[i6]) {
      characters[i6] = characters[i6].toUpperCase();
    }
    if ((hash[i6 >> 1] & 15) >= 8 && characters[i6 + 1]) {
      characters[i6 + 1] = characters[i6 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError2 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError2 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError2 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@walletconnect/ethereum-provider/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value2) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value2;
    this.position++;
  },
  pushUint16(value2) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value2);
    this.position += 2;
  },
  pushUint24(value2) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value2 >> 8);
    this.dataView.setUint8(this.position + 2, value2 & ~4294967040);
    this.position += 3;
  },
  pushUint32(value2) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value2);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectByte();
    this.position++;
    return value2;
  },
  readBytes(length, size10) {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectBytes(length);
    this.position += size10 ?? length;
    return value2;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint8();
    this.position += 1;
    return value2;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint16();
    this.position += 2;
    return value2;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint24();
    this.position += 3;
    return value2;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint32();
    this.position += 4;
    return value2;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError2 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError2 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError2 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i6 = 0; i6 < types.length; i6++) {
    const type = types[i6];
    const value2 = values[i6];
    data.push(encodePacked2.encode(type, value2));
  }
  return concat(...data);
}
(function(encodePacked7) {
  function encode12(type, value2, isArray = false) {
    if (type === "address") {
      const address = value2;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString2(value2);
    if (type === "bytes")
      return value2;
    if (type === "bool")
      return padLeft(fromBoolean(value2), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size10 = Number.parseInt(bits) / 8;
      return fromNumber(value2, {
        size: isArray ? 32 : size10,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size10] = bytesMatch;
      if (Number.parseInt(size10) !== (value2.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size10),
          value: value2
        });
      return padRight(value2, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value2)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i6 = 0; i6 < value2.length; i6++) {
        data.push(encode12(childType, value2[i6], true));
      }
      if (data.length === 0)
        return "0x";
      return concat(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked7.encode = encode12;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError2 {
  constructor({ expectedSize, value: value2 }) {
    super(`Size of bytes "${value2}" (bytes${size(value2)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError2 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/base-x/src/esm/index.js
function base(ALPHABET4) {
  if (ALPHABET4.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j6 = 0; j6 < BASE_MAP.length; j6++) {
    BASE_MAP[j6] = 255;
  }
  for (let i6 = 0; i6 < ALPHABET4.length; i6++) {
    const x5 = ALPHABET4.charAt(i6);
    const xc5 = x5.charCodeAt(0);
    if (BASE_MAP[xc5] !== 255) {
      throw new TypeError(x5 + " is ambiguous");
    }
    BASE_MAP[xc5] = i6;
  }
  const BASE = ALPHABET4.length;
  const LEADER = ALPHABET4.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode12(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size10 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size10);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i6 = 0;
      for (let it1 = size10 - 1; (carry !== 0 || i6 < length) && it1 !== -1; it1--, i6++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i6;
      pbegin++;
    }
    let it22 = size10 - length;
    while (it22 !== size10 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size10; ++it22) {
      str += ALPHABET4.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size10 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size10);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i6 = 0;
      for (let it32 = size10 - 1; (carry !== 0 || i6 < length) && it32 !== -1; it32--, i6++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i6;
      psz++;
    }
    let it4 = size10 - length;
    while (it4 !== size10 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size10 - it4));
    let j6 = zeroes;
    while (it4 !== size10) {
      vch[j6++] = b256[it4++];
    }
    return vch;
  }
  function decode7(string4) {
    const buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode12,
    decodeUnsafe,
    decode: decode7
  };
}
var esm_default = base;

// node_modules/@walletconnect/ethereum-provider/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs
function utf8Count(str) {
  const strLength = str.length;
  let byteLength2 = 0;
  let pos = 0;
  while (pos < strLength) {
    let value2 = str.charCodeAt(pos++);
    if ((value2 & 4294967168) === 0) {
      byteLength2++;
      continue;
    } else if ((value2 & 4294965248) === 0) {
      byteLength2 += 2;
    } else {
      if (value2 >= 55296 && value2 <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value2 = ((value2 & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value2 & 4294901760) === 0) {
        byteLength2 += 3;
      } else {
        byteLength2 += 4;
      }
    }
  }
  return byteLength2;
}
function utf8EncodeJs(str, output, outputOffset) {
  const strLength = str.length;
  let offset = outputOffset;
  let pos = 0;
  while (pos < strLength) {
    let value2 = str.charCodeAt(pos++);
    if ((value2 & 4294967168) === 0) {
      output[offset++] = value2;
      continue;
    } else if ((value2 & 4294965248) === 0) {
      output[offset++] = value2 >> 6 & 31 | 192;
    } else {
      if (value2 >= 55296 && value2 <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value2 = ((value2 & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value2 & 4294901760) === 0) {
        output[offset++] = value2 >> 12 & 15 | 224;
        output[offset++] = value2 >> 6 & 63 | 128;
      } else {
        output[offset++] = value2 >> 18 & 7 | 240;
        output[offset++] = value2 >> 12 & 63 | 128;
        output[offset++] = value2 >> 6 & 63 | 128;
      }
    }
    output[offset++] = value2 & 63 | 128;
  }
}
var sharedTextEncoder = new TextEncoder();
var TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output, outputOffset);
  } else {
    utf8EncodeJs(str, output, outputOffset);
  }
}
var CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength2) {
  let offset = inputOffset;
  const end = offset + byteLength2;
  const units = [];
  let result = "";
  while (offset < end) {
    const byte1 = bytes[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = bytes[offset++] & 63;
      const byte3 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = bytes[offset++] & 63;
      const byte3 = bytes[offset++] & 63;
      const byte4 = bytes[offset++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode(...units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode(...units);
  }
  return result;
}
var sharedTextDecoder = new TextDecoder();
var TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes, inputOffset, byteLength2) {
  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength2);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength2) {
  if (byteLength2 > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes, inputOffset, byteLength2);
  } else {
    return utf8DecodeJs(bytes, inputOffset, byteLength2);
  }
}

// node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs
var ExtData = class {
  constructor(type, data) {
    this.type = type;
    this.data = data;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs
var DecodeError = class _DecodeError extends Error {
  constructor(message) {
    super(message);
    const proto = Object.create(_DecodeError.prototype);
    Object.setPrototypeOf(this, proto);
    Object.defineProperty(this, "name", {
      configurable: true,
      enumerable: false,
      value: _DecodeError.name
    });
  }
};

// node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs
var UINT32_MAX = 4294967295;
function setUint64(view, offset, value2) {
  const high = value2 / 4294967296;
  const low = value2;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value2) {
  const high = Math.floor(value2 / 4294967296);
  const low = value2;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
  const high = view.getInt32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
function getUint64(view, offset) {
  const high = view.getUint32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}

// node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
function encodeTimeSpecToTimestamp({ sec, nsec }) {
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      const rv = new Uint8Array(4);
      const view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      const secHigh = sec / 4294967296;
      const secLow = sec & 4294967295;
      const rv = new Uint8Array(8);
      const view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    const rv = new Uint8Array(12);
    const view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  const msec = date.getTime();
  const sec = Math.floor(msec / 1e3);
  const nsec = (msec - sec * 1e3) * 1e6;
  const nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    const timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      const sec = view.getUint32(0);
      const nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      const nsec30AndSecHigh2 = view.getUint32(0);
      const secLow32 = view.getUint32(4);
      const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      const nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      const sec = getInt64(view, 4);
      const nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
  }
}
function decodeTimestampExtension(data) {
  const timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
  type: EXT_TIMESTAMP,
  encode: encodeTimestampExtension,
  decode: decodeTimestampExtension
};

// node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs
var ExtensionCodec = class {
  constructor() {
    this.builtInEncoders = [];
    this.builtInDecoders = [];
    this.encoders = [];
    this.decoders = [];
    this.register(timestampExtension);
  }
  register({ type, encode: encode12, decode: decode7 }) {
    if (type >= 0) {
      this.encoders[type] = encode12;
      this.decoders[type] = decode7;
    } else {
      const index = -1 - type;
      this.builtInEncoders[index] = encode12;
      this.builtInDecoders[index] = decode7;
    }
  }
  tryToEncode(object, context) {
    for (let i6 = 0; i6 < this.builtInEncoders.length; i6++) {
      const encodeExt = this.builtInEncoders[i6];
      if (encodeExt != null) {
        const data = encodeExt(object, context);
        if (data != null) {
          const type = -1 - i6;
          return new ExtData(type, data);
        }
      }
    }
    for (let i6 = 0; i6 < this.encoders.length; i6++) {
      const encodeExt = this.encoders[i6];
      if (encodeExt != null) {
        const data = encodeExt(object, context);
        if (data != null) {
          const type = i6;
          return new ExtData(type, data);
        }
      }
    }
    if (object instanceof ExtData) {
      return object;
    }
    return null;
  }
  decode(data, type, context) {
    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
    if (decodeExt) {
      return decodeExt(data, type, context);
    } else {
      return new ExtData(type, data);
    }
  }
};
ExtensionCodec.defaultCodec = new ExtensionCodec();

// node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs
function isArrayBufferLike(buffer) {
  return buffer instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && buffer instanceof SharedArrayBuffer;
}
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (isArrayBufferLike(buffer)) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}

// node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = class _Encoder {
  constructor(options) {
    this.entered = false;
    this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;
    this.context = options?.context;
    this.useBigInt64 = options?.useBigInt64 ?? false;
    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;
    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;
    this.sortKeys = options?.sortKeys ?? false;
    this.forceFloat32 = options?.forceFloat32 ?? false;
    this.ignoreUndefined = options?.ignoreUndefined ?? false;
    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;
    this.pos = 0;
    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
    this.bytes = new Uint8Array(this.view.buffer);
  }
  clone() {
    return new _Encoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      maxDepth: this.maxDepth,
      initialBufferSize: this.initialBufferSize,
      sortKeys: this.sortKeys,
      forceFloat32: this.forceFloat32,
      ignoreUndefined: this.ignoreUndefined,
      forceIntegerToFloat: this.forceIntegerToFloat
    });
  }
  reinitializeState() {
    this.pos = 0;
  }
  /**
   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
   *
   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
   */
  encodeSharedRef(object) {
    if (this.entered) {
      const instance = this.clone();
      return instance.encodeSharedRef(object);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.subarray(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  /**
   * @returns Encodes the object and returns a copy of the encoder's internal buffer.
   */
  encode(object) {
    if (this.entered) {
      const instance = this.clone();
      return instance.encode(object);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.slice(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  doEncode(object, depth) {
    if (depth > this.maxDepth) {
      throw new Error(`Too deep objects in depth ${depth}`);
    }
    if (object == null) {
      this.encodeNil();
    } else if (typeof object === "boolean") {
      this.encodeBoolean(object);
    } else if (typeof object === "number") {
      if (!this.forceIntegerToFloat) {
        this.encodeNumber(object);
      } else {
        this.encodeNumberAsFloat(object);
      }
    } else if (typeof object === "string") {
      this.encodeString(object);
    } else if (this.useBigInt64 && typeof object === "bigint") {
      this.encodeBigInt64(object);
    } else {
      this.encodeObject(object, depth);
    }
  }
  ensureBufferSizeToWrite(sizeToWrite) {
    const requiredSize = this.pos + sizeToWrite;
    if (this.view.byteLength < requiredSize) {
      this.resizeBuffer(requiredSize * 2);
    }
  }
  resizeBuffer(newSize) {
    const newBuffer = new ArrayBuffer(newSize);
    const newBytes = new Uint8Array(newBuffer);
    const newView = new DataView(newBuffer);
    newBytes.set(this.bytes);
    this.view = newView;
    this.bytes = newBytes;
  }
  encodeNil() {
    this.writeU8(192);
  }
  encodeBoolean(object) {
    if (object === false) {
      this.writeU8(194);
    } else {
      this.writeU8(195);
    }
  }
  encodeNumber(object) {
    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
      if (object >= 0) {
        if (object < 128) {
          this.writeU8(object);
        } else if (object < 256) {
          this.writeU8(204);
          this.writeU8(object);
        } else if (object < 65536) {
          this.writeU8(205);
          this.writeU16(object);
        } else if (object < 4294967296) {
          this.writeU8(206);
          this.writeU32(object);
        } else if (!this.useBigInt64) {
          this.writeU8(207);
          this.writeU64(object);
        } else {
          this.encodeNumberAsFloat(object);
        }
      } else {
        if (object >= -32) {
          this.writeU8(224 | object + 32);
        } else if (object >= -128) {
          this.writeU8(208);
          this.writeI8(object);
        } else if (object >= -32768) {
          this.writeU8(209);
          this.writeI16(object);
        } else if (object >= -2147483648) {
          this.writeU8(210);
          this.writeI32(object);
        } else if (!this.useBigInt64) {
          this.writeU8(211);
          this.writeI64(object);
        } else {
          this.encodeNumberAsFloat(object);
        }
      }
    } else {
      this.encodeNumberAsFloat(object);
    }
  }
  encodeNumberAsFloat(object) {
    if (this.forceFloat32) {
      this.writeU8(202);
      this.writeF32(object);
    } else {
      this.writeU8(203);
      this.writeF64(object);
    }
  }
  encodeBigInt64(object) {
    if (object >= BigInt(0)) {
      this.writeU8(207);
      this.writeBigUint64(object);
    } else {
      this.writeU8(211);
      this.writeBigInt64(object);
    }
  }
  writeStringHeader(byteLength2) {
    if (byteLength2 < 32) {
      this.writeU8(160 + byteLength2);
    } else if (byteLength2 < 256) {
      this.writeU8(217);
      this.writeU8(byteLength2);
    } else if (byteLength2 < 65536) {
      this.writeU8(218);
      this.writeU16(byteLength2);
    } else if (byteLength2 < 4294967296) {
      this.writeU8(219);
      this.writeU32(byteLength2);
    } else {
      throw new Error(`Too long string: ${byteLength2} bytes in UTF-8`);
    }
  }
  encodeString(object) {
    const maxHeaderSize = 1 + 4;
    const byteLength2 = utf8Count(object);
    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength2);
    this.writeStringHeader(byteLength2);
    utf8Encode(object, this.bytes, this.pos);
    this.pos += byteLength2;
  }
  encodeObject(object, depth) {
    const ext = this.extensionCodec.tryToEncode(object, this.context);
    if (ext != null) {
      this.encodeExtension(ext);
    } else if (Array.isArray(object)) {
      this.encodeArray(object, depth);
    } else if (ArrayBuffer.isView(object)) {
      this.encodeBinary(object);
    } else if (typeof object === "object") {
      this.encodeMap(object, depth);
    } else {
      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
    }
  }
  encodeBinary(object) {
    const size10 = object.byteLength;
    if (size10 < 256) {
      this.writeU8(196);
      this.writeU8(size10);
    } else if (size10 < 65536) {
      this.writeU8(197);
      this.writeU16(size10);
    } else if (size10 < 4294967296) {
      this.writeU8(198);
      this.writeU32(size10);
    } else {
      throw new Error(`Too large binary: ${size10}`);
    }
    const bytes = ensureUint8Array(object);
    this.writeU8a(bytes);
  }
  encodeArray(object, depth) {
    const size10 = object.length;
    if (size10 < 16) {
      this.writeU8(144 + size10);
    } else if (size10 < 65536) {
      this.writeU8(220);
      this.writeU16(size10);
    } else if (size10 < 4294967296) {
      this.writeU8(221);
      this.writeU32(size10);
    } else {
      throw new Error(`Too large array: ${size10}`);
    }
    for (const item of object) {
      this.doEncode(item, depth + 1);
    }
  }
  countWithoutUndefined(object, keys) {
    let count = 0;
    for (const key of keys) {
      if (object[key] !== void 0) {
        count++;
      }
    }
    return count;
  }
  encodeMap(object, depth) {
    const keys = Object.keys(object);
    if (this.sortKeys) {
      keys.sort();
    }
    const size10 = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
    if (size10 < 16) {
      this.writeU8(128 + size10);
    } else if (size10 < 65536) {
      this.writeU8(222);
      this.writeU16(size10);
    } else if (size10 < 4294967296) {
      this.writeU8(223);
      this.writeU32(size10);
    } else {
      throw new Error(`Too large map object: ${size10}`);
    }
    for (const key of keys) {
      const value2 = object[key];
      if (!(this.ignoreUndefined && value2 === void 0)) {
        this.encodeString(key);
        this.doEncode(value2, depth + 1);
      }
    }
  }
  encodeExtension(ext) {
    if (typeof ext.data === "function") {
      const data = ext.data(this.pos + 6);
      const size11 = data.length;
      if (size11 >= 4294967296) {
        throw new Error(`Too large extension object: ${size11}`);
      }
      this.writeU8(201);
      this.writeU32(size11);
      this.writeI8(ext.type);
      this.writeU8a(data);
      return;
    }
    const size10 = ext.data.length;
    if (size10 === 1) {
      this.writeU8(212);
    } else if (size10 === 2) {
      this.writeU8(213);
    } else if (size10 === 4) {
      this.writeU8(214);
    } else if (size10 === 8) {
      this.writeU8(215);
    } else if (size10 === 16) {
      this.writeU8(216);
    } else if (size10 < 256) {
      this.writeU8(199);
      this.writeU8(size10);
    } else if (size10 < 65536) {
      this.writeU8(200);
      this.writeU16(size10);
    } else if (size10 < 4294967296) {
      this.writeU8(201);
      this.writeU32(size10);
    } else {
      throw new Error(`Too large extension object: ${size10}`);
    }
    this.writeI8(ext.type);
    this.writeU8a(ext.data);
  }
  writeU8(value2) {
    this.ensureBufferSizeToWrite(1);
    this.view.setUint8(this.pos, value2);
    this.pos++;
  }
  writeU8a(values) {
    const size10 = values.length;
    this.ensureBufferSizeToWrite(size10);
    this.bytes.set(values, this.pos);
    this.pos += size10;
  }
  writeI8(value2) {
    this.ensureBufferSizeToWrite(1);
    this.view.setInt8(this.pos, value2);
    this.pos++;
  }
  writeU16(value2) {
    this.ensureBufferSizeToWrite(2);
    this.view.setUint16(this.pos, value2);
    this.pos += 2;
  }
  writeI16(value2) {
    this.ensureBufferSizeToWrite(2);
    this.view.setInt16(this.pos, value2);
    this.pos += 2;
  }
  writeU32(value2) {
    this.ensureBufferSizeToWrite(4);
    this.view.setUint32(this.pos, value2);
    this.pos += 4;
  }
  writeI32(value2) {
    this.ensureBufferSizeToWrite(4);
    this.view.setInt32(this.pos, value2);
    this.pos += 4;
  }
  writeF32(value2) {
    this.ensureBufferSizeToWrite(4);
    this.view.setFloat32(this.pos, value2);
    this.pos += 4;
  }
  writeF64(value2) {
    this.ensureBufferSizeToWrite(8);
    this.view.setFloat64(this.pos, value2);
    this.pos += 8;
  }
  writeU64(value2) {
    this.ensureBufferSizeToWrite(8);
    setUint64(this.view, this.pos, value2);
    this.pos += 8;
  }
  writeI64(value2) {
    this.ensureBufferSizeToWrite(8);
    setInt64(this.view, this.pos, value2);
    this.pos += 8;
  }
  writeBigUint64(value2) {
    this.ensureBufferSizeToWrite(8);
    this.view.setBigUint64(this.pos, value2);
    this.pos += 8;
  }
  writeBigInt64(value2) {
    this.ensureBufferSizeToWrite(8);
    this.view.setBigInt64(this.pos, value2);
    this.pos += 8;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/encode.mjs
function encode4(value2, options) {
  const encoder = new Encoder(options);
  return encoder.encodeSharedRef(value2);
}

// node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
}

// node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH = 16;
var DEFAULT_MAX_LENGTH_PER_KEY = 16;
var CachedKeyDecoder = class {
  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
    this.hit = 0;
    this.miss = 0;
    this.maxKeyLength = maxKeyLength;
    this.maxLengthPerKey = maxLengthPerKey;
    this.caches = [];
    for (let i6 = 0; i6 < this.maxKeyLength; i6++) {
      this.caches.push([]);
    }
  }
  canBeCached(byteLength2) {
    return byteLength2 > 0 && byteLength2 <= this.maxKeyLength;
  }
  find(bytes, inputOffset, byteLength2) {
    const records = this.caches[byteLength2 - 1];
    FIND_CHUNK: for (const record of records) {
      const recordBytes = record.bytes;
      for (let j6 = 0; j6 < byteLength2; j6++) {
        if (recordBytes[j6] !== bytes[inputOffset + j6]) {
          continue FIND_CHUNK;
        }
      }
      return record.str;
    }
    return null;
  }
  store(bytes, value2) {
    const records = this.caches[bytes.length - 1];
    const record = { bytes, str: value2 };
    if (records.length >= this.maxLengthPerKey) {
      records[Math.random() * records.length | 0] = record;
    } else {
      records.push(record);
    }
  }
  decode(bytes, inputOffset, byteLength2) {
    const cachedValue = this.find(bytes, inputOffset, byteLength2);
    if (cachedValue != null) {
      this.hit++;
      return cachedValue;
    }
    this.miss++;
    const str = utf8DecodeJs(bytes, inputOffset, byteLength2);
    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength2);
    this.store(slicedCopyOfBytes, str);
    return str;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs
var STATE_ARRAY = "array";
var STATE_MAP_KEY = "map_key";
var STATE_MAP_VALUE = "map_value";
var mapKeyConverter = (key) => {
  if (typeof key === "string" || typeof key === "number") {
    return key;
  }
  throw new DecodeError("The type of key must be string or number but " + typeof key);
};
var StackPool = class {
  constructor() {
    this.stack = [];
    this.stackHeadPosition = -1;
  }
  get length() {
    return this.stackHeadPosition + 1;
  }
  top() {
    return this.stack[this.stackHeadPosition];
  }
  pushArrayState(size10) {
    const state = this.getUninitializedStateFromPool();
    state.type = STATE_ARRAY;
    state.position = 0;
    state.size = size10;
    state.array = new Array(size10);
  }
  pushMapState(size10) {
    const state = this.getUninitializedStateFromPool();
    state.type = STATE_MAP_KEY;
    state.readCount = 0;
    state.size = size10;
    state.map = {};
  }
  getUninitializedStateFromPool() {
    this.stackHeadPosition++;
    if (this.stackHeadPosition === this.stack.length) {
      const partialState = {
        type: void 0,
        size: 0,
        array: void 0,
        position: 0,
        readCount: 0,
        map: void 0,
        key: null
      };
      this.stack.push(partialState);
    }
    return this.stack[this.stackHeadPosition];
  }
  release(state) {
    const topStackState = this.stack[this.stackHeadPosition];
    if (topStackState !== state) {
      throw new Error("Invalid stack state. Released state is not on top of the stack.");
    }
    if (state.type === STATE_ARRAY) {
      const partialState = state;
      partialState.size = 0;
      partialState.array = void 0;
      partialState.position = 0;
      partialState.type = void 0;
    }
    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
      const partialState = state;
      partialState.size = 0;
      partialState.map = void 0;
      partialState.readCount = 0;
      partialState.type = void 0;
    }
    this.stackHeadPosition--;
  }
  reset() {
    this.stack.length = 0;
    this.stackHeadPosition = -1;
  }
};
var HEAD_BYTE_REQUIRED = -1;
var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
  EMPTY_VIEW.getInt8(0);
} catch (e9) {
  if (!(e9 instanceof RangeError)) {
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
  }
}
var MORE_DATA = new RangeError("Insufficient data");
var sharedCachedKeyDecoder = new CachedKeyDecoder();
var Decoder = class _Decoder {
  constructor(options) {
    this.totalPos = 0;
    this.pos = 0;
    this.view = EMPTY_VIEW;
    this.bytes = EMPTY_BYTES;
    this.headByte = HEAD_BYTE_REQUIRED;
    this.stack = new StackPool();
    this.entered = false;
    this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;
    this.context = options?.context;
    this.useBigInt64 = options?.useBigInt64 ?? false;
    this.rawStrings = options?.rawStrings ?? false;
    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;
    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;
    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;
    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;
    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;
    this.keyDecoder = options?.keyDecoder !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
    this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;
  }
  clone() {
    return new _Decoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      rawStrings: this.rawStrings,
      maxStrLength: this.maxStrLength,
      maxBinLength: this.maxBinLength,
      maxArrayLength: this.maxArrayLength,
      maxMapLength: this.maxMapLength,
      maxExtLength: this.maxExtLength,
      keyDecoder: this.keyDecoder
    });
  }
  reinitializeState() {
    this.totalPos = 0;
    this.headByte = HEAD_BYTE_REQUIRED;
    this.stack.reset();
  }
  setBuffer(buffer) {
    const bytes = ensureUint8Array(buffer);
    this.bytes = bytes;
    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    this.pos = 0;
  }
  appendBuffer(buffer) {
    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
      this.setBuffer(buffer);
    } else {
      const remainingData = this.bytes.subarray(this.pos);
      const newData = ensureUint8Array(buffer);
      const newBuffer = new Uint8Array(remainingData.length + newData.length);
      newBuffer.set(remainingData);
      newBuffer.set(newData, remainingData.length);
      this.setBuffer(newBuffer);
    }
  }
  hasRemaining(size10) {
    return this.view.byteLength - this.pos >= size10;
  }
  createExtraByteError(posToShow) {
    const { view, pos } = this;
    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
  }
  /**
   * @throws {@link DecodeError}
   * @throws {@link RangeError}
   */
  decode(buffer) {
    if (this.entered) {
      const instance = this.clone();
      return instance.decode(buffer);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.setBuffer(buffer);
      const object = this.doDecodeSync();
      if (this.hasRemaining(1)) {
        throw this.createExtraByteError(this.pos);
      }
      return object;
    } finally {
      this.entered = false;
    }
  }
  *decodeMulti(buffer) {
    if (this.entered) {
      const instance = this.clone();
      yield* instance.decodeMulti(buffer);
      return;
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.setBuffer(buffer);
      while (this.hasRemaining(1)) {
        yield this.doDecodeSync();
      }
    } finally {
      this.entered = false;
    }
  }
  async decodeAsync(stream) {
    if (this.entered) {
      const instance = this.clone();
      return instance.decodeAsync(stream);
    }
    try {
      this.entered = true;
      let decoded = false;
      let object;
      for await (const buffer of stream) {
        if (decoded) {
          this.entered = false;
          throw this.createExtraByteError(this.totalPos);
        }
        this.appendBuffer(buffer);
        try {
          object = this.doDecodeSync();
          decoded = true;
        } catch (e9) {
          if (!(e9 instanceof RangeError)) {
            throw e9;
          }
        }
        this.totalPos += this.pos;
      }
      if (decoded) {
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.totalPos);
        }
        return object;
      }
      const { headByte, pos, totalPos } = this;
      throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
    } finally {
      this.entered = false;
    }
  }
  decodeArrayStream(stream) {
    return this.decodeMultiAsync(stream, true);
  }
  decodeStream(stream) {
    return this.decodeMultiAsync(stream, false);
  }
  async *decodeMultiAsync(stream, isArray) {
    if (this.entered) {
      const instance = this.clone();
      yield* instance.decodeMultiAsync(stream, isArray);
      return;
    }
    try {
      this.entered = true;
      let isArrayHeaderRequired = isArray;
      let arrayItemsLeft = -1;
      for await (const buffer of stream) {
        if (isArray && arrayItemsLeft === 0) {
          throw this.createExtraByteError(this.totalPos);
        }
        this.appendBuffer(buffer);
        if (isArrayHeaderRequired) {
          arrayItemsLeft = this.readArraySize();
          isArrayHeaderRequired = false;
          this.complete();
        }
        try {
          while (true) {
            yield this.doDecodeSync();
            if (--arrayItemsLeft === 0) {
              break;
            }
          }
        } catch (e9) {
          if (!(e9 instanceof RangeError)) {
            throw e9;
          }
        }
        this.totalPos += this.pos;
      }
    } finally {
      this.entered = false;
    }
  }
  doDecodeSync() {
    DECODE: while (true) {
      const headByte = this.readHeadByte();
      let object;
      if (headByte >= 224) {
        object = headByte - 256;
      } else if (headByte < 192) {
        if (headByte < 128) {
          object = headByte;
        } else if (headByte < 144) {
          const size10 = headByte - 128;
          if (size10 !== 0) {
            this.pushMapState(size10);
            this.complete();
            continue DECODE;
          } else {
            object = {};
          }
        } else if (headByte < 160) {
          const size10 = headByte - 144;
          if (size10 !== 0) {
            this.pushArrayState(size10);
            this.complete();
            continue DECODE;
          } else {
            object = [];
          }
        } else {
          const byteLength2 = headByte - 160;
          object = this.decodeString(byteLength2, 0);
        }
      } else if (headByte === 192) {
        object = null;
      } else if (headByte === 194) {
        object = false;
      } else if (headByte === 195) {
        object = true;
      } else if (headByte === 202) {
        object = this.readF32();
      } else if (headByte === 203) {
        object = this.readF64();
      } else if (headByte === 204) {
        object = this.readU8();
      } else if (headByte === 205) {
        object = this.readU16();
      } else if (headByte === 206) {
        object = this.readU32();
      } else if (headByte === 207) {
        if (this.useBigInt64) {
          object = this.readU64AsBigInt();
        } else {
          object = this.readU64();
        }
      } else if (headByte === 208) {
        object = this.readI8();
      } else if (headByte === 209) {
        object = this.readI16();
      } else if (headByte === 210) {
        object = this.readI32();
      } else if (headByte === 211) {
        if (this.useBigInt64) {
          object = this.readI64AsBigInt();
        } else {
          object = this.readI64();
        }
      } else if (headByte === 217) {
        const byteLength2 = this.lookU8();
        object = this.decodeString(byteLength2, 1);
      } else if (headByte === 218) {
        const byteLength2 = this.lookU16();
        object = this.decodeString(byteLength2, 2);
      } else if (headByte === 219) {
        const byteLength2 = this.lookU32();
        object = this.decodeString(byteLength2, 4);
      } else if (headByte === 220) {
        const size10 = this.readU16();
        if (size10 !== 0) {
          this.pushArrayState(size10);
          this.complete();
          continue DECODE;
        } else {
          object = [];
        }
      } else if (headByte === 221) {
        const size10 = this.readU32();
        if (size10 !== 0) {
          this.pushArrayState(size10);
          this.complete();
          continue DECODE;
        } else {
          object = [];
        }
      } else if (headByte === 222) {
        const size10 = this.readU16();
        if (size10 !== 0) {
          this.pushMapState(size10);
          this.complete();
          continue DECODE;
        } else {
          object = {};
        }
      } else if (headByte === 223) {
        const size10 = this.readU32();
        if (size10 !== 0) {
          this.pushMapState(size10);
          this.complete();
          continue DECODE;
        } else {
          object = {};
        }
      } else if (headByte === 196) {
        const size10 = this.lookU8();
        object = this.decodeBinary(size10, 1);
      } else if (headByte === 197) {
        const size10 = this.lookU16();
        object = this.decodeBinary(size10, 2);
      } else if (headByte === 198) {
        const size10 = this.lookU32();
        object = this.decodeBinary(size10, 4);
      } else if (headByte === 212) {
        object = this.decodeExtension(1, 0);
      } else if (headByte === 213) {
        object = this.decodeExtension(2, 0);
      } else if (headByte === 214) {
        object = this.decodeExtension(4, 0);
      } else if (headByte === 215) {
        object = this.decodeExtension(8, 0);
      } else if (headByte === 216) {
        object = this.decodeExtension(16, 0);
      } else if (headByte === 199) {
        const size10 = this.lookU8();
        object = this.decodeExtension(size10, 1);
      } else if (headByte === 200) {
        const size10 = this.lookU16();
        object = this.decodeExtension(size10, 2);
      } else if (headByte === 201) {
        const size10 = this.lookU32();
        object = this.decodeExtension(size10, 4);
      } else {
        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
      }
      this.complete();
      const stack = this.stack;
      while (stack.length > 0) {
        const state = stack.top();
        if (state.type === STATE_ARRAY) {
          state.array[state.position] = object;
          state.position++;
          if (state.position === state.size) {
            object = state.array;
            stack.release(state);
          } else {
            continue DECODE;
          }
        } else if (state.type === STATE_MAP_KEY) {
          if (object === "__proto__") {
            throw new DecodeError("The key __proto__ is not allowed");
          }
          state.key = this.mapKeyConverter(object);
          state.type = STATE_MAP_VALUE;
          continue DECODE;
        } else {
          state.map[state.key] = object;
          state.readCount++;
          if (state.readCount === state.size) {
            object = state.map;
            stack.release(state);
          } else {
            state.key = null;
            state.type = STATE_MAP_KEY;
            continue DECODE;
          }
        }
      }
      return object;
    }
  }
  readHeadByte() {
    if (this.headByte === HEAD_BYTE_REQUIRED) {
      this.headByte = this.readU8();
    }
    return this.headByte;
  }
  complete() {
    this.headByte = HEAD_BYTE_REQUIRED;
  }
  readArraySize() {
    const headByte = this.readHeadByte();
    switch (headByte) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (headByte < 160) {
          return headByte - 144;
        } else {
          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);
        }
      }
    }
  }
  pushMapState(size10) {
    if (size10 > this.maxMapLength) {
      throw new DecodeError(`Max length exceeded: map length (${size10}) > maxMapLengthLength (${this.maxMapLength})`);
    }
    this.stack.pushMapState(size10);
  }
  pushArrayState(size10) {
    if (size10 > this.maxArrayLength) {
      throw new DecodeError(`Max length exceeded: array length (${size10}) > maxArrayLength (${this.maxArrayLength})`);
    }
    this.stack.pushArrayState(size10);
  }
  decodeString(byteLength2, headerOffset) {
    if (!this.rawStrings || this.stateIsMapKey()) {
      return this.decodeUtf8String(byteLength2, headerOffset);
    }
    return this.decodeBinary(byteLength2, headerOffset);
  }
  /**
   * @throws {@link RangeError}
   */
  decodeUtf8String(byteLength2, headerOffset) {
    if (byteLength2 > this.maxStrLength) {
      throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength2}) > maxStrLength (${this.maxStrLength})`);
    }
    if (this.bytes.byteLength < this.pos + headerOffset + byteLength2) {
      throw MORE_DATA;
    }
    const offset = this.pos + headerOffset;
    let object;
    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength2)) {
      object = this.keyDecoder.decode(this.bytes, offset, byteLength2);
    } else {
      object = utf8Decode(this.bytes, offset, byteLength2);
    }
    this.pos += headerOffset + byteLength2;
    return object;
  }
  stateIsMapKey() {
    if (this.stack.length > 0) {
      const state = this.stack.top();
      return state.type === STATE_MAP_KEY;
    }
    return false;
  }
  /**
   * @throws {@link RangeError}
   */
  decodeBinary(byteLength2, headOffset) {
    if (byteLength2 > this.maxBinLength) {
      throw new DecodeError(`Max length exceeded: bin length (${byteLength2}) > maxBinLength (${this.maxBinLength})`);
    }
    if (!this.hasRemaining(byteLength2 + headOffset)) {
      throw MORE_DATA;
    }
    const offset = this.pos + headOffset;
    const object = this.bytes.subarray(offset, offset + byteLength2);
    this.pos += headOffset + byteLength2;
    return object;
  }
  decodeExtension(size10, headOffset) {
    if (size10 > this.maxExtLength) {
      throw new DecodeError(`Max length exceeded: ext length (${size10}) > maxExtLength (${this.maxExtLength})`);
    }
    const extType = this.view.getInt8(this.pos + headOffset);
    const data = this.decodeBinary(
      size10,
      headOffset + 1
      /* extType */
    );
    return this.extensionCodec.decode(data, extType, this.context);
  }
  lookU8() {
    return this.view.getUint8(this.pos);
  }
  lookU16() {
    return this.view.getUint16(this.pos);
  }
  lookU32() {
    return this.view.getUint32(this.pos);
  }
  readU8() {
    const value2 = this.view.getUint8(this.pos);
    this.pos++;
    return value2;
  }
  readI8() {
    const value2 = this.view.getInt8(this.pos);
    this.pos++;
    return value2;
  }
  readU16() {
    const value2 = this.view.getUint16(this.pos);
    this.pos += 2;
    return value2;
  }
  readI16() {
    const value2 = this.view.getInt16(this.pos);
    this.pos += 2;
    return value2;
  }
  readU32() {
    const value2 = this.view.getUint32(this.pos);
    this.pos += 4;
    return value2;
  }
  readI32() {
    const value2 = this.view.getInt32(this.pos);
    this.pos += 4;
    return value2;
  }
  readU64() {
    const value2 = getUint64(this.view, this.pos);
    this.pos += 8;
    return value2;
  }
  readI64() {
    const value2 = getInt64(this.view, this.pos);
    this.pos += 8;
    return value2;
  }
  readU64AsBigInt() {
    const value2 = this.view.getBigUint64(this.pos);
    this.pos += 8;
    return value2;
  }
  readI64AsBigInt() {
    const value2 = this.view.getBigInt64(this.pos);
    this.pos += 8;
    return value2;
  }
  readF32() {
    const value2 = this.view.getFloat32(this.pos);
    this.pos += 4;
    return value2;
  }
  readF64() {
    const value2 = this.view.getFloat64(this.pos);
    this.pos += 8;
    return value2;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/decode.mjs
function decode2(buffer, options) {
  const decoder = new Decoder(options);
  return decoder.decode(buffer);
}

// node_modules/@walletconnect/ethereum-provider/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@walletconnect/ethereum-provider/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size10 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size10));
  }
  return new Uint8Array(size10);
}

// node_modules/@walletconnect/ethereum-provider/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name, prefix, encode12, decode7) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode12
    },
    decoder: { decode: decode7 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string4 = "a";
  for (let i6 = 0; i6 < buf.length; i6++) {
    string4 += String.fromCharCode(buf[i6]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i6 = 0; i6 < str.length; i6++) {
    buf[i6] = str.charCodeAt(i6);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs = __toESM(require_blakejs());
function _s(t4, e9 = []) {
  const n4 = [];
  return Object.keys(t4).forEach((r6) => {
    if (e9.length && !e9.includes(r6)) return;
    const o4 = t4[r6];
    n4.push(...o4.accounts);
  }), n4;
}
var Be = BigInt(2 ** 32 - 1);
var yr = BigInt(32);
function mr(t4, e9 = false) {
  return e9 ? { h: Number(t4 & Be), l: Number(t4 >> yr & Be) } : { h: Number(t4 >> yr & Be) | 0, l: Number(t4 & Be) | 0 };
}
function wr(t4, e9 = false) {
  const n4 = t4.length;
  let r6 = new Uint32Array(n4), o4 = new Uint32Array(n4);
  for (let s3 = 0; s3 < n4; s3++) {
    const { h: i6, l: f12 } = mr(t4[s3], e9);
    [r6[s3], o4[s3]] = [i6, f12];
  }
  return [r6, o4];
}
var xr = (t4, e9, n4) => t4 >>> n4;
var vr = (t4, e9, n4) => t4 << 32 - n4 | e9 >>> n4;
var At = (t4, e9, n4) => t4 >>> n4 | e9 << 32 - n4;
var St = (t4, e9, n4) => t4 << 32 - n4 | e9 >>> n4;
var se = (t4, e9, n4) => t4 << 64 - n4 | e9 >>> n4 - 32;
var ie = (t4, e9, n4) => t4 >>> n4 - 32 | e9 << 64 - n4;
var bi = (t4, e9) => e9;
var yi = (t4, e9) => t4;
var mi = (t4, e9, n4) => t4 << n4 | e9 >>> 32 - n4;
var wi = (t4, e9, n4) => e9 << n4 | t4 >>> 32 - n4;
var xi = (t4, e9, n4) => e9 << n4 - 32 | t4 >>> 64 - n4;
var vi = (t4, e9, n4) => t4 << n4 - 32 | e9 >>> 64 - n4;
function dt(t4, e9, n4, r6) {
  const o4 = (e9 >>> 0) + (r6 >>> 0);
  return { h: t4 + n4 + (o4 / 2 ** 32 | 0) | 0, l: o4 | 0 };
}
var tn = (t4, e9, n4) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0);
var en = (t4, e9, n4, r6) => e9 + n4 + r6 + (t4 / 2 ** 32 | 0) | 0;
var Ei = (t4, e9, n4, r6) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0) + (r6 >>> 0);
var Bi = (t4, e9, n4, r6, o4) => e9 + n4 + r6 + o4 + (t4 / 2 ** 32 | 0) | 0;
var Ii = (t4, e9, n4, r6, o4) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0) + (r6 >>> 0) + (o4 >>> 0);
var Ai = (t4, e9, n4, r6, o4, s3) => e9 + n4 + r6 + o4 + s3 + (t4 / 2 ** 32 | 0) | 0;
var Gt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn(t4) {
  return t4 instanceof Uint8Array || ArrayBuffer.isView(t4) && t4.constructor.name === "Uint8Array";
}
function mt(t4) {
  if (!Number.isSafeInteger(t4) || t4 < 0) throw new Error("positive integer expected, got " + t4);
}
function at(t4, ...e9) {
  if (!nn(t4)) throw new Error("Uint8Array expected");
  if (e9.length > 0 && !e9.includes(t4.length)) throw new Error("Uint8Array expected of length " + e9 + ", got length=" + t4.length);
}
function rn(t4) {
  if (typeof t4 != "function" || typeof t4.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t4.outputLen), mt(t4.blockLen);
}
function Nt(t4, e9 = true) {
  if (t4.destroyed) throw new Error("Hash instance has been destroyed");
  if (e9 && t4.finished) throw new Error("Hash#digest() has already been called");
}
function on(t4, e9) {
  at(t4);
  const n4 = e9.outputLen;
  if (t4.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function fe(t4) {
  return new Uint32Array(t4.buffer, t4.byteOffset, Math.floor(t4.byteLength / 4));
}
function ut(...t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9].fill(0);
}
function sn2(t4) {
  return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
}
function gt(t4, e9) {
  return t4 << 32 - e9 | t4 >>> e9;
}
var Er = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br(t4) {
  return t4 << 24 & 4278190080 | t4 << 8 & 16711680 | t4 >>> 8 & 65280 | t4 >>> 24 & 255;
}
var wt = Er ? (t4) => t4 : (t4) => Br(t4);
function Si(t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9] = Br(t4[e9]);
  return t4;
}
var Ot = Er ? (t4) => t4 : Si;
var Ir = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni = Array.from({ length: 256 }, (t4, e9) => e9.toString(16).padStart(2, "0"));
function ce(t4) {
  if (at(t4), Ir) return t4.toHex();
  let e9 = "";
  for (let n4 = 0; n4 < t4.length; n4++) e9 += Ni[t4[n4]];
  return e9;
}
var xt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar(t4) {
  if (t4 >= xt._0 && t4 <= xt._9) return t4 - xt._0;
  if (t4 >= xt.A && t4 <= xt.F) return t4 - (xt.A - 10);
  if (t4 >= xt.a && t4 <= xt.f) return t4 - (xt.a - 10);
}
function fn(t4) {
  if (typeof t4 != "string") throw new Error("hex string expected, got " + typeof t4);
  if (Ir) return Uint8Array.fromHex(t4);
  const e9 = t4.length, n4 = e9 / 2;
  if (e9 % 2) throw new Error("hex string expected, got unpadded hex of length " + e9);
  const r6 = new Uint8Array(n4);
  for (let o4 = 0, s3 = 0; o4 < n4; o4++, s3 += 2) {
    const i6 = Ar(t4.charCodeAt(s3)), f12 = Ar(t4.charCodeAt(s3 + 1));
    if (i6 === void 0 || f12 === void 0) {
      const a4 = t4[s3] + t4[s3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a4 + '" at index ' + s3);
    }
    r6[o4] = i6 * 16 + f12;
  }
  return r6;
}
function Oi(t4) {
  if (typeof t4 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t4));
}
function ht(t4) {
  return typeof t4 == "string" && (t4 = Oi(t4)), at(t4), t4;
}
function Ht(...t4) {
  let e9 = 0;
  for (let r6 = 0; r6 < t4.length; r6++) {
    const o4 = t4[r6];
    at(o4), e9 += o4.length;
  }
  const n4 = new Uint8Array(e9);
  for (let r6 = 0, o4 = 0; r6 < t4.length; r6++) {
    const s3 = t4[r6];
    n4.set(s3, o4), o4 += s3.length;
  }
  return n4;
}
var Ie = class {
};
function ae(t4) {
  const e9 = (r6) => t4().update(ht(r6)).digest(), n4 = t4();
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = () => t4(), e9;
}
function Ui(t4) {
  const e9 = (r6, o4) => t4(o4).update(ht(r6)).digest(), n4 = t4({});
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = (r6) => t4(r6), e9;
}
function Zt(t4 = 32) {
  if (Gt && typeof Gt.getRandomValues == "function") return Gt.getRandomValues(new Uint8Array(t4));
  if (Gt && typeof Gt.randomBytes == "function") return Uint8Array.from(Gt.randomBytes(t4));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i = BigInt(0);
var ue = BigInt(1);
var Ti = BigInt(2);
var Ri = BigInt(7);
var $i = BigInt(256);
var Ci = BigInt(113);
var Sr = [];
var Nr = [];
var Or = [];
for (let t4 = 0, e9 = ue, n4 = 1, r6 = 0; t4 < 24; t4++) {
  [n4, r6] = [r6, (2 * n4 + 3 * r6) % 5], Sr.push(2 * (5 * r6 + n4)), Nr.push((t4 + 1) * (t4 + 2) / 2 % 64);
  let o4 = _i;
  for (let s3 = 0; s3 < 7; s3++) e9 = (e9 << ue ^ (e9 >> Ri) * Ci) % $i, e9 & Ti && (o4 ^= ue << (ue << BigInt(s3)) - ue);
  Or.push(o4);
}
var Ur = wr(Or, true);
var Li = Ur[0];
var ji = Ur[1];
var _r = (t4, e9, n4) => n4 > 32 ? xi(t4, e9, n4) : mi(t4, e9, n4);
var Tr = (t4, e9, n4) => n4 > 32 ? vi(t4, e9, n4) : wi(t4, e9, n4);
function ki(t4, e9 = 24) {
  const n4 = new Uint32Array(10);
  for (let r6 = 24 - e9; r6 < 24; r6++) {
    for (let i6 = 0; i6 < 10; i6++) n4[i6] = t4[i6] ^ t4[i6 + 10] ^ t4[i6 + 20] ^ t4[i6 + 30] ^ t4[i6 + 40];
    for (let i6 = 0; i6 < 10; i6 += 2) {
      const f12 = (i6 + 8) % 10, a4 = (i6 + 2) % 10, l6 = n4[a4], c6 = n4[a4 + 1], u6 = _r(l6, c6, 1) ^ n4[f12], h7 = Tr(l6, c6, 1) ^ n4[f12 + 1];
      for (let g3 = 0; g3 < 50; g3 += 10) t4[i6 + g3] ^= u6, t4[i6 + g3 + 1] ^= h7;
    }
    let o4 = t4[2], s3 = t4[3];
    for (let i6 = 0; i6 < 24; i6++) {
      const f12 = Nr[i6], a4 = _r(o4, s3, f12), l6 = Tr(o4, s3, f12), c6 = Sr[i6];
      o4 = t4[c6], s3 = t4[c6 + 1], t4[c6] = a4, t4[c6 + 1] = l6;
    }
    for (let i6 = 0; i6 < 50; i6 += 10) {
      for (let f12 = 0; f12 < 10; f12++) n4[f12] = t4[i6 + f12];
      for (let f12 = 0; f12 < 10; f12++) t4[i6 + f12] ^= ~n4[(f12 + 2) % 10] & n4[(f12 + 4) % 10];
    }
    t4[0] ^= Li[r6], t4[1] ^= ji[r6];
  }
  ut(n4);
}
var qn = class _qn extends Ie {
  constructor(e9, n4, r6, o4 = false, s3 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e9, this.suffix = n4, this.outputLen = r6, this.enableXOF = o4, this.rounds = s3, mt(r6), !(0 < e9 && e9 < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot(this.state32), ki(this.state32, this.rounds), Ot(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e9) {
    Nt(this), e9 = ht(e9), at(e9);
    const { blockLen: n4, state: r6 } = this, o4 = e9.length;
    for (let s3 = 0; s3 < o4; ) {
      const i6 = Math.min(n4 - this.pos, o4 - s3);
      for (let f12 = 0; f12 < i6; f12++) r6[this.pos++] ^= e9[s3++];
      this.pos === n4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e9, suffix: n4, pos: r6, blockLen: o4 } = this;
    e9[r6] ^= n4, (n4 & 128) !== 0 && r6 === o4 - 1 && this.keccak(), e9[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(e9) {
    Nt(this, false), at(e9), this.finish();
    const n4 = this.state, { blockLen: r6 } = this;
    for (let o4 = 0, s3 = e9.length; o4 < s3; ) {
      this.posOut >= r6 && this.keccak();
      const i6 = Math.min(r6 - this.posOut, s3 - o4);
      e9.set(n4.subarray(this.posOut, this.posOut + i6), o4), this.posOut += i6, o4 += i6;
    }
    return e9;
  }
  xofInto(e9) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e9);
  }
  xof(e9) {
    return mt(e9), this.xofInto(new Uint8Array(e9));
  }
  digestInto(e9) {
    if (on(e9, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e9), this.destroy(), e9;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut(this.state);
  }
  _cloneInto(e9) {
    const { blockLen: n4, suffix: r6, outputLen: o4, rounds: s3, enableXOF: i6 } = this;
    return e9 || (e9 = new _qn(n4, r6, o4, i6, s3)), e9.state32.set(this.state32), e9.pos = this.pos, e9.posOut = this.posOut, e9.finished = this.finished, e9.rounds = s3, e9.suffix = r6, e9.outputLen = o4, e9.enableXOF = i6, e9.destroyed = this.destroyed, e9;
  }
};
var Pi = (t4, e9, n4) => ae(() => new qn(e9, t4, n4));
var Hi = Pi(1, 136, 256 / 8);
function Di(t4, e9, n4, r6) {
  if (typeof t4.setBigUint64 == "function") return t4.setBigUint64(e9, n4, r6);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i6 = Number(n4 >> o4 & s3), f12 = Number(n4 & s3), a4 = r6 ? 4 : 0, l6 = r6 ? 0 : 4;
  t4.setUint32(e9 + a4, i6, r6), t4.setUint32(e9 + l6, f12, r6);
}
function Mi(t4, e9, n4) {
  return t4 & e9 ^ ~t4 & n4;
}
function Vi(t4, e9, n4) {
  return t4 & e9 ^ t4 & n4 ^ e9 & n4;
}
var Rr = class extends Ie {
  constructor(e9, n4, r6, o4) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e9, this.outputLen = n4, this.padOffset = r6, this.isLE = o4, this.buffer = new Uint8Array(e9), this.view = sn2(this.buffer);
  }
  update(e9) {
    Nt(this), e9 = ht(e9), at(e9);
    const { view: n4, buffer: r6, blockLen: o4 } = this, s3 = e9.length;
    for (let i6 = 0; i6 < s3; ) {
      const f12 = Math.min(o4 - this.pos, s3 - i6);
      if (f12 === o4) {
        const a4 = sn2(e9);
        for (; o4 <= s3 - i6; i6 += o4) this.process(a4, i6);
        continue;
      }
      r6.set(e9.subarray(i6, i6 + f12), this.pos), this.pos += f12, i6 += f12, this.pos === o4 && (this.process(n4, 0), this.pos = 0);
    }
    return this.length += e9.length, this.roundClean(), this;
  }
  digestInto(e9) {
    Nt(this), on(e9, this), this.finished = true;
    const { buffer: n4, view: r6, blockLen: o4, isLE: s3 } = this;
    let { pos: i6 } = this;
    n4[i6++] = 128, ut(this.buffer.subarray(i6)), this.padOffset > o4 - i6 && (this.process(r6, 0), i6 = 0);
    for (let u6 = i6; u6 < o4; u6++) n4[u6] = 0;
    Di(r6, o4 - 8, BigInt(this.length * 8), s3), this.process(r6, 0);
    const f12 = sn2(e9), a4 = this.outputLen;
    if (a4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l6 = a4 / 4, c6 = this.get();
    if (l6 > c6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u6 = 0; u6 < l6; u6++) f12.setUint32(4 * u6, c6[u6], s3);
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
  _cloneInto(e9) {
    e9 || (e9 = new this.constructor()), e9.set(...this.get());
    const { blockLen: n4, buffer: r6, length: o4, finished: s3, destroyed: i6, pos: f12 } = this;
    return e9.destroyed = i6, e9.finished = s3, e9.length = o4, e9.pos = f12, o4 % n4 && e9.buffer.set(r6), e9;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t = new Uint32Array(64);
var Ki = class extends Rr {
  constructor(e9 = 32) {
    super(64, e9, 8, false), this.A = Ut[0] | 0, this.B = Ut[1] | 0, this.C = Ut[2] | 0, this.D = Ut[3] | 0, this.E = Ut[4] | 0, this.F = Ut[5] | 0, this.G = Ut[6] | 0, this.H = Ut[7] | 0;
  }
  get() {
    const { A: e9, B: n4, C: r6, D: o4, E: s3, F: i6, G: f12, H: a4 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4) {
    this.A = e9 | 0, this.B = n4 | 0, this.C = r6 | 0, this.D = o4 | 0, this.E = s3 | 0, this.F = i6 | 0, this.G = f12 | 0, this.H = a4 | 0;
  }
  process(e9, n4) {
    for (let u6 = 0; u6 < 16; u6++, n4 += 4) _t[u6] = e9.getUint32(n4, false);
    for (let u6 = 16; u6 < 64; u6++) {
      const h7 = _t[u6 - 15], g3 = _t[u6 - 2], w6 = gt(h7, 7) ^ gt(h7, 18) ^ h7 >>> 3, y8 = gt(g3, 17) ^ gt(g3, 19) ^ g3 >>> 10;
      _t[u6] = y8 + _t[u6 - 7] + w6 + _t[u6 - 16] | 0;
    }
    let { A: r6, B: o4, C: s3, D: i6, E: f12, F: a4, G: l6, H: c6 } = this;
    for (let u6 = 0; u6 < 64; u6++) {
      const h7 = gt(f12, 6) ^ gt(f12, 11) ^ gt(f12, 25), g3 = c6 + h7 + Mi(f12, a4, l6) + qi[u6] + _t[u6] | 0, y8 = (gt(r6, 2) ^ gt(r6, 13) ^ gt(r6, 22)) + Vi(r6, o4, s3) | 0;
      c6 = l6, l6 = a4, a4 = f12, f12 = i6 + g3 | 0, i6 = s3, s3 = o4, o4 = r6, r6 = g3 + y8 | 0;
    }
    r6 = r6 + this.A | 0, o4 = o4 + this.B | 0, s3 = s3 + this.C | 0, i6 = i6 + this.D | 0, f12 = f12 + this.E | 0, a4 = a4 + this.F | 0, l6 = l6 + this.G | 0, c6 = c6 + this.H | 0, this.set(r6, o4, s3, i6, f12, a4, l6, c6);
  }
  roundClean() {
    ut(_t);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut(this.buffer);
  }
};
var $r = wr(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t4) => BigInt(t4)));
var Fi = $r[0];
var zi = $r[1];
var Tt = new Uint32Array(80);
var Rt = new Uint32Array(80);
var cn = class extends Rr {
  constructor(e9 = 64) {
    super(128, e9, 16, false), this.Ah = Y[0] | 0, this.Al = Y[1] | 0, this.Bh = Y[2] | 0, this.Bl = Y[3] | 0, this.Ch = Y[4] | 0, this.Cl = Y[5] | 0, this.Dh = Y[6] | 0, this.Dl = Y[7] | 0, this.Eh = Y[8] | 0, this.El = Y[9] | 0, this.Fh = Y[10] | 0, this.Fl = Y[11] | 0, this.Gh = Y[12] | 0, this.Gl = Y[13] | 0, this.Hh = Y[14] | 0, this.Hl = Y[15] | 0;
  }
  get() {
    const { Ah: e9, Al: n4, Bh: r6, Bl: o4, Ch: s3, Cl: i6, Dh: f12, Dl: a4, Eh: l6, El: c6, Fh: u6, Fl: h7, Gh: g3, Gl: w6, Hh: y8, Hl: x5 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5) {
    this.Ah = e9 | 0, this.Al = n4 | 0, this.Bh = r6 | 0, this.Bl = o4 | 0, this.Ch = s3 | 0, this.Cl = i6 | 0, this.Dh = f12 | 0, this.Dl = a4 | 0, this.Eh = l6 | 0, this.El = c6 | 0, this.Fh = u6 | 0, this.Fl = h7 | 0, this.Gh = g3 | 0, this.Gl = w6 | 0, this.Hh = y8 | 0, this.Hl = x5 | 0;
  }
  process(e9, n4) {
    for (let L6 = 0; L6 < 16; L6++, n4 += 4) Tt[L6] = e9.getUint32(n4), Rt[L6] = e9.getUint32(n4 += 4);
    for (let L6 = 16; L6 < 80; L6++) {
      const V7 = Tt[L6 - 15] | 0, _4 = Rt[L6 - 15] | 0, k8 = At(V7, _4, 1) ^ At(V7, _4, 8) ^ xr(V7, _4, 7), j6 = St(V7, _4, 1) ^ St(V7, _4, 8) ^ vr(V7, _4, 7), $7 = Tt[L6 - 2] | 0, d5 = Rt[L6 - 2] | 0, m5 = At($7, d5, 19) ^ se($7, d5, 61) ^ xr($7, d5, 6), p7 = St($7, d5, 19) ^ ie($7, d5, 61) ^ vr($7, d5, 6), b5 = Ei(j6, p7, Rt[L6 - 7], Rt[L6 - 16]), v7 = Bi(b5, k8, m5, Tt[L6 - 7], Tt[L6 - 16]);
      Tt[L6] = v7 | 0, Rt[L6] = b5 | 0;
    }
    let { Ah: r6, Al: o4, Bh: s3, Bl: i6, Ch: f12, Cl: a4, Dh: l6, Dl: c6, Eh: u6, El: h7, Fh: g3, Fl: w6, Gh: y8, Gl: x5, Hh: R6, Hl: M7 } = this;
    for (let L6 = 0; L6 < 80; L6++) {
      const V7 = At(u6, h7, 14) ^ At(u6, h7, 18) ^ se(u6, h7, 41), _4 = St(u6, h7, 14) ^ St(u6, h7, 18) ^ ie(u6, h7, 41), k8 = u6 & g3 ^ ~u6 & y8, j6 = h7 & w6 ^ ~h7 & x5, $7 = Ii(M7, _4, j6, zi[L6], Rt[L6]), d5 = Ai($7, R6, V7, k8, Fi[L6], Tt[L6]), m5 = $7 | 0, p7 = At(r6, o4, 28) ^ se(r6, o4, 34) ^ se(r6, o4, 39), b5 = St(r6, o4, 28) ^ ie(r6, o4, 34) ^ ie(r6, o4, 39), v7 = r6 & s3 ^ r6 & f12 ^ s3 & f12, B7 = o4 & i6 ^ o4 & a4 ^ i6 & a4;
      R6 = y8 | 0, M7 = x5 | 0, y8 = g3 | 0, x5 = w6 | 0, g3 = u6 | 0, w6 = h7 | 0, { h: u6, l: h7 } = dt(l6 | 0, c6 | 0, d5 | 0, m5 | 0), l6 = f12 | 0, c6 = a4 | 0, f12 = s3 | 0, a4 = i6 | 0, s3 = r6 | 0, i6 = o4 | 0;
      const E7 = tn(m5, b5, B7);
      r6 = en(E7, d5, p7, v7), o4 = E7 | 0;
    }
    ({ h: r6, l: o4 } = dt(this.Ah | 0, this.Al | 0, r6 | 0, o4 | 0)), { h: s3, l: i6 } = dt(this.Bh | 0, this.Bl | 0, s3 | 0, i6 | 0), { h: f12, l: a4 } = dt(this.Ch | 0, this.Cl | 0, f12 | 0, a4 | 0), { h: l6, l: c6 } = dt(this.Dh | 0, this.Dl | 0, l6 | 0, c6 | 0), { h: u6, l: h7 } = dt(this.Eh | 0, this.El | 0, u6 | 0, h7 | 0), { h: g3, l: w6 } = dt(this.Fh | 0, this.Fl | 0, g3 | 0, w6 | 0), { h: y8, l: x5 } = dt(this.Gh | 0, this.Gl | 0, y8 | 0, x5 | 0), { h: R6, l: M7 } = dt(this.Hh | 0, this.Hl | 0, R6 | 0, M7 | 0), this.set(r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5, R6, M7);
  }
  roundClean() {
    ut(Tt, Rt);
  }
  destroy() {
    ut(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi = class extends cn {
  constructor() {
    super(48), this.Ah = W[0] | 0, this.Al = W[1] | 0, this.Bh = W[2] | 0, this.Bl = W[3] | 0, this.Ch = W[4] | 0, this.Cl = W[5] | 0, this.Dh = W[6] | 0, this.Dl = W[7] | 0, this.Eh = W[8] | 0, this.El = W[9] | 0, this.Fh = W[10] | 0, this.Fl = W[11] | 0, this.Gh = W[12] | 0, this.Gl = W[13] | 0, this.Hh = W[14] | 0, this.Hl = W[15] | 0;
  }
};
var X = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi = class extends cn {
  constructor() {
    super(32), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Ae = ae(() => new Ki());
var Wi = ae(() => new cn());
var Yi = ae(() => new Gi());
var Xi = ae(() => new Zi());
var Ji = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N = new Uint32Array(32);
function $t(t4, e9, n4, r6, o4, s3) {
  const i6 = o4[s3], f12 = o4[s3 + 1];
  let a4 = N[2 * t4], l6 = N[2 * t4 + 1], c6 = N[2 * e9], u6 = N[2 * e9 + 1], h7 = N[2 * n4], g3 = N[2 * n4 + 1], w6 = N[2 * r6], y8 = N[2 * r6 + 1], x5 = tn(a4, c6, i6);
  l6 = en(x5, l6, u6, f12), a4 = x5 | 0, { Dh: y8, Dl: w6 } = { Dh: y8 ^ l6, Dl: w6 ^ a4 }, { Dh: y8, Dl: w6 } = { Dh: bi(y8, w6), Dl: yi(y8) }, { h: g3, l: h7 } = dt(g3, h7, y8, w6), { Bh: u6, Bl: c6 } = { Bh: u6 ^ g3, Bl: c6 ^ h7 }, { Bh: u6, Bl: c6 } = { Bh: At(u6, c6, 24), Bl: St(u6, c6, 24) }, N[2 * t4] = a4, N[2 * t4 + 1] = l6, N[2 * e9] = c6, N[2 * e9 + 1] = u6, N[2 * n4] = h7, N[2 * n4 + 1] = g3, N[2 * r6] = w6, N[2 * r6 + 1] = y8;
}
function Ct(t4, e9, n4, r6, o4, s3) {
  const i6 = o4[s3], f12 = o4[s3 + 1];
  let a4 = N[2 * t4], l6 = N[2 * t4 + 1], c6 = N[2 * e9], u6 = N[2 * e9 + 1], h7 = N[2 * n4], g3 = N[2 * n4 + 1], w6 = N[2 * r6], y8 = N[2 * r6 + 1], x5 = tn(a4, c6, i6);
  l6 = en(x5, l6, u6, f12), a4 = x5 | 0, { Dh: y8, Dl: w6 } = { Dh: y8 ^ l6, Dl: w6 ^ a4 }, { Dh: y8, Dl: w6 } = { Dh: At(y8, w6, 16), Dl: St(y8, w6, 16) }, { h: g3, l: h7 } = dt(g3, h7, y8, w6), { Bh: u6, Bl: c6 } = { Bh: u6 ^ g3, Bl: c6 ^ h7 }, { Bh: u6, Bl: c6 } = { Bh: se(u6, c6, 63), Bl: ie(u6, c6, 63) }, N[2 * t4] = a4, N[2 * t4 + 1] = l6, N[2 * e9] = c6, N[2 * e9 + 1] = u6, N[2 * n4] = h7, N[2 * n4 + 1] = g3, N[2 * r6] = w6, N[2 * r6 + 1] = y8;
}
function Qi(t4, e9 = {}, n4, r6, o4) {
  if (mt(n4), t4 < 0 || t4 > n4) throw new Error("outputLen bigger than keyLen");
  const { key: s3, salt: i6, personalization: f12 } = e9;
  if (s3 !== void 0 && (s3.length < 1 || s3.length > n4)) throw new Error("key length must be undefined or 1.." + n4);
  if (i6 !== void 0 && i6.length !== r6) throw new Error("salt must be undefined or " + r6);
  if (f12 !== void 0 && f12.length !== o4) throw new Error("personalization must be undefined or " + o4);
}
var tf = class extends Ie {
  constructor(e9, n4) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e9), mt(n4), this.blockLen = e9, this.outputLen = n4, this.buffer = new Uint8Array(e9), this.buffer32 = fe(this.buffer);
  }
  update(e9) {
    Nt(this), e9 = ht(e9), at(e9);
    const { blockLen: n4, buffer: r6, buffer32: o4 } = this, s3 = e9.length, i6 = e9.byteOffset, f12 = e9.buffer;
    for (let a4 = 0; a4 < s3; ) {
      this.pos === n4 && (Ot(o4), this.compress(o4, 0, false), Ot(o4), this.pos = 0);
      const l6 = Math.min(n4 - this.pos, s3 - a4), c6 = i6 + a4;
      if (l6 === n4 && !(c6 % 4) && a4 + l6 < s3) {
        const u6 = new Uint32Array(f12, c6, Math.floor((s3 - a4) / 4));
        Ot(u6);
        for (let h7 = 0; a4 + n4 < s3; h7 += o4.length, a4 += n4) this.length += n4, this.compress(u6, h7, false);
        Ot(u6);
        continue;
      }
      r6.set(e9.subarray(a4, a4 + l6), this.pos), this.pos += l6, this.length += l6, a4 += l6;
    }
    return this;
  }
  digestInto(e9) {
    Nt(this), on(e9, this);
    const { pos: n4, buffer32: r6 } = this;
    this.finished = true, ut(this.buffer.subarray(n4)), Ot(r6), this.compress(r6, 0, true), Ot(r6);
    const o4 = fe(e9);
    this.get().forEach((s3, i6) => o4[i6] = wt(s3));
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
  _cloneInto(e9) {
    const { buffer: n4, length: r6, finished: o4, destroyed: s3, outputLen: i6, pos: f12 } = this;
    return e9 || (e9 = new this.constructor({ dkLen: i6 })), e9.set(...this.get()), e9.buffer.set(n4), e9.destroyed = s3, e9.finished = o4, e9.length = r6, e9.pos = f12, e9.outputLen = i6, e9;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef = class extends tf {
  constructor(e9 = {}) {
    const n4 = e9.dkLen === void 0 ? 64 : e9.dkLen;
    super(128, n4), this.v0l = F[0] | 0, this.v0h = F[1] | 0, this.v1l = F[2] | 0, this.v1h = F[3] | 0, this.v2l = F[4] | 0, this.v2h = F[5] | 0, this.v3l = F[6] | 0, this.v3h = F[7] | 0, this.v4l = F[8] | 0, this.v4h = F[9] | 0, this.v5l = F[10] | 0, this.v5h = F[11] | 0, this.v6l = F[12] | 0, this.v6h = F[13] | 0, this.v7l = F[14] | 0, this.v7h = F[15] | 0, Qi(n4, e9, 64, 16, 16);
    let { key: r6, personalization: o4, salt: s3 } = e9, i6 = 0;
    if (r6 !== void 0 && (r6 = ht(r6), i6 = r6.length), this.v0l ^= this.outputLen | i6 << 8 | 65536 | 1 << 24, s3 !== void 0) {
      s3 = ht(s3);
      const f12 = fe(s3);
      this.v4l ^= wt(f12[0]), this.v4h ^= wt(f12[1]), this.v5l ^= wt(f12[2]), this.v5h ^= wt(f12[3]);
    }
    if (o4 !== void 0) {
      o4 = ht(o4);
      const f12 = fe(o4);
      this.v6l ^= wt(f12[0]), this.v6h ^= wt(f12[1]), this.v7l ^= wt(f12[2]), this.v7h ^= wt(f12[3]);
    }
    if (r6 !== void 0) {
      const f12 = new Uint8Array(this.blockLen);
      f12.set(r6), this.update(f12);
    }
  }
  get() {
    let { v0l: e9, v0h: n4, v1l: r6, v1h: o4, v2l: s3, v2h: i6, v3l: f12, v3h: a4, v4l: l6, v4h: c6, v5l: u6, v5h: h7, v6l: g3, v6h: w6, v7l: y8, v7h: x5 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5) {
    this.v0l = e9 | 0, this.v0h = n4 | 0, this.v1l = r6 | 0, this.v1h = o4 | 0, this.v2l = s3 | 0, this.v2h = i6 | 0, this.v3l = f12 | 0, this.v3h = a4 | 0, this.v4l = l6 | 0, this.v4h = c6 | 0, this.v5l = u6 | 0, this.v5h = h7 | 0, this.v6l = g3 | 0, this.v6h = w6 | 0, this.v7l = y8 | 0, this.v7h = x5 | 0;
  }
  compress(e9, n4, r6) {
    this.get().forEach((a4, l6) => N[l6] = a4), N.set(F, 16);
    let { h: o4, l: s3 } = mr(BigInt(this.length));
    N[24] = F[8] ^ s3, N[25] = F[9] ^ o4, r6 && (N[28] = ~N[28], N[29] = ~N[29]);
    let i6 = 0;
    const f12 = Ji;
    for (let a4 = 0; a4 < 12; a4++) $t(0, 4, 8, 12, e9, n4 + 2 * f12[i6++]), Ct(0, 4, 8, 12, e9, n4 + 2 * f12[i6++]), $t(1, 5, 9, 13, e9, n4 + 2 * f12[i6++]), Ct(1, 5, 9, 13, e9, n4 + 2 * f12[i6++]), $t(2, 6, 10, 14, e9, n4 + 2 * f12[i6++]), Ct(2, 6, 10, 14, e9, n4 + 2 * f12[i6++]), $t(3, 7, 11, 15, e9, n4 + 2 * f12[i6++]), Ct(3, 7, 11, 15, e9, n4 + 2 * f12[i6++]), $t(0, 5, 10, 15, e9, n4 + 2 * f12[i6++]), Ct(0, 5, 10, 15, e9, n4 + 2 * f12[i6++]), $t(1, 6, 11, 12, e9, n4 + 2 * f12[i6++]), Ct(1, 6, 11, 12, e9, n4 + 2 * f12[i6++]), $t(2, 7, 8, 13, e9, n4 + 2 * f12[i6++]), Ct(2, 7, 8, 13, e9, n4 + 2 * f12[i6++]), $t(3, 4, 9, 14, e9, n4 + 2 * f12[i6++]), Ct(3, 4, 9, 14, e9, n4 + 2 * f12[i6++]);
    this.v0l ^= N[0] ^ N[16], this.v0h ^= N[1] ^ N[17], this.v1l ^= N[2] ^ N[18], this.v1h ^= N[3] ^ N[19], this.v2l ^= N[4] ^ N[20], this.v2h ^= N[5] ^ N[21], this.v3l ^= N[6] ^ N[22], this.v3h ^= N[7] ^ N[23], this.v4l ^= N[8] ^ N[24], this.v4h ^= N[9] ^ N[25], this.v5l ^= N[10] ^ N[26], this.v5h ^= N[11] ^ N[27], this.v6l ^= N[12] ^ N[28], this.v6h ^= N[13] ^ N[29], this.v7l ^= N[14] ^ N[30], this.v7h ^= N[15] ^ N[31], ut(N);
  }
  destroy() {
    this.destroyed = true, ut(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf = Ui((t4) => new ef(t4));
function Qr(t4) {
  return t4 instanceof Uint8Array || ArrayBuffer.isView(t4) && t4.constructor.name === "Uint8Array";
}
function bn(t4) {
  if (typeof t4 != "boolean") throw new Error(`boolean expected, not ${t4}`);
}
function yn(t4) {
  if (!Number.isSafeInteger(t4) || t4 < 0) throw new Error("positive integer expected, got " + t4);
}
function nt(t4, ...e9) {
  if (!Qr(t4)) throw new Error("Uint8Array expected");
  if (e9.length > 0 && !e9.includes(t4.length)) throw new Error("Uint8Array expected of length " + e9 + ", got length=" + t4.length);
}
function to(t4, e9 = true) {
  if (t4.destroyed) throw new Error("Hash instance has been destroyed");
  if (e9 && t4.finished) throw new Error("Hash#digest() has already been called");
}
function Sf(t4, e9) {
  nt(t4);
  const n4 = e9.outputLen;
  if (t4.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function jt(t4) {
  return new Uint32Array(t4.buffer, t4.byteOffset, Math.floor(t4.byteLength / 4));
}
function Wt(...t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9].fill(0);
}
function Nf(t4) {
  return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
}
var Of = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf(t4) {
  if (typeof t4 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t4));
}
function mn(t4) {
  if (typeof t4 == "string") t4 = Uf(t4);
  else if (Qr(t4)) t4 = wn(t4);
  else throw new Error("Uint8Array expected, got " + typeof t4);
  return t4;
}
function _f(t4, e9) {
  if (e9 == null || typeof e9 != "object") throw new Error("options must be defined");
  return Object.assign(t4, e9);
}
function Tf(t4, e9) {
  if (t4.length !== e9.length) return false;
  let n4 = 0;
  for (let r6 = 0; r6 < t4.length; r6++) n4 |= t4[r6] ^ e9[r6];
  return n4 === 0;
}
var Rf = (t4, e9) => {
  function n4(r6, ...o4) {
    if (nt(r6), !Of) throw new Error("Non little-endian hardware is not yet supported");
    if (t4.nonceLength !== void 0) {
      const c6 = o4[0];
      if (!c6) throw new Error("nonce / iv required");
      t4.varSizeNonce ? nt(c6) : nt(c6, t4.nonceLength);
    }
    const s3 = t4.tagLength;
    s3 && o4[1] !== void 0 && nt(o4[1]);
    const i6 = e9(r6, ...o4), f12 = (c6, u6) => {
      if (u6 !== void 0) {
        if (c6 !== 2) throw new Error("cipher output not supported");
        nt(u6);
      }
    };
    let a4 = false;
    return { encrypt(c6, u6) {
      if (a4) throw new Error("cannot encrypt() twice with same key + nonce");
      return a4 = true, nt(c6), f12(i6.encrypt.length, u6), i6.encrypt(c6, u6);
    }, decrypt(c6, u6) {
      if (nt(c6), s3 && c6.length < s3) throw new Error("invalid ciphertext length: smaller than tagLength=" + s3);
      return f12(i6.decrypt.length, u6), i6.decrypt(c6, u6);
    } };
  }
  return Object.assign(n4, t4), n4;
};
function eo(t4, e9, n4 = true) {
  if (e9 === void 0) return new Uint8Array(t4);
  if (e9.length !== t4) throw new Error("invalid output length, expected " + t4 + ", got: " + e9.length);
  if (n4 && !Cf(e9)) throw new Error("invalid output, must be aligned");
  return e9;
}
function no(t4, e9, n4, r6) {
  if (typeof t4.setBigUint64 == "function") return t4.setBigUint64(e9, n4, r6);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i6 = Number(n4 >> o4 & s3), f12 = Number(n4 & s3), a4 = r6 ? 4 : 0, l6 = r6 ? 0 : 4;
  t4.setUint32(e9 + a4, i6, r6), t4.setUint32(e9 + l6, f12, r6);
}
function $f(t4, e9, n4) {
  bn(n4);
  const r6 = new Uint8Array(16), o4 = Nf(r6);
  return no(o4, 0, BigInt(e9), n4), no(o4, 8, BigInt(t4), n4), r6;
}
function Cf(t4) {
  return t4.byteOffset % 4 === 0;
}
function wn(t4) {
  return Uint8Array.from(t4);
}
var ro = (t4) => Uint8Array.from(t4.split("").map((e9) => e9.charCodeAt(0)));
var Lf = ro("expand 16-byte k");
var jf = ro("expand 32-byte k");
var kf = jt(Lf);
var Pf = jt(jf);
function D(t4, e9) {
  return t4 << e9 | t4 >>> 32 - e9;
}
function xn(t4) {
  return t4.byteOffset % 4 === 0;
}
var Ue = 64;
var Hf = 16;
var oo = 2 ** 32 - 1;
var so = new Uint32Array();
function Df(t4, e9, n4, r6, o4, s3, i6, f12) {
  const a4 = o4.length, l6 = new Uint8Array(Ue), c6 = jt(l6), u6 = xn(o4) && xn(s3), h7 = u6 ? jt(o4) : so, g3 = u6 ? jt(s3) : so;
  for (let w6 = 0; w6 < a4; i6++) {
    if (t4(e9, n4, r6, c6, i6, f12), i6 >= oo) throw new Error("arx: counter overflow");
    const y8 = Math.min(Ue, a4 - w6);
    if (u6 && y8 === Ue) {
      const x5 = w6 / 4;
      if (w6 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R6 = 0, M7; R6 < Hf; R6++) M7 = x5 + R6, g3[M7] = h7[M7] ^ c6[R6];
      w6 += Ue;
      continue;
    }
    for (let x5 = 0, R6; x5 < y8; x5++) R6 = w6 + x5, s3[R6] = o4[R6] ^ l6[x5];
    w6 += y8;
  }
}
function Mf(t4, e9) {
  const { allowShortKeys: n4, extendNonceFn: r6, counterLength: o4, counterRight: s3, rounds: i6 } = _f({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e9);
  if (typeof t4 != "function") throw new Error("core must be a function");
  return yn(o4), yn(i6), bn(s3), bn(n4), (f12, a4, l6, c6, u6 = 0) => {
    nt(f12), nt(a4), nt(l6);
    const h7 = l6.length;
    if (c6 === void 0 && (c6 = new Uint8Array(h7)), nt(c6), yn(u6), u6 < 0 || u6 >= oo) throw new Error("arx: counter overflow");
    if (c6.length < h7) throw new Error(`arx: output (${c6.length}) is shorter than data (${h7})`);
    const g3 = [];
    let w6 = f12.length, y8, x5;
    if (w6 === 32) g3.push(y8 = wn(f12)), x5 = Pf;
    else if (w6 === 16 && n4) y8 = new Uint8Array(32), y8.set(f12), y8.set(f12, 16), x5 = kf, g3.push(y8);
    else throw new Error(`arx: invalid 32-byte key, got length=${w6}`);
    xn(a4) || g3.push(a4 = wn(a4));
    const R6 = jt(y8);
    if (r6) {
      if (a4.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r6(x5, R6, jt(a4.subarray(0, 16)), R6), a4 = a4.subarray(16);
    }
    const M7 = 16 - o4;
    if (M7 !== a4.length) throw new Error(`arx: nonce must be ${M7} or 16 bytes`);
    if (M7 !== 12) {
      const V7 = new Uint8Array(12);
      V7.set(a4, s3 ? 0 : 12 - a4.length), a4 = V7, g3.push(a4);
    }
    const L6 = jt(a4);
    return Df(t4, x5, R6, L6, l6, c6, u6, i6), Wt(...g3), c6;
  };
}
var G = (t4, e9) => t4[e9++] & 255 | (t4[e9++] & 255) << 8;
var Vf = class {
  constructor(e9) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e9 = mn(e9), nt(e9, 32);
    const n4 = G(e9, 0), r6 = G(e9, 2), o4 = G(e9, 4), s3 = G(e9, 6), i6 = G(e9, 8), f12 = G(e9, 10), a4 = G(e9, 12), l6 = G(e9, 14);
    this.r[0] = n4 & 8191, this.r[1] = (n4 >>> 13 | r6 << 3) & 8191, this.r[2] = (r6 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | s3 << 9) & 8191, this.r[4] = (s3 >>> 4 | i6 << 12) & 255, this.r[5] = i6 >>> 1 & 8190, this.r[6] = (i6 >>> 14 | f12 << 2) & 8191, this.r[7] = (f12 >>> 11 | a4 << 5) & 8065, this.r[8] = (a4 >>> 8 | l6 << 8) & 8191, this.r[9] = l6 >>> 5 & 127;
    for (let c6 = 0; c6 < 8; c6++) this.pad[c6] = G(e9, 16 + 2 * c6);
  }
  process(e9, n4, r6 = false) {
    const o4 = r6 ? 0 : 2048, { h: s3, r: i6 } = this, f12 = i6[0], a4 = i6[1], l6 = i6[2], c6 = i6[3], u6 = i6[4], h7 = i6[5], g3 = i6[6], w6 = i6[7], y8 = i6[8], x5 = i6[9], R6 = G(e9, n4 + 0), M7 = G(e9, n4 + 2), L6 = G(e9, n4 + 4), V7 = G(e9, n4 + 6), _4 = G(e9, n4 + 8), k8 = G(e9, n4 + 10), j6 = G(e9, n4 + 12), $7 = G(e9, n4 + 14);
    let d5 = s3[0] + (R6 & 8191), m5 = s3[1] + ((R6 >>> 13 | M7 << 3) & 8191), p7 = s3[2] + ((M7 >>> 10 | L6 << 6) & 8191), b5 = s3[3] + ((L6 >>> 7 | V7 << 9) & 8191), v7 = s3[4] + ((V7 >>> 4 | _4 << 12) & 8191), B7 = s3[5] + (_4 >>> 1 & 8191), E7 = s3[6] + ((_4 >>> 14 | k8 << 2) & 8191), I7 = s3[7] + ((k8 >>> 11 | j6 << 5) & 8191), S7 = s3[8] + ((j6 >>> 8 | $7 << 8) & 8191), O6 = s3[9] + ($7 >>> 5 | o4), A8 = 0, T6 = A8 + d5 * f12 + m5 * (5 * x5) + p7 * (5 * y8) + b5 * (5 * w6) + v7 * (5 * g3);
    A8 = T6 >>> 13, T6 &= 8191, T6 += B7 * (5 * h7) + E7 * (5 * u6) + I7 * (5 * c6) + S7 * (5 * l6) + O6 * (5 * a4), A8 += T6 >>> 13, T6 &= 8191;
    let U6 = A8 + d5 * a4 + m5 * f12 + p7 * (5 * x5) + b5 * (5 * y8) + v7 * (5 * w6);
    A8 = U6 >>> 13, U6 &= 8191, U6 += B7 * (5 * g3) + E7 * (5 * h7) + I7 * (5 * u6) + S7 * (5 * c6) + O6 * (5 * l6), A8 += U6 >>> 13, U6 &= 8191;
    let C8 = A8 + d5 * l6 + m5 * a4 + p7 * f12 + b5 * (5 * x5) + v7 * (5 * y8);
    A8 = C8 >>> 13, C8 &= 8191, C8 += B7 * (5 * w6) + E7 * (5 * g3) + I7 * (5 * h7) + S7 * (5 * u6) + O6 * (5 * c6), A8 += C8 >>> 13, C8 &= 8191;
    let H4 = A8 + d5 * c6 + m5 * l6 + p7 * a4 + b5 * f12 + v7 * (5 * x5);
    A8 = H4 >>> 13, H4 &= 8191, H4 += B7 * (5 * y8) + E7 * (5 * w6) + I7 * (5 * g3) + S7 * (5 * h7) + O6 * (5 * u6), A8 += H4 >>> 13, H4 &= 8191;
    let q5 = A8 + d5 * u6 + m5 * c6 + p7 * l6 + b5 * a4 + v7 * f12;
    A8 = q5 >>> 13, q5 &= 8191, q5 += B7 * (5 * x5) + E7 * (5 * y8) + I7 * (5 * w6) + S7 * (5 * g3) + O6 * (5 * h7), A8 += q5 >>> 13, q5 &= 8191;
    let P6 = A8 + d5 * h7 + m5 * u6 + p7 * c6 + b5 * l6 + v7 * a4;
    A8 = P6 >>> 13, P6 &= 8191, P6 += B7 * f12 + E7 * (5 * x5) + I7 * (5 * y8) + S7 * (5 * w6) + O6 * (5 * g3), A8 += P6 >>> 13, P6 &= 8191;
    let K4 = A8 + d5 * g3 + m5 * h7 + p7 * u6 + b5 * c6 + v7 * l6;
    A8 = K4 >>> 13, K4 &= 8191, K4 += B7 * a4 + E7 * f12 + I7 * (5 * x5) + S7 * (5 * y8) + O6 * (5 * w6), A8 += K4 >>> 13, K4 &= 8191;
    let et3 = A8 + d5 * w6 + m5 * g3 + p7 * h7 + b5 * u6 + v7 * c6;
    A8 = et3 >>> 13, et3 &= 8191, et3 += B7 * l6 + E7 * a4 + I7 * f12 + S7 * (5 * x5) + O6 * (5 * y8), A8 += et3 >>> 13, et3 &= 8191;
    let Z5 = A8 + d5 * y8 + m5 * w6 + p7 * g3 + b5 * h7 + v7 * u6;
    A8 = Z5 >>> 13, Z5 &= 8191, Z5 += B7 * c6 + E7 * l6 + I7 * a4 + S7 * f12 + O6 * (5 * x5), A8 += Z5 >>> 13, Z5 &= 8191;
    let z6 = A8 + d5 * x5 + m5 * y8 + p7 * w6 + b5 * g3 + v7 * h7;
    A8 = z6 >>> 13, z6 &= 8191, z6 += B7 * u6 + E7 * c6 + I7 * l6 + S7 * a4 + O6 * f12, A8 += z6 >>> 13, z6 &= 8191, A8 = (A8 << 2) + A8 | 0, A8 = A8 + T6 | 0, T6 = A8 & 8191, A8 = A8 >>> 13, U6 += A8, s3[0] = T6, s3[1] = U6, s3[2] = C8, s3[3] = H4, s3[4] = q5, s3[5] = P6, s3[6] = K4, s3[7] = et3, s3[8] = Z5, s3[9] = z6;
  }
  finalize() {
    const { h: e9, pad: n4 } = this, r6 = new Uint16Array(10);
    let o4 = e9[1] >>> 13;
    e9[1] &= 8191;
    for (let f12 = 2; f12 < 10; f12++) e9[f12] += o4, o4 = e9[f12] >>> 13, e9[f12] &= 8191;
    e9[0] += o4 * 5, o4 = e9[0] >>> 13, e9[0] &= 8191, e9[1] += o4, o4 = e9[1] >>> 13, e9[1] &= 8191, e9[2] += o4, r6[0] = e9[0] + 5, o4 = r6[0] >>> 13, r6[0] &= 8191;
    for (let f12 = 1; f12 < 10; f12++) r6[f12] = e9[f12] + o4, o4 = r6[f12] >>> 13, r6[f12] &= 8191;
    r6[9] -= 8192;
    let s3 = (o4 ^ 1) - 1;
    for (let f12 = 0; f12 < 10; f12++) r6[f12] &= s3;
    s3 = ~s3;
    for (let f12 = 0; f12 < 10; f12++) e9[f12] = e9[f12] & s3 | r6[f12];
    e9[0] = (e9[0] | e9[1] << 13) & 65535, e9[1] = (e9[1] >>> 3 | e9[2] << 10) & 65535, e9[2] = (e9[2] >>> 6 | e9[3] << 7) & 65535, e9[3] = (e9[3] >>> 9 | e9[4] << 4) & 65535, e9[4] = (e9[4] >>> 12 | e9[5] << 1 | e9[6] << 14) & 65535, e9[5] = (e9[6] >>> 2 | e9[7] << 11) & 65535, e9[6] = (e9[7] >>> 5 | e9[8] << 8) & 65535, e9[7] = (e9[8] >>> 8 | e9[9] << 5) & 65535;
    let i6 = e9[0] + n4[0];
    e9[0] = i6 & 65535;
    for (let f12 = 1; f12 < 8; f12++) i6 = (e9[f12] + n4[f12] | 0) + (i6 >>> 16) | 0, e9[f12] = i6 & 65535;
    Wt(r6);
  }
  update(e9) {
    to(this), e9 = mn(e9), nt(e9);
    const { buffer: n4, blockLen: r6 } = this, o4 = e9.length;
    for (let s3 = 0; s3 < o4; ) {
      const i6 = Math.min(r6 - this.pos, o4 - s3);
      if (i6 === r6) {
        for (; r6 <= o4 - s3; s3 += r6) this.process(e9, s3);
        continue;
      }
      n4.set(e9.subarray(s3, s3 + i6), this.pos), this.pos += i6, s3 += i6, this.pos === r6 && (this.process(n4, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e9) {
    to(this), Sf(e9, this), this.finished = true;
    const { buffer: n4, h: r6 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n4[o4++] = 1; o4 < 16; o4++) n4[o4] = 0;
      this.process(n4, 0, true);
    }
    this.finalize();
    let s3 = 0;
    for (let i6 = 0; i6 < 8; i6++) e9[s3++] = r6[i6] >>> 0, e9[s3++] = r6[i6] >>> 8;
    return e9;
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
};
function qf(t4) {
  const e9 = (r6, o4) => t4(o4).update(mn(r6)).digest(), n4 = t4(new Uint8Array(32));
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = (r6) => t4(r6), e9;
}
var Kf = qf((t4) => new Vf(t4));
function Ff(t4, e9, n4, r6, o4, s3 = 20) {
  let i6 = t4[0], f12 = t4[1], a4 = t4[2], l6 = t4[3], c6 = e9[0], u6 = e9[1], h7 = e9[2], g3 = e9[3], w6 = e9[4], y8 = e9[5], x5 = e9[6], R6 = e9[7], M7 = o4, L6 = n4[0], V7 = n4[1], _4 = n4[2], k8 = i6, j6 = f12, $7 = a4, d5 = l6, m5 = c6, p7 = u6, b5 = h7, v7 = g3, B7 = w6, E7 = y8, I7 = x5, S7 = R6, O6 = M7, A8 = L6, T6 = V7, U6 = _4;
  for (let H4 = 0; H4 < s3; H4 += 2) k8 = k8 + m5 | 0, O6 = D(O6 ^ k8, 16), B7 = B7 + O6 | 0, m5 = D(m5 ^ B7, 12), k8 = k8 + m5 | 0, O6 = D(O6 ^ k8, 8), B7 = B7 + O6 | 0, m5 = D(m5 ^ B7, 7), j6 = j6 + p7 | 0, A8 = D(A8 ^ j6, 16), E7 = E7 + A8 | 0, p7 = D(p7 ^ E7, 12), j6 = j6 + p7 | 0, A8 = D(A8 ^ j6, 8), E7 = E7 + A8 | 0, p7 = D(p7 ^ E7, 7), $7 = $7 + b5 | 0, T6 = D(T6 ^ $7, 16), I7 = I7 + T6 | 0, b5 = D(b5 ^ I7, 12), $7 = $7 + b5 | 0, T6 = D(T6 ^ $7, 8), I7 = I7 + T6 | 0, b5 = D(b5 ^ I7, 7), d5 = d5 + v7 | 0, U6 = D(U6 ^ d5, 16), S7 = S7 + U6 | 0, v7 = D(v7 ^ S7, 12), d5 = d5 + v7 | 0, U6 = D(U6 ^ d5, 8), S7 = S7 + U6 | 0, v7 = D(v7 ^ S7, 7), k8 = k8 + p7 | 0, U6 = D(U6 ^ k8, 16), I7 = I7 + U6 | 0, p7 = D(p7 ^ I7, 12), k8 = k8 + p7 | 0, U6 = D(U6 ^ k8, 8), I7 = I7 + U6 | 0, p7 = D(p7 ^ I7, 7), j6 = j6 + b5 | 0, O6 = D(O6 ^ j6, 16), S7 = S7 + O6 | 0, b5 = D(b5 ^ S7, 12), j6 = j6 + b5 | 0, O6 = D(O6 ^ j6, 8), S7 = S7 + O6 | 0, b5 = D(b5 ^ S7, 7), $7 = $7 + v7 | 0, A8 = D(A8 ^ $7, 16), B7 = B7 + A8 | 0, v7 = D(v7 ^ B7, 12), $7 = $7 + v7 | 0, A8 = D(A8 ^ $7, 8), B7 = B7 + A8 | 0, v7 = D(v7 ^ B7, 7), d5 = d5 + m5 | 0, T6 = D(T6 ^ d5, 16), E7 = E7 + T6 | 0, m5 = D(m5 ^ E7, 12), d5 = d5 + m5 | 0, T6 = D(T6 ^ d5, 8), E7 = E7 + T6 | 0, m5 = D(m5 ^ E7, 7);
  let C8 = 0;
  r6[C8++] = i6 + k8 | 0, r6[C8++] = f12 + j6 | 0, r6[C8++] = a4 + $7 | 0, r6[C8++] = l6 + d5 | 0, r6[C8++] = c6 + m5 | 0, r6[C8++] = u6 + p7 | 0, r6[C8++] = h7 + b5 | 0, r6[C8++] = g3 + v7 | 0, r6[C8++] = w6 + B7 | 0, r6[C8++] = y8 + E7 | 0, r6[C8++] = x5 + I7 | 0, r6[C8++] = R6 + S7 | 0, r6[C8++] = M7 + O6 | 0, r6[C8++] = L6 + A8 | 0, r6[C8++] = V7 + T6 | 0, r6[C8++] = _4 + U6 | 0;
}
var zf = Mf(Ff, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf = new Uint8Array(16);
var io = (t4, e9) => {
  t4.update(e9);
  const n4 = e9.length % 16;
  n4 && t4.update(Gf.subarray(n4));
};
var Zf = new Uint8Array(32);
function fo(t4, e9, n4, r6, o4) {
  const s3 = t4(e9, n4, Zf), i6 = Kf.create(s3);
  o4 && io(i6, o4), io(i6, r6);
  const f12 = $f(r6.length, o4 ? o4.length : 0, true);
  i6.update(f12);
  const a4 = i6.digest();
  return Wt(s3, f12), a4;
}
var Wf = (t4) => (e9, n4, r6) => ({ encrypt(s3, i6) {
  const f12 = s3.length;
  i6 = eo(f12 + 16, i6, false), i6.set(s3);
  const a4 = i6.subarray(0, -16);
  t4(e9, n4, a4, a4, 1);
  const l6 = fo(t4, e9, n4, a4, r6);
  return i6.set(l6, f12), Wt(l6), i6;
}, decrypt(s3, i6) {
  i6 = eo(s3.length - 16, i6, false);
  const f12 = s3.subarray(0, -16), a4 = s3.subarray(-16), l6 = fo(t4, e9, n4, f12, r6);
  if (!Tf(a4, l6)) throw new Error("invalid tag");
  return i6.set(s3.subarray(0, -16)), t4(e9, n4, i6, i6, 1), Wt(l6), i6;
} });
var co = Rf({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf(zf));
var ao = class extends Ie {
  constructor(e9, n4) {
    super(), this.finished = false, this.destroyed = false, rn(e9);
    const r6 = ht(n4);
    if (this.iHash = e9.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, s3 = new Uint8Array(o4);
    s3.set(r6.length > o4 ? e9.create().update(r6).digest() : r6);
    for (let i6 = 0; i6 < s3.length; i6++) s3[i6] ^= 54;
    this.iHash.update(s3), this.oHash = e9.create();
    for (let i6 = 0; i6 < s3.length; i6++) s3[i6] ^= 106;
    this.oHash.update(s3), ut(s3);
  }
  update(e9) {
    return Nt(this), this.iHash.update(e9), this;
  }
  digestInto(e9) {
    Nt(this), at(e9, this.outputLen), this.finished = true, this.iHash.digestInto(e9), this.oHash.update(e9), this.oHash.digestInto(e9), this.destroy();
  }
  digest() {
    const e9 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e9), e9;
  }
  _cloneInto(e9) {
    e9 || (e9 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n4, iHash: r6, finished: o4, destroyed: s3, blockLen: i6, outputLen: f12 } = this;
    return e9 = e9, e9.finished = o4, e9.destroyed = s3, e9.blockLen = i6, e9.outputLen = f12, e9.oHash = n4._cloneInto(e9.oHash), e9.iHash = r6._cloneInto(e9.iHash), e9;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e = (t4, e9, n4) => new ao(t4, e9).update(n4).digest();
_e.create = (t4, e9) => new ao(t4, e9);
var vn = Uint8Array.from([0]);
var uo = Uint8Array.of();
var En = BigInt(0);
var Bn = BigInt(1);
function Re(t4, e9) {
  if (typeof e9 != "boolean") throw new Error(t4 + " boolean expected, got " + e9);
}
function $e(t4) {
  const e9 = t4.toString(16);
  return e9.length & 1 ? "0" + e9 : e9;
}
function lo(t4) {
  if (typeof t4 != "string") throw new Error("hex string expected, got " + typeof t4);
  return t4 === "" ? En : BigInt("0x" + t4);
}
function Ce(t4) {
  return lo(ce(t4));
}
function Le(t4) {
  return at(t4), lo(ce(Uint8Array.from(t4).reverse()));
}
function In(t4, e9) {
  return fn(t4.toString(16).padStart(e9 * 2, "0"));
}
function An(t4, e9) {
  return In(t4, e9).reverse();
}
function rt(t4, e9, n4) {
  let r6;
  if (typeof e9 == "string") try {
    r6 = fn(e9);
  } catch (s3) {
    throw new Error(t4 + " must be hex string or Uint8Array, cause: " + s3);
  }
  else if (nn(e9)) r6 = Uint8Array.from(e9);
  else throw new Error(t4 + " must be hex string or Uint8Array");
  const o4 = r6.length;
  if (typeof n4 == "number" && o4 !== n4) throw new Error(t4 + " of length " + n4 + " expected, got " + o4);
  return r6;
}
var Sn = (t4) => typeof t4 == "bigint" && En <= t4;
function Qf(t4, e9, n4) {
  return Sn(t4) && Sn(e9) && Sn(n4) && e9 <= t4 && t4 < n4;
}
function Nn(t4, e9, n4, r6) {
  if (!Qf(e9, n4, r6)) throw new Error("expected valid " + t4 + ": " + n4 + " <= n < " + r6 + ", got " + e9);
}
function tc(t4) {
  let e9;
  for (e9 = 0; t4 > En; t4 >>= Bn, e9 += 1) ;
  return e9;
}
var je = (t4) => (Bn << BigInt(t4)) - Bn;
function ec(t4, e9, n4) {
  if (typeof t4 != "number" || t4 < 2) throw new Error("hashLen must be a number");
  if (typeof e9 != "number" || e9 < 2) throw new Error("qByteLen must be a number");
  if (typeof n4 != "function") throw new Error("hmacFn must be a function");
  const r6 = (g3) => new Uint8Array(g3), o4 = (g3) => Uint8Array.of(g3);
  let s3 = r6(t4), i6 = r6(t4), f12 = 0;
  const a4 = () => {
    s3.fill(1), i6.fill(0), f12 = 0;
  }, l6 = (...g3) => n4(i6, s3, ...g3), c6 = (g3 = r6(0)) => {
    i6 = l6(o4(0), g3), s3 = l6(), g3.length !== 0 && (i6 = l6(o4(1), g3), s3 = l6());
  }, u6 = () => {
    if (f12++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g3 = 0;
    const w6 = [];
    for (; g3 < e9; ) {
      s3 = l6();
      const y8 = s3.slice();
      w6.push(y8), g3 += s3.length;
    }
    return Ht(...w6);
  };
  return (g3, w6) => {
    a4(), c6(g3);
    let y8;
    for (; !(y8 = w6(u6())); ) c6();
    return a4(), y8;
  };
}
function ke(t4, e9, n4 = {}) {
  if (!t4 || typeof t4 != "object") throw new Error("expected valid options object");
  function r6(o4, s3, i6) {
    const f12 = t4[o4];
    if (i6 && f12 === void 0) return;
    const a4 = typeof f12;
    if (a4 !== s3 || f12 === null) throw new Error(`param "${o4}" is invalid: expected ${s3}, got ${a4}`);
  }
  Object.entries(e9).forEach(([o4, s3]) => r6(o4, s3, false)), Object.entries(n4).forEach(([o4, s3]) => r6(o4, s3, true));
}
function ho(t4) {
  const e9 = /* @__PURE__ */ new WeakMap();
  return (n4, ...r6) => {
    const o4 = e9.get(n4);
    if (o4 !== void 0) return o4;
    const s3 = t4(n4, ...r6);
    return e9.set(n4, s3), s3;
  };
}
var ot = BigInt(0);
var Q = BigInt(1);
var Dt = BigInt(2);
var nc = BigInt(3);
var po = BigInt(4);
var go = BigInt(5);
var bo = BigInt(8);
function lt(t4, e9) {
  const n4 = t4 % e9;
  return n4 >= ot ? n4 : e9 + n4;
}
function pt(t4, e9, n4) {
  let r6 = t4;
  for (; e9-- > ot; ) r6 *= r6, r6 %= n4;
  return r6;
}
function yo(t4, e9) {
  if (t4 === ot) throw new Error("invert: expected non-zero number");
  if (e9 <= ot) throw new Error("invert: expected positive modulus, got " + e9);
  let n4 = lt(t4, e9), r6 = e9, o4 = ot, s3 = Q;
  for (; n4 !== ot; ) {
    const f12 = r6 / n4, a4 = r6 % n4, l6 = o4 - s3 * f12;
    r6 = n4, n4 = a4, o4 = s3, s3 = l6;
  }
  if (r6 !== Q) throw new Error("invert: does not exist");
  return lt(o4, e9);
}
function mo(t4, e9) {
  const n4 = (t4.ORDER + Q) / po, r6 = t4.pow(e9, n4);
  if (!t4.eql(t4.sqr(r6), e9)) throw new Error("Cannot find square root");
  return r6;
}
function rc(t4, e9) {
  const n4 = (t4.ORDER - go) / bo, r6 = t4.mul(e9, Dt), o4 = t4.pow(r6, n4), s3 = t4.mul(e9, o4), i6 = t4.mul(t4.mul(s3, Dt), o4), f12 = t4.mul(s3, t4.sub(i6, t4.ONE));
  if (!t4.eql(t4.sqr(f12), e9)) throw new Error("Cannot find square root");
  return f12;
}
function oc(t4) {
  if (t4 < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e9 = t4 - Q, n4 = 0;
  for (; e9 % Dt === ot; ) e9 /= Dt, n4++;
  let r6 = Dt;
  const o4 = Yt(t4);
  for (; xo(o4, r6) === 1; ) if (r6++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n4 === 1) return mo;
  let s3 = o4.pow(r6, e9);
  const i6 = (e9 + Q) / Dt;
  return function(a4, l6) {
    if (a4.is0(l6)) return l6;
    if (xo(a4, l6) !== 1) throw new Error("Cannot find square root");
    let c6 = n4, u6 = a4.mul(a4.ONE, s3), h7 = a4.pow(l6, e9), g3 = a4.pow(l6, i6);
    for (; !a4.eql(h7, a4.ONE); ) {
      if (a4.is0(h7)) return a4.ZERO;
      let w6 = 1, y8 = a4.sqr(h7);
      for (; !a4.eql(y8, a4.ONE); ) if (w6++, y8 = a4.sqr(y8), w6 === c6) throw new Error("Cannot find square root");
      const x5 = Q << BigInt(c6 - w6 - 1), R6 = a4.pow(u6, x5);
      c6 = w6, u6 = a4.sqr(R6), h7 = a4.mul(h7, u6), g3 = a4.mul(g3, R6);
    }
    return g3;
  };
}
function sc(t4) {
  return t4 % po === nc ? mo : t4 % bo === go ? rc : oc(t4);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc(t4) {
  const e9 = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n4 = ic.reduce((r6, o4) => (r6[o4] = "function", r6), e9);
  return ke(t4, n4), t4;
}
function cc(t4, e9, n4) {
  if (n4 < ot) throw new Error("invalid exponent, negatives unsupported");
  if (n4 === ot) return t4.ONE;
  if (n4 === Q) return e9;
  let r6 = t4.ONE, o4 = e9;
  for (; n4 > ot; ) n4 & Q && (r6 = t4.mul(r6, o4)), o4 = t4.sqr(o4), n4 >>= Q;
  return r6;
}
function wo(t4, e9, n4 = false) {
  const r6 = new Array(e9.length).fill(n4 ? t4.ZERO : void 0), o4 = e9.reduce((i6, f12, a4) => t4.is0(f12) ? i6 : (r6[a4] = i6, t4.mul(i6, f12)), t4.ONE), s3 = t4.inv(o4);
  return e9.reduceRight((i6, f12, a4) => t4.is0(f12) ? i6 : (r6[a4] = t4.mul(i6, r6[a4]), t4.mul(i6, f12)), s3), r6;
}
function xo(t4, e9) {
  const n4 = (t4.ORDER - Q) / Dt, r6 = t4.pow(e9, n4), o4 = t4.eql(r6, t4.ONE), s3 = t4.eql(r6, t4.ZERO), i6 = t4.eql(r6, t4.neg(t4.ONE));
  if (!o4 && !s3 && !i6) throw new Error("invalid Legendre symbol result");
  return o4 ? 1 : s3 ? 0 : -1;
}
function ac(t4, e9) {
  e9 !== void 0 && mt(e9);
  const n4 = e9 !== void 0 ? e9 : t4.toString(2).length, r6 = Math.ceil(n4 / 8);
  return { nBitLength: n4, nByteLength: r6 };
}
function Yt(t4, e9, n4 = false, r6 = {}) {
  if (t4 <= ot) throw new Error("invalid field: expected ORDER > 0, got " + t4);
  let o4, s3;
  if (typeof e9 == "object" && e9 != null) {
    if (r6.sqrt || n4) throw new Error("cannot specify opts in two arguments");
    const c6 = e9;
    c6.BITS && (o4 = c6.BITS), c6.sqrt && (s3 = c6.sqrt), typeof c6.isLE == "boolean" && (n4 = c6.isLE);
  } else typeof e9 == "number" && (o4 = e9), r6.sqrt && (s3 = r6.sqrt);
  const { nBitLength: i6, nByteLength: f12 } = ac(t4, o4);
  if (f12 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a4;
  const l6 = Object.freeze({ ORDER: t4, isLE: n4, BITS: i6, BYTES: f12, MASK: je(i6), ZERO: ot, ONE: Q, create: (c6) => lt(c6, t4), isValid: (c6) => {
    if (typeof c6 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c6);
    return ot <= c6 && c6 < t4;
  }, is0: (c6) => c6 === ot, isValidNot0: (c6) => !l6.is0(c6) && l6.isValid(c6), isOdd: (c6) => (c6 & Q) === Q, neg: (c6) => lt(-c6, t4), eql: (c6, u6) => c6 === u6, sqr: (c6) => lt(c6 * c6, t4), add: (c6, u6) => lt(c6 + u6, t4), sub: (c6, u6) => lt(c6 - u6, t4), mul: (c6, u6) => lt(c6 * u6, t4), pow: (c6, u6) => cc(l6, c6, u6), div: (c6, u6) => lt(c6 * yo(u6, t4), t4), sqrN: (c6) => c6 * c6, addN: (c6, u6) => c6 + u6, subN: (c6, u6) => c6 - u6, mulN: (c6, u6) => c6 * u6, inv: (c6) => yo(c6, t4), sqrt: s3 || ((c6) => (a4 || (a4 = sc(t4)), a4(l6, c6))), toBytes: (c6) => n4 ? An(c6, f12) : In(c6, f12), fromBytes: (c6) => {
    if (c6.length !== f12) throw new Error("Field.fromBytes: expected " + f12 + " bytes, got " + c6.length);
    return n4 ? Le(c6) : Ce(c6);
  }, invertBatch: (c6) => wo(l6, c6), cmov: (c6, u6, h7) => h7 ? u6 : c6 });
  return Object.freeze(l6);
}
function vo(t4) {
  if (typeof t4 != "bigint") throw new Error("field order must be bigint");
  const e9 = t4.toString(2).length;
  return Math.ceil(e9 / 8);
}
function Eo(t4) {
  const e9 = vo(t4);
  return e9 + Math.ceil(e9 / 2);
}
function uc(t4, e9, n4 = false) {
  const r6 = t4.length, o4 = vo(e9), s3 = Eo(e9);
  if (r6 < 16 || r6 < s3 || r6 > 1024) throw new Error("expected " + s3 + "-1024 bytes of input, got " + r6);
  const i6 = n4 ? Le(t4) : Ce(t4), f12 = lt(i6, e9 - Q) + Q;
  return n4 ? An(f12, o4) : In(f12, o4);
}
var Xt = BigInt(0);
var Mt = BigInt(1);
function le(t4, e9) {
  const n4 = e9.negate();
  return t4 ? n4 : e9;
}
function lc(t4, e9, n4) {
  const r6 = e9 === "pz" ? (i6) => i6.pz : (i6) => i6.ez, o4 = wo(t4.Fp, n4.map(r6));
  return n4.map((i6, f12) => i6.toAffine(o4[f12])).map(t4.fromAffine);
}
function Bo(t4, e9) {
  if (!Number.isSafeInteger(t4) || t4 <= 0 || t4 > e9) throw new Error("invalid window size, expected [1.." + e9 + "], got W=" + t4);
}
function On(t4, e9) {
  Bo(t4, e9);
  const n4 = Math.ceil(e9 / t4) + 1, r6 = 2 ** (t4 - 1), o4 = 2 ** t4, s3 = je(t4), i6 = BigInt(t4);
  return { windows: n4, windowSize: r6, mask: s3, maxNumber: o4, shiftBy: i6 };
}
function Io(t4, e9, n4) {
  const { windowSize: r6, mask: o4, maxNumber: s3, shiftBy: i6 } = n4;
  let f12 = Number(t4 & o4), a4 = t4 >> i6;
  f12 > r6 && (f12 -= s3, a4 += Mt);
  const l6 = e9 * r6, c6 = l6 + Math.abs(f12) - 1, u6 = f12 === 0, h7 = f12 < 0, g3 = e9 % 2 !== 0;
  return { nextN: a4, offset: c6, isZero: u6, isNeg: h7, isNegF: g3, offsetF: l6 };
}
function dc(t4, e9) {
  if (!Array.isArray(t4)) throw new Error("array expected");
  t4.forEach((n4, r6) => {
    if (!(n4 instanceof e9)) throw new Error("invalid point at index " + r6);
  });
}
function hc(t4, e9) {
  if (!Array.isArray(t4)) throw new Error("array of scalars expected");
  t4.forEach((n4, r6) => {
    if (!e9.isValid(n4)) throw new Error("invalid scalar at index " + r6);
  });
}
var Un = /* @__PURE__ */ new WeakMap();
var Ao = /* @__PURE__ */ new WeakMap();
function _n(t4) {
  return Ao.get(t4) || 1;
}
function So(t4) {
  if (t4 !== Xt) throw new Error("invalid wNAF");
}
function pc(t4, e9) {
  return { constTimeNegate: le, hasPrecomputes(n4) {
    return _n(n4) !== 1;
  }, unsafeLadder(n4, r6, o4 = t4.ZERO) {
    let s3 = n4;
    for (; r6 > Xt; ) r6 & Mt && (o4 = o4.add(s3)), s3 = s3.double(), r6 >>= Mt;
    return o4;
  }, precomputeWindow(n4, r6) {
    const { windows: o4, windowSize: s3 } = On(r6, e9), i6 = [];
    let f12 = n4, a4 = f12;
    for (let l6 = 0; l6 < o4; l6++) {
      a4 = f12, i6.push(a4);
      for (let c6 = 1; c6 < s3; c6++) a4 = a4.add(f12), i6.push(a4);
      f12 = a4.double();
    }
    return i6;
  }, wNAF(n4, r6, o4) {
    let s3 = t4.ZERO, i6 = t4.BASE;
    const f12 = On(n4, e9);
    for (let a4 = 0; a4 < f12.windows; a4++) {
      const { nextN: l6, offset: c6, isZero: u6, isNeg: h7, isNegF: g3, offsetF: w6 } = Io(o4, a4, f12);
      o4 = l6, u6 ? i6 = i6.add(le(g3, r6[w6])) : s3 = s3.add(le(h7, r6[c6]));
    }
    return So(o4), { p: s3, f: i6 };
  }, wNAFUnsafe(n4, r6, o4, s3 = t4.ZERO) {
    const i6 = On(n4, e9);
    for (let f12 = 0; f12 < i6.windows && o4 !== Xt; f12++) {
      const { nextN: a4, offset: l6, isZero: c6, isNeg: u6 } = Io(o4, f12, i6);
      if (o4 = a4, !c6) {
        const h7 = r6[l6];
        s3 = s3.add(u6 ? h7.negate() : h7);
      }
    }
    return So(o4), s3;
  }, getPrecomputes(n4, r6, o4) {
    let s3 = Un.get(r6);
    return s3 || (s3 = this.precomputeWindow(r6, n4), n4 !== 1 && (typeof o4 == "function" && (s3 = o4(s3)), Un.set(r6, s3))), s3;
  }, wNAFCached(n4, r6, o4) {
    const s3 = _n(n4);
    return this.wNAF(s3, this.getPrecomputes(s3, n4, o4), r6);
  }, wNAFCachedUnsafe(n4, r6, o4, s3) {
    const i6 = _n(n4);
    return i6 === 1 ? this.unsafeLadder(n4, r6, s3) : this.wNAFUnsafe(i6, this.getPrecomputes(i6, n4, o4), r6, s3);
  }, setWindowSize(n4, r6) {
    Bo(r6, e9), Ao.set(n4, r6), Un.delete(n4);
  } };
}
function gc(t4, e9, n4, r6) {
  let o4 = e9, s3 = t4.ZERO, i6 = t4.ZERO;
  for (; n4 > Xt || r6 > Xt; ) n4 & Mt && (s3 = s3.add(o4)), r6 & Mt && (i6 = i6.add(o4)), o4 = o4.double(), n4 >>= Mt, r6 >>= Mt;
  return { p1: s3, p2: i6 };
}
function bc(t4, e9, n4, r6) {
  dc(n4, t4), hc(r6, e9);
  const o4 = n4.length, s3 = r6.length;
  if (o4 !== s3) throw new Error("arrays of points and scalars must have equal length");
  const i6 = t4.ZERO, f12 = tc(BigInt(o4));
  let a4 = 1;
  f12 > 12 ? a4 = f12 - 3 : f12 > 4 ? a4 = f12 - 2 : f12 > 0 && (a4 = 2);
  const l6 = je(a4), c6 = new Array(Number(l6) + 1).fill(i6), u6 = Math.floor((e9.BITS - 1) / a4) * a4;
  let h7 = i6;
  for (let g3 = u6; g3 >= 0; g3 -= a4) {
    c6.fill(i6);
    for (let y8 = 0; y8 < s3; y8++) {
      const x5 = r6[y8], R6 = Number(x5 >> BigInt(g3) & l6);
      c6[R6] = c6[R6].add(n4[y8]);
    }
    let w6 = i6;
    for (let y8 = c6.length - 1, x5 = i6; y8 > 0; y8--) x5 = x5.add(c6[y8]), w6 = w6.add(x5);
    if (h7 = h7.add(w6), g3 !== 0) for (let y8 = 0; y8 < a4; y8++) h7 = h7.double();
  }
  return h7;
}
function No(t4, e9) {
  if (e9) {
    if (e9.ORDER !== t4) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc(e9), e9;
  } else return Yt(t4);
}
function yc(t4, e9, n4 = {}) {
  if (!e9 || typeof e9 != "object") throw new Error(`expected valid ${t4} CURVE object`);
  for (const f12 of ["p", "n", "h"]) {
    const a4 = e9[f12];
    if (!(typeof a4 == "bigint" && a4 > Xt)) throw new Error(`CURVE.${f12} must be positive bigint`);
  }
  const r6 = No(e9.p, n4.Fp), o4 = No(e9.n, n4.Fn), i6 = ["Gx", "Gy", "a", t4 === "weierstrass" ? "b" : "d"];
  for (const f12 of i6) if (!r6.isValid(e9[f12])) throw new Error(`CURVE.${f12} must be valid field element of CURVE.Fp`);
  return { Fp: r6, Fn: o4 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de = BigInt(0);
var Jt = BigInt(1);
var Pe = BigInt(2);
function mc(t4) {
  return ke(t4, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t4 });
}
function wc(t4) {
  const e9 = mc(t4), { P: n4, type: r6, adjustScalarBytes: o4, powPminus2: s3, randomBytes: i6 } = e9, f12 = r6 === "x25519";
  if (!f12 && r6 !== "x448") throw new Error("invalid type");
  const a4 = i6 || Zt, l6 = f12 ? 255 : 448, c6 = f12 ? 32 : 56, u6 = BigInt(f12 ? 9 : 5), h7 = BigInt(f12 ? 121665 : 39081), g3 = f12 ? Pe ** BigInt(254) : Pe ** BigInt(447), w6 = f12 ? BigInt(8) * Pe ** BigInt(251) - Jt : BigInt(4) * Pe ** BigInt(445) - Jt, y8 = g3 + w6 + Jt, x5 = (d5) => lt(d5, n4), R6 = M7(u6);
  function M7(d5) {
    return An(x5(d5), c6);
  }
  function L6(d5) {
    const m5 = rt("u coordinate", d5, c6);
    return f12 && (m5[31] &= 127), x5(Le(m5));
  }
  function V7(d5) {
    return Le(o4(rt("scalar", d5, c6)));
  }
  function _4(d5, m5) {
    const p7 = $7(L6(m5), V7(d5));
    if (p7 === de) throw new Error("invalid private or public key received");
    return M7(p7);
  }
  function k8(d5) {
    return _4(d5, R6);
  }
  function j6(d5, m5, p7) {
    const b5 = x5(d5 * (m5 - p7));
    return m5 = x5(m5 - b5), p7 = x5(p7 + b5), { x_2: m5, x_3: p7 };
  }
  function $7(d5, m5) {
    Nn("u", d5, de, n4), Nn("scalar", m5, g3, y8);
    const p7 = m5, b5 = d5;
    let v7 = Jt, B7 = de, E7 = d5, I7 = Jt, S7 = de;
    for (let A8 = BigInt(l6 - 1); A8 >= de; A8--) {
      const T6 = p7 >> A8 & Jt;
      S7 ^= T6, { x_2: v7, x_3: E7 } = j6(S7, v7, E7), { x_2: B7, x_3: I7 } = j6(S7, B7, I7), S7 = T6;
      const U6 = v7 + B7, C8 = x5(U6 * U6), H4 = v7 - B7, q5 = x5(H4 * H4), P6 = C8 - q5, K4 = E7 + I7, et3 = E7 - I7, Z5 = x5(et3 * U6), z6 = x5(K4 * H4), Ft3 = Z5 + z6, yt4 = Z5 - z6;
      E7 = x5(Ft3 * Ft3), I7 = x5(b5 * x5(yt4 * yt4)), v7 = x5(C8 * q5), B7 = x5(P6 * (C8 + x5(h7 * P6)));
    }
    ({ x_2: v7, x_3: E7 } = j6(S7, v7, E7)), { x_2: B7, x_3: I7 } = j6(S7, B7, I7);
    const O6 = s3(B7);
    return x5(v7 * O6);
  }
  return { scalarMult: _4, scalarMultBase: k8, getSharedSecret: (d5, m5) => _4(d5, m5), getPublicKey: (d5) => k8(d5), utils: { randomPrivateKey: () => a4(c6) }, GuBytes: R6.slice() };
}
BigInt(0);
var xc = BigInt(1);
var Oo = BigInt(2);
var vc = BigInt(3);
var Ec = BigInt(5);
var Bc = BigInt(8);
var Uo = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic(t4) {
  const e9 = BigInt(10), n4 = BigInt(20), r6 = BigInt(40), o4 = BigInt(80), s3 = Uo.p, f12 = t4 * t4 % s3 * t4 % s3, a4 = pt(f12, Oo, s3) * f12 % s3, l6 = pt(a4, xc, s3) * t4 % s3, c6 = pt(l6, Ec, s3) * l6 % s3, u6 = pt(c6, e9, s3) * c6 % s3, h7 = pt(u6, n4, s3) * u6 % s3, g3 = pt(h7, r6, s3) * h7 % s3, w6 = pt(g3, o4, s3) * g3 % s3, y8 = pt(w6, o4, s3) * g3 % s3, x5 = pt(y8, e9, s3) * c6 % s3;
  return { pow_p_5_8: pt(x5, Oo, s3) * t4 % s3, b2: f12 };
}
function Ac(t4) {
  return t4[0] &= 248, t4[31] &= 127, t4[31] |= 64, t4;
}
var Tn = (() => {
  const t4 = Uo.p;
  return wc({ P: t4, type: "x25519", powPminus2: (e9) => {
    const { pow_p_5_8: n4, b2: r6 } = Ic(e9);
    return lt(pt(n4, vc, t4) * r6, t4);
  }, adjustScalarBytes: Ac });
})();
function _o(t4) {
  t4.lowS !== void 0 && Re("lowS", t4.lowS), t4.prehash !== void 0 && Re("prehash", t4.prehash);
}
var Sc = class extends Error {
  constructor(e9 = "") {
    super(e9);
  }
};
var vt = { Err: Sc, _tlv: { encode: (t4, e9) => {
  const { Err: n4 } = vt;
  if (t4 < 0 || t4 > 256) throw new n4("tlv.encode: wrong tag");
  if (e9.length & 1) throw new n4("tlv.encode: unpadded data");
  const r6 = e9.length / 2, o4 = $e(r6);
  if (o4.length / 2 & 128) throw new n4("tlv.encode: long form length too big");
  const s3 = r6 > 127 ? $e(o4.length / 2 | 128) : "";
  return $e(t4) + s3 + o4 + e9;
}, decode(t4, e9) {
  const { Err: n4 } = vt;
  let r6 = 0;
  if (t4 < 0 || t4 > 256) throw new n4("tlv.encode: wrong tag");
  if (e9.length < 2 || e9[r6++] !== t4) throw new n4("tlv.decode: wrong tlv");
  const o4 = e9[r6++], s3 = !!(o4 & 128);
  let i6 = 0;
  if (!s3) i6 = o4;
  else {
    const a4 = o4 & 127;
    if (!a4) throw new n4("tlv.decode(long): indefinite length not supported");
    if (a4 > 4) throw new n4("tlv.decode(long): byte length is too big");
    const l6 = e9.subarray(r6, r6 + a4);
    if (l6.length !== a4) throw new n4("tlv.decode: length bytes not complete");
    if (l6[0] === 0) throw new n4("tlv.decode(long): zero leftmost byte");
    for (const c6 of l6) i6 = i6 << 8 | c6;
    if (r6 += a4, i6 < 128) throw new n4("tlv.decode(long): not minimal encoding");
  }
  const f12 = e9.subarray(r6, r6 + i6);
  if (f12.length !== i6) throw new n4("tlv.decode: wrong value length");
  return { v: f12, l: e9.subarray(r6 + i6) };
} }, _int: { encode(t4) {
  const { Err: e9 } = vt;
  if (t4 < he) throw new e9("integer: negative integers are not allowed");
  let n4 = $e(t4);
  if (Number.parseInt(n4[0], 16) & 8 && (n4 = "00" + n4), n4.length & 1) throw new e9("unexpected DER parsing assertion: unpadded hex");
  return n4;
}, decode(t4) {
  const { Err: e9 } = vt;
  if (t4[0] & 128) throw new e9("invalid signature integer: negative");
  if (t4[0] === 0 && !(t4[1] & 128)) throw new e9("invalid signature integer: unnecessary leading zero");
  return Ce(t4);
} }, toSig(t4) {
  const { Err: e9, _int: n4, _tlv: r6 } = vt, o4 = rt("signature", t4), { v: s3, l: i6 } = r6.decode(48, o4);
  if (i6.length) throw new e9("invalid signature: left bytes after parsing");
  const { v: f12, l: a4 } = r6.decode(2, s3), { v: l6, l: c6 } = r6.decode(2, a4);
  if (c6.length) throw new e9("invalid signature: left bytes after parsing");
  return { r: n4.decode(f12), s: n4.decode(l6) };
}, hexFromSig(t4) {
  const { _tlv: e9, _int: n4 } = vt, r6 = e9.encode(2, n4.encode(t4.r)), o4 = e9.encode(2, n4.encode(t4.s)), s3 = r6 + o4;
  return e9.encode(48, s3);
} };
var he = BigInt(0);
var pe = BigInt(1);
var Nc = BigInt(2);
var He = BigInt(3);
var Oc = BigInt(4);
function Uc(t4, e9, n4) {
  function r6(o4) {
    const s3 = t4.sqr(o4), i6 = t4.mul(s3, o4);
    return t4.add(t4.add(i6, t4.mul(o4, e9)), n4);
  }
  return r6;
}
function To(t4, e9, n4) {
  const { BYTES: r6 } = t4;
  function o4(s3) {
    let i6;
    if (typeof s3 == "bigint") i6 = s3;
    else {
      let f12 = rt("private key", s3);
      if (e9) {
        if (!e9.includes(f12.length * 2)) throw new Error("invalid private key");
        const a4 = new Uint8Array(r6);
        a4.set(f12, a4.length - f12.length), f12 = a4;
      }
      try {
        i6 = t4.fromBytes(f12);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r6}, got ${typeof s3}`);
      }
    }
    if (n4 && (i6 = t4.create(i6)), !t4.isValidNot0(i6)) throw new Error("invalid private key: out of range [1..N-1]");
    return i6;
  }
  return o4;
}
function _c(t4, e9 = {}) {
  const { Fp: n4, Fn: r6 } = yc("weierstrass", t4, e9), { h: o4, n: s3 } = t4;
  ke(e9, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i6 } = e9;
  if (i6 && (!n4.is0(t4.a) || typeof i6.beta != "bigint" || typeof i6.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f12() {
    if (!n4.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a4($7, d5, m5) {
    const { x: p7, y: b5 } = d5.toAffine(), v7 = n4.toBytes(p7);
    if (Re("isCompressed", m5), m5) {
      f12();
      const B7 = !n4.isOdd(b5);
      return Ht(Ro(B7), v7);
    } else return Ht(Uint8Array.of(4), v7, n4.toBytes(b5));
  }
  function l6($7) {
    at($7);
    const d5 = n4.BYTES, m5 = d5 + 1, p7 = 2 * d5 + 1, b5 = $7.length, v7 = $7[0], B7 = $7.subarray(1);
    if (b5 === m5 && (v7 === 2 || v7 === 3)) {
      const E7 = n4.fromBytes(B7);
      if (!n4.isValid(E7)) throw new Error("bad point: is not on curve, wrong x");
      const I7 = h7(E7);
      let S7;
      try {
        S7 = n4.sqrt(I7);
      } catch (T6) {
        const U6 = T6 instanceof Error ? ": " + T6.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U6);
      }
      f12();
      const O6 = n4.isOdd(S7);
      return (v7 & 1) === 1 !== O6 && (S7 = n4.neg(S7)), { x: E7, y: S7 };
    } else if (b5 === p7 && v7 === 4) {
      const E7 = n4.fromBytes(B7.subarray(d5 * 0, d5 * 1)), I7 = n4.fromBytes(B7.subarray(d5 * 1, d5 * 2));
      if (!g3(E7, I7)) throw new Error("bad point: is not on curve");
      return { x: E7, y: I7 };
    } else throw new Error(`bad point: got length ${b5}, expected compressed=${m5} or uncompressed=${p7}`);
  }
  const c6 = e9.toBytes || a4, u6 = e9.fromBytes || l6, h7 = Uc(n4, t4.a, t4.b);
  function g3($7, d5) {
    const m5 = n4.sqr(d5), p7 = h7($7);
    return n4.eql(m5, p7);
  }
  if (!g3(t4.Gx, t4.Gy)) throw new Error("bad curve params: generator point");
  const w6 = n4.mul(n4.pow(t4.a, He), Oc), y8 = n4.mul(n4.sqr(t4.b), BigInt(27));
  if (n4.is0(n4.add(w6, y8))) throw new Error("bad curve params: a or b");
  function x5($7, d5, m5 = false) {
    if (!n4.isValid(d5) || m5 && n4.is0(d5)) throw new Error(`bad point coordinate ${$7}`);
    return d5;
  }
  function R6($7) {
    if (!($7 instanceof _4)) throw new Error("ProjectivePoint expected");
  }
  const M7 = ho(($7, d5) => {
    const { px: m5, py: p7, pz: b5 } = $7;
    if (n4.eql(b5, n4.ONE)) return { x: m5, y: p7 };
    const v7 = $7.is0();
    d5 == null && (d5 = v7 ? n4.ONE : n4.inv(b5));
    const B7 = n4.mul(m5, d5), E7 = n4.mul(p7, d5), I7 = n4.mul(b5, d5);
    if (v7) return { x: n4.ZERO, y: n4.ZERO };
    if (!n4.eql(I7, n4.ONE)) throw new Error("invZ was invalid");
    return { x: B7, y: E7 };
  }), L6 = ho(($7) => {
    if ($7.is0()) {
      if (e9.allowInfinityPoint && !n4.is0($7.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d5, y: m5 } = $7.toAffine();
    if (!n4.isValid(d5) || !n4.isValid(m5)) throw new Error("bad point: x or y not field elements");
    if (!g3(d5, m5)) throw new Error("bad point: equation left != right");
    if (!$7.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V7($7, d5, m5, p7, b5) {
    return m5 = new _4(n4.mul(m5.px, $7), m5.py, m5.pz), d5 = le(p7, d5), m5 = le(b5, m5), d5.add(m5);
  }
  class _4 {
    constructor(d5, m5, p7) {
      this.px = x5("x", d5), this.py = x5("y", m5, true), this.pz = x5("z", p7), Object.freeze(this);
    }
    static fromAffine(d5) {
      const { x: m5, y: p7 } = d5 || {};
      if (!d5 || !n4.isValid(m5) || !n4.isValid(p7)) throw new Error("invalid affine point");
      if (d5 instanceof _4) throw new Error("projective point not allowed");
      return n4.is0(m5) && n4.is0(p7) ? _4.ZERO : new _4(m5, p7, n4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d5) {
      return lc(_4, "pz", d5);
    }
    static fromBytes(d5) {
      return at(d5), _4.fromHex(d5);
    }
    static fromHex(d5) {
      const m5 = _4.fromAffine(u6(rt("pointHex", d5)));
      return m5.assertValidity(), m5;
    }
    static fromPrivateKey(d5) {
      const m5 = To(r6, e9.allowedPrivateKeyLengths, e9.wrapPrivateKey);
      return _4.BASE.multiply(m5(d5));
    }
    static msm(d5, m5) {
      return bc(_4, r6, d5, m5);
    }
    precompute(d5 = 8, m5 = true) {
      return j6.setWindowSize(this, d5), m5 || this.multiply(He), this;
    }
    _setWindowSize(d5) {
      this.precompute(d5);
    }
    assertValidity() {
      L6(this);
    }
    hasEvenY() {
      const { y: d5 } = this.toAffine();
      if (!n4.isOdd) throw new Error("Field doesn't support isOdd");
      return !n4.isOdd(d5);
    }
    equals(d5) {
      R6(d5);
      const { px: m5, py: p7, pz: b5 } = this, { px: v7, py: B7, pz: E7 } = d5, I7 = n4.eql(n4.mul(m5, E7), n4.mul(v7, b5)), S7 = n4.eql(n4.mul(p7, E7), n4.mul(B7, b5));
      return I7 && S7;
    }
    negate() {
      return new _4(this.px, n4.neg(this.py), this.pz);
    }
    double() {
      const { a: d5, b: m5 } = t4, p7 = n4.mul(m5, He), { px: b5, py: v7, pz: B7 } = this;
      let E7 = n4.ZERO, I7 = n4.ZERO, S7 = n4.ZERO, O6 = n4.mul(b5, b5), A8 = n4.mul(v7, v7), T6 = n4.mul(B7, B7), U6 = n4.mul(b5, v7);
      return U6 = n4.add(U6, U6), S7 = n4.mul(b5, B7), S7 = n4.add(S7, S7), E7 = n4.mul(d5, S7), I7 = n4.mul(p7, T6), I7 = n4.add(E7, I7), E7 = n4.sub(A8, I7), I7 = n4.add(A8, I7), I7 = n4.mul(E7, I7), E7 = n4.mul(U6, E7), S7 = n4.mul(p7, S7), T6 = n4.mul(d5, T6), U6 = n4.sub(O6, T6), U6 = n4.mul(d5, U6), U6 = n4.add(U6, S7), S7 = n4.add(O6, O6), O6 = n4.add(S7, O6), O6 = n4.add(O6, T6), O6 = n4.mul(O6, U6), I7 = n4.add(I7, O6), T6 = n4.mul(v7, B7), T6 = n4.add(T6, T6), O6 = n4.mul(T6, U6), E7 = n4.sub(E7, O6), S7 = n4.mul(T6, A8), S7 = n4.add(S7, S7), S7 = n4.add(S7, S7), new _4(E7, I7, S7);
    }
    add(d5) {
      R6(d5);
      const { px: m5, py: p7, pz: b5 } = this, { px: v7, py: B7, pz: E7 } = d5;
      let I7 = n4.ZERO, S7 = n4.ZERO, O6 = n4.ZERO;
      const A8 = t4.a, T6 = n4.mul(t4.b, He);
      let U6 = n4.mul(m5, v7), C8 = n4.mul(p7, B7), H4 = n4.mul(b5, E7), q5 = n4.add(m5, p7), P6 = n4.add(v7, B7);
      q5 = n4.mul(q5, P6), P6 = n4.add(U6, C8), q5 = n4.sub(q5, P6), P6 = n4.add(m5, b5);
      let K4 = n4.add(v7, E7);
      return P6 = n4.mul(P6, K4), K4 = n4.add(U6, H4), P6 = n4.sub(P6, K4), K4 = n4.add(p7, b5), I7 = n4.add(B7, E7), K4 = n4.mul(K4, I7), I7 = n4.add(C8, H4), K4 = n4.sub(K4, I7), O6 = n4.mul(A8, P6), I7 = n4.mul(T6, H4), O6 = n4.add(I7, O6), I7 = n4.sub(C8, O6), O6 = n4.add(C8, O6), S7 = n4.mul(I7, O6), C8 = n4.add(U6, U6), C8 = n4.add(C8, U6), H4 = n4.mul(A8, H4), P6 = n4.mul(T6, P6), C8 = n4.add(C8, H4), H4 = n4.sub(U6, H4), H4 = n4.mul(A8, H4), P6 = n4.add(P6, H4), U6 = n4.mul(C8, P6), S7 = n4.add(S7, U6), U6 = n4.mul(K4, P6), I7 = n4.mul(q5, I7), I7 = n4.sub(I7, U6), U6 = n4.mul(q5, C8), O6 = n4.mul(K4, O6), O6 = n4.add(O6, U6), new _4(I7, S7, O6);
    }
    subtract(d5) {
      return this.add(d5.negate());
    }
    is0() {
      return this.equals(_4.ZERO);
    }
    multiply(d5) {
      const { endo: m5 } = e9;
      if (!r6.isValidNot0(d5)) throw new Error("invalid scalar: out of range");
      let p7, b5;
      const v7 = (B7) => j6.wNAFCached(this, B7, _4.normalizeZ);
      if (m5) {
        const { k1neg: B7, k1: E7, k2neg: I7, k2: S7 } = m5.splitScalar(d5), { p: O6, f: A8 } = v7(E7), { p: T6, f: U6 } = v7(S7);
        b5 = A8.add(U6), p7 = V7(m5.beta, O6, T6, B7, I7);
      } else {
        const { p: B7, f: E7 } = v7(d5);
        p7 = B7, b5 = E7;
      }
      return _4.normalizeZ([p7, b5])[0];
    }
    multiplyUnsafe(d5) {
      const { endo: m5 } = e9, p7 = this;
      if (!r6.isValid(d5)) throw new Error("invalid scalar: out of range");
      if (d5 === he || p7.is0()) return _4.ZERO;
      if (d5 === pe) return p7;
      if (j6.hasPrecomputes(this)) return this.multiply(d5);
      if (m5) {
        const { k1neg: b5, k1: v7, k2neg: B7, k2: E7 } = m5.splitScalar(d5), { p1: I7, p2: S7 } = gc(_4, p7, v7, E7);
        return V7(m5.beta, I7, S7, b5, B7);
      } else return j6.wNAFCachedUnsafe(p7, d5);
    }
    multiplyAndAddUnsafe(d5, m5, p7) {
      const b5 = this.multiplyUnsafe(m5).add(d5.multiplyUnsafe(p7));
      return b5.is0() ? void 0 : b5;
    }
    toAffine(d5) {
      return M7(this, d5);
    }
    isTorsionFree() {
      const { isTorsionFree: d5 } = e9;
      return o4 === pe ? true : d5 ? d5(_4, this) : j6.wNAFCachedUnsafe(this, s3).is0();
    }
    clearCofactor() {
      const { clearCofactor: d5 } = e9;
      return o4 === pe ? this : d5 ? d5(_4, this) : this.multiplyUnsafe(o4);
    }
    toBytes(d5 = true) {
      return Re("isCompressed", d5), this.assertValidity(), c6(_4, this, d5);
    }
    toRawBytes(d5 = true) {
      return this.toBytes(d5);
    }
    toHex(d5 = true) {
      return ce(this.toBytes(d5));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _4.BASE = new _4(t4.Gx, t4.Gy, n4.ONE), _4.ZERO = new _4(n4.ZERO, n4.ONE, n4.ZERO), _4.Fp = n4, _4.Fn = r6;
  const k8 = r6.BITS, j6 = pc(_4, e9.endo ? Math.ceil(k8 / 2) : k8);
  return _4;
}
function Ro(t4) {
  return Uint8Array.of(t4 ? 2 : 3);
}
function Tc(t4, e9, n4 = {}) {
  ke(e9, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r6 = e9.randomBytes || Zt, o4 = e9.hmac || ((p7, ...b5) => _e(e9.hash, p7, Ht(...b5))), { Fp: s3, Fn: i6 } = t4, { ORDER: f12, BITS: a4 } = i6;
  function l6(p7) {
    const b5 = f12 >> pe;
    return p7 > b5;
  }
  function c6(p7) {
    return l6(p7) ? i6.neg(p7) : p7;
  }
  function u6(p7, b5) {
    if (!i6.isValidNot0(b5)) throw new Error(`invalid signature ${p7}: out of range 1..CURVE.n`);
  }
  class h7 {
    constructor(b5, v7, B7) {
      u6("r", b5), u6("s", v7), this.r = b5, this.s = v7, B7 != null && (this.recovery = B7), Object.freeze(this);
    }
    static fromCompact(b5) {
      const v7 = i6.BYTES, B7 = rt("compactSignature", b5, v7 * 2);
      return new h7(i6.fromBytes(B7.subarray(0, v7)), i6.fromBytes(B7.subarray(v7, v7 * 2)));
    }
    static fromDER(b5) {
      const { r: v7, s: B7 } = vt.toSig(rt("DER", b5));
      return new h7(v7, B7);
    }
    assertValidity() {
    }
    addRecoveryBit(b5) {
      return new h7(this.r, this.s, b5);
    }
    recoverPublicKey(b5) {
      const v7 = s3.ORDER, { r: B7, s: E7, recovery: I7 } = this;
      if (I7 == null || ![0, 1, 2, 3].includes(I7)) throw new Error("recovery id invalid");
      if (f12 * Nc < v7 && I7 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O6 = I7 === 2 || I7 === 3 ? B7 + f12 : B7;
      if (!s3.isValid(O6)) throw new Error("recovery id 2 or 3 invalid");
      const A8 = s3.toBytes(O6), T6 = t4.fromHex(Ht(Ro((I7 & 1) === 0), A8)), U6 = i6.inv(O6), C8 = L6(rt("msgHash", b5)), H4 = i6.create(-C8 * U6), q5 = i6.create(E7 * U6), P6 = t4.BASE.multiplyUnsafe(H4).add(T6.multiplyUnsafe(q5));
      if (P6.is0()) throw new Error("point at infinify");
      return P6.assertValidity(), P6;
    }
    hasHighS() {
      return l6(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h7(this.r, i6.neg(this.s), this.recovery) : this;
    }
    toBytes(b5) {
      if (b5 === "compact") return Ht(i6.toBytes(this.r), i6.toBytes(this.s));
      if (b5 === "der") return fn(vt.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce(this.toBytes("compact"));
    }
  }
  const g3 = To(i6, n4.allowedPrivateKeyLengths, n4.wrapPrivateKey), w6 = { isValidPrivateKey(p7) {
    try {
      return g3(p7), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g3, randomPrivateKey: () => {
    const p7 = f12;
    return uc(r6(Eo(p7)), p7);
  }, precompute(p7 = 8, b5 = t4.BASE) {
    return b5.precompute(p7, false);
  } };
  function y8(p7, b5 = true) {
    return t4.fromPrivateKey(p7).toBytes(b5);
  }
  function x5(p7) {
    if (typeof p7 == "bigint") return false;
    if (p7 instanceof t4) return true;
    const v7 = rt("key", p7).length, B7 = s3.BYTES, E7 = B7 + 1, I7 = 2 * B7 + 1;
    if (!(n4.allowedPrivateKeyLengths || i6.BYTES === E7)) return v7 === E7 || v7 === I7;
  }
  function R6(p7, b5, v7 = true) {
    if (x5(p7) === true) throw new Error("first arg must be private key");
    if (x5(b5) === false) throw new Error("second arg must be public key");
    return t4.fromHex(b5).multiply(g3(p7)).toBytes(v7);
  }
  const M7 = e9.bits2int || function(p7) {
    if (p7.length > 8192) throw new Error("input is too large");
    const b5 = Ce(p7), v7 = p7.length * 8 - a4;
    return v7 > 0 ? b5 >> BigInt(v7) : b5;
  }, L6 = e9.bits2int_modN || function(p7) {
    return i6.create(M7(p7));
  }, V7 = je(a4);
  function _4(p7) {
    return Nn("num < 2^" + a4, p7, he, V7), i6.toBytes(p7);
  }
  function k8(p7, b5, v7 = j6) {
    if (["recovered", "canonical"].some((q5) => q5 in v7)) throw new Error("sign() legacy options not supported");
    const { hash: B7 } = e9;
    let { lowS: E7, prehash: I7, extraEntropy: S7 } = v7;
    E7 == null && (E7 = true), p7 = rt("msgHash", p7), _o(v7), I7 && (p7 = rt("prehashed msgHash", B7(p7)));
    const O6 = L6(p7), A8 = g3(b5), T6 = [_4(A8), _4(O6)];
    if (S7 != null && S7 !== false) {
      const q5 = S7 === true ? r6(s3.BYTES) : S7;
      T6.push(rt("extraEntropy", q5));
    }
    const U6 = Ht(...T6), C8 = O6;
    function H4(q5) {
      const P6 = M7(q5);
      if (!i6.isValidNot0(P6)) return;
      const K4 = i6.inv(P6), et3 = t4.BASE.multiply(P6).toAffine(), Z5 = i6.create(et3.x);
      if (Z5 === he) return;
      const z6 = i6.create(K4 * i6.create(C8 + Z5 * A8));
      if (z6 === he) return;
      let Ft3 = (et3.x === Z5 ? 0 : 2) | Number(et3.y & pe), yt4 = z6;
      return E7 && l6(z6) && (yt4 = c6(z6), Ft3 ^= 1), new h7(Z5, yt4, Ft3);
    }
    return { seed: U6, k2sig: H4 };
  }
  const j6 = { lowS: e9.lowS, prehash: false }, $7 = { lowS: e9.lowS, prehash: false };
  function d5(p7, b5, v7 = j6) {
    const { seed: B7, k2sig: E7 } = k8(p7, b5, v7);
    return ec(e9.hash.outputLen, i6.BYTES, o4)(B7, E7);
  }
  t4.BASE.precompute(8);
  function m5(p7, b5, v7, B7 = $7) {
    const E7 = p7;
    b5 = rt("msgHash", b5), v7 = rt("publicKey", v7), _o(B7);
    const { lowS: I7, prehash: S7, format: O6 } = B7;
    if ("strict" in B7) throw new Error("options.strict was renamed to lowS");
    if (O6 !== void 0 && !["compact", "der", "js"].includes(O6)) throw new Error('format must be "compact", "der" or "js"');
    const A8 = typeof E7 == "string" || nn(E7), T6 = !A8 && !O6 && typeof E7 == "object" && E7 !== null && typeof E7.r == "bigint" && typeof E7.s == "bigint";
    if (!A8 && !T6) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U6, C8;
    try {
      if (T6) if (O6 === void 0 || O6 === "js") U6 = new h7(E7.r, E7.s);
      else throw new Error("invalid format");
      if (A8) {
        try {
          O6 !== "compact" && (U6 = h7.fromDER(E7));
        } catch (yt4) {
          if (!(yt4 instanceof vt.Err)) throw yt4;
        }
        !U6 && O6 !== "der" && (U6 = h7.fromCompact(E7));
      }
      C8 = t4.fromHex(v7);
    } catch {
      return false;
    }
    if (!U6 || I7 && U6.hasHighS()) return false;
    S7 && (b5 = e9.hash(b5));
    const { r: H4, s: q5 } = U6, P6 = L6(b5), K4 = i6.inv(q5), et3 = i6.create(P6 * K4), Z5 = i6.create(H4 * K4), z6 = t4.BASE.multiplyUnsafe(et3).add(C8.multiplyUnsafe(Z5));
    return z6.is0() ? false : i6.create(z6.x) === H4;
  }
  return Object.freeze({ getPublicKey: y8, getSharedSecret: R6, sign: d5, verify: m5, utils: w6, Point: t4, Signature: h7 });
}
function Rc(t4) {
  const e9 = { a: t4.a, b: t4.b, p: t4.Fp.ORDER, n: t4.n, h: t4.h, Gx: t4.Gx, Gy: t4.Gy }, n4 = t4.Fp, r6 = Yt(e9.n, t4.nBitLength), o4 = { Fp: n4, Fn: r6, allowedPrivateKeyLengths: t4.allowedPrivateKeyLengths, allowInfinityPoint: t4.allowInfinityPoint, endo: t4.endo, wrapPrivateKey: t4.wrapPrivateKey, isTorsionFree: t4.isTorsionFree, clearCofactor: t4.clearCofactor, fromBytes: t4.fromBytes, toBytes: t4.toBytes };
  return { CURVE: e9, curveOpts: o4 };
}
function $c(t4) {
  const { CURVE: e9, curveOpts: n4 } = Rc(t4), r6 = { hash: t4.hash, hmac: t4.hmac, randomBytes: t4.randomBytes, lowS: t4.lowS, bits2int: t4.bits2int, bits2int_modN: t4.bits2int_modN };
  return { CURVE: e9, curveOpts: n4, ecdsaOpts: r6 };
}
function Cc(t4, e9) {
  return Object.assign({}, e9, { ProjectivePoint: e9.Point, CURVE: t4 });
}
function Lc(t4) {
  const { CURVE: e9, curveOpts: n4, ecdsaOpts: r6 } = $c(t4), o4 = _c(e9, n4), s3 = Tc(o4, r6, n4);
  return Cc(t4, s3);
}
function Rn(t4, e9) {
  const n4 = (r6) => Lc({ ...t4, hash: r6 });
  return { ...n4(e9), create: n4 };
}
var $o = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc = Yt($o.p);
var kc = Yt(Co.p);
var Pc = Yt(Lo.p);
var Hc = Rn({ ...$o, Fp: jc, lowS: false }, Ae);
Rn({ ...Co, Fp: kc, lowS: false }, Yi), Rn({ ...Lo, Fp: Pc, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi);
var Jo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function Kt(t4, e9) {
  const { message: n4, code: r6 } = Jo[t4];
  return { message: e9 ? `${n4} ${e9}` : n4, code: r6 };
}
function me(t4, e9) {
  return Array.isArray(t4) ? typeof e9 < "u" && t4.length ? t4.every(e9) : true : false;
}

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e9, s3, r6) => s3 in e9 ? a(e9, s3, { enumerable: true, configurable: true, writable: true, value: r6 }) : e9[s3] = r6;
var c = (e9, s3, r6) => u(e9, typeof s3 != "symbol" ? s3 + "" : s3, r6);
var h2 = class extends IEvents {
  constructor(s3) {
    super(), this.opts = s3, c(this, "protocol", "wc"), c(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e9, s3, r6) => s3 in e9 ? p(e9, s3, { enumerable: true, configurable: true, writable: true, value: r6 }) : e9[s3] = r6;
var v = (e9, s3, r6) => b(e9, typeof s3 != "symbol" ? s3 + "" : s3, r6);
var I = class extends IEvents {
  constructor(s3, r6) {
    super(), this.core = s3, this.logger = r6, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y2 = class {
  constructor(s3, r6) {
    this.logger = s3, this.core = r6;
  }
};
var m = class extends IEvents {
  constructor(s3, r6) {
    super(), this.relayer = s3, this.logger = r6;
  }
};
var d = class extends IEvents {
  constructor(s3) {
    super();
  }
};
var f3 = class {
  constructor(s3, r6, t4, q5) {
    this.core = s3, this.logger = r6, this.name = t4;
  }
};
var P = class extends IEvents {
  constructor(s3, r6) {
    super(), this.relayer = s3, this.logger = r6;
  }
};
var S = class extends IEvents {
  constructor(s3, r6) {
    super(), this.core = s3, this.logger = r6;
  }
};
var M = class {
  constructor(s3, r6, t4) {
    this.core = s3, this.logger = r6, this.store = t4;
  }
};
var O = class {
  constructor(s3, r6) {
    this.projectId = s3, this.logger = r6;
  }
};
var R = class {
  constructor(s3, r6, t4) {
    this.core = s3, this.logger = r6, this.telemetryEnabled = t4;
  }
};
var T = Object.defineProperty;
var k2 = (e9, s3, r6) => s3 in e9 ? T(e9, s3, { enumerable: true, configurable: true, writable: true, value: r6 }) : e9[s3] = r6;
var i2 = (e9, s3, r6) => k2(e9, typeof s3 != "symbol" ? s3 + "" : s3, r6);
var J = class {
  constructor(s3) {
    this.opts = s3, i2(this, "protocol", "wc"), i2(this, "version", 2);
  }
};
var V = class {
  constructor(s3) {
    this.client = s3;
  }
};

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/utils/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters2 = __toESM(require_cjs4());
var import_window_metadata2 = __toESM(require_cjs5());

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress2(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey2({ hash, signature }) {
  const hashHex = isHex2(hash) ? hash : toHex2(hash);
  const { secp256k1: secp256k14 } = await import("./secp256k1-5POLAE4F.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r6, s: s3, v: v7, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v7);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k14.Signature(hexToBigInt(r6), hexToBigInt(s3)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex2(signature) ? signature : toHex2(signature);
    if (size2(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber3(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k14.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress2({ hash, signature }) {
  return publicKeyToAddress2(await recoverPublicKey2({ hash, signature }));
}

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType2 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction2(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber3(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber3(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType2[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction2 = defineFormatter2("transaction", formatTransaction2);
function formatAuthorizationList2(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock2(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction2(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock2 = defineFormatter2("block", formatBlock2);

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount2(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex2(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber3(count);
}

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction2 = 6;
var bytesPerFieldElement2 = 32;
var fieldElementsPerBlob2 = 4096;
var bytesPerBlob2 = bytesPerFieldElement2 * fieldElementsPerBlob2;
var maxBytesPerTransaction2 = bytesPerBlob2 * blobsPerTransaction2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob2 * blobsPerTransaction2;

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/formatters/log.js
function formatLog2(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace2 = new LruMap2(128);

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses2 = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt2(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog2(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber3(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses2[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType2[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt2 = defineFormatter2("transactionReceipt", formatTransactionReceipt2);

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier2 = numberToHex2(0, {
  size: 32
});

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache2 = new LruMap2(8192);

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore2() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache2 = createIdStore2();

// node_modules/@walletconnect/sign-client/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager2(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap2(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc2() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount2(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager2 = createNonceManager2({
  source: jsonRpc2()
});

// node_modules/@walletconnect/sign-client/node_modules/ox/_esm/core/Hash.js
function keccak2564(value2, options = {}) {
  const { as: as3 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from2(value2));
  if (as3 === "Bytes")
    return bytes;
  return fromBytes2(bytes);
}

// node_modules/@walletconnect/sign-client/node_modules/ox/_esm/core/internal/lru.js
var LruMap5 = class extends Map {
  constructor(size10) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size10;
  }
  get(key) {
    const value2 = super.get(key);
    if (super.has(key) && value2 !== void 0) {
      this.delete(key);
      super.set(key, value2);
    }
    return value2;
  }
  set(key, value2) {
    super.set(key, value2);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@walletconnect/sign-client/node_modules/ox/_esm/core/Caches.js
var caches2 = {
  checksum: new LruMap5(8192)
};
var checksum3 = caches2.checksum;

// node_modules/@walletconnect/sign-client/node_modules/ox/_esm/core/Address.js
var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
function assert2(value2, options = {}) {
  const { strict = true } = options;
  if (!addressRegex2.test(value2))
    throw new InvalidAddressError4({
      address: value2,
      cause: new InvalidInputError2()
    });
  if (strict) {
    if (value2.toLowerCase() === value2)
      return;
    if (checksum4(value2) !== value2)
      throw new InvalidAddressError4({
        address: value2,
        cause: new InvalidChecksumError2()
      });
  }
}
function checksum4(address) {
  if (checksum3.has(address))
    return checksum3.get(address);
  assert2(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2564(fromString3(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i6 = 0; i6 < 40; i6 += 2) {
    if (hash[i6 >> 1] >> 4 >= 8 && characters[i6]) {
      characters[i6] = characters[i6].toUpperCase();
    }
    if ((hash[i6 >> 1] & 15) >= 8 && characters[i6 + 1]) {
      characters[i6 + 1] = characters[i6 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum3.set(address, result);
  return result;
}
var InvalidAddressError4 = class extends BaseError3 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError2 = class extends BaseError3 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError2 = class extends BaseError3 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@walletconnect/sign-client/node_modules/ox/_esm/core/Solidity.js
var arrayRegex4 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex4 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex4 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt83 = 2n ** (8n - 1n) - 1n;
var maxInt163 = 2n ** (16n - 1n) - 1n;
var maxInt243 = 2n ** (24n - 1n) - 1n;
var maxInt323 = 2n ** (32n - 1n) - 1n;
var maxInt403 = 2n ** (40n - 1n) - 1n;
var maxInt483 = 2n ** (48n - 1n) - 1n;
var maxInt563 = 2n ** (56n - 1n) - 1n;
var maxInt643 = 2n ** (64n - 1n) - 1n;
var maxInt723 = 2n ** (72n - 1n) - 1n;
var maxInt803 = 2n ** (80n - 1n) - 1n;
var maxInt883 = 2n ** (88n - 1n) - 1n;
var maxInt963 = 2n ** (96n - 1n) - 1n;
var maxInt1043 = 2n ** (104n - 1n) - 1n;
var maxInt1123 = 2n ** (112n - 1n) - 1n;
var maxInt1203 = 2n ** (120n - 1n) - 1n;
var maxInt1283 = 2n ** (128n - 1n) - 1n;
var maxInt1363 = 2n ** (136n - 1n) - 1n;
var maxInt1443 = 2n ** (144n - 1n) - 1n;
var maxInt1523 = 2n ** (152n - 1n) - 1n;
var maxInt1603 = 2n ** (160n - 1n) - 1n;
var maxInt1683 = 2n ** (168n - 1n) - 1n;
var maxInt1763 = 2n ** (176n - 1n) - 1n;
var maxInt1843 = 2n ** (184n - 1n) - 1n;
var maxInt1923 = 2n ** (192n - 1n) - 1n;
var maxInt2003 = 2n ** (200n - 1n) - 1n;
var maxInt2083 = 2n ** (208n - 1n) - 1n;
var maxInt2163 = 2n ** (216n - 1n) - 1n;
var maxInt2243 = 2n ** (224n - 1n) - 1n;
var maxInt2323 = 2n ** (232n - 1n) - 1n;
var maxInt2403 = 2n ** (240n - 1n) - 1n;
var maxInt2483 = 2n ** (248n - 1n) - 1n;
var maxInt2563 = 2n ** (256n - 1n) - 1n;
var minInt83 = -(2n ** (8n - 1n));
var minInt163 = -(2n ** (16n - 1n));
var minInt243 = -(2n ** (24n - 1n));
var minInt323 = -(2n ** (32n - 1n));
var minInt403 = -(2n ** (40n - 1n));
var minInt483 = -(2n ** (48n - 1n));
var minInt563 = -(2n ** (56n - 1n));
var minInt643 = -(2n ** (64n - 1n));
var minInt723 = -(2n ** (72n - 1n));
var minInt803 = -(2n ** (80n - 1n));
var minInt883 = -(2n ** (88n - 1n));
var minInt963 = -(2n ** (96n - 1n));
var minInt1043 = -(2n ** (104n - 1n));
var minInt1123 = -(2n ** (112n - 1n));
var minInt1203 = -(2n ** (120n - 1n));
var minInt1283 = -(2n ** (128n - 1n));
var minInt1363 = -(2n ** (136n - 1n));
var minInt1443 = -(2n ** (144n - 1n));
var minInt1523 = -(2n ** (152n - 1n));
var minInt1603 = -(2n ** (160n - 1n));
var minInt1683 = -(2n ** (168n - 1n));
var minInt1763 = -(2n ** (176n - 1n));
var minInt1843 = -(2n ** (184n - 1n));
var minInt1923 = -(2n ** (192n - 1n));
var minInt2003 = -(2n ** (200n - 1n));
var minInt2083 = -(2n ** (208n - 1n));
var minInt2163 = -(2n ** (216n - 1n));
var minInt2243 = -(2n ** (224n - 1n));
var minInt2323 = -(2n ** (232n - 1n));
var minInt2403 = -(2n ** (240n - 1n));
var minInt2483 = -(2n ** (248n - 1n));
var minInt2563 = -(2n ** (256n - 1n));
var maxUint83 = 2n ** 8n - 1n;
var maxUint163 = 2n ** 16n - 1n;
var maxUint243 = 2n ** 24n - 1n;
var maxUint323 = 2n ** 32n - 1n;
var maxUint403 = 2n ** 40n - 1n;
var maxUint483 = 2n ** 48n - 1n;
var maxUint563 = 2n ** 56n - 1n;
var maxUint643 = 2n ** 64n - 1n;
var maxUint723 = 2n ** 72n - 1n;
var maxUint803 = 2n ** 80n - 1n;
var maxUint883 = 2n ** 88n - 1n;
var maxUint963 = 2n ** 96n - 1n;
var maxUint1043 = 2n ** 104n - 1n;
var maxUint1123 = 2n ** 112n - 1n;
var maxUint1203 = 2n ** 120n - 1n;
var maxUint1283 = 2n ** 128n - 1n;
var maxUint1363 = 2n ** 136n - 1n;
var maxUint1443 = 2n ** 144n - 1n;
var maxUint1523 = 2n ** 152n - 1n;
var maxUint1603 = 2n ** 160n - 1n;
var maxUint1683 = 2n ** 168n - 1n;
var maxUint1763 = 2n ** 176n - 1n;
var maxUint1843 = 2n ** 184n - 1n;
var maxUint1923 = 2n ** 192n - 1n;
var maxUint2003 = 2n ** 200n - 1n;
var maxUint2083 = 2n ** 208n - 1n;
var maxUint2163 = 2n ** 216n - 1n;
var maxUint2243 = 2n ** 224n - 1n;
var maxUint2323 = 2n ** 232n - 1n;
var maxUint2403 = 2n ** 240n - 1n;
var maxUint2483 = 2n ** 248n - 1n;
var maxUint2564 = 2n ** 256n - 1n;

// node_modules/@walletconnect/sign-client/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor2 = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError2({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError4({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError2({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError2({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value2) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value2;
    this.position++;
  },
  pushUint16(value2) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value2);
    this.position += 2;
  },
  pushUint24(value2) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value2 >> 8);
    this.dataView.setUint8(this.position + 2, value2 & ~4294967040);
    this.position += 3;
  },
  pushUint32(value2) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value2);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectByte();
    this.position++;
    return value2;
  },
  readBytes(length, size10) {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectBytes(length);
    this.position += size10 ?? length;
    return value2;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint8();
    this.position += 1;
    return value2;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint16();
    this.position += 2;
    return value2;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint24();
    this.position += 3;
    return value2;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint32();
    this.position += 4;
    return value2;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError2 = class extends BaseError3 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError4 = class extends BaseError3 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError2 = class extends BaseError3 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@walletconnect/sign-client/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked4(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError2({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i6 = 0; i6 < types.length; i6++) {
    const type = types[i6];
    const value2 = values[i6];
    data.push(encodePacked4.encode(type, value2));
  }
  return concat2(...data);
}
(function(encodePacked7) {
  function encode12(type, value2, isArray = false) {
    if (type === "address") {
      const address = value2;
      assert2(address);
      return padLeft2(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString4(value2);
    if (type === "bytes")
      return value2;
    if (type === "bool")
      return padLeft2(fromBoolean2(value2), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex4);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size10 = Number.parseInt(bits) / 8;
      return fromNumber2(value2, {
        size: isArray ? 32 : size10,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex4);
    if (bytesMatch) {
      const [_type, size10] = bytesMatch;
      if (Number.parseInt(size10) !== (value2.length - 2) / 2)
        throw new BytesSizeMismatchError4({
          expectedSize: Number.parseInt(size10),
          value: value2
        });
      return padRight2(value2, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex4);
    if (arrayMatch && Array.isArray(value2)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i6 = 0; i6 < value2.length; i6++) {
        data.push(encode12(childType, value2[i6], true));
      }
      if (data.length === 0)
        return "0x";
      return concat2(...data);
    }
    throw new InvalidTypeError2(type);
  }
  encodePacked7.encode = encode12;
})(encodePacked4 || (encodePacked4 = {}));
var BytesSizeMismatchError4 = class extends BaseError3 {
  constructor({ expectedSize, value: value2 }) {
    super(`Size of bytes "${value2}" (bytes${size3(value2)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError2 = class extends BaseError3 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError2 = class extends BaseError3 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@walletconnect/sign-client/node_modules/base-x/src/esm/index.js
function base2(ALPHABET4) {
  if (ALPHABET4.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j6 = 0; j6 < BASE_MAP.length; j6++) {
    BASE_MAP[j6] = 255;
  }
  for (let i6 = 0; i6 < ALPHABET4.length; i6++) {
    const x5 = ALPHABET4.charAt(i6);
    const xc5 = x5.charCodeAt(0);
    if (BASE_MAP[xc5] !== 255) {
      throw new TypeError(x5 + " is ambiguous");
    }
    BASE_MAP[xc5] = i6;
  }
  const BASE = ALPHABET4.length;
  const LEADER = ALPHABET4.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode12(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size10 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size10);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i6 = 0;
      for (let it1 = size10 - 1; (carry !== 0 || i6 < length) && it1 !== -1; it1--, i6++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i6;
      pbegin++;
    }
    let it22 = size10 - length;
    while (it22 !== size10 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size10; ++it22) {
      str += ALPHABET4.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size10 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size10);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i6 = 0;
      for (let it32 = size10 - 1; (carry !== 0 || i6 < length) && it32 !== -1; it32--, i6++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i6;
      psz++;
    }
    let it4 = size10 - length;
    while (it4 !== size10 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size10 - it4));
    let j6 = zeroes;
    while (it4 !== size10) {
      vch[j6++] = b256[it4++];
    }
    return vch;
  }
  function decode7(string4) {
    const buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode12,
    decodeUnsafe,
    decode: decode7
  };
}
var esm_default3 = base2;

// node_modules/@walletconnect/sign-client/node_modules/bs58/src/esm/index.js
var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default4 = esm_default3(ALPHABET2);

// node_modules/@walletconnect/sign-client/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array2(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@walletconnect/sign-client/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe2(size10 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array2(globalThis.Buffer.allocUnsafe(size10));
  }
  return new Uint8Array(size10);
}

// node_modules/@walletconnect/sign-client/node_modules/uint8arrays/esm/src/concat.js
function concat7(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe2(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output);
}

// node_modules/@walletconnect/sign-client/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec2(name, prefix, encode12, decode7) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode12
    },
    decoder: { decode: decode7 }
  };
}
var string2 = createCodec2("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii2 = createCodec2("ascii", "a", (buf) => {
  let string4 = "a";
  for (let i6 = 0; i6 < buf.length; i6++) {
    string4 += String.fromCharCode(buf[i6]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe2(str.length);
  for (let i6 = 0; i6 < str.length; i6++) {
    buf[i6] = str.charCodeAt(i6);
  }
  return buf;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases
};
var bases_default2 = BASES2;

// node_modules/@walletconnect/sign-client/node_modules/uint8arrays/esm/src/from-string.js
function fromString8(string4, encoding = "utf8") {
  const base4 = bases_default2[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array2(globalThis.Buffer.from(string4, "utf-8"));
  }
  return base4.decoder.decode(`${base4.prefix}${string4}`);
}

// node_modules/@walletconnect/sign-client/node_modules/uint8arrays/esm/src/to-string.js
function toString4(array, encoding = "utf8") {
  const base4 = bases_default2[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base4.encoder.encode(array).substring(1);
}

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs2 = __toESM(require_blakejs());
var xe = ":";
function Fe(t4) {
  const [e9, n4] = t4.split(xe);
  return { namespace: e9, reference: n4 };
}
function ve(t4, e9) {
  return t4.includes(":") ? [t4] : e9.chains || [];
}
var $s = Object.defineProperty;
var Cs = Object.defineProperties;
var Ls = Object.getOwnPropertyDescriptors;
var Jn = Object.getOwnPropertySymbols;
var js = Object.prototype.hasOwnProperty;
var ks = Object.prototype.propertyIsEnumerable;
var Ze = (t4, e9, n4) => e9 in t4 ? $s(t4, e9, { enumerable: true, configurable: true, writable: true, value: n4 }) : t4[e9] = n4;
var Qn = (t4, e9) => {
  for (var n4 in e9 || (e9 = {})) js.call(e9, n4) && Ze(t4, n4, e9[n4]);
  if (Jn) for (var n4 of Jn(e9)) ks.call(e9, n4) && Ze(t4, n4, e9[n4]);
  return t4;
};
var Ps = (t4, e9) => Cs(t4, Ls(e9));
var tr = (t4, e9, n4) => Ze(t4, typeof e9 != "symbol" ? e9 + "" : e9, n4);
var er = "ReactNative";
var J2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var rr = "js";
function Ye() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Bt() {
  return !(0, import_window_getters2.getDocument)() && !!(0, import_window_getters2.getNavigator)() && navigator.product === er;
}
function Ms() {
  return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Vs() {
  return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function zt() {
  return !Ye() && !!(0, import_window_getters2.getNavigator)() && !!(0, import_window_getters2.getDocument)();
}
function Pt() {
  return Bt() ? J2.reactNative : Ye() ? J2.node : zt() ? J2.browser : J2.unknown;
}
function qs() {
  var t4;
  try {
    return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t4 = global.Application) == null ? void 0 : t4.applicationId : void 0;
  } catch {
    return;
  }
}
function or(t4, e9) {
  const n4 = new URLSearchParams(t4);
  for (const r6 of Object.keys(e9).sort()) if (e9.hasOwnProperty(r6)) {
    const o4 = e9[r6];
    o4 !== void 0 && n4.set(r6, o4);
  }
  return n4.toString();
}
function Ks(t4) {
  var e9, n4;
  const r6 = sr();
  try {
    return t4 != null && t4.url && r6.url && new URL(t4.url).host !== new URL(r6.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t4.url} differs from the actual page url:${r6.url}. This is probably unintended and can lead to issues.`), t4.url = r6.url), (e9 = t4?.icons) != null && e9.length && t4.icons.length > 0 && (t4.icons = t4.icons.filter((o4) => o4 !== "")), Ps(Qn(Qn({}, r6), t4), { url: t4?.url || r6.url, name: t4?.name || r6.name, description: t4?.description || r6.description, icons: (n4 = t4?.icons) != null && n4.length && t4.icons.length > 0 ? t4.icons : r6.icons });
  } catch (o4) {
    return console.warn("Error populating app metadata", o4), t4 || r6;
  }
}
function sr() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ir() {
  if (Pt() === J2.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n4, Version: r6 } = global.Platform;
    return [n4, r6].join("-");
  }
  const t4 = detect();
  if (t4 === null) return "unknown";
  const e9 = t4.os ? t4.os.replace(" ", "").toLowerCase() : "unknown";
  return t4.type === "browser" ? [e9, t4.name, t4.version].join("-") : [e9, t4.version].join("-");
}
function fr() {
  var t4;
  const e9 = Pt();
  return e9 === J2.browser ? [e9, ((t4 = (0, import_window_getters2.getLocation)()) == null ? void 0 : t4.host) || "unknown"].join(":") : e9;
}
function cr(t4, e9, n4) {
  const r6 = ir(), o4 = fr();
  return [[t4, e9].join("-"), [rr, n4].join("-"), r6, o4].join("/");
}
function zs({ protocol: t4, version: e9, relayUrl: n4, sdkVersion: r6, auth: o4, projectId: s3, useOnCloseEvent: i6, bundleId: f12, packageName: a4 }) {
  const l6 = n4.split("?"), c6 = cr(t4, e9, r6), u6 = { auth: o4, ua: c6, projectId: s3, useOnCloseEvent: i6 || void 0, packageName: a4 || void 0, bundleId: f12 || void 0 }, h7 = or(l6[1] || "", u6);
  return l6[0] + "?" + h7;
}
function It(t4, e9) {
  return t4.filter((n4) => e9.includes(n4)).length === t4.length;
}
function Ys(t4) {
  return Object.fromEntries(t4.entries());
}
function Xs(t4) {
  return new Map(Object.entries(t4));
}
function ei(t4 = import_time2.FIVE_MINUTES, e9) {
  const n4 = (0, import_time2.toMiliseconds)(t4 || import_time2.FIVE_MINUTES);
  let r6, o4, s3, i6;
  return { resolve: (f12) => {
    s3 && r6 && (clearTimeout(s3), r6(f12), i6 = Promise.resolve(f12));
  }, reject: (f12) => {
    s3 && o4 && (clearTimeout(s3), o4(f12));
  }, done: () => new Promise((f12, a4) => {
    if (i6) return f12(i6);
    s3 = setTimeout(() => {
      const l6 = new Error(e9);
      i6 = Promise.reject(l6), a4(l6);
    }, n4), r6 = f12, o4 = a4;
  }) };
}
function ni(t4, e9, n4) {
  return new Promise(async (r6, o4) => {
    const s3 = setTimeout(() => o4(new Error(n4)), e9);
    try {
      const i6 = await t4;
      r6(i6);
    } catch (i6) {
      o4(i6);
    }
    clearTimeout(s3);
  });
}
function Xe(t4, e9) {
  if (typeof e9 == "string" && e9.startsWith(`${t4}:`)) return e9;
  if (t4.toLowerCase() === "topic") {
    if (typeof e9 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e9}`;
  } else if (t4.toLowerCase() === "id") {
    if (typeof e9 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e9}`;
  }
  throw new Error(`Unknown expirer target type: ${t4}`);
}
function ri(t4) {
  return Xe("topic", t4);
}
function oi(t4) {
  return Xe("id", t4);
}
function si(t4) {
  const [e9, n4] = t4.split(":"), r6 = { id: void 0, topic: void 0 };
  if (e9 === "topic" && typeof n4 == "string") r6.topic = n4;
  else if (e9 === "id" && Number.isInteger(Number(n4))) r6.id = Number(n4);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e9}:${n4}`);
  return r6;
}
function ii(t4, e9) {
  return (0, import_time2.fromMiliseconds)((e9 || Date.now()) + (0, import_time2.toMiliseconds)(t4));
}
function fi(t4) {
  return Date.now() >= (0, import_time2.toMiliseconds)(t4);
}
function ci(t4, e9) {
  return `${t4}${e9 ? `:${e9}` : ""}`;
}
function ct(t4 = [], e9 = []) {
  return [.../* @__PURE__ */ new Set([...t4, ...e9])];
}
async function ai({ id: t4, topic: e9, wcDeepLink: n4 }) {
  var r6;
  try {
    if (!n4) return;
    const o4 = typeof n4 == "string" ? JSON.parse(n4) : n4, s3 = o4?.href;
    if (typeof s3 != "string") return;
    const i6 = dr(s3, t4, e9), f12 = Pt();
    if (f12 === J2.browser) {
      if (!((r6 = (0, import_window_getters2.getDocument)()) != null && r6.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      hr(i6);
    } else f12 === J2.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i6);
  } catch (o4) {
    console.error(o4);
  }
}
function dr(t4, e9, n4) {
  const r6 = `requestId=${e9}&sessionTopic=${n4}`;
  t4.endsWith("/") && (t4 = t4.slice(0, -1));
  let o4 = `${t4}`;
  if (t4.startsWith("https://t.me")) {
    const s3 = t4.includes("?") ? "&startapp=" : "?startapp=";
    o4 = `${o4}${s3}${br(r6, true)}`;
  } else o4 = `${o4}/wc?${r6}`;
  return o4;
}
function hr(t4) {
  let e9 = "_self";
  gr() ? e9 = "_top" : (pr() || t4.startsWith("https://") || t4.startsWith("http://")) && (e9 = "_blank"), window.open(t4, e9, "noreferrer noopener");
}
async function ui(t4, e9) {
  let n4 = "";
  try {
    if (zt() && (n4 = localStorage.getItem(e9), n4)) return n4;
    n4 = await t4.getItem(e9);
  } catch (r6) {
    console.error(r6);
  }
  return n4;
}
function li(t4, e9) {
  if (!t4.includes(e9)) return null;
  const n4 = t4.split(/([&,?,=])/), r6 = n4.indexOf(e9);
  return n4[r6 + 2];
}
function di() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t4) => {
    const e9 = Math.random() * 16 | 0;
    return (t4 === "x" ? e9 : e9 & 3 | 8).toString(16);
  });
}
function hi() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function pr() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function gr() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function br(t4, e9 = false) {
  const n4 = Buffer.from(t4).toString("base64");
  return e9 ? n4.replace(/[=]/g, "") : n4;
}
function Qe2(t4) {
  return Buffer.from(t4, "base64").toString("utf-8");
}
function pi(t4) {
  return new Promise((e9) => setTimeout(e9, t4));
}
var gi = class {
  constructor({ limit: e9 }) {
    tr(this, "limit"), tr(this, "set"), this.limit = e9, this.set = /* @__PURE__ */ new Set();
  }
  add(e9) {
    if (!this.set.has(e9)) {
      if (this.set.size >= this.limit) {
        const n4 = this.set.values().next().value;
        n4 && this.set.delete(n4);
      }
      this.set.add(e9);
    }
  }
  has(e9) {
    return this.set.has(e9);
  }
};
var Be2 = BigInt(2 ** 32 - 1);
var yr2 = BigInt(32);
function mr2(t4, e9 = false) {
  return e9 ? { h: Number(t4 & Be2), l: Number(t4 >> yr2 & Be2) } : { h: Number(t4 >> yr2 & Be2) | 0, l: Number(t4 & Be2) | 0 };
}
function wr2(t4, e9 = false) {
  const n4 = t4.length;
  let r6 = new Uint32Array(n4), o4 = new Uint32Array(n4);
  for (let s3 = 0; s3 < n4; s3++) {
    const { h: i6, l: f12 } = mr2(t4[s3], e9);
    [r6[s3], o4[s3]] = [i6, f12];
  }
  return [r6, o4];
}
var xr2 = (t4, e9, n4) => t4 >>> n4;
var vr2 = (t4, e9, n4) => t4 << 32 - n4 | e9 >>> n4;
var At2 = (t4, e9, n4) => t4 >>> n4 | e9 << 32 - n4;
var St2 = (t4, e9, n4) => t4 << 32 - n4 | e9 >>> n4;
var se2 = (t4, e9, n4) => t4 << 64 - n4 | e9 >>> n4 - 32;
var ie2 = (t4, e9, n4) => t4 >>> n4 - 32 | e9 << 64 - n4;
var bi2 = (t4, e9) => e9;
var yi2 = (t4, e9) => t4;
var mi2 = (t4, e9, n4) => t4 << n4 | e9 >>> 32 - n4;
var wi2 = (t4, e9, n4) => e9 << n4 | t4 >>> 32 - n4;
var xi2 = (t4, e9, n4) => e9 << n4 - 32 | t4 >>> 64 - n4;
var vi2 = (t4, e9, n4) => t4 << n4 - 32 | e9 >>> 64 - n4;
function dt2(t4, e9, n4, r6) {
  const o4 = (e9 >>> 0) + (r6 >>> 0);
  return { h: t4 + n4 + (o4 / 2 ** 32 | 0) | 0, l: o4 | 0 };
}
var tn2 = (t4, e9, n4) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0);
var en2 = (t4, e9, n4, r6) => e9 + n4 + r6 + (t4 / 2 ** 32 | 0) | 0;
var Ei2 = (t4, e9, n4, r6) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0) + (r6 >>> 0);
var Bi2 = (t4, e9, n4, r6, o4) => e9 + n4 + r6 + o4 + (t4 / 2 ** 32 | 0) | 0;
var Ii2 = (t4, e9, n4, r6, o4) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0) + (r6 >>> 0) + (o4 >>> 0);
var Ai2 = (t4, e9, n4, r6, o4, s3) => e9 + n4 + r6 + o4 + s3 + (t4 / 2 ** 32 | 0) | 0;
var Gt2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn2(t4) {
  return t4 instanceof Uint8Array || ArrayBuffer.isView(t4) && t4.constructor.name === "Uint8Array";
}
function mt2(t4) {
  if (!Number.isSafeInteger(t4) || t4 < 0) throw new Error("positive integer expected, got " + t4);
}
function at2(t4, ...e9) {
  if (!nn2(t4)) throw new Error("Uint8Array expected");
  if (e9.length > 0 && !e9.includes(t4.length)) throw new Error("Uint8Array expected of length " + e9 + ", got length=" + t4.length);
}
function rn2(t4) {
  if (typeof t4 != "function" || typeof t4.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt2(t4.outputLen), mt2(t4.blockLen);
}
function Nt2(t4, e9 = true) {
  if (t4.destroyed) throw new Error("Hash instance has been destroyed");
  if (e9 && t4.finished) throw new Error("Hash#digest() has already been called");
}
function on2(t4, e9) {
  at2(t4);
  const n4 = e9.outputLen;
  if (t4.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function fe2(t4) {
  return new Uint32Array(t4.buffer, t4.byteOffset, Math.floor(t4.byteLength / 4));
}
function ut2(...t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9].fill(0);
}
function sn3(t4) {
  return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
}
function gt2(t4, e9) {
  return t4 << 32 - e9 | t4 >>> e9;
}
var Er2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br2(t4) {
  return t4 << 24 & 4278190080 | t4 << 8 & 16711680 | t4 >>> 8 & 65280 | t4 >>> 24 & 255;
}
var wt2 = Er2 ? (t4) => t4 : (t4) => Br2(t4);
function Si2(t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9] = Br2(t4[e9]);
  return t4;
}
var Ot2 = Er2 ? (t4) => t4 : Si2;
var Ir2 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni2 = Array.from({ length: 256 }, (t4, e9) => e9.toString(16).padStart(2, "0"));
function ce2(t4) {
  if (at2(t4), Ir2) return t4.toHex();
  let e9 = "";
  for (let n4 = 0; n4 < t4.length; n4++) e9 += Ni2[t4[n4]];
  return e9;
}
var xt2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar2(t4) {
  if (t4 >= xt2._0 && t4 <= xt2._9) return t4 - xt2._0;
  if (t4 >= xt2.A && t4 <= xt2.F) return t4 - (xt2.A - 10);
  if (t4 >= xt2.a && t4 <= xt2.f) return t4 - (xt2.a - 10);
}
function fn2(t4) {
  if (typeof t4 != "string") throw new Error("hex string expected, got " + typeof t4);
  if (Ir2) return Uint8Array.fromHex(t4);
  const e9 = t4.length, n4 = e9 / 2;
  if (e9 % 2) throw new Error("hex string expected, got unpadded hex of length " + e9);
  const r6 = new Uint8Array(n4);
  for (let o4 = 0, s3 = 0; o4 < n4; o4++, s3 += 2) {
    const i6 = Ar2(t4.charCodeAt(s3)), f12 = Ar2(t4.charCodeAt(s3 + 1));
    if (i6 === void 0 || f12 === void 0) {
      const a4 = t4[s3] + t4[s3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a4 + '" at index ' + s3);
    }
    r6[o4] = i6 * 16 + f12;
  }
  return r6;
}
function Oi2(t4) {
  if (typeof t4 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t4));
}
function ht2(t4) {
  return typeof t4 == "string" && (t4 = Oi2(t4)), at2(t4), t4;
}
function Ht2(...t4) {
  let e9 = 0;
  for (let r6 = 0; r6 < t4.length; r6++) {
    const o4 = t4[r6];
    at2(o4), e9 += o4.length;
  }
  const n4 = new Uint8Array(e9);
  for (let r6 = 0, o4 = 0; r6 < t4.length; r6++) {
    const s3 = t4[r6];
    n4.set(s3, o4), o4 += s3.length;
  }
  return n4;
}
var Ie2 = class {
};
function ae2(t4) {
  const e9 = (r6) => t4().update(ht2(r6)).digest(), n4 = t4();
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = () => t4(), e9;
}
function Ui2(t4) {
  const e9 = (r6, o4) => t4(o4).update(ht2(r6)).digest(), n4 = t4({});
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = (r6) => t4(r6), e9;
}
function Zt2(t4 = 32) {
  if (Gt2 && typeof Gt2.getRandomValues == "function") return Gt2.getRandomValues(new Uint8Array(t4));
  if (Gt2 && typeof Gt2.randomBytes == "function") return Uint8Array.from(Gt2.randomBytes(t4));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i2 = BigInt(0);
var ue2 = BigInt(1);
var Ti2 = BigInt(2);
var Ri2 = BigInt(7);
var $i2 = BigInt(256);
var Ci2 = BigInt(113);
var Sr2 = [];
var Nr2 = [];
var Or2 = [];
for (let t4 = 0, e9 = ue2, n4 = 1, r6 = 0; t4 < 24; t4++) {
  [n4, r6] = [r6, (2 * n4 + 3 * r6) % 5], Sr2.push(2 * (5 * r6 + n4)), Nr2.push((t4 + 1) * (t4 + 2) / 2 % 64);
  let o4 = _i2;
  for (let s3 = 0; s3 < 7; s3++) e9 = (e9 << ue2 ^ (e9 >> Ri2) * Ci2) % $i2, e9 & Ti2 && (o4 ^= ue2 << (ue2 << BigInt(s3)) - ue2);
  Or2.push(o4);
}
var Ur2 = wr2(Or2, true);
var Li2 = Ur2[0];
var ji2 = Ur2[1];
var _r2 = (t4, e9, n4) => n4 > 32 ? xi2(t4, e9, n4) : mi2(t4, e9, n4);
var Tr2 = (t4, e9, n4) => n4 > 32 ? vi2(t4, e9, n4) : wi2(t4, e9, n4);
function ki2(t4, e9 = 24) {
  const n4 = new Uint32Array(10);
  for (let r6 = 24 - e9; r6 < 24; r6++) {
    for (let i6 = 0; i6 < 10; i6++) n4[i6] = t4[i6] ^ t4[i6 + 10] ^ t4[i6 + 20] ^ t4[i6 + 30] ^ t4[i6 + 40];
    for (let i6 = 0; i6 < 10; i6 += 2) {
      const f12 = (i6 + 8) % 10, a4 = (i6 + 2) % 10, l6 = n4[a4], c6 = n4[a4 + 1], u6 = _r2(l6, c6, 1) ^ n4[f12], h7 = Tr2(l6, c6, 1) ^ n4[f12 + 1];
      for (let g3 = 0; g3 < 50; g3 += 10) t4[i6 + g3] ^= u6, t4[i6 + g3 + 1] ^= h7;
    }
    let o4 = t4[2], s3 = t4[3];
    for (let i6 = 0; i6 < 24; i6++) {
      const f12 = Nr2[i6], a4 = _r2(o4, s3, f12), l6 = Tr2(o4, s3, f12), c6 = Sr2[i6];
      o4 = t4[c6], s3 = t4[c6 + 1], t4[c6] = a4, t4[c6 + 1] = l6;
    }
    for (let i6 = 0; i6 < 50; i6 += 10) {
      for (let f12 = 0; f12 < 10; f12++) n4[f12] = t4[i6 + f12];
      for (let f12 = 0; f12 < 10; f12++) t4[i6 + f12] ^= ~n4[(f12 + 2) % 10] & n4[(f12 + 4) % 10];
    }
    t4[0] ^= Li2[r6], t4[1] ^= ji2[r6];
  }
  ut2(n4);
}
var qn2 = class _qn extends Ie2 {
  constructor(e9, n4, r6, o4 = false, s3 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e9, this.suffix = n4, this.outputLen = r6, this.enableXOF = o4, this.rounds = s3, mt2(r6), !(0 < e9 && e9 < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe2(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot2(this.state32), ki2(this.state32, this.rounds), Ot2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e9) {
    Nt2(this), e9 = ht2(e9), at2(e9);
    const { blockLen: n4, state: r6 } = this, o4 = e9.length;
    for (let s3 = 0; s3 < o4; ) {
      const i6 = Math.min(n4 - this.pos, o4 - s3);
      for (let f12 = 0; f12 < i6; f12++) r6[this.pos++] ^= e9[s3++];
      this.pos === n4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e9, suffix: n4, pos: r6, blockLen: o4 } = this;
    e9[r6] ^= n4, (n4 & 128) !== 0 && r6 === o4 - 1 && this.keccak(), e9[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(e9) {
    Nt2(this, false), at2(e9), this.finish();
    const n4 = this.state, { blockLen: r6 } = this;
    for (let o4 = 0, s3 = e9.length; o4 < s3; ) {
      this.posOut >= r6 && this.keccak();
      const i6 = Math.min(r6 - this.posOut, s3 - o4);
      e9.set(n4.subarray(this.posOut, this.posOut + i6), o4), this.posOut += i6, o4 += i6;
    }
    return e9;
  }
  xofInto(e9) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e9);
  }
  xof(e9) {
    return mt2(e9), this.xofInto(new Uint8Array(e9));
  }
  digestInto(e9) {
    if (on2(e9, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e9), this.destroy(), e9;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut2(this.state);
  }
  _cloneInto(e9) {
    const { blockLen: n4, suffix: r6, outputLen: o4, rounds: s3, enableXOF: i6 } = this;
    return e9 || (e9 = new _qn(n4, r6, o4, i6, s3)), e9.state32.set(this.state32), e9.pos = this.pos, e9.posOut = this.posOut, e9.finished = this.finished, e9.rounds = s3, e9.suffix = r6, e9.outputLen = o4, e9.enableXOF = i6, e9.destroyed = this.destroyed, e9;
  }
};
var Pi2 = (t4, e9, n4) => ae2(() => new qn2(e9, t4, n4));
var Hi2 = Pi2(1, 136, 256 / 8);
function Di2(t4, e9, n4, r6) {
  if (typeof t4.setBigUint64 == "function") return t4.setBigUint64(e9, n4, r6);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i6 = Number(n4 >> o4 & s3), f12 = Number(n4 & s3), a4 = r6 ? 4 : 0, l6 = r6 ? 0 : 4;
  t4.setUint32(e9 + a4, i6, r6), t4.setUint32(e9 + l6, f12, r6);
}
function Mi2(t4, e9, n4) {
  return t4 & e9 ^ ~t4 & n4;
}
function Vi2(t4, e9, n4) {
  return t4 & e9 ^ t4 & n4 ^ e9 & n4;
}
var Rr2 = class extends Ie2 {
  constructor(e9, n4, r6, o4) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e9, this.outputLen = n4, this.padOffset = r6, this.isLE = o4, this.buffer = new Uint8Array(e9), this.view = sn3(this.buffer);
  }
  update(e9) {
    Nt2(this), e9 = ht2(e9), at2(e9);
    const { view: n4, buffer: r6, blockLen: o4 } = this, s3 = e9.length;
    for (let i6 = 0; i6 < s3; ) {
      const f12 = Math.min(o4 - this.pos, s3 - i6);
      if (f12 === o4) {
        const a4 = sn3(e9);
        for (; o4 <= s3 - i6; i6 += o4) this.process(a4, i6);
        continue;
      }
      r6.set(e9.subarray(i6, i6 + f12), this.pos), this.pos += f12, i6 += f12, this.pos === o4 && (this.process(n4, 0), this.pos = 0);
    }
    return this.length += e9.length, this.roundClean(), this;
  }
  digestInto(e9) {
    Nt2(this), on2(e9, this), this.finished = true;
    const { buffer: n4, view: r6, blockLen: o4, isLE: s3 } = this;
    let { pos: i6 } = this;
    n4[i6++] = 128, ut2(this.buffer.subarray(i6)), this.padOffset > o4 - i6 && (this.process(r6, 0), i6 = 0);
    for (let u6 = i6; u6 < o4; u6++) n4[u6] = 0;
    Di2(r6, o4 - 8, BigInt(this.length * 8), s3), this.process(r6, 0);
    const f12 = sn3(e9), a4 = this.outputLen;
    if (a4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l6 = a4 / 4, c6 = this.get();
    if (l6 > c6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u6 = 0; u6 < l6; u6++) f12.setUint32(4 * u6, c6[u6], s3);
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
  _cloneInto(e9) {
    e9 || (e9 = new this.constructor()), e9.set(...this.get());
    const { blockLen: n4, buffer: r6, length: o4, finished: s3, destroyed: i6, pos: f12 } = this;
    return e9.destroyed = i6, e9.finished = s3, e9.length = o4, e9.pos = f12, o4 % n4 && e9.buffer.set(r6), e9;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut2 = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W2 = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y2 = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi2 = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t2 = new Uint32Array(64);
var Ki2 = class extends Rr2 {
  constructor(e9 = 32) {
    super(64, e9, 8, false), this.A = Ut2[0] | 0, this.B = Ut2[1] | 0, this.C = Ut2[2] | 0, this.D = Ut2[3] | 0, this.E = Ut2[4] | 0, this.F = Ut2[5] | 0, this.G = Ut2[6] | 0, this.H = Ut2[7] | 0;
  }
  get() {
    const { A: e9, B: n4, C: r6, D: o4, E: s3, F: i6, G: f12, H: a4 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4) {
    this.A = e9 | 0, this.B = n4 | 0, this.C = r6 | 0, this.D = o4 | 0, this.E = s3 | 0, this.F = i6 | 0, this.G = f12 | 0, this.H = a4 | 0;
  }
  process(e9, n4) {
    for (let u6 = 0; u6 < 16; u6++, n4 += 4) _t2[u6] = e9.getUint32(n4, false);
    for (let u6 = 16; u6 < 64; u6++) {
      const h7 = _t2[u6 - 15], g3 = _t2[u6 - 2], w6 = gt2(h7, 7) ^ gt2(h7, 18) ^ h7 >>> 3, y8 = gt2(g3, 17) ^ gt2(g3, 19) ^ g3 >>> 10;
      _t2[u6] = y8 + _t2[u6 - 7] + w6 + _t2[u6 - 16] | 0;
    }
    let { A: r6, B: o4, C: s3, D: i6, E: f12, F: a4, G: l6, H: c6 } = this;
    for (let u6 = 0; u6 < 64; u6++) {
      const h7 = gt2(f12, 6) ^ gt2(f12, 11) ^ gt2(f12, 25), g3 = c6 + h7 + Mi2(f12, a4, l6) + qi2[u6] + _t2[u6] | 0, y8 = (gt2(r6, 2) ^ gt2(r6, 13) ^ gt2(r6, 22)) + Vi2(r6, o4, s3) | 0;
      c6 = l6, l6 = a4, a4 = f12, f12 = i6 + g3 | 0, i6 = s3, s3 = o4, o4 = r6, r6 = g3 + y8 | 0;
    }
    r6 = r6 + this.A | 0, o4 = o4 + this.B | 0, s3 = s3 + this.C | 0, i6 = i6 + this.D | 0, f12 = f12 + this.E | 0, a4 = a4 + this.F | 0, l6 = l6 + this.G | 0, c6 = c6 + this.H | 0, this.set(r6, o4, s3, i6, f12, a4, l6, c6);
  }
  roundClean() {
    ut2(_t2);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut2(this.buffer);
  }
};
var $r2 = wr2(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t4) => BigInt(t4)));
var Fi2 = $r2[0];
var zi2 = $r2[1];
var Tt2 = new Uint32Array(80);
var Rt2 = new Uint32Array(80);
var cn2 = class extends Rr2 {
  constructor(e9 = 64) {
    super(128, e9, 16, false), this.Ah = Y2[0] | 0, this.Al = Y2[1] | 0, this.Bh = Y2[2] | 0, this.Bl = Y2[3] | 0, this.Ch = Y2[4] | 0, this.Cl = Y2[5] | 0, this.Dh = Y2[6] | 0, this.Dl = Y2[7] | 0, this.Eh = Y2[8] | 0, this.El = Y2[9] | 0, this.Fh = Y2[10] | 0, this.Fl = Y2[11] | 0, this.Gh = Y2[12] | 0, this.Gl = Y2[13] | 0, this.Hh = Y2[14] | 0, this.Hl = Y2[15] | 0;
  }
  get() {
    const { Ah: e9, Al: n4, Bh: r6, Bl: o4, Ch: s3, Cl: i6, Dh: f12, Dl: a4, Eh: l6, El: c6, Fh: u6, Fl: h7, Gh: g3, Gl: w6, Hh: y8, Hl: x5 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5) {
    this.Ah = e9 | 0, this.Al = n4 | 0, this.Bh = r6 | 0, this.Bl = o4 | 0, this.Ch = s3 | 0, this.Cl = i6 | 0, this.Dh = f12 | 0, this.Dl = a4 | 0, this.Eh = l6 | 0, this.El = c6 | 0, this.Fh = u6 | 0, this.Fl = h7 | 0, this.Gh = g3 | 0, this.Gl = w6 | 0, this.Hh = y8 | 0, this.Hl = x5 | 0;
  }
  process(e9, n4) {
    for (let L6 = 0; L6 < 16; L6++, n4 += 4) Tt2[L6] = e9.getUint32(n4), Rt2[L6] = e9.getUint32(n4 += 4);
    for (let L6 = 16; L6 < 80; L6++) {
      const V7 = Tt2[L6 - 15] | 0, _4 = Rt2[L6 - 15] | 0, k8 = At2(V7, _4, 1) ^ At2(V7, _4, 8) ^ xr2(V7, _4, 7), j6 = St2(V7, _4, 1) ^ St2(V7, _4, 8) ^ vr2(V7, _4, 7), $7 = Tt2[L6 - 2] | 0, d5 = Rt2[L6 - 2] | 0, m5 = At2($7, d5, 19) ^ se2($7, d5, 61) ^ xr2($7, d5, 6), p7 = St2($7, d5, 19) ^ ie2($7, d5, 61) ^ vr2($7, d5, 6), b5 = Ei2(j6, p7, Rt2[L6 - 7], Rt2[L6 - 16]), v7 = Bi2(b5, k8, m5, Tt2[L6 - 7], Tt2[L6 - 16]);
      Tt2[L6] = v7 | 0, Rt2[L6] = b5 | 0;
    }
    let { Ah: r6, Al: o4, Bh: s3, Bl: i6, Ch: f12, Cl: a4, Dh: l6, Dl: c6, Eh: u6, El: h7, Fh: g3, Fl: w6, Gh: y8, Gl: x5, Hh: R6, Hl: M7 } = this;
    for (let L6 = 0; L6 < 80; L6++) {
      const V7 = At2(u6, h7, 14) ^ At2(u6, h7, 18) ^ se2(u6, h7, 41), _4 = St2(u6, h7, 14) ^ St2(u6, h7, 18) ^ ie2(u6, h7, 41), k8 = u6 & g3 ^ ~u6 & y8, j6 = h7 & w6 ^ ~h7 & x5, $7 = Ii2(M7, _4, j6, zi2[L6], Rt2[L6]), d5 = Ai2($7, R6, V7, k8, Fi2[L6], Tt2[L6]), m5 = $7 | 0, p7 = At2(r6, o4, 28) ^ se2(r6, o4, 34) ^ se2(r6, o4, 39), b5 = St2(r6, o4, 28) ^ ie2(r6, o4, 34) ^ ie2(r6, o4, 39), v7 = r6 & s3 ^ r6 & f12 ^ s3 & f12, B7 = o4 & i6 ^ o4 & a4 ^ i6 & a4;
      R6 = y8 | 0, M7 = x5 | 0, y8 = g3 | 0, x5 = w6 | 0, g3 = u6 | 0, w6 = h7 | 0, { h: u6, l: h7 } = dt2(l6 | 0, c6 | 0, d5 | 0, m5 | 0), l6 = f12 | 0, c6 = a4 | 0, f12 = s3 | 0, a4 = i6 | 0, s3 = r6 | 0, i6 = o4 | 0;
      const E7 = tn2(m5, b5, B7);
      r6 = en2(E7, d5, p7, v7), o4 = E7 | 0;
    }
    ({ h: r6, l: o4 } = dt2(this.Ah | 0, this.Al | 0, r6 | 0, o4 | 0)), { h: s3, l: i6 } = dt2(this.Bh | 0, this.Bl | 0, s3 | 0, i6 | 0), { h: f12, l: a4 } = dt2(this.Ch | 0, this.Cl | 0, f12 | 0, a4 | 0), { h: l6, l: c6 } = dt2(this.Dh | 0, this.Dl | 0, l6 | 0, c6 | 0), { h: u6, l: h7 } = dt2(this.Eh | 0, this.El | 0, u6 | 0, h7 | 0), { h: g3, l: w6 } = dt2(this.Fh | 0, this.Fl | 0, g3 | 0, w6 | 0), { h: y8, l: x5 } = dt2(this.Gh | 0, this.Gl | 0, y8 | 0, x5 | 0), { h: R6, l: M7 } = dt2(this.Hh | 0, this.Hl | 0, R6 | 0, M7 | 0), this.set(r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5, R6, M7);
  }
  roundClean() {
    ut2(Tt2, Rt2);
  }
  destroy() {
    ut2(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi2 = class extends cn2 {
  constructor() {
    super(48), this.Ah = W2[0] | 0, this.Al = W2[1] | 0, this.Bh = W2[2] | 0, this.Bl = W2[3] | 0, this.Ch = W2[4] | 0, this.Cl = W2[5] | 0, this.Dh = W2[6] | 0, this.Dl = W2[7] | 0, this.Eh = W2[8] | 0, this.El = W2[9] | 0, this.Fh = W2[10] | 0, this.Fl = W2[11] | 0, this.Gh = W2[12] | 0, this.Gl = W2[13] | 0, this.Hh = W2[14] | 0, this.Hl = W2[15] | 0;
  }
};
var X2 = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi2 = class extends cn2 {
  constructor() {
    super(32), this.Ah = X2[0] | 0, this.Al = X2[1] | 0, this.Bh = X2[2] | 0, this.Bl = X2[3] | 0, this.Ch = X2[4] | 0, this.Cl = X2[5] | 0, this.Dh = X2[6] | 0, this.Dl = X2[7] | 0, this.Eh = X2[8] | 0, this.El = X2[9] | 0, this.Fh = X2[10] | 0, this.Fl = X2[11] | 0, this.Gh = X2[12] | 0, this.Gl = X2[13] | 0, this.Hh = X2[14] | 0, this.Hl = X2[15] | 0;
  }
};
var Ae2 = ae2(() => new Ki2());
var Wi2 = ae2(() => new cn2());
var Yi2 = ae2(() => new Gi2());
var Xi2 = ae2(() => new Zi2());
var Ji2 = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F2 = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N2 = new Uint32Array(32);
function $t2(t4, e9, n4, r6, o4, s3) {
  const i6 = o4[s3], f12 = o4[s3 + 1];
  let a4 = N2[2 * t4], l6 = N2[2 * t4 + 1], c6 = N2[2 * e9], u6 = N2[2 * e9 + 1], h7 = N2[2 * n4], g3 = N2[2 * n4 + 1], w6 = N2[2 * r6], y8 = N2[2 * r6 + 1], x5 = tn2(a4, c6, i6);
  l6 = en2(x5, l6, u6, f12), a4 = x5 | 0, { Dh: y8, Dl: w6 } = { Dh: y8 ^ l6, Dl: w6 ^ a4 }, { Dh: y8, Dl: w6 } = { Dh: bi2(y8, w6), Dl: yi2(y8) }, { h: g3, l: h7 } = dt2(g3, h7, y8, w6), { Bh: u6, Bl: c6 } = { Bh: u6 ^ g3, Bl: c6 ^ h7 }, { Bh: u6, Bl: c6 } = { Bh: At2(u6, c6, 24), Bl: St2(u6, c6, 24) }, N2[2 * t4] = a4, N2[2 * t4 + 1] = l6, N2[2 * e9] = c6, N2[2 * e9 + 1] = u6, N2[2 * n4] = h7, N2[2 * n4 + 1] = g3, N2[2 * r6] = w6, N2[2 * r6 + 1] = y8;
}
function Ct2(t4, e9, n4, r6, o4, s3) {
  const i6 = o4[s3], f12 = o4[s3 + 1];
  let a4 = N2[2 * t4], l6 = N2[2 * t4 + 1], c6 = N2[2 * e9], u6 = N2[2 * e9 + 1], h7 = N2[2 * n4], g3 = N2[2 * n4 + 1], w6 = N2[2 * r6], y8 = N2[2 * r6 + 1], x5 = tn2(a4, c6, i6);
  l6 = en2(x5, l6, u6, f12), a4 = x5 | 0, { Dh: y8, Dl: w6 } = { Dh: y8 ^ l6, Dl: w6 ^ a4 }, { Dh: y8, Dl: w6 } = { Dh: At2(y8, w6, 16), Dl: St2(y8, w6, 16) }, { h: g3, l: h7 } = dt2(g3, h7, y8, w6), { Bh: u6, Bl: c6 } = { Bh: u6 ^ g3, Bl: c6 ^ h7 }, { Bh: u6, Bl: c6 } = { Bh: se2(u6, c6, 63), Bl: ie2(u6, c6, 63) }, N2[2 * t4] = a4, N2[2 * t4 + 1] = l6, N2[2 * e9] = c6, N2[2 * e9 + 1] = u6, N2[2 * n4] = h7, N2[2 * n4 + 1] = g3, N2[2 * r6] = w6, N2[2 * r6 + 1] = y8;
}
function Qi2(t4, e9 = {}, n4, r6, o4) {
  if (mt2(n4), t4 < 0 || t4 > n4) throw new Error("outputLen bigger than keyLen");
  const { key: s3, salt: i6, personalization: f12 } = e9;
  if (s3 !== void 0 && (s3.length < 1 || s3.length > n4)) throw new Error("key length must be undefined or 1.." + n4);
  if (i6 !== void 0 && i6.length !== r6) throw new Error("salt must be undefined or " + r6);
  if (f12 !== void 0 && f12.length !== o4) throw new Error("personalization must be undefined or " + o4);
}
var tf2 = class extends Ie2 {
  constructor(e9, n4) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt2(e9), mt2(n4), this.blockLen = e9, this.outputLen = n4, this.buffer = new Uint8Array(e9), this.buffer32 = fe2(this.buffer);
  }
  update(e9) {
    Nt2(this), e9 = ht2(e9), at2(e9);
    const { blockLen: n4, buffer: r6, buffer32: o4 } = this, s3 = e9.length, i6 = e9.byteOffset, f12 = e9.buffer;
    for (let a4 = 0; a4 < s3; ) {
      this.pos === n4 && (Ot2(o4), this.compress(o4, 0, false), Ot2(o4), this.pos = 0);
      const l6 = Math.min(n4 - this.pos, s3 - a4), c6 = i6 + a4;
      if (l6 === n4 && !(c6 % 4) && a4 + l6 < s3) {
        const u6 = new Uint32Array(f12, c6, Math.floor((s3 - a4) / 4));
        Ot2(u6);
        for (let h7 = 0; a4 + n4 < s3; h7 += o4.length, a4 += n4) this.length += n4, this.compress(u6, h7, false);
        Ot2(u6);
        continue;
      }
      r6.set(e9.subarray(a4, a4 + l6), this.pos), this.pos += l6, this.length += l6, a4 += l6;
    }
    return this;
  }
  digestInto(e9) {
    Nt2(this), on2(e9, this);
    const { pos: n4, buffer32: r6 } = this;
    this.finished = true, ut2(this.buffer.subarray(n4)), Ot2(r6), this.compress(r6, 0, true), Ot2(r6);
    const o4 = fe2(e9);
    this.get().forEach((s3, i6) => o4[i6] = wt2(s3));
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
  _cloneInto(e9) {
    const { buffer: n4, length: r6, finished: o4, destroyed: s3, outputLen: i6, pos: f12 } = this;
    return e9 || (e9 = new this.constructor({ dkLen: i6 })), e9.set(...this.get()), e9.buffer.set(n4), e9.destroyed = s3, e9.finished = o4, e9.length = r6, e9.pos = f12, e9.outputLen = i6, e9;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef2 = class extends tf2 {
  constructor(e9 = {}) {
    const n4 = e9.dkLen === void 0 ? 64 : e9.dkLen;
    super(128, n4), this.v0l = F2[0] | 0, this.v0h = F2[1] | 0, this.v1l = F2[2] | 0, this.v1h = F2[3] | 0, this.v2l = F2[4] | 0, this.v2h = F2[5] | 0, this.v3l = F2[6] | 0, this.v3h = F2[7] | 0, this.v4l = F2[8] | 0, this.v4h = F2[9] | 0, this.v5l = F2[10] | 0, this.v5h = F2[11] | 0, this.v6l = F2[12] | 0, this.v6h = F2[13] | 0, this.v7l = F2[14] | 0, this.v7h = F2[15] | 0, Qi2(n4, e9, 64, 16, 16);
    let { key: r6, personalization: o4, salt: s3 } = e9, i6 = 0;
    if (r6 !== void 0 && (r6 = ht2(r6), i6 = r6.length), this.v0l ^= this.outputLen | i6 << 8 | 65536 | 1 << 24, s3 !== void 0) {
      s3 = ht2(s3);
      const f12 = fe2(s3);
      this.v4l ^= wt2(f12[0]), this.v4h ^= wt2(f12[1]), this.v5l ^= wt2(f12[2]), this.v5h ^= wt2(f12[3]);
    }
    if (o4 !== void 0) {
      o4 = ht2(o4);
      const f12 = fe2(o4);
      this.v6l ^= wt2(f12[0]), this.v6h ^= wt2(f12[1]), this.v7l ^= wt2(f12[2]), this.v7h ^= wt2(f12[3]);
    }
    if (r6 !== void 0) {
      const f12 = new Uint8Array(this.blockLen);
      f12.set(r6), this.update(f12);
    }
  }
  get() {
    let { v0l: e9, v0h: n4, v1l: r6, v1h: o4, v2l: s3, v2h: i6, v3l: f12, v3h: a4, v4l: l6, v4h: c6, v5l: u6, v5h: h7, v6l: g3, v6h: w6, v7l: y8, v7h: x5 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5) {
    this.v0l = e9 | 0, this.v0h = n4 | 0, this.v1l = r6 | 0, this.v1h = o4 | 0, this.v2l = s3 | 0, this.v2h = i6 | 0, this.v3l = f12 | 0, this.v3h = a4 | 0, this.v4l = l6 | 0, this.v4h = c6 | 0, this.v5l = u6 | 0, this.v5h = h7 | 0, this.v6l = g3 | 0, this.v6h = w6 | 0, this.v7l = y8 | 0, this.v7h = x5 | 0;
  }
  compress(e9, n4, r6) {
    this.get().forEach((a4, l6) => N2[l6] = a4), N2.set(F2, 16);
    let { h: o4, l: s3 } = mr2(BigInt(this.length));
    N2[24] = F2[8] ^ s3, N2[25] = F2[9] ^ o4, r6 && (N2[28] = ~N2[28], N2[29] = ~N2[29]);
    let i6 = 0;
    const f12 = Ji2;
    for (let a4 = 0; a4 < 12; a4++) $t2(0, 4, 8, 12, e9, n4 + 2 * f12[i6++]), Ct2(0, 4, 8, 12, e9, n4 + 2 * f12[i6++]), $t2(1, 5, 9, 13, e9, n4 + 2 * f12[i6++]), Ct2(1, 5, 9, 13, e9, n4 + 2 * f12[i6++]), $t2(2, 6, 10, 14, e9, n4 + 2 * f12[i6++]), Ct2(2, 6, 10, 14, e9, n4 + 2 * f12[i6++]), $t2(3, 7, 11, 15, e9, n4 + 2 * f12[i6++]), Ct2(3, 7, 11, 15, e9, n4 + 2 * f12[i6++]), $t2(0, 5, 10, 15, e9, n4 + 2 * f12[i6++]), Ct2(0, 5, 10, 15, e9, n4 + 2 * f12[i6++]), $t2(1, 6, 11, 12, e9, n4 + 2 * f12[i6++]), Ct2(1, 6, 11, 12, e9, n4 + 2 * f12[i6++]), $t2(2, 7, 8, 13, e9, n4 + 2 * f12[i6++]), Ct2(2, 7, 8, 13, e9, n4 + 2 * f12[i6++]), $t2(3, 4, 9, 14, e9, n4 + 2 * f12[i6++]), Ct2(3, 4, 9, 14, e9, n4 + 2 * f12[i6++]);
    this.v0l ^= N2[0] ^ N2[16], this.v0h ^= N2[1] ^ N2[17], this.v1l ^= N2[2] ^ N2[18], this.v1h ^= N2[3] ^ N2[19], this.v2l ^= N2[4] ^ N2[20], this.v2h ^= N2[5] ^ N2[21], this.v3l ^= N2[6] ^ N2[22], this.v3h ^= N2[7] ^ N2[23], this.v4l ^= N2[8] ^ N2[24], this.v4h ^= N2[9] ^ N2[25], this.v5l ^= N2[10] ^ N2[26], this.v5h ^= N2[11] ^ N2[27], this.v6l ^= N2[12] ^ N2[28], this.v6h ^= N2[13] ^ N2[29], this.v7l ^= N2[14] ^ N2[30], this.v7h ^= N2[15] ^ N2[31], ut2(N2);
  }
  destroy() {
    this.destroyed = true, ut2(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf2 = Ui2((t4) => new ef2(t4));
var rf = "https://rpc.walletconnect.org/v1";
function an(t4) {
  const e9 = `Ethereum Signed Message:
${t4.length}`, n4 = new TextEncoder().encode(e9 + t4);
  return "0x" + Buffer.from(Hi2(n4)).toString("hex");
}
async function Cr(t4, e9, n4, r6, o4, s3) {
  switch (n4.t) {
    case "eip191":
      return await Lr(t4, e9, n4.s);
    case "eip1271":
      return await jr(t4, e9, n4.s, r6, o4, s3);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n4.t}`);
  }
}
async function Lr(t4, e9, n4) {
  return (await recoverAddress2({ hash: an(e9), signature: n4 })).toLowerCase() === t4.toLowerCase();
}
async function jr(t4, e9, n4, r6, o4, s3) {
  const i6 = Fe(r6);
  if (!i6.namespace || !i6.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r6}`);
  try {
    const f12 = "0x1626ba7e", a4 = "0000000000000000000000000000000000000000000000000000000000000040", l6 = n4.substring(2), c6 = (l6.length / 2).toString(16).padStart(64, "0"), u6 = (e9.startsWith("0x") ? e9 : an(e9)).substring(2), h7 = f12 + u6 + a4 + c6 + l6, g3 = await fetch(`${s3 || rf}/?chainId=${r6}&projectId=${o4}`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ id: of(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t4, data: h7 }, "latest"] }) }), { result: w6 } = await g3.json();
    return w6 ? w6.slice(0, f12.length).toLowerCase() === f12.toLowerCase() : false;
  } catch (f12) {
    return console.error("isValidEip1271Signature: ", f12), false;
  }
}
function of() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function sf(t4) {
  const e9 = atob(t4), n4 = new Uint8Array(e9.length);
  for (let i6 = 0; i6 < e9.length; i6++) n4[i6] = e9.charCodeAt(i6);
  const r6 = n4[0];
  if (r6 === 0) throw new Error("No signatures found");
  const o4 = 1 + r6 * 64;
  if (n4.length < o4) throw new Error("Transaction data too short for claimed signature count");
  if (n4.length < 100) throw new Error("Transaction too short");
  const s3 = Buffer.from(t4, "base64").slice(1, 65);
  return esm_default4.encode(s3);
}
function ff(t4) {
  const e9 = new Uint8Array(Buffer.from(t4, "base64")), n4 = Array.from("TransactionData::").map((s3) => s3.charCodeAt(0)), r6 = new Uint8Array(n4.length + e9.length);
  r6.set(n4), r6.set(e9, n4.length);
  const o4 = nf2(r6, { dkLen: 32 });
  return esm_default4.encode(o4);
}
function cf(t4) {
  const e9 = new Uint8Array(Ae2(kr(t4)));
  return esm_default4.encode(e9);
}
function kr(t4) {
  if (t4 instanceof Uint8Array) return t4;
  if (Array.isArray(t4)) return new Uint8Array(t4);
  if (typeof t4 == "object" && t4 != null && t4.data) return new Uint8Array(Object.values(t4.data));
  if (typeof t4 == "object" && t4) return new Uint8Array(Object.values(t4));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function af(t4) {
  const e9 = Buffer.from(t4, "base64"), n4 = decode2(e9).txn;
  if (!n4) throw new Error("Invalid signed transaction: missing 'txn' field");
  const r6 = encode4(n4), o4 = Buffer.from("TX"), s3 = Buffer.concat([o4, Buffer.from(r6)]), i6 = Xi2(s3);
  return base32.encode(i6).replace(/=+$/, "");
}
function un(t4) {
  const e9 = [];
  let n4 = BigInt(t4);
  for (; n4 >= BigInt(128); ) e9.push(Number(n4 & BigInt(127) | BigInt(128))), n4 >>= BigInt(7);
  return e9.push(Number(n4)), Buffer.from(e9);
}
function uf(t4) {
  const e9 = Buffer.from(t4.signed.bodyBytes, "base64"), n4 = Buffer.from(t4.signed.authInfoBytes, "base64"), r6 = Buffer.from(t4.signature.signature, "base64"), o4 = [];
  o4.push(Buffer.from([10])), o4.push(un(e9.length)), o4.push(e9), o4.push(Buffer.from([18])), o4.push(un(n4.length)), o4.push(n4), o4.push(Buffer.from([26])), o4.push(un(r6.length)), o4.push(r6);
  const s3 = Buffer.concat(o4), i6 = Ae2(s3);
  return Buffer.from(i6).toString("hex").toUpperCase();
}
var lf = Object.defineProperty;
var df = Object.defineProperties;
var hf = Object.getOwnPropertyDescriptors;
var Pr = Object.getOwnPropertySymbols;
var pf = Object.prototype.hasOwnProperty;
var gf = Object.prototype.propertyIsEnumerable;
var Hr = (t4, e9, n4) => e9 in t4 ? lf(t4, e9, { enumerable: true, configurable: true, writable: true, value: n4 }) : t4[e9] = n4;
var ln = (t4, e9) => {
  for (var n4 in e9 || (e9 = {})) pf.call(e9, n4) && Hr(t4, n4, e9[n4]);
  if (Pr) for (var n4 of Pr(e9)) gf.call(e9, n4) && Hr(t4, n4, e9[n4]);
  return t4;
};
var Dr = (t4, e9) => df(t4, hf(e9));
var bf = "did:pkh:";
var Se = (t4) => t4?.split(":");
var Mr = (t4) => {
  const e9 = t4 && Se(t4);
  if (e9) return t4.includes(bf) ? e9[3] : e9[1];
};
var Vr = (t4) => {
  const e9 = t4 && Se(t4);
  if (e9) return e9[2] + ":" + e9[3];
};
var dn = (t4) => {
  const e9 = t4 && Se(t4);
  if (e9) return e9.pop();
};
async function yf(t4) {
  const { cacao: e9, projectId: n4 } = t4, { s: r6, p: o4 } = e9, s3 = qr(o4, o4.iss), i6 = dn(o4.iss);
  return await Cr(i6, s3, r6, Vr(o4.iss), n4);
}
var qr = (t4, e9) => {
  const n4 = `${t4.domain} wants you to sign in with your Ethereum account:`, r6 = dn(e9);
  if (!t4.aud && !t4.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o4 = t4.statement || void 0;
  const s3 = `URI: ${t4.aud || t4.uri}`, i6 = `Version: ${t4.version}`, f12 = `Chain ID: ${Mr(e9)}`, a4 = `Nonce: ${t4.nonce}`, l6 = `Issued At: ${t4.iat}`, c6 = t4.exp ? `Expiration Time: ${t4.exp}` : void 0, u6 = t4.nbf ? `Not Before: ${t4.nbf}` : void 0, h7 = t4.requestId ? `Request ID: ${t4.requestId}` : void 0, g3 = t4.resources ? `Resources:${t4.resources.map((y8) => `
- ${y8}`).join("")}` : void 0, w6 = Oe(t4.resources);
  if (w6) {
    const y8 = Lt(w6);
    o4 = gn(o4, y8);
  }
  return [n4, r6, "", o4, "", s3, i6, f12, a4, l6, c6, u6, h7, g3].filter((y8) => y8 != null).join(`
`);
};
function Gr(t4) {
  return Buffer.from(JSON.stringify(t4)).toString("base64");
}
function Zr(t4) {
  return JSON.parse(Buffer.from(t4, "base64").toString("utf-8"));
}
function bt(t4) {
  if (!t4) throw new Error("No recap provided, value is undefined");
  if (!t4.att) throw new Error("No `att` property found");
  const e9 = Object.keys(t4.att);
  if (!(e9 != null && e9.length)) throw new Error("No resources found in `att` property");
  e9.forEach((n4) => {
    const r6 = t4.att[n4];
    if (Array.isArray(r6)) throw new Error(`Resource must be an object: ${n4}`);
    if (typeof r6 != "object") throw new Error(`Resource must be an object: ${n4}`);
    if (!Object.keys(r6).length) throw new Error(`Resource object is empty: ${n4}`);
    Object.keys(r6).forEach((o4) => {
      const s3 = r6[o4];
      if (!Array.isArray(s3)) throw new Error(`Ability limits ${o4} must be an array of objects, found: ${s3}`);
      if (!s3.length) throw new Error(`Value of ${o4} is empty array, must be an array with objects`);
      s3.forEach((i6) => {
        if (typeof i6 != "object") throw new Error(`Ability limits (${o4}) must be an array of objects, found: ${i6}`);
      });
    });
  });
}
function Wr(t4, e9, n4, r6 = {}) {
  return n4?.sort((o4, s3) => o4.localeCompare(s3)), { att: { [t4]: hn(e9, n4, r6) } };
}
function hn(t4, e9, n4 = {}) {
  e9 = e9?.sort((o4, s3) => o4.localeCompare(s3));
  const r6 = e9.map((o4) => ({ [`${t4}/${o4}`]: [n4] }));
  return Object.assign({}, ...r6);
}
function Ne(t4) {
  return bt(t4), `urn:recap:${Gr(t4).replace(/=/g, "")}`;
}
function Lt(t4) {
  const e9 = Zr(t4.replace("urn:recap:", ""));
  return bt(e9), e9;
}
function Ef(t4, e9, n4) {
  const r6 = Wr(t4, e9, n4);
  return Ne(r6);
}
function pn(t4) {
  return t4 && t4.includes("urn:recap:");
}
function Bf(t4, e9) {
  const n4 = Lt(t4), r6 = Lt(e9), o4 = Xr(n4, r6);
  return Ne(o4);
}
function Xr(t4, e9) {
  bt(t4), bt(e9);
  const n4 = Object.keys(t4.att).concat(Object.keys(e9.att)).sort((o4, s3) => o4.localeCompare(s3)), r6 = { att: {} };
  return n4.forEach((o4) => {
    var s3, i6;
    Object.keys(((s3 = t4.att) == null ? void 0 : s3[o4]) || {}).concat(Object.keys(((i6 = e9.att) == null ? void 0 : i6[o4]) || {})).sort((f12, a4) => f12.localeCompare(a4)).forEach((f12) => {
      var a4, l6;
      r6.att[o4] = Dr(ln({}, r6.att[o4]), { [f12]: ((a4 = t4.att[o4]) == null ? void 0 : a4[f12]) || ((l6 = e9.att[o4]) == null ? void 0 : l6[f12]) });
    });
  }), r6;
}
function gn(t4 = "", e9) {
  bt(e9);
  const n4 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t4.includes(n4)) return t4;
  const r6 = [];
  let o4 = 0;
  Object.keys(e9.att).forEach((f12) => {
    const a4 = Object.keys(e9.att[f12]).map((u6) => ({ ability: u6.split("/")[0], action: u6.split("/")[1] }));
    a4.sort((u6, h7) => u6.action.localeCompare(h7.action));
    const l6 = {};
    a4.forEach((u6) => {
      l6[u6.ability] || (l6[u6.ability] = []), l6[u6.ability].push(u6.action);
    });
    const c6 = Object.keys(l6).map((u6) => (o4++, `(${o4}) '${u6}': '${l6[u6].join("', '")}' for '${f12}'.`));
    r6.push(c6.join(", ").replace(".,", "."));
  });
  const s3 = r6.join(" "), i6 = `${n4}${s3}`;
  return `${t4 ? t4 + " " : ""}${i6}`;
}
function If(t4) {
  var e9;
  const n4 = Lt(t4);
  bt(n4);
  const r6 = (e9 = n4.att) == null ? void 0 : e9.eip155;
  return r6 ? Object.keys(r6).map((o4) => o4.split("/")[1]) : [];
}
function Af(t4) {
  const e9 = Lt(t4);
  bt(e9);
  const n4 = [];
  return Object.values(e9.att).forEach((r6) => {
    Object.values(r6).forEach((o4) => {
      var s3;
      (s3 = o4?.[0]) != null && s3.chains && n4.push(o4[0].chains);
    });
  }), [...new Set(n4.flat())];
}
function Oe(t4) {
  if (!t4) return;
  const e9 = t4?.[t4.length - 1];
  return pn(e9) ? e9 : void 0;
}
function Qr2(t4) {
  return t4 instanceof Uint8Array || ArrayBuffer.isView(t4) && t4.constructor.name === "Uint8Array";
}
function bn2(t4) {
  if (typeof t4 != "boolean") throw new Error(`boolean expected, not ${t4}`);
}
function yn2(t4) {
  if (!Number.isSafeInteger(t4) || t4 < 0) throw new Error("positive integer expected, got " + t4);
}
function nt2(t4, ...e9) {
  if (!Qr2(t4)) throw new Error("Uint8Array expected");
  if (e9.length > 0 && !e9.includes(t4.length)) throw new Error("Uint8Array expected of length " + e9 + ", got length=" + t4.length);
}
function to2(t4, e9 = true) {
  if (t4.destroyed) throw new Error("Hash instance has been destroyed");
  if (e9 && t4.finished) throw new Error("Hash#digest() has already been called");
}
function Sf2(t4, e9) {
  nt2(t4);
  const n4 = e9.outputLen;
  if (t4.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function jt2(t4) {
  return new Uint32Array(t4.buffer, t4.byteOffset, Math.floor(t4.byteLength / 4));
}
function Wt2(...t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9].fill(0);
}
function Nf2(t4) {
  return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
}
var Of2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf2(t4) {
  if (typeof t4 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t4));
}
function mn2(t4) {
  if (typeof t4 == "string") t4 = Uf2(t4);
  else if (Qr2(t4)) t4 = wn2(t4);
  else throw new Error("Uint8Array expected, got " + typeof t4);
  return t4;
}
function _f2(t4, e9) {
  if (e9 == null || typeof e9 != "object") throw new Error("options must be defined");
  return Object.assign(t4, e9);
}
function Tf2(t4, e9) {
  if (t4.length !== e9.length) return false;
  let n4 = 0;
  for (let r6 = 0; r6 < t4.length; r6++) n4 |= t4[r6] ^ e9[r6];
  return n4 === 0;
}
var Rf2 = (t4, e9) => {
  function n4(r6, ...o4) {
    if (nt2(r6), !Of2) throw new Error("Non little-endian hardware is not yet supported");
    if (t4.nonceLength !== void 0) {
      const c6 = o4[0];
      if (!c6) throw new Error("nonce / iv required");
      t4.varSizeNonce ? nt2(c6) : nt2(c6, t4.nonceLength);
    }
    const s3 = t4.tagLength;
    s3 && o4[1] !== void 0 && nt2(o4[1]);
    const i6 = e9(r6, ...o4), f12 = (c6, u6) => {
      if (u6 !== void 0) {
        if (c6 !== 2) throw new Error("cipher output not supported");
        nt2(u6);
      }
    };
    let a4 = false;
    return { encrypt(c6, u6) {
      if (a4) throw new Error("cannot encrypt() twice with same key + nonce");
      return a4 = true, nt2(c6), f12(i6.encrypt.length, u6), i6.encrypt(c6, u6);
    }, decrypt(c6, u6) {
      if (nt2(c6), s3 && c6.length < s3) throw new Error("invalid ciphertext length: smaller than tagLength=" + s3);
      return f12(i6.decrypt.length, u6), i6.decrypt(c6, u6);
    } };
  }
  return Object.assign(n4, t4), n4;
};
function eo2(t4, e9, n4 = true) {
  if (e9 === void 0) return new Uint8Array(t4);
  if (e9.length !== t4) throw new Error("invalid output length, expected " + t4 + ", got: " + e9.length);
  if (n4 && !Cf2(e9)) throw new Error("invalid output, must be aligned");
  return e9;
}
function no2(t4, e9, n4, r6) {
  if (typeof t4.setBigUint64 == "function") return t4.setBigUint64(e9, n4, r6);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i6 = Number(n4 >> o4 & s3), f12 = Number(n4 & s3), a4 = r6 ? 4 : 0, l6 = r6 ? 0 : 4;
  t4.setUint32(e9 + a4, i6, r6), t4.setUint32(e9 + l6, f12, r6);
}
function $f2(t4, e9, n4) {
  bn2(n4);
  const r6 = new Uint8Array(16), o4 = Nf2(r6);
  return no2(o4, 0, BigInt(e9), n4), no2(o4, 8, BigInt(t4), n4), r6;
}
function Cf2(t4) {
  return t4.byteOffset % 4 === 0;
}
function wn2(t4) {
  return Uint8Array.from(t4);
}
var ro2 = (t4) => Uint8Array.from(t4.split("").map((e9) => e9.charCodeAt(0)));
var Lf2 = ro2("expand 16-byte k");
var jf2 = ro2("expand 32-byte k");
var kf2 = jt2(Lf2);
var Pf2 = jt2(jf2);
function D2(t4, e9) {
  return t4 << e9 | t4 >>> 32 - e9;
}
function xn2(t4) {
  return t4.byteOffset % 4 === 0;
}
var Ue2 = 64;
var Hf2 = 16;
var oo2 = 2 ** 32 - 1;
var so2 = new Uint32Array();
function Df2(t4, e9, n4, r6, o4, s3, i6, f12) {
  const a4 = o4.length, l6 = new Uint8Array(Ue2), c6 = jt2(l6), u6 = xn2(o4) && xn2(s3), h7 = u6 ? jt2(o4) : so2, g3 = u6 ? jt2(s3) : so2;
  for (let w6 = 0; w6 < a4; i6++) {
    if (t4(e9, n4, r6, c6, i6, f12), i6 >= oo2) throw new Error("arx: counter overflow");
    const y8 = Math.min(Ue2, a4 - w6);
    if (u6 && y8 === Ue2) {
      const x5 = w6 / 4;
      if (w6 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R6 = 0, M7; R6 < Hf2; R6++) M7 = x5 + R6, g3[M7] = h7[M7] ^ c6[R6];
      w6 += Ue2;
      continue;
    }
    for (let x5 = 0, R6; x5 < y8; x5++) R6 = w6 + x5, s3[R6] = o4[R6] ^ l6[x5];
    w6 += y8;
  }
}
function Mf2(t4, e9) {
  const { allowShortKeys: n4, extendNonceFn: r6, counterLength: o4, counterRight: s3, rounds: i6 } = _f2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e9);
  if (typeof t4 != "function") throw new Error("core must be a function");
  return yn2(o4), yn2(i6), bn2(s3), bn2(n4), (f12, a4, l6, c6, u6 = 0) => {
    nt2(f12), nt2(a4), nt2(l6);
    const h7 = l6.length;
    if (c6 === void 0 && (c6 = new Uint8Array(h7)), nt2(c6), yn2(u6), u6 < 0 || u6 >= oo2) throw new Error("arx: counter overflow");
    if (c6.length < h7) throw new Error(`arx: output (${c6.length}) is shorter than data (${h7})`);
    const g3 = [];
    let w6 = f12.length, y8, x5;
    if (w6 === 32) g3.push(y8 = wn2(f12)), x5 = Pf2;
    else if (w6 === 16 && n4) y8 = new Uint8Array(32), y8.set(f12), y8.set(f12, 16), x5 = kf2, g3.push(y8);
    else throw new Error(`arx: invalid 32-byte key, got length=${w6}`);
    xn2(a4) || g3.push(a4 = wn2(a4));
    const R6 = jt2(y8);
    if (r6) {
      if (a4.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r6(x5, R6, jt2(a4.subarray(0, 16)), R6), a4 = a4.subarray(16);
    }
    const M7 = 16 - o4;
    if (M7 !== a4.length) throw new Error(`arx: nonce must be ${M7} or 16 bytes`);
    if (M7 !== 12) {
      const V7 = new Uint8Array(12);
      V7.set(a4, s3 ? 0 : 12 - a4.length), a4 = V7, g3.push(a4);
    }
    const L6 = jt2(a4);
    return Df2(t4, x5, R6, L6, l6, c6, u6, i6), Wt2(...g3), c6;
  };
}
var G2 = (t4, e9) => t4[e9++] & 255 | (t4[e9++] & 255) << 8;
var Vf2 = class {
  constructor(e9) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e9 = mn2(e9), nt2(e9, 32);
    const n4 = G2(e9, 0), r6 = G2(e9, 2), o4 = G2(e9, 4), s3 = G2(e9, 6), i6 = G2(e9, 8), f12 = G2(e9, 10), a4 = G2(e9, 12), l6 = G2(e9, 14);
    this.r[0] = n4 & 8191, this.r[1] = (n4 >>> 13 | r6 << 3) & 8191, this.r[2] = (r6 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | s3 << 9) & 8191, this.r[4] = (s3 >>> 4 | i6 << 12) & 255, this.r[5] = i6 >>> 1 & 8190, this.r[6] = (i6 >>> 14 | f12 << 2) & 8191, this.r[7] = (f12 >>> 11 | a4 << 5) & 8065, this.r[8] = (a4 >>> 8 | l6 << 8) & 8191, this.r[9] = l6 >>> 5 & 127;
    for (let c6 = 0; c6 < 8; c6++) this.pad[c6] = G2(e9, 16 + 2 * c6);
  }
  process(e9, n4, r6 = false) {
    const o4 = r6 ? 0 : 2048, { h: s3, r: i6 } = this, f12 = i6[0], a4 = i6[1], l6 = i6[2], c6 = i6[3], u6 = i6[4], h7 = i6[5], g3 = i6[6], w6 = i6[7], y8 = i6[8], x5 = i6[9], R6 = G2(e9, n4 + 0), M7 = G2(e9, n4 + 2), L6 = G2(e9, n4 + 4), V7 = G2(e9, n4 + 6), _4 = G2(e9, n4 + 8), k8 = G2(e9, n4 + 10), j6 = G2(e9, n4 + 12), $7 = G2(e9, n4 + 14);
    let d5 = s3[0] + (R6 & 8191), m5 = s3[1] + ((R6 >>> 13 | M7 << 3) & 8191), p7 = s3[2] + ((M7 >>> 10 | L6 << 6) & 8191), b5 = s3[3] + ((L6 >>> 7 | V7 << 9) & 8191), v7 = s3[4] + ((V7 >>> 4 | _4 << 12) & 8191), B7 = s3[5] + (_4 >>> 1 & 8191), E7 = s3[6] + ((_4 >>> 14 | k8 << 2) & 8191), I7 = s3[7] + ((k8 >>> 11 | j6 << 5) & 8191), S7 = s3[8] + ((j6 >>> 8 | $7 << 8) & 8191), O6 = s3[9] + ($7 >>> 5 | o4), A8 = 0, T6 = A8 + d5 * f12 + m5 * (5 * x5) + p7 * (5 * y8) + b5 * (5 * w6) + v7 * (5 * g3);
    A8 = T6 >>> 13, T6 &= 8191, T6 += B7 * (5 * h7) + E7 * (5 * u6) + I7 * (5 * c6) + S7 * (5 * l6) + O6 * (5 * a4), A8 += T6 >>> 13, T6 &= 8191;
    let U6 = A8 + d5 * a4 + m5 * f12 + p7 * (5 * x5) + b5 * (5 * y8) + v7 * (5 * w6);
    A8 = U6 >>> 13, U6 &= 8191, U6 += B7 * (5 * g3) + E7 * (5 * h7) + I7 * (5 * u6) + S7 * (5 * c6) + O6 * (5 * l6), A8 += U6 >>> 13, U6 &= 8191;
    let C8 = A8 + d5 * l6 + m5 * a4 + p7 * f12 + b5 * (5 * x5) + v7 * (5 * y8);
    A8 = C8 >>> 13, C8 &= 8191, C8 += B7 * (5 * w6) + E7 * (5 * g3) + I7 * (5 * h7) + S7 * (5 * u6) + O6 * (5 * c6), A8 += C8 >>> 13, C8 &= 8191;
    let H4 = A8 + d5 * c6 + m5 * l6 + p7 * a4 + b5 * f12 + v7 * (5 * x5);
    A8 = H4 >>> 13, H4 &= 8191, H4 += B7 * (5 * y8) + E7 * (5 * w6) + I7 * (5 * g3) + S7 * (5 * h7) + O6 * (5 * u6), A8 += H4 >>> 13, H4 &= 8191;
    let q5 = A8 + d5 * u6 + m5 * c6 + p7 * l6 + b5 * a4 + v7 * f12;
    A8 = q5 >>> 13, q5 &= 8191, q5 += B7 * (5 * x5) + E7 * (5 * y8) + I7 * (5 * w6) + S7 * (5 * g3) + O6 * (5 * h7), A8 += q5 >>> 13, q5 &= 8191;
    let P6 = A8 + d5 * h7 + m5 * u6 + p7 * c6 + b5 * l6 + v7 * a4;
    A8 = P6 >>> 13, P6 &= 8191, P6 += B7 * f12 + E7 * (5 * x5) + I7 * (5 * y8) + S7 * (5 * w6) + O6 * (5 * g3), A8 += P6 >>> 13, P6 &= 8191;
    let K4 = A8 + d5 * g3 + m5 * h7 + p7 * u6 + b5 * c6 + v7 * l6;
    A8 = K4 >>> 13, K4 &= 8191, K4 += B7 * a4 + E7 * f12 + I7 * (5 * x5) + S7 * (5 * y8) + O6 * (5 * w6), A8 += K4 >>> 13, K4 &= 8191;
    let et3 = A8 + d5 * w6 + m5 * g3 + p7 * h7 + b5 * u6 + v7 * c6;
    A8 = et3 >>> 13, et3 &= 8191, et3 += B7 * l6 + E7 * a4 + I7 * f12 + S7 * (5 * x5) + O6 * (5 * y8), A8 += et3 >>> 13, et3 &= 8191;
    let Z5 = A8 + d5 * y8 + m5 * w6 + p7 * g3 + b5 * h7 + v7 * u6;
    A8 = Z5 >>> 13, Z5 &= 8191, Z5 += B7 * c6 + E7 * l6 + I7 * a4 + S7 * f12 + O6 * (5 * x5), A8 += Z5 >>> 13, Z5 &= 8191;
    let z6 = A8 + d5 * x5 + m5 * y8 + p7 * w6 + b5 * g3 + v7 * h7;
    A8 = z6 >>> 13, z6 &= 8191, z6 += B7 * u6 + E7 * c6 + I7 * l6 + S7 * a4 + O6 * f12, A8 += z6 >>> 13, z6 &= 8191, A8 = (A8 << 2) + A8 | 0, A8 = A8 + T6 | 0, T6 = A8 & 8191, A8 = A8 >>> 13, U6 += A8, s3[0] = T6, s3[1] = U6, s3[2] = C8, s3[3] = H4, s3[4] = q5, s3[5] = P6, s3[6] = K4, s3[7] = et3, s3[8] = Z5, s3[9] = z6;
  }
  finalize() {
    const { h: e9, pad: n4 } = this, r6 = new Uint16Array(10);
    let o4 = e9[1] >>> 13;
    e9[1] &= 8191;
    for (let f12 = 2; f12 < 10; f12++) e9[f12] += o4, o4 = e9[f12] >>> 13, e9[f12] &= 8191;
    e9[0] += o4 * 5, o4 = e9[0] >>> 13, e9[0] &= 8191, e9[1] += o4, o4 = e9[1] >>> 13, e9[1] &= 8191, e9[2] += o4, r6[0] = e9[0] + 5, o4 = r6[0] >>> 13, r6[0] &= 8191;
    for (let f12 = 1; f12 < 10; f12++) r6[f12] = e9[f12] + o4, o4 = r6[f12] >>> 13, r6[f12] &= 8191;
    r6[9] -= 8192;
    let s3 = (o4 ^ 1) - 1;
    for (let f12 = 0; f12 < 10; f12++) r6[f12] &= s3;
    s3 = ~s3;
    for (let f12 = 0; f12 < 10; f12++) e9[f12] = e9[f12] & s3 | r6[f12];
    e9[0] = (e9[0] | e9[1] << 13) & 65535, e9[1] = (e9[1] >>> 3 | e9[2] << 10) & 65535, e9[2] = (e9[2] >>> 6 | e9[3] << 7) & 65535, e9[3] = (e9[3] >>> 9 | e9[4] << 4) & 65535, e9[4] = (e9[4] >>> 12 | e9[5] << 1 | e9[6] << 14) & 65535, e9[5] = (e9[6] >>> 2 | e9[7] << 11) & 65535, e9[6] = (e9[7] >>> 5 | e9[8] << 8) & 65535, e9[7] = (e9[8] >>> 8 | e9[9] << 5) & 65535;
    let i6 = e9[0] + n4[0];
    e9[0] = i6 & 65535;
    for (let f12 = 1; f12 < 8; f12++) i6 = (e9[f12] + n4[f12] | 0) + (i6 >>> 16) | 0, e9[f12] = i6 & 65535;
    Wt2(r6);
  }
  update(e9) {
    to2(this), e9 = mn2(e9), nt2(e9);
    const { buffer: n4, blockLen: r6 } = this, o4 = e9.length;
    for (let s3 = 0; s3 < o4; ) {
      const i6 = Math.min(r6 - this.pos, o4 - s3);
      if (i6 === r6) {
        for (; r6 <= o4 - s3; s3 += r6) this.process(e9, s3);
        continue;
      }
      n4.set(e9.subarray(s3, s3 + i6), this.pos), this.pos += i6, s3 += i6, this.pos === r6 && (this.process(n4, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt2(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e9) {
    to2(this), Sf2(e9, this), this.finished = true;
    const { buffer: n4, h: r6 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n4[o4++] = 1; o4 < 16; o4++) n4[o4] = 0;
      this.process(n4, 0, true);
    }
    this.finalize();
    let s3 = 0;
    for (let i6 = 0; i6 < 8; i6++) e9[s3++] = r6[i6] >>> 0, e9[s3++] = r6[i6] >>> 8;
    return e9;
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
};
function qf2(t4) {
  const e9 = (r6, o4) => t4(o4).update(mn2(r6)).digest(), n4 = t4(new Uint8Array(32));
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = (r6) => t4(r6), e9;
}
var Kf2 = qf2((t4) => new Vf2(t4));
function Ff2(t4, e9, n4, r6, o4, s3 = 20) {
  let i6 = t4[0], f12 = t4[1], a4 = t4[2], l6 = t4[3], c6 = e9[0], u6 = e9[1], h7 = e9[2], g3 = e9[3], w6 = e9[4], y8 = e9[5], x5 = e9[6], R6 = e9[7], M7 = o4, L6 = n4[0], V7 = n4[1], _4 = n4[2], k8 = i6, j6 = f12, $7 = a4, d5 = l6, m5 = c6, p7 = u6, b5 = h7, v7 = g3, B7 = w6, E7 = y8, I7 = x5, S7 = R6, O6 = M7, A8 = L6, T6 = V7, U6 = _4;
  for (let H4 = 0; H4 < s3; H4 += 2) k8 = k8 + m5 | 0, O6 = D2(O6 ^ k8, 16), B7 = B7 + O6 | 0, m5 = D2(m5 ^ B7, 12), k8 = k8 + m5 | 0, O6 = D2(O6 ^ k8, 8), B7 = B7 + O6 | 0, m5 = D2(m5 ^ B7, 7), j6 = j6 + p7 | 0, A8 = D2(A8 ^ j6, 16), E7 = E7 + A8 | 0, p7 = D2(p7 ^ E7, 12), j6 = j6 + p7 | 0, A8 = D2(A8 ^ j6, 8), E7 = E7 + A8 | 0, p7 = D2(p7 ^ E7, 7), $7 = $7 + b5 | 0, T6 = D2(T6 ^ $7, 16), I7 = I7 + T6 | 0, b5 = D2(b5 ^ I7, 12), $7 = $7 + b5 | 0, T6 = D2(T6 ^ $7, 8), I7 = I7 + T6 | 0, b5 = D2(b5 ^ I7, 7), d5 = d5 + v7 | 0, U6 = D2(U6 ^ d5, 16), S7 = S7 + U6 | 0, v7 = D2(v7 ^ S7, 12), d5 = d5 + v7 | 0, U6 = D2(U6 ^ d5, 8), S7 = S7 + U6 | 0, v7 = D2(v7 ^ S7, 7), k8 = k8 + p7 | 0, U6 = D2(U6 ^ k8, 16), I7 = I7 + U6 | 0, p7 = D2(p7 ^ I7, 12), k8 = k8 + p7 | 0, U6 = D2(U6 ^ k8, 8), I7 = I7 + U6 | 0, p7 = D2(p7 ^ I7, 7), j6 = j6 + b5 | 0, O6 = D2(O6 ^ j6, 16), S7 = S7 + O6 | 0, b5 = D2(b5 ^ S7, 12), j6 = j6 + b5 | 0, O6 = D2(O6 ^ j6, 8), S7 = S7 + O6 | 0, b5 = D2(b5 ^ S7, 7), $7 = $7 + v7 | 0, A8 = D2(A8 ^ $7, 16), B7 = B7 + A8 | 0, v7 = D2(v7 ^ B7, 12), $7 = $7 + v7 | 0, A8 = D2(A8 ^ $7, 8), B7 = B7 + A8 | 0, v7 = D2(v7 ^ B7, 7), d5 = d5 + m5 | 0, T6 = D2(T6 ^ d5, 16), E7 = E7 + T6 | 0, m5 = D2(m5 ^ E7, 12), d5 = d5 + m5 | 0, T6 = D2(T6 ^ d5, 8), E7 = E7 + T6 | 0, m5 = D2(m5 ^ E7, 7);
  let C8 = 0;
  r6[C8++] = i6 + k8 | 0, r6[C8++] = f12 + j6 | 0, r6[C8++] = a4 + $7 | 0, r6[C8++] = l6 + d5 | 0, r6[C8++] = c6 + m5 | 0, r6[C8++] = u6 + p7 | 0, r6[C8++] = h7 + b5 | 0, r6[C8++] = g3 + v7 | 0, r6[C8++] = w6 + B7 | 0, r6[C8++] = y8 + E7 | 0, r6[C8++] = x5 + I7 | 0, r6[C8++] = R6 + S7 | 0, r6[C8++] = M7 + O6 | 0, r6[C8++] = L6 + A8 | 0, r6[C8++] = V7 + T6 | 0, r6[C8++] = _4 + U6 | 0;
}
var zf2 = Mf2(Ff2, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf2 = new Uint8Array(16);
var io2 = (t4, e9) => {
  t4.update(e9);
  const n4 = e9.length % 16;
  n4 && t4.update(Gf2.subarray(n4));
};
var Zf2 = new Uint8Array(32);
function fo2(t4, e9, n4, r6, o4) {
  const s3 = t4(e9, n4, Zf2), i6 = Kf2.create(s3);
  o4 && io2(i6, o4), io2(i6, r6);
  const f12 = $f2(r6.length, o4 ? o4.length : 0, true);
  i6.update(f12);
  const a4 = i6.digest();
  return Wt2(s3, f12), a4;
}
var Wf2 = (t4) => (e9, n4, r6) => ({ encrypt(s3, i6) {
  const f12 = s3.length;
  i6 = eo2(f12 + 16, i6, false), i6.set(s3);
  const a4 = i6.subarray(0, -16);
  t4(e9, n4, a4, a4, 1);
  const l6 = fo2(t4, e9, n4, a4, r6);
  return i6.set(l6, f12), Wt2(l6), i6;
}, decrypt(s3, i6) {
  i6 = eo2(s3.length - 16, i6, false);
  const f12 = s3.subarray(0, -16), a4 = s3.subarray(-16), l6 = fo2(t4, e9, n4, f12, r6);
  if (!Tf2(a4, l6)) throw new Error("invalid tag");
  return i6.set(s3.subarray(0, -16)), t4(e9, n4, i6, i6, 1), Wt2(l6), i6;
} });
var co2 = Rf2({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf2(zf2));
var ao2 = class extends Ie2 {
  constructor(e9, n4) {
    super(), this.finished = false, this.destroyed = false, rn2(e9);
    const r6 = ht2(n4);
    if (this.iHash = e9.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, s3 = new Uint8Array(o4);
    s3.set(r6.length > o4 ? e9.create().update(r6).digest() : r6);
    for (let i6 = 0; i6 < s3.length; i6++) s3[i6] ^= 54;
    this.iHash.update(s3), this.oHash = e9.create();
    for (let i6 = 0; i6 < s3.length; i6++) s3[i6] ^= 106;
    this.oHash.update(s3), ut2(s3);
  }
  update(e9) {
    return Nt2(this), this.iHash.update(e9), this;
  }
  digestInto(e9) {
    Nt2(this), at2(e9, this.outputLen), this.finished = true, this.iHash.digestInto(e9), this.oHash.update(e9), this.oHash.digestInto(e9), this.destroy();
  }
  digest() {
    const e9 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e9), e9;
  }
  _cloneInto(e9) {
    e9 || (e9 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n4, iHash: r6, finished: o4, destroyed: s3, blockLen: i6, outputLen: f12 } = this;
    return e9 = e9, e9.finished = o4, e9.destroyed = s3, e9.blockLen = i6, e9.outputLen = f12, e9.oHash = n4._cloneInto(e9.oHash), e9.iHash = r6._cloneInto(e9.iHash), e9;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e2 = (t4, e9, n4) => new ao2(t4, e9).update(n4).digest();
_e2.create = (t4, e9) => new ao2(t4, e9);
function Yf(t4, e9, n4) {
  return rn2(t4), n4 === void 0 && (n4 = new Uint8Array(t4.outputLen)), _e2(t4, ht2(n4), ht2(e9));
}
var vn2 = Uint8Array.from([0]);
var uo2 = Uint8Array.of();
function Xf(t4, e9, n4, r6 = 32) {
  rn2(t4), mt2(r6);
  const o4 = t4.outputLen;
  if (r6 > 255 * o4) throw new Error("Length should be <= 255*HashLen");
  const s3 = Math.ceil(r6 / o4);
  n4 === void 0 && (n4 = uo2);
  const i6 = new Uint8Array(s3 * o4), f12 = _e2.create(t4, e9), a4 = f12._cloneInto(), l6 = new Uint8Array(f12.outputLen);
  for (let c6 = 0; c6 < s3; c6++) vn2[0] = c6 + 1, a4.update(c6 === 0 ? uo2 : l6).update(n4).update(vn2).digestInto(l6), i6.set(l6, o4 * c6), f12._cloneInto(a4);
  return f12.destroy(), a4.destroy(), ut2(l6, vn2), i6.slice(0, r6);
}
var Jf = (t4, e9, n4, r6, o4) => Xf(t4, Yf(t4, e9, n4), r6, o4);
var Te = Ae2;
var En2 = BigInt(0);
var Bn2 = BigInt(1);
function Re2(t4, e9) {
  if (typeof e9 != "boolean") throw new Error(t4 + " boolean expected, got " + e9);
}
function $e2(t4) {
  const e9 = t4.toString(16);
  return e9.length & 1 ? "0" + e9 : e9;
}
function lo2(t4) {
  if (typeof t4 != "string") throw new Error("hex string expected, got " + typeof t4);
  return t4 === "" ? En2 : BigInt("0x" + t4);
}
function Ce2(t4) {
  return lo2(ce2(t4));
}
function Le2(t4) {
  return at2(t4), lo2(ce2(Uint8Array.from(t4).reverse()));
}
function In2(t4, e9) {
  return fn2(t4.toString(16).padStart(e9 * 2, "0"));
}
function An2(t4, e9) {
  return In2(t4, e9).reverse();
}
function rt2(t4, e9, n4) {
  let r6;
  if (typeof e9 == "string") try {
    r6 = fn2(e9);
  } catch (s3) {
    throw new Error(t4 + " must be hex string or Uint8Array, cause: " + s3);
  }
  else if (nn2(e9)) r6 = Uint8Array.from(e9);
  else throw new Error(t4 + " must be hex string or Uint8Array");
  const o4 = r6.length;
  if (typeof n4 == "number" && o4 !== n4) throw new Error(t4 + " of length " + n4 + " expected, got " + o4);
  return r6;
}
var Sn2 = (t4) => typeof t4 == "bigint" && En2 <= t4;
function Qf2(t4, e9, n4) {
  return Sn2(t4) && Sn2(e9) && Sn2(n4) && e9 <= t4 && t4 < n4;
}
function Nn2(t4, e9, n4, r6) {
  if (!Qf2(e9, n4, r6)) throw new Error("expected valid " + t4 + ": " + n4 + " <= n < " + r6 + ", got " + e9);
}
function tc2(t4) {
  let e9;
  for (e9 = 0; t4 > En2; t4 >>= Bn2, e9 += 1) ;
  return e9;
}
var je2 = (t4) => (Bn2 << BigInt(t4)) - Bn2;
function ec2(t4, e9, n4) {
  if (typeof t4 != "number" || t4 < 2) throw new Error("hashLen must be a number");
  if (typeof e9 != "number" || e9 < 2) throw new Error("qByteLen must be a number");
  if (typeof n4 != "function") throw new Error("hmacFn must be a function");
  const r6 = (g3) => new Uint8Array(g3), o4 = (g3) => Uint8Array.of(g3);
  let s3 = r6(t4), i6 = r6(t4), f12 = 0;
  const a4 = () => {
    s3.fill(1), i6.fill(0), f12 = 0;
  }, l6 = (...g3) => n4(i6, s3, ...g3), c6 = (g3 = r6(0)) => {
    i6 = l6(o4(0), g3), s3 = l6(), g3.length !== 0 && (i6 = l6(o4(1), g3), s3 = l6());
  }, u6 = () => {
    if (f12++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g3 = 0;
    const w6 = [];
    for (; g3 < e9; ) {
      s3 = l6();
      const y8 = s3.slice();
      w6.push(y8), g3 += s3.length;
    }
    return Ht2(...w6);
  };
  return (g3, w6) => {
    a4(), c6(g3);
    let y8;
    for (; !(y8 = w6(u6())); ) c6();
    return a4(), y8;
  };
}
function ke2(t4, e9, n4 = {}) {
  if (!t4 || typeof t4 != "object") throw new Error("expected valid options object");
  function r6(o4, s3, i6) {
    const f12 = t4[o4];
    if (i6 && f12 === void 0) return;
    const a4 = typeof f12;
    if (a4 !== s3 || f12 === null) throw new Error(`param "${o4}" is invalid: expected ${s3}, got ${a4}`);
  }
  Object.entries(e9).forEach(([o4, s3]) => r6(o4, s3, false)), Object.entries(n4).forEach(([o4, s3]) => r6(o4, s3, true));
}
function ho2(t4) {
  const e9 = /* @__PURE__ */ new WeakMap();
  return (n4, ...r6) => {
    const o4 = e9.get(n4);
    if (o4 !== void 0) return o4;
    const s3 = t4(n4, ...r6);
    return e9.set(n4, s3), s3;
  };
}
var ot2 = BigInt(0);
var Q2 = BigInt(1);
var Dt2 = BigInt(2);
var nc2 = BigInt(3);
var po2 = BigInt(4);
var go2 = BigInt(5);
var bo2 = BigInt(8);
function lt2(t4, e9) {
  const n4 = t4 % e9;
  return n4 >= ot2 ? n4 : e9 + n4;
}
function pt2(t4, e9, n4) {
  let r6 = t4;
  for (; e9-- > ot2; ) r6 *= r6, r6 %= n4;
  return r6;
}
function yo2(t4, e9) {
  if (t4 === ot2) throw new Error("invert: expected non-zero number");
  if (e9 <= ot2) throw new Error("invert: expected positive modulus, got " + e9);
  let n4 = lt2(t4, e9), r6 = e9, o4 = ot2, s3 = Q2;
  for (; n4 !== ot2; ) {
    const f12 = r6 / n4, a4 = r6 % n4, l6 = o4 - s3 * f12;
    r6 = n4, n4 = a4, o4 = s3, s3 = l6;
  }
  if (r6 !== Q2) throw new Error("invert: does not exist");
  return lt2(o4, e9);
}
function mo2(t4, e9) {
  const n4 = (t4.ORDER + Q2) / po2, r6 = t4.pow(e9, n4);
  if (!t4.eql(t4.sqr(r6), e9)) throw new Error("Cannot find square root");
  return r6;
}
function rc2(t4, e9) {
  const n4 = (t4.ORDER - go2) / bo2, r6 = t4.mul(e9, Dt2), o4 = t4.pow(r6, n4), s3 = t4.mul(e9, o4), i6 = t4.mul(t4.mul(s3, Dt2), o4), f12 = t4.mul(s3, t4.sub(i6, t4.ONE));
  if (!t4.eql(t4.sqr(f12), e9)) throw new Error("Cannot find square root");
  return f12;
}
function oc2(t4) {
  if (t4 < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e9 = t4 - Q2, n4 = 0;
  for (; e9 % Dt2 === ot2; ) e9 /= Dt2, n4++;
  let r6 = Dt2;
  const o4 = Yt2(t4);
  for (; xo2(o4, r6) === 1; ) if (r6++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n4 === 1) return mo2;
  let s3 = o4.pow(r6, e9);
  const i6 = (e9 + Q2) / Dt2;
  return function(a4, l6) {
    if (a4.is0(l6)) return l6;
    if (xo2(a4, l6) !== 1) throw new Error("Cannot find square root");
    let c6 = n4, u6 = a4.mul(a4.ONE, s3), h7 = a4.pow(l6, e9), g3 = a4.pow(l6, i6);
    for (; !a4.eql(h7, a4.ONE); ) {
      if (a4.is0(h7)) return a4.ZERO;
      let w6 = 1, y8 = a4.sqr(h7);
      for (; !a4.eql(y8, a4.ONE); ) if (w6++, y8 = a4.sqr(y8), w6 === c6) throw new Error("Cannot find square root");
      const x5 = Q2 << BigInt(c6 - w6 - 1), R6 = a4.pow(u6, x5);
      c6 = w6, u6 = a4.sqr(R6), h7 = a4.mul(h7, u6), g3 = a4.mul(g3, R6);
    }
    return g3;
  };
}
function sc2(t4) {
  return t4 % po2 === nc2 ? mo2 : t4 % bo2 === go2 ? rc2 : oc2(t4);
}
var ic2 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc2(t4) {
  const e9 = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n4 = ic2.reduce((r6, o4) => (r6[o4] = "function", r6), e9);
  return ke2(t4, n4), t4;
}
function cc2(t4, e9, n4) {
  if (n4 < ot2) throw new Error("invalid exponent, negatives unsupported");
  if (n4 === ot2) return t4.ONE;
  if (n4 === Q2) return e9;
  let r6 = t4.ONE, o4 = e9;
  for (; n4 > ot2; ) n4 & Q2 && (r6 = t4.mul(r6, o4)), o4 = t4.sqr(o4), n4 >>= Q2;
  return r6;
}
function wo2(t4, e9, n4 = false) {
  const r6 = new Array(e9.length).fill(n4 ? t4.ZERO : void 0), o4 = e9.reduce((i6, f12, a4) => t4.is0(f12) ? i6 : (r6[a4] = i6, t4.mul(i6, f12)), t4.ONE), s3 = t4.inv(o4);
  return e9.reduceRight((i6, f12, a4) => t4.is0(f12) ? i6 : (r6[a4] = t4.mul(i6, r6[a4]), t4.mul(i6, f12)), s3), r6;
}
function xo2(t4, e9) {
  const n4 = (t4.ORDER - Q2) / Dt2, r6 = t4.pow(e9, n4), o4 = t4.eql(r6, t4.ONE), s3 = t4.eql(r6, t4.ZERO), i6 = t4.eql(r6, t4.neg(t4.ONE));
  if (!o4 && !s3 && !i6) throw new Error("invalid Legendre symbol result");
  return o4 ? 1 : s3 ? 0 : -1;
}
function ac2(t4, e9) {
  e9 !== void 0 && mt2(e9);
  const n4 = e9 !== void 0 ? e9 : t4.toString(2).length, r6 = Math.ceil(n4 / 8);
  return { nBitLength: n4, nByteLength: r6 };
}
function Yt2(t4, e9, n4 = false, r6 = {}) {
  if (t4 <= ot2) throw new Error("invalid field: expected ORDER > 0, got " + t4);
  let o4, s3;
  if (typeof e9 == "object" && e9 != null) {
    if (r6.sqrt || n4) throw new Error("cannot specify opts in two arguments");
    const c6 = e9;
    c6.BITS && (o4 = c6.BITS), c6.sqrt && (s3 = c6.sqrt), typeof c6.isLE == "boolean" && (n4 = c6.isLE);
  } else typeof e9 == "number" && (o4 = e9), r6.sqrt && (s3 = r6.sqrt);
  const { nBitLength: i6, nByteLength: f12 } = ac2(t4, o4);
  if (f12 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a4;
  const l6 = Object.freeze({ ORDER: t4, isLE: n4, BITS: i6, BYTES: f12, MASK: je2(i6), ZERO: ot2, ONE: Q2, create: (c6) => lt2(c6, t4), isValid: (c6) => {
    if (typeof c6 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c6);
    return ot2 <= c6 && c6 < t4;
  }, is0: (c6) => c6 === ot2, isValidNot0: (c6) => !l6.is0(c6) && l6.isValid(c6), isOdd: (c6) => (c6 & Q2) === Q2, neg: (c6) => lt2(-c6, t4), eql: (c6, u6) => c6 === u6, sqr: (c6) => lt2(c6 * c6, t4), add: (c6, u6) => lt2(c6 + u6, t4), sub: (c6, u6) => lt2(c6 - u6, t4), mul: (c6, u6) => lt2(c6 * u6, t4), pow: (c6, u6) => cc2(l6, c6, u6), div: (c6, u6) => lt2(c6 * yo2(u6, t4), t4), sqrN: (c6) => c6 * c6, addN: (c6, u6) => c6 + u6, subN: (c6, u6) => c6 - u6, mulN: (c6, u6) => c6 * u6, inv: (c6) => yo2(c6, t4), sqrt: s3 || ((c6) => (a4 || (a4 = sc2(t4)), a4(l6, c6))), toBytes: (c6) => n4 ? An2(c6, f12) : In2(c6, f12), fromBytes: (c6) => {
    if (c6.length !== f12) throw new Error("Field.fromBytes: expected " + f12 + " bytes, got " + c6.length);
    return n4 ? Le2(c6) : Ce2(c6);
  }, invertBatch: (c6) => wo2(l6, c6), cmov: (c6, u6, h7) => h7 ? u6 : c6 });
  return Object.freeze(l6);
}
function vo2(t4) {
  if (typeof t4 != "bigint") throw new Error("field order must be bigint");
  const e9 = t4.toString(2).length;
  return Math.ceil(e9 / 8);
}
function Eo2(t4) {
  const e9 = vo2(t4);
  return e9 + Math.ceil(e9 / 2);
}
function uc2(t4, e9, n4 = false) {
  const r6 = t4.length, o4 = vo2(e9), s3 = Eo2(e9);
  if (r6 < 16 || r6 < s3 || r6 > 1024) throw new Error("expected " + s3 + "-1024 bytes of input, got " + r6);
  const i6 = n4 ? Le2(t4) : Ce2(t4), f12 = lt2(i6, e9 - Q2) + Q2;
  return n4 ? An2(f12, o4) : In2(f12, o4);
}
var Xt2 = BigInt(0);
var Mt2 = BigInt(1);
function le2(t4, e9) {
  const n4 = e9.negate();
  return t4 ? n4 : e9;
}
function lc2(t4, e9, n4) {
  const r6 = e9 === "pz" ? (i6) => i6.pz : (i6) => i6.ez, o4 = wo2(t4.Fp, n4.map(r6));
  return n4.map((i6, f12) => i6.toAffine(o4[f12])).map(t4.fromAffine);
}
function Bo2(t4, e9) {
  if (!Number.isSafeInteger(t4) || t4 <= 0 || t4 > e9) throw new Error("invalid window size, expected [1.." + e9 + "], got W=" + t4);
}
function On2(t4, e9) {
  Bo2(t4, e9);
  const n4 = Math.ceil(e9 / t4) + 1, r6 = 2 ** (t4 - 1), o4 = 2 ** t4, s3 = je2(t4), i6 = BigInt(t4);
  return { windows: n4, windowSize: r6, mask: s3, maxNumber: o4, shiftBy: i6 };
}
function Io2(t4, e9, n4) {
  const { windowSize: r6, mask: o4, maxNumber: s3, shiftBy: i6 } = n4;
  let f12 = Number(t4 & o4), a4 = t4 >> i6;
  f12 > r6 && (f12 -= s3, a4 += Mt2);
  const l6 = e9 * r6, c6 = l6 + Math.abs(f12) - 1, u6 = f12 === 0, h7 = f12 < 0, g3 = e9 % 2 !== 0;
  return { nextN: a4, offset: c6, isZero: u6, isNeg: h7, isNegF: g3, offsetF: l6 };
}
function dc2(t4, e9) {
  if (!Array.isArray(t4)) throw new Error("array expected");
  t4.forEach((n4, r6) => {
    if (!(n4 instanceof e9)) throw new Error("invalid point at index " + r6);
  });
}
function hc2(t4, e9) {
  if (!Array.isArray(t4)) throw new Error("array of scalars expected");
  t4.forEach((n4, r6) => {
    if (!e9.isValid(n4)) throw new Error("invalid scalar at index " + r6);
  });
}
var Un2 = /* @__PURE__ */ new WeakMap();
var Ao2 = /* @__PURE__ */ new WeakMap();
function _n2(t4) {
  return Ao2.get(t4) || 1;
}
function So2(t4) {
  if (t4 !== Xt2) throw new Error("invalid wNAF");
}
function pc2(t4, e9) {
  return { constTimeNegate: le2, hasPrecomputes(n4) {
    return _n2(n4) !== 1;
  }, unsafeLadder(n4, r6, o4 = t4.ZERO) {
    let s3 = n4;
    for (; r6 > Xt2; ) r6 & Mt2 && (o4 = o4.add(s3)), s3 = s3.double(), r6 >>= Mt2;
    return o4;
  }, precomputeWindow(n4, r6) {
    const { windows: o4, windowSize: s3 } = On2(r6, e9), i6 = [];
    let f12 = n4, a4 = f12;
    for (let l6 = 0; l6 < o4; l6++) {
      a4 = f12, i6.push(a4);
      for (let c6 = 1; c6 < s3; c6++) a4 = a4.add(f12), i6.push(a4);
      f12 = a4.double();
    }
    return i6;
  }, wNAF(n4, r6, o4) {
    let s3 = t4.ZERO, i6 = t4.BASE;
    const f12 = On2(n4, e9);
    for (let a4 = 0; a4 < f12.windows; a4++) {
      const { nextN: l6, offset: c6, isZero: u6, isNeg: h7, isNegF: g3, offsetF: w6 } = Io2(o4, a4, f12);
      o4 = l6, u6 ? i6 = i6.add(le2(g3, r6[w6])) : s3 = s3.add(le2(h7, r6[c6]));
    }
    return So2(o4), { p: s3, f: i6 };
  }, wNAFUnsafe(n4, r6, o4, s3 = t4.ZERO) {
    const i6 = On2(n4, e9);
    for (let f12 = 0; f12 < i6.windows && o4 !== Xt2; f12++) {
      const { nextN: a4, offset: l6, isZero: c6, isNeg: u6 } = Io2(o4, f12, i6);
      if (o4 = a4, !c6) {
        const h7 = r6[l6];
        s3 = s3.add(u6 ? h7.negate() : h7);
      }
    }
    return So2(o4), s3;
  }, getPrecomputes(n4, r6, o4) {
    let s3 = Un2.get(r6);
    return s3 || (s3 = this.precomputeWindow(r6, n4), n4 !== 1 && (typeof o4 == "function" && (s3 = o4(s3)), Un2.set(r6, s3))), s3;
  }, wNAFCached(n4, r6, o4) {
    const s3 = _n2(n4);
    return this.wNAF(s3, this.getPrecomputes(s3, n4, o4), r6);
  }, wNAFCachedUnsafe(n4, r6, o4, s3) {
    const i6 = _n2(n4);
    return i6 === 1 ? this.unsafeLadder(n4, r6, s3) : this.wNAFUnsafe(i6, this.getPrecomputes(i6, n4, o4), r6, s3);
  }, setWindowSize(n4, r6) {
    Bo2(r6, e9), Ao2.set(n4, r6), Un2.delete(n4);
  } };
}
function gc2(t4, e9, n4, r6) {
  let o4 = e9, s3 = t4.ZERO, i6 = t4.ZERO;
  for (; n4 > Xt2 || r6 > Xt2; ) n4 & Mt2 && (s3 = s3.add(o4)), r6 & Mt2 && (i6 = i6.add(o4)), o4 = o4.double(), n4 >>= Mt2, r6 >>= Mt2;
  return { p1: s3, p2: i6 };
}
function bc2(t4, e9, n4, r6) {
  dc2(n4, t4), hc2(r6, e9);
  const o4 = n4.length, s3 = r6.length;
  if (o4 !== s3) throw new Error("arrays of points and scalars must have equal length");
  const i6 = t4.ZERO, f12 = tc2(BigInt(o4));
  let a4 = 1;
  f12 > 12 ? a4 = f12 - 3 : f12 > 4 ? a4 = f12 - 2 : f12 > 0 && (a4 = 2);
  const l6 = je2(a4), c6 = new Array(Number(l6) + 1).fill(i6), u6 = Math.floor((e9.BITS - 1) / a4) * a4;
  let h7 = i6;
  for (let g3 = u6; g3 >= 0; g3 -= a4) {
    c6.fill(i6);
    for (let y8 = 0; y8 < s3; y8++) {
      const x5 = r6[y8], R6 = Number(x5 >> BigInt(g3) & l6);
      c6[R6] = c6[R6].add(n4[y8]);
    }
    let w6 = i6;
    for (let y8 = c6.length - 1, x5 = i6; y8 > 0; y8--) x5 = x5.add(c6[y8]), w6 = w6.add(x5);
    if (h7 = h7.add(w6), g3 !== 0) for (let y8 = 0; y8 < a4; y8++) h7 = h7.double();
  }
  return h7;
}
function No2(t4, e9) {
  if (e9) {
    if (e9.ORDER !== t4) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc2(e9), e9;
  } else return Yt2(t4);
}
function yc2(t4, e9, n4 = {}) {
  if (!e9 || typeof e9 != "object") throw new Error(`expected valid ${t4} CURVE object`);
  for (const f12 of ["p", "n", "h"]) {
    const a4 = e9[f12];
    if (!(typeof a4 == "bigint" && a4 > Xt2)) throw new Error(`CURVE.${f12} must be positive bigint`);
  }
  const r6 = No2(e9.p, n4.Fp), o4 = No2(e9.n, n4.Fn), i6 = ["Gx", "Gy", "a", t4 === "weierstrass" ? "b" : "d"];
  for (const f12 of i6) if (!r6.isValid(e9[f12])) throw new Error(`CURVE.${f12} must be valid field element of CURVE.Fp`);
  return { Fp: r6, Fn: o4 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de2 = BigInt(0);
var Jt2 = BigInt(1);
var Pe2 = BigInt(2);
function mc2(t4) {
  return ke2(t4, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t4 });
}
function wc2(t4) {
  const e9 = mc2(t4), { P: n4, type: r6, adjustScalarBytes: o4, powPminus2: s3, randomBytes: i6 } = e9, f12 = r6 === "x25519";
  if (!f12 && r6 !== "x448") throw new Error("invalid type");
  const a4 = i6 || Zt2, l6 = f12 ? 255 : 448, c6 = f12 ? 32 : 56, u6 = BigInt(f12 ? 9 : 5), h7 = BigInt(f12 ? 121665 : 39081), g3 = f12 ? Pe2 ** BigInt(254) : Pe2 ** BigInt(447), w6 = f12 ? BigInt(8) * Pe2 ** BigInt(251) - Jt2 : BigInt(4) * Pe2 ** BigInt(445) - Jt2, y8 = g3 + w6 + Jt2, x5 = (d5) => lt2(d5, n4), R6 = M7(u6);
  function M7(d5) {
    return An2(x5(d5), c6);
  }
  function L6(d5) {
    const m5 = rt2("u coordinate", d5, c6);
    return f12 && (m5[31] &= 127), x5(Le2(m5));
  }
  function V7(d5) {
    return Le2(o4(rt2("scalar", d5, c6)));
  }
  function _4(d5, m5) {
    const p7 = $7(L6(m5), V7(d5));
    if (p7 === de2) throw new Error("invalid private or public key received");
    return M7(p7);
  }
  function k8(d5) {
    return _4(d5, R6);
  }
  function j6(d5, m5, p7) {
    const b5 = x5(d5 * (m5 - p7));
    return m5 = x5(m5 - b5), p7 = x5(p7 + b5), { x_2: m5, x_3: p7 };
  }
  function $7(d5, m5) {
    Nn2("u", d5, de2, n4), Nn2("scalar", m5, g3, y8);
    const p7 = m5, b5 = d5;
    let v7 = Jt2, B7 = de2, E7 = d5, I7 = Jt2, S7 = de2;
    for (let A8 = BigInt(l6 - 1); A8 >= de2; A8--) {
      const T6 = p7 >> A8 & Jt2;
      S7 ^= T6, { x_2: v7, x_3: E7 } = j6(S7, v7, E7), { x_2: B7, x_3: I7 } = j6(S7, B7, I7), S7 = T6;
      const U6 = v7 + B7, C8 = x5(U6 * U6), H4 = v7 - B7, q5 = x5(H4 * H4), P6 = C8 - q5, K4 = E7 + I7, et3 = E7 - I7, Z5 = x5(et3 * U6), z6 = x5(K4 * H4), Ft3 = Z5 + z6, yt4 = Z5 - z6;
      E7 = x5(Ft3 * Ft3), I7 = x5(b5 * x5(yt4 * yt4)), v7 = x5(C8 * q5), B7 = x5(P6 * (C8 + x5(h7 * P6)));
    }
    ({ x_2: v7, x_3: E7 } = j6(S7, v7, E7)), { x_2: B7, x_3: I7 } = j6(S7, B7, I7);
    const O6 = s3(B7);
    return x5(v7 * O6);
  }
  return { scalarMult: _4, scalarMultBase: k8, getSharedSecret: (d5, m5) => _4(d5, m5), getPublicKey: (d5) => k8(d5), utils: { randomPrivateKey: () => a4(c6) }, GuBytes: R6.slice() };
}
BigInt(0);
var xc2 = BigInt(1);
var Oo2 = BigInt(2);
var vc2 = BigInt(3);
var Ec2 = BigInt(5);
var Bc2 = BigInt(8);
var Uo2 = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc2, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic2(t4) {
  const e9 = BigInt(10), n4 = BigInt(20), r6 = BigInt(40), o4 = BigInt(80), s3 = Uo2.p, f12 = t4 * t4 % s3 * t4 % s3, a4 = pt2(f12, Oo2, s3) * f12 % s3, l6 = pt2(a4, xc2, s3) * t4 % s3, c6 = pt2(l6, Ec2, s3) * l6 % s3, u6 = pt2(c6, e9, s3) * c6 % s3, h7 = pt2(u6, n4, s3) * u6 % s3, g3 = pt2(h7, r6, s3) * h7 % s3, w6 = pt2(g3, o4, s3) * g3 % s3, y8 = pt2(w6, o4, s3) * g3 % s3, x5 = pt2(y8, e9, s3) * c6 % s3;
  return { pow_p_5_8: pt2(x5, Oo2, s3) * t4 % s3, b2: f12 };
}
function Ac2(t4) {
  return t4[0] &= 248, t4[31] &= 127, t4[31] |= 64, t4;
}
var Tn2 = (() => {
  const t4 = Uo2.p;
  return wc2({ P: t4, type: "x25519", powPminus2: (e9) => {
    const { pow_p_5_8: n4, b2: r6 } = Ic2(e9);
    return lt2(pt2(n4, vc2, t4) * r6, t4);
  }, adjustScalarBytes: Ac2 });
})();
function _o2(t4) {
  t4.lowS !== void 0 && Re2("lowS", t4.lowS), t4.prehash !== void 0 && Re2("prehash", t4.prehash);
}
var Sc2 = class extends Error {
  constructor(e9 = "") {
    super(e9);
  }
};
var vt2 = { Err: Sc2, _tlv: { encode: (t4, e9) => {
  const { Err: n4 } = vt2;
  if (t4 < 0 || t4 > 256) throw new n4("tlv.encode: wrong tag");
  if (e9.length & 1) throw new n4("tlv.encode: unpadded data");
  const r6 = e9.length / 2, o4 = $e2(r6);
  if (o4.length / 2 & 128) throw new n4("tlv.encode: long form length too big");
  const s3 = r6 > 127 ? $e2(o4.length / 2 | 128) : "";
  return $e2(t4) + s3 + o4 + e9;
}, decode(t4, e9) {
  const { Err: n4 } = vt2;
  let r6 = 0;
  if (t4 < 0 || t4 > 256) throw new n4("tlv.encode: wrong tag");
  if (e9.length < 2 || e9[r6++] !== t4) throw new n4("tlv.decode: wrong tlv");
  const o4 = e9[r6++], s3 = !!(o4 & 128);
  let i6 = 0;
  if (!s3) i6 = o4;
  else {
    const a4 = o4 & 127;
    if (!a4) throw new n4("tlv.decode(long): indefinite length not supported");
    if (a4 > 4) throw new n4("tlv.decode(long): byte length is too big");
    const l6 = e9.subarray(r6, r6 + a4);
    if (l6.length !== a4) throw new n4("tlv.decode: length bytes not complete");
    if (l6[0] === 0) throw new n4("tlv.decode(long): zero leftmost byte");
    for (const c6 of l6) i6 = i6 << 8 | c6;
    if (r6 += a4, i6 < 128) throw new n4("tlv.decode(long): not minimal encoding");
  }
  const f12 = e9.subarray(r6, r6 + i6);
  if (f12.length !== i6) throw new n4("tlv.decode: wrong value length");
  return { v: f12, l: e9.subarray(r6 + i6) };
} }, _int: { encode(t4) {
  const { Err: e9 } = vt2;
  if (t4 < he2) throw new e9("integer: negative integers are not allowed");
  let n4 = $e2(t4);
  if (Number.parseInt(n4[0], 16) & 8 && (n4 = "00" + n4), n4.length & 1) throw new e9("unexpected DER parsing assertion: unpadded hex");
  return n4;
}, decode(t4) {
  const { Err: e9 } = vt2;
  if (t4[0] & 128) throw new e9("invalid signature integer: negative");
  if (t4[0] === 0 && !(t4[1] & 128)) throw new e9("invalid signature integer: unnecessary leading zero");
  return Ce2(t4);
} }, toSig(t4) {
  const { Err: e9, _int: n4, _tlv: r6 } = vt2, o4 = rt2("signature", t4), { v: s3, l: i6 } = r6.decode(48, o4);
  if (i6.length) throw new e9("invalid signature: left bytes after parsing");
  const { v: f12, l: a4 } = r6.decode(2, s3), { v: l6, l: c6 } = r6.decode(2, a4);
  if (c6.length) throw new e9("invalid signature: left bytes after parsing");
  return { r: n4.decode(f12), s: n4.decode(l6) };
}, hexFromSig(t4) {
  const { _tlv: e9, _int: n4 } = vt2, r6 = e9.encode(2, n4.encode(t4.r)), o4 = e9.encode(2, n4.encode(t4.s)), s3 = r6 + o4;
  return e9.encode(48, s3);
} };
var he2 = BigInt(0);
var pe2 = BigInt(1);
var Nc2 = BigInt(2);
var He2 = BigInt(3);
var Oc2 = BigInt(4);
function Uc2(t4, e9, n4) {
  function r6(o4) {
    const s3 = t4.sqr(o4), i6 = t4.mul(s3, o4);
    return t4.add(t4.add(i6, t4.mul(o4, e9)), n4);
  }
  return r6;
}
function To2(t4, e9, n4) {
  const { BYTES: r6 } = t4;
  function o4(s3) {
    let i6;
    if (typeof s3 == "bigint") i6 = s3;
    else {
      let f12 = rt2("private key", s3);
      if (e9) {
        if (!e9.includes(f12.length * 2)) throw new Error("invalid private key");
        const a4 = new Uint8Array(r6);
        a4.set(f12, a4.length - f12.length), f12 = a4;
      }
      try {
        i6 = t4.fromBytes(f12);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r6}, got ${typeof s3}`);
      }
    }
    if (n4 && (i6 = t4.create(i6)), !t4.isValidNot0(i6)) throw new Error("invalid private key: out of range [1..N-1]");
    return i6;
  }
  return o4;
}
function _c2(t4, e9 = {}) {
  const { Fp: n4, Fn: r6 } = yc2("weierstrass", t4, e9), { h: o4, n: s3 } = t4;
  ke2(e9, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i6 } = e9;
  if (i6 && (!n4.is0(t4.a) || typeof i6.beta != "bigint" || typeof i6.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f12() {
    if (!n4.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a4($7, d5, m5) {
    const { x: p7, y: b5 } = d5.toAffine(), v7 = n4.toBytes(p7);
    if (Re2("isCompressed", m5), m5) {
      f12();
      const B7 = !n4.isOdd(b5);
      return Ht2(Ro2(B7), v7);
    } else return Ht2(Uint8Array.of(4), v7, n4.toBytes(b5));
  }
  function l6($7) {
    at2($7);
    const d5 = n4.BYTES, m5 = d5 + 1, p7 = 2 * d5 + 1, b5 = $7.length, v7 = $7[0], B7 = $7.subarray(1);
    if (b5 === m5 && (v7 === 2 || v7 === 3)) {
      const E7 = n4.fromBytes(B7);
      if (!n4.isValid(E7)) throw new Error("bad point: is not on curve, wrong x");
      const I7 = h7(E7);
      let S7;
      try {
        S7 = n4.sqrt(I7);
      } catch (T6) {
        const U6 = T6 instanceof Error ? ": " + T6.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U6);
      }
      f12();
      const O6 = n4.isOdd(S7);
      return (v7 & 1) === 1 !== O6 && (S7 = n4.neg(S7)), { x: E7, y: S7 };
    } else if (b5 === p7 && v7 === 4) {
      const E7 = n4.fromBytes(B7.subarray(d5 * 0, d5 * 1)), I7 = n4.fromBytes(B7.subarray(d5 * 1, d5 * 2));
      if (!g3(E7, I7)) throw new Error("bad point: is not on curve");
      return { x: E7, y: I7 };
    } else throw new Error(`bad point: got length ${b5}, expected compressed=${m5} or uncompressed=${p7}`);
  }
  const c6 = e9.toBytes || a4, u6 = e9.fromBytes || l6, h7 = Uc2(n4, t4.a, t4.b);
  function g3($7, d5) {
    const m5 = n4.sqr(d5), p7 = h7($7);
    return n4.eql(m5, p7);
  }
  if (!g3(t4.Gx, t4.Gy)) throw new Error("bad curve params: generator point");
  const w6 = n4.mul(n4.pow(t4.a, He2), Oc2), y8 = n4.mul(n4.sqr(t4.b), BigInt(27));
  if (n4.is0(n4.add(w6, y8))) throw new Error("bad curve params: a or b");
  function x5($7, d5, m5 = false) {
    if (!n4.isValid(d5) || m5 && n4.is0(d5)) throw new Error(`bad point coordinate ${$7}`);
    return d5;
  }
  function R6($7) {
    if (!($7 instanceof _4)) throw new Error("ProjectivePoint expected");
  }
  const M7 = ho2(($7, d5) => {
    const { px: m5, py: p7, pz: b5 } = $7;
    if (n4.eql(b5, n4.ONE)) return { x: m5, y: p7 };
    const v7 = $7.is0();
    d5 == null && (d5 = v7 ? n4.ONE : n4.inv(b5));
    const B7 = n4.mul(m5, d5), E7 = n4.mul(p7, d5), I7 = n4.mul(b5, d5);
    if (v7) return { x: n4.ZERO, y: n4.ZERO };
    if (!n4.eql(I7, n4.ONE)) throw new Error("invZ was invalid");
    return { x: B7, y: E7 };
  }), L6 = ho2(($7) => {
    if ($7.is0()) {
      if (e9.allowInfinityPoint && !n4.is0($7.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d5, y: m5 } = $7.toAffine();
    if (!n4.isValid(d5) || !n4.isValid(m5)) throw new Error("bad point: x or y not field elements");
    if (!g3(d5, m5)) throw new Error("bad point: equation left != right");
    if (!$7.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V7($7, d5, m5, p7, b5) {
    return m5 = new _4(n4.mul(m5.px, $7), m5.py, m5.pz), d5 = le2(p7, d5), m5 = le2(b5, m5), d5.add(m5);
  }
  class _4 {
    constructor(d5, m5, p7) {
      this.px = x5("x", d5), this.py = x5("y", m5, true), this.pz = x5("z", p7), Object.freeze(this);
    }
    static fromAffine(d5) {
      const { x: m5, y: p7 } = d5 || {};
      if (!d5 || !n4.isValid(m5) || !n4.isValid(p7)) throw new Error("invalid affine point");
      if (d5 instanceof _4) throw new Error("projective point not allowed");
      return n4.is0(m5) && n4.is0(p7) ? _4.ZERO : new _4(m5, p7, n4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d5) {
      return lc2(_4, "pz", d5);
    }
    static fromBytes(d5) {
      return at2(d5), _4.fromHex(d5);
    }
    static fromHex(d5) {
      const m5 = _4.fromAffine(u6(rt2("pointHex", d5)));
      return m5.assertValidity(), m5;
    }
    static fromPrivateKey(d5) {
      const m5 = To2(r6, e9.allowedPrivateKeyLengths, e9.wrapPrivateKey);
      return _4.BASE.multiply(m5(d5));
    }
    static msm(d5, m5) {
      return bc2(_4, r6, d5, m5);
    }
    precompute(d5 = 8, m5 = true) {
      return j6.setWindowSize(this, d5), m5 || this.multiply(He2), this;
    }
    _setWindowSize(d5) {
      this.precompute(d5);
    }
    assertValidity() {
      L6(this);
    }
    hasEvenY() {
      const { y: d5 } = this.toAffine();
      if (!n4.isOdd) throw new Error("Field doesn't support isOdd");
      return !n4.isOdd(d5);
    }
    equals(d5) {
      R6(d5);
      const { px: m5, py: p7, pz: b5 } = this, { px: v7, py: B7, pz: E7 } = d5, I7 = n4.eql(n4.mul(m5, E7), n4.mul(v7, b5)), S7 = n4.eql(n4.mul(p7, E7), n4.mul(B7, b5));
      return I7 && S7;
    }
    negate() {
      return new _4(this.px, n4.neg(this.py), this.pz);
    }
    double() {
      const { a: d5, b: m5 } = t4, p7 = n4.mul(m5, He2), { px: b5, py: v7, pz: B7 } = this;
      let E7 = n4.ZERO, I7 = n4.ZERO, S7 = n4.ZERO, O6 = n4.mul(b5, b5), A8 = n4.mul(v7, v7), T6 = n4.mul(B7, B7), U6 = n4.mul(b5, v7);
      return U6 = n4.add(U6, U6), S7 = n4.mul(b5, B7), S7 = n4.add(S7, S7), E7 = n4.mul(d5, S7), I7 = n4.mul(p7, T6), I7 = n4.add(E7, I7), E7 = n4.sub(A8, I7), I7 = n4.add(A8, I7), I7 = n4.mul(E7, I7), E7 = n4.mul(U6, E7), S7 = n4.mul(p7, S7), T6 = n4.mul(d5, T6), U6 = n4.sub(O6, T6), U6 = n4.mul(d5, U6), U6 = n4.add(U6, S7), S7 = n4.add(O6, O6), O6 = n4.add(S7, O6), O6 = n4.add(O6, T6), O6 = n4.mul(O6, U6), I7 = n4.add(I7, O6), T6 = n4.mul(v7, B7), T6 = n4.add(T6, T6), O6 = n4.mul(T6, U6), E7 = n4.sub(E7, O6), S7 = n4.mul(T6, A8), S7 = n4.add(S7, S7), S7 = n4.add(S7, S7), new _4(E7, I7, S7);
    }
    add(d5) {
      R6(d5);
      const { px: m5, py: p7, pz: b5 } = this, { px: v7, py: B7, pz: E7 } = d5;
      let I7 = n4.ZERO, S7 = n4.ZERO, O6 = n4.ZERO;
      const A8 = t4.a, T6 = n4.mul(t4.b, He2);
      let U6 = n4.mul(m5, v7), C8 = n4.mul(p7, B7), H4 = n4.mul(b5, E7), q5 = n4.add(m5, p7), P6 = n4.add(v7, B7);
      q5 = n4.mul(q5, P6), P6 = n4.add(U6, C8), q5 = n4.sub(q5, P6), P6 = n4.add(m5, b5);
      let K4 = n4.add(v7, E7);
      return P6 = n4.mul(P6, K4), K4 = n4.add(U6, H4), P6 = n4.sub(P6, K4), K4 = n4.add(p7, b5), I7 = n4.add(B7, E7), K4 = n4.mul(K4, I7), I7 = n4.add(C8, H4), K4 = n4.sub(K4, I7), O6 = n4.mul(A8, P6), I7 = n4.mul(T6, H4), O6 = n4.add(I7, O6), I7 = n4.sub(C8, O6), O6 = n4.add(C8, O6), S7 = n4.mul(I7, O6), C8 = n4.add(U6, U6), C8 = n4.add(C8, U6), H4 = n4.mul(A8, H4), P6 = n4.mul(T6, P6), C8 = n4.add(C8, H4), H4 = n4.sub(U6, H4), H4 = n4.mul(A8, H4), P6 = n4.add(P6, H4), U6 = n4.mul(C8, P6), S7 = n4.add(S7, U6), U6 = n4.mul(K4, P6), I7 = n4.mul(q5, I7), I7 = n4.sub(I7, U6), U6 = n4.mul(q5, C8), O6 = n4.mul(K4, O6), O6 = n4.add(O6, U6), new _4(I7, S7, O6);
    }
    subtract(d5) {
      return this.add(d5.negate());
    }
    is0() {
      return this.equals(_4.ZERO);
    }
    multiply(d5) {
      const { endo: m5 } = e9;
      if (!r6.isValidNot0(d5)) throw new Error("invalid scalar: out of range");
      let p7, b5;
      const v7 = (B7) => j6.wNAFCached(this, B7, _4.normalizeZ);
      if (m5) {
        const { k1neg: B7, k1: E7, k2neg: I7, k2: S7 } = m5.splitScalar(d5), { p: O6, f: A8 } = v7(E7), { p: T6, f: U6 } = v7(S7);
        b5 = A8.add(U6), p7 = V7(m5.beta, O6, T6, B7, I7);
      } else {
        const { p: B7, f: E7 } = v7(d5);
        p7 = B7, b5 = E7;
      }
      return _4.normalizeZ([p7, b5])[0];
    }
    multiplyUnsafe(d5) {
      const { endo: m5 } = e9, p7 = this;
      if (!r6.isValid(d5)) throw new Error("invalid scalar: out of range");
      if (d5 === he2 || p7.is0()) return _4.ZERO;
      if (d5 === pe2) return p7;
      if (j6.hasPrecomputes(this)) return this.multiply(d5);
      if (m5) {
        const { k1neg: b5, k1: v7, k2neg: B7, k2: E7 } = m5.splitScalar(d5), { p1: I7, p2: S7 } = gc2(_4, p7, v7, E7);
        return V7(m5.beta, I7, S7, b5, B7);
      } else return j6.wNAFCachedUnsafe(p7, d5);
    }
    multiplyAndAddUnsafe(d5, m5, p7) {
      const b5 = this.multiplyUnsafe(m5).add(d5.multiplyUnsafe(p7));
      return b5.is0() ? void 0 : b5;
    }
    toAffine(d5) {
      return M7(this, d5);
    }
    isTorsionFree() {
      const { isTorsionFree: d5 } = e9;
      return o4 === pe2 ? true : d5 ? d5(_4, this) : j6.wNAFCachedUnsafe(this, s3).is0();
    }
    clearCofactor() {
      const { clearCofactor: d5 } = e9;
      return o4 === pe2 ? this : d5 ? d5(_4, this) : this.multiplyUnsafe(o4);
    }
    toBytes(d5 = true) {
      return Re2("isCompressed", d5), this.assertValidity(), c6(_4, this, d5);
    }
    toRawBytes(d5 = true) {
      return this.toBytes(d5);
    }
    toHex(d5 = true) {
      return ce2(this.toBytes(d5));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _4.BASE = new _4(t4.Gx, t4.Gy, n4.ONE), _4.ZERO = new _4(n4.ZERO, n4.ONE, n4.ZERO), _4.Fp = n4, _4.Fn = r6;
  const k8 = r6.BITS, j6 = pc2(_4, e9.endo ? Math.ceil(k8 / 2) : k8);
  return _4;
}
function Ro2(t4) {
  return Uint8Array.of(t4 ? 2 : 3);
}
function Tc2(t4, e9, n4 = {}) {
  ke2(e9, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r6 = e9.randomBytes || Zt2, o4 = e9.hmac || ((p7, ...b5) => _e2(e9.hash, p7, Ht2(...b5))), { Fp: s3, Fn: i6 } = t4, { ORDER: f12, BITS: a4 } = i6;
  function l6(p7) {
    const b5 = f12 >> pe2;
    return p7 > b5;
  }
  function c6(p7) {
    return l6(p7) ? i6.neg(p7) : p7;
  }
  function u6(p7, b5) {
    if (!i6.isValidNot0(b5)) throw new Error(`invalid signature ${p7}: out of range 1..CURVE.n`);
  }
  class h7 {
    constructor(b5, v7, B7) {
      u6("r", b5), u6("s", v7), this.r = b5, this.s = v7, B7 != null && (this.recovery = B7), Object.freeze(this);
    }
    static fromCompact(b5) {
      const v7 = i6.BYTES, B7 = rt2("compactSignature", b5, v7 * 2);
      return new h7(i6.fromBytes(B7.subarray(0, v7)), i6.fromBytes(B7.subarray(v7, v7 * 2)));
    }
    static fromDER(b5) {
      const { r: v7, s: B7 } = vt2.toSig(rt2("DER", b5));
      return new h7(v7, B7);
    }
    assertValidity() {
    }
    addRecoveryBit(b5) {
      return new h7(this.r, this.s, b5);
    }
    recoverPublicKey(b5) {
      const v7 = s3.ORDER, { r: B7, s: E7, recovery: I7 } = this;
      if (I7 == null || ![0, 1, 2, 3].includes(I7)) throw new Error("recovery id invalid");
      if (f12 * Nc2 < v7 && I7 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O6 = I7 === 2 || I7 === 3 ? B7 + f12 : B7;
      if (!s3.isValid(O6)) throw new Error("recovery id 2 or 3 invalid");
      const A8 = s3.toBytes(O6), T6 = t4.fromHex(Ht2(Ro2((I7 & 1) === 0), A8)), U6 = i6.inv(O6), C8 = L6(rt2("msgHash", b5)), H4 = i6.create(-C8 * U6), q5 = i6.create(E7 * U6), P6 = t4.BASE.multiplyUnsafe(H4).add(T6.multiplyUnsafe(q5));
      if (P6.is0()) throw new Error("point at infinify");
      return P6.assertValidity(), P6;
    }
    hasHighS() {
      return l6(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h7(this.r, i6.neg(this.s), this.recovery) : this;
    }
    toBytes(b5) {
      if (b5 === "compact") return Ht2(i6.toBytes(this.r), i6.toBytes(this.s));
      if (b5 === "der") return fn2(vt2.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce2(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce2(this.toBytes("compact"));
    }
  }
  const g3 = To2(i6, n4.allowedPrivateKeyLengths, n4.wrapPrivateKey), w6 = { isValidPrivateKey(p7) {
    try {
      return g3(p7), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g3, randomPrivateKey: () => {
    const p7 = f12;
    return uc2(r6(Eo2(p7)), p7);
  }, precompute(p7 = 8, b5 = t4.BASE) {
    return b5.precompute(p7, false);
  } };
  function y8(p7, b5 = true) {
    return t4.fromPrivateKey(p7).toBytes(b5);
  }
  function x5(p7) {
    if (typeof p7 == "bigint") return false;
    if (p7 instanceof t4) return true;
    const v7 = rt2("key", p7).length, B7 = s3.BYTES, E7 = B7 + 1, I7 = 2 * B7 + 1;
    if (!(n4.allowedPrivateKeyLengths || i6.BYTES === E7)) return v7 === E7 || v7 === I7;
  }
  function R6(p7, b5, v7 = true) {
    if (x5(p7) === true) throw new Error("first arg must be private key");
    if (x5(b5) === false) throw new Error("second arg must be public key");
    return t4.fromHex(b5).multiply(g3(p7)).toBytes(v7);
  }
  const M7 = e9.bits2int || function(p7) {
    if (p7.length > 8192) throw new Error("input is too large");
    const b5 = Ce2(p7), v7 = p7.length * 8 - a4;
    return v7 > 0 ? b5 >> BigInt(v7) : b5;
  }, L6 = e9.bits2int_modN || function(p7) {
    return i6.create(M7(p7));
  }, V7 = je2(a4);
  function _4(p7) {
    return Nn2("num < 2^" + a4, p7, he2, V7), i6.toBytes(p7);
  }
  function k8(p7, b5, v7 = j6) {
    if (["recovered", "canonical"].some((q5) => q5 in v7)) throw new Error("sign() legacy options not supported");
    const { hash: B7 } = e9;
    let { lowS: E7, prehash: I7, extraEntropy: S7 } = v7;
    E7 == null && (E7 = true), p7 = rt2("msgHash", p7), _o2(v7), I7 && (p7 = rt2("prehashed msgHash", B7(p7)));
    const O6 = L6(p7), A8 = g3(b5), T6 = [_4(A8), _4(O6)];
    if (S7 != null && S7 !== false) {
      const q5 = S7 === true ? r6(s3.BYTES) : S7;
      T6.push(rt2("extraEntropy", q5));
    }
    const U6 = Ht2(...T6), C8 = O6;
    function H4(q5) {
      const P6 = M7(q5);
      if (!i6.isValidNot0(P6)) return;
      const K4 = i6.inv(P6), et3 = t4.BASE.multiply(P6).toAffine(), Z5 = i6.create(et3.x);
      if (Z5 === he2) return;
      const z6 = i6.create(K4 * i6.create(C8 + Z5 * A8));
      if (z6 === he2) return;
      let Ft3 = (et3.x === Z5 ? 0 : 2) | Number(et3.y & pe2), yt4 = z6;
      return E7 && l6(z6) && (yt4 = c6(z6), Ft3 ^= 1), new h7(Z5, yt4, Ft3);
    }
    return { seed: U6, k2sig: H4 };
  }
  const j6 = { lowS: e9.lowS, prehash: false }, $7 = { lowS: e9.lowS, prehash: false };
  function d5(p7, b5, v7 = j6) {
    const { seed: B7, k2sig: E7 } = k8(p7, b5, v7);
    return ec2(e9.hash.outputLen, i6.BYTES, o4)(B7, E7);
  }
  t4.BASE.precompute(8);
  function m5(p7, b5, v7, B7 = $7) {
    const E7 = p7;
    b5 = rt2("msgHash", b5), v7 = rt2("publicKey", v7), _o2(B7);
    const { lowS: I7, prehash: S7, format: O6 } = B7;
    if ("strict" in B7) throw new Error("options.strict was renamed to lowS");
    if (O6 !== void 0 && !["compact", "der", "js"].includes(O6)) throw new Error('format must be "compact", "der" or "js"');
    const A8 = typeof E7 == "string" || nn2(E7), T6 = !A8 && !O6 && typeof E7 == "object" && E7 !== null && typeof E7.r == "bigint" && typeof E7.s == "bigint";
    if (!A8 && !T6) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U6, C8;
    try {
      if (T6) if (O6 === void 0 || O6 === "js") U6 = new h7(E7.r, E7.s);
      else throw new Error("invalid format");
      if (A8) {
        try {
          O6 !== "compact" && (U6 = h7.fromDER(E7));
        } catch (yt4) {
          if (!(yt4 instanceof vt2.Err)) throw yt4;
        }
        !U6 && O6 !== "der" && (U6 = h7.fromCompact(E7));
      }
      C8 = t4.fromHex(v7);
    } catch {
      return false;
    }
    if (!U6 || I7 && U6.hasHighS()) return false;
    S7 && (b5 = e9.hash(b5));
    const { r: H4, s: q5 } = U6, P6 = L6(b5), K4 = i6.inv(q5), et3 = i6.create(P6 * K4), Z5 = i6.create(H4 * K4), z6 = t4.BASE.multiplyUnsafe(et3).add(C8.multiplyUnsafe(Z5));
    return z6.is0() ? false : i6.create(z6.x) === H4;
  }
  return Object.freeze({ getPublicKey: y8, getSharedSecret: R6, sign: d5, verify: m5, utils: w6, Point: t4, Signature: h7 });
}
function Rc2(t4) {
  const e9 = { a: t4.a, b: t4.b, p: t4.Fp.ORDER, n: t4.n, h: t4.h, Gx: t4.Gx, Gy: t4.Gy }, n4 = t4.Fp, r6 = Yt2(e9.n, t4.nBitLength), o4 = { Fp: n4, Fn: r6, allowedPrivateKeyLengths: t4.allowedPrivateKeyLengths, allowInfinityPoint: t4.allowInfinityPoint, endo: t4.endo, wrapPrivateKey: t4.wrapPrivateKey, isTorsionFree: t4.isTorsionFree, clearCofactor: t4.clearCofactor, fromBytes: t4.fromBytes, toBytes: t4.toBytes };
  return { CURVE: e9, curveOpts: o4 };
}
function $c2(t4) {
  const { CURVE: e9, curveOpts: n4 } = Rc2(t4), r6 = { hash: t4.hash, hmac: t4.hmac, randomBytes: t4.randomBytes, lowS: t4.lowS, bits2int: t4.bits2int, bits2int_modN: t4.bits2int_modN };
  return { CURVE: e9, curveOpts: n4, ecdsaOpts: r6 };
}
function Cc2(t4, e9) {
  return Object.assign({}, e9, { ProjectivePoint: e9.Point, CURVE: t4 });
}
function Lc2(t4) {
  const { CURVE: e9, curveOpts: n4, ecdsaOpts: r6 } = $c2(t4), o4 = _c2(e9, n4), s3 = Tc2(o4, r6, n4);
  return Cc2(t4, s3);
}
function Rn2(t4, e9) {
  const n4 = (r6) => Lc2({ ...t4, hash: r6 });
  return { ...n4(e9), create: n4 };
}
var $o2 = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co2 = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo2 = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc2 = Yt2($o2.p);
var kc2 = Yt2(Co2.p);
var Pc2 = Yt2(Lo2.p);
var Hc2 = Rn2({ ...$o2, Fp: jc2, lowS: false }, Ae2);
Rn2({ ...Co2, Fp: kc2, lowS: false }, Yi2), Rn2({ ...Lo2, Fp: Pc2, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi2);
var Dc = Hc2;
var $n = "base10";
var tt = "base16";
var Qt = "base64pad";
var De = "base64url";
var te = "utf8";
var Cn = 0;
var ee = 1;
var ge = 2;
var Mc = 0;
var jo = 1;
var be = 12;
var Ln = 32;
function Vc() {
  const t4 = Tn2.utils.randomPrivateKey(), e9 = Tn2.getPublicKey(t4);
  return { privateKey: toString4(t4, tt), publicKey: toString4(e9, tt) };
}
function qc() {
  const t4 = Zt2(Ln);
  return toString4(t4, tt);
}
function Kc(t4, e9) {
  const n4 = Tn2.getSharedSecret(fromString8(t4, tt), fromString8(e9, tt)), r6 = Jf(Te, n4, void 0, void 0, Ln);
  return toString4(r6, tt);
}
function Fc(t4) {
  const e9 = Te(fromString8(t4, tt));
  return toString4(e9, tt);
}
function zc(t4) {
  const e9 = Te(fromString8(t4, te));
  return toString4(e9, tt);
}
function jn(t4) {
  return fromString8(`${t4}`, $n);
}
function Vt(t4) {
  return Number(toString4(t4, $n));
}
function ko(t4) {
  return t4.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Po2(t4) {
  const e9 = t4.replace(/-/g, "+").replace(/_/g, "/"), n4 = (4 - e9.length % 4) % 4;
  return e9 + "=".repeat(n4);
}
function Gc(t4) {
  const e9 = jn(typeof t4.type < "u" ? t4.type : Cn);
  if (Vt(e9) === ee && typeof t4.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n4 = typeof t4.senderPublicKey < "u" ? fromString8(t4.senderPublicKey, tt) : void 0, r6 = typeof t4.iv < "u" ? fromString8(t4.iv, tt) : Zt2(be), o4 = fromString8(t4.symKey, tt), s3 = co2(o4, r6).encrypt(fromString8(t4.message, te)), i6 = kn({ type: e9, sealed: s3, iv: r6, senderPublicKey: n4 });
  return t4.encoding === De ? ko(i6) : i6;
}
function Zc(t4) {
  const e9 = fromString8(t4.symKey, tt), { sealed: n4, iv: r6 } = Me({ encoded: t4.encoded, encoding: t4.encoding }), o4 = co2(e9, r6).decrypt(n4);
  if (o4 === null) throw new Error("Failed to decrypt");
  return toString4(o4, te);
}
function Wc(t4, e9) {
  const n4 = jn(ge), r6 = Zt2(be), o4 = fromString8(t4, te), s3 = kn({ type: n4, sealed: o4, iv: r6 });
  return e9 === De ? ko(s3) : s3;
}
function Yc(t4, e9) {
  const { sealed: n4 } = Me({ encoded: t4, encoding: e9 });
  return toString4(n4, te);
}
function kn(t4) {
  if (Vt(t4.type) === ge) return toString4(concat7([t4.type, t4.sealed]), Qt);
  if (Vt(t4.type) === ee) {
    if (typeof t4.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString4(concat7([t4.type, t4.senderPublicKey, t4.iv, t4.sealed]), Qt);
  }
  return toString4(concat7([t4.type, t4.iv, t4.sealed]), Qt);
}
function Me(t4) {
  const e9 = (t4.encoding || Qt) === De ? Po2(t4.encoded) : t4.encoded, n4 = fromString8(e9, Qt), r6 = n4.slice(Mc, jo), o4 = jo;
  if (Vt(r6) === ee) {
    const a4 = o4 + Ln, l6 = a4 + be, c6 = n4.slice(o4, a4), u6 = n4.slice(a4, l6), h7 = n4.slice(l6);
    return { type: r6, sealed: h7, iv: u6, senderPublicKey: c6 };
  }
  if (Vt(r6) === ge) {
    const a4 = n4.slice(o4), l6 = Zt2(be);
    return { type: r6, sealed: a4, iv: l6 };
  }
  const s3 = o4 + be, i6 = n4.slice(o4, s3), f12 = n4.slice(s3);
  return { type: r6, sealed: f12, iv: i6 };
}
function Xc(t4, e9) {
  const n4 = Me({ encoded: t4, encoding: e9?.encoding });
  return Ho({ type: Vt(n4.type), senderPublicKey: typeof n4.senderPublicKey < "u" ? toString4(n4.senderPublicKey, tt) : void 0, receiverPublicKey: e9?.receiverPublicKey });
}
function Ho(t4) {
  const e9 = t4?.type || Cn;
  if (e9 === ee) {
    if (typeof t4?.senderPublicKey > "u") throw new Error("missing sender public key");
    if (typeof t4?.receiverPublicKey > "u") throw new Error("missing receiver public key");
  }
  return { type: e9, senderPublicKey: t4?.senderPublicKey, receiverPublicKey: t4?.receiverPublicKey };
}
function Jc(t4) {
  return t4.type === ee && typeof t4.senderPublicKey == "string" && typeof t4.receiverPublicKey == "string";
}
function Qc(t4) {
  return t4.type === ge;
}
function Do(t4) {
  const e9 = Buffer.from(t4.x, "base64"), n4 = Buffer.from(t4.y, "base64");
  return concat7([new Uint8Array([4]), e9, n4]);
}
function ta(t4, e9) {
  const [n4, r6, o4] = t4.split("."), s3 = Buffer.from(Po2(o4), "base64");
  if (s3.length !== 64) throw new Error("Invalid signature length");
  const i6 = s3.slice(0, 32), f12 = s3.slice(32, 64), a4 = `${n4}.${r6}`, l6 = Te(a4), c6 = Do(e9);
  if (!Dc.verify(concat7([i6, f12]), l6, c6)) throw new Error("Invalid signature");
  return sn(t4).payload;
}
var Mo = "irn";
function ea(t4) {
  return t4?.relay || { protocol: Mo };
}
function na(t4) {
  const e9 = C[t4];
  if (typeof e9 > "u") throw new Error(`Relay Protocol not supported: ${t4}`);
  return e9;
}
function Vo(t4, e9 = "-") {
  const n4 = {}, r6 = "relay" + e9;
  return Object.keys(t4).forEach((o4) => {
    if (o4.startsWith(r6)) {
      const s3 = o4.replace(r6, ""), i6 = t4[o4];
      n4[s3] = i6;
    }
  }), n4;
}
function ra(t4) {
  if (!t4.includes("wc:")) {
    const l6 = Qe2(t4);
    l6 != null && l6.includes("wc:") && (t4 = l6);
  }
  t4 = t4.includes("wc://") ? t4.replace("wc://", "") : t4, t4 = t4.includes("wc:") ? t4.replace("wc:", "") : t4;
  const e9 = t4.indexOf(":"), n4 = t4.indexOf("?") !== -1 ? t4.indexOf("?") : void 0, r6 = t4.substring(0, e9), o4 = t4.substring(e9 + 1, n4).split("@"), s3 = typeof n4 < "u" ? t4.substring(n4) : "", i6 = new URLSearchParams(s3), f12 = {};
  i6.forEach((l6, c6) => {
    f12[c6] = l6;
  });
  const a4 = typeof f12.methods == "string" ? f12.methods.split(",") : void 0;
  return { protocol: r6, topic: qo(o4[0]), version: parseInt(o4[1], 10), symKey: f12.symKey, relay: Vo(f12), methods: a4, expiryTimestamp: f12.expiryTimestamp ? parseInt(f12.expiryTimestamp, 10) : void 0 };
}
function qo(t4) {
  return t4.startsWith("//") ? t4.substring(2) : t4;
}
function Ko(t4, e9 = "-") {
  const n4 = "relay", r6 = {};
  return Object.keys(t4).forEach((o4) => {
    const s3 = o4, i6 = n4 + e9 + s3;
    t4[s3] && (r6[i6] = t4[s3]);
  }), r6;
}
function oa(t4) {
  const e9 = new URLSearchParams(), n4 = Ko(t4.relay);
  Object.keys(n4).sort().forEach((o4) => {
    e9.set(o4, n4[o4]);
  }), e9.set("symKey", t4.symKey), t4.expiryTimestamp && e9.set("expiryTimestamp", t4.expiryTimestamp.toString()), t4.methods && e9.set("methods", t4.methods.join(","));
  const r6 = e9.toString();
  return `${t4.protocol}:${t4.topic}@${t4.version}?${r6}`;
}
function sa(t4, e9, n4) {
  return `${t4}?wc_ev=${n4}&topic=${e9}`;
}
var ia = Object.defineProperty;
var fa = Object.defineProperties;
var ca = Object.getOwnPropertyDescriptors;
var Fo = Object.getOwnPropertySymbols;
var aa = Object.prototype.hasOwnProperty;
var ua = Object.prototype.propertyIsEnumerable;
var zo = (t4, e9, n4) => e9 in t4 ? ia(t4, e9, { enumerable: true, configurable: true, writable: true, value: n4 }) : t4[e9] = n4;
var la = (t4, e9) => {
  for (var n4 in e9 || (e9 = {})) aa.call(e9, n4) && zo(t4, n4, e9[n4]);
  if (Fo) for (var n4 of Fo(e9)) ua.call(e9, n4) && zo(t4, n4, e9[n4]);
  return t4;
};
var da = (t4, e9) => fa(t4, ca(e9));
function qt(t4) {
  const e9 = [];
  return t4.forEach((n4) => {
    const [r6, o4] = n4.split(":");
    e9.push(`${r6}:${o4}`);
  }), e9;
}
function Go(t4) {
  const e9 = [];
  return Object.values(t4).forEach((n4) => {
    e9.push(...qt(n4.accounts));
  }), e9;
}
function Zo(t4, e9) {
  const n4 = [];
  return Object.values(t4).forEach((r6) => {
    qt(r6.accounts).includes(e9) && n4.push(...r6.methods);
  }), n4;
}
function Wo(t4, e9) {
  const n4 = [];
  return Object.values(t4).forEach((r6) => {
    qt(r6.accounts).includes(e9) && n4.push(...r6.events);
  }), n4;
}
function Pn(t4) {
  return t4.includes(":");
}
function Yo(t4) {
  return Pn(t4) ? t4.split(":")[0] : t4;
}
function ye(t4) {
  var e9, n4, r6;
  const o4 = {};
  if (!Ve(t4)) return o4;
  for (const [s3, i6] of Object.entries(t4)) {
    const f12 = Pn(s3) ? [s3] : i6.chains, a4 = i6.methods || [], l6 = i6.events || [], c6 = Yo(s3);
    o4[c6] = da(la({}, o4[c6]), { chains: ct(f12, (e9 = o4[c6]) == null ? void 0 : e9.chains), methods: ct(a4, (n4 = o4[c6]) == null ? void 0 : n4.methods), events: ct(l6, (r6 = o4[c6]) == null ? void 0 : r6.events) });
  }
  return o4;
}
function Xo(t4) {
  const e9 = {};
  return t4?.forEach((n4) => {
    var r6;
    const [o4, s3] = n4.split(":");
    e9[o4] || (e9[o4] = { accounts: [], chains: [], events: [], methods: [] }), e9[o4].accounts.push(n4), (r6 = e9[o4].chains) == null || r6.push(`${o4}:${s3}`);
  }), e9;
}
function ga(t4, e9) {
  e9 = e9.map((r6) => r6.replace("did:pkh:", ""));
  const n4 = Xo(e9);
  for (const [r6, o4] of Object.entries(n4)) o4.methods ? o4.methods = ct(o4.methods, t4) : o4.methods = t4, o4.events = ["chainChanged", "accountsChanged"];
  return n4;
}
function ba(t4, e9) {
  var n4, r6, o4, s3, i6, f12;
  const a4 = ye(t4), l6 = ye(e9), c6 = {}, u6 = Object.keys(a4).concat(Object.keys(l6));
  for (const h7 of u6) c6[h7] = { chains: ct((n4 = a4[h7]) == null ? void 0 : n4.chains, (r6 = l6[h7]) == null ? void 0 : r6.chains), methods: ct((o4 = a4[h7]) == null ? void 0 : o4.methods, (s3 = l6[h7]) == null ? void 0 : s3.methods), events: ct((i6 = a4[h7]) == null ? void 0 : i6.events, (f12 = l6[h7]) == null ? void 0 : f12.events) };
  return c6;
}
var Jo2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Qo2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function Et(t4, e9) {
  const { message: n4, code: r6 } = Qo2[t4];
  return { message: e9 ? `${n4} ${e9}` : n4, code: r6 };
}
function Kt2(t4, e9) {
  const { message: n4, code: r6 } = Jo2[t4];
  return { message: e9 ? `${n4} ${e9}` : n4, code: r6 };
}
function me2(t4, e9) {
  return Array.isArray(t4) ? typeof e9 < "u" && t4.length ? t4.every(e9) : true : false;
}
function Ve(t4) {
  return Object.getPrototypeOf(t4) === Object.prototype && Object.keys(t4).length;
}
function kt(t4) {
  return typeof t4 > "u";
}
function it(t4, e9) {
  return e9 && kt(t4) ? true : typeof t4 == "string" && !!t4.trim().length;
}
function qe(t4, e9) {
  return e9 && kt(t4) ? true : typeof t4 == "number" && !isNaN(t4);
}
function ya(t4, e9) {
  const { requiredNamespaces: n4 } = e9, r6 = Object.keys(t4.namespaces), o4 = Object.keys(n4);
  let s3 = true;
  return It(o4, r6) ? (r6.forEach((i6) => {
    const { accounts: f12, methods: a4, events: l6 } = t4.namespaces[i6], c6 = qt(f12), u6 = n4[i6];
    (!It(ve(i6, u6), c6) || !It(u6.methods, a4) || !It(u6.events, l6)) && (s3 = false);
  }), s3) : false;
}
function we(t4) {
  return it(t4, false) && t4.includes(":") ? t4.split(":").length === 2 : false;
}
function ts(t4) {
  if (it(t4, false) && t4.includes(":")) {
    const e9 = t4.split(":");
    if (e9.length === 3) {
      const n4 = e9[0] + ":" + e9[1];
      return !!e9[2] && we(n4);
    }
  }
  return false;
}
function ma(t4) {
  function e9(n4) {
    try {
      return typeof new URL(n4) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (it(t4, false)) {
      if (e9(t4)) return true;
      const n4 = Qe2(t4);
      return e9(n4);
    }
  } catch {
  }
  return false;
}
function wa(t4) {
  var e9;
  return (e9 = t4?.proposer) == null ? void 0 : e9.publicKey;
}
function xa(t4) {
  return t4?.topic;
}
function va(t4, e9) {
  let n4 = null;
  return it(t4?.publicKey, false) || (n4 = Et("MISSING_OR_INVALID", `${e9} controller public key should be a string`)), n4;
}
function Hn(t4) {
  let e9 = true;
  return me2(t4) ? t4.length && (e9 = t4.every((n4) => it(n4, false))) : e9 = false, e9;
}
function es(t4, e9, n4) {
  let r6 = null;
  return me2(e9) && e9.length ? e9.forEach((o4) => {
    r6 || we(o4) || (r6 = Kt2("UNSUPPORTED_CHAINS", `${n4}, chain ${o4} should be a string and conform to "namespace:chainId" format`));
  }) : we(t4) || (r6 = Kt2("UNSUPPORTED_CHAINS", `${n4}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r6;
}
function ns(t4, e9, n4) {
  let r6 = null;
  return Object.entries(t4).forEach(([o4, s3]) => {
    if (r6) return;
    const i6 = es(o4, ve(o4, s3), `${e9} ${n4}`);
    i6 && (r6 = i6);
  }), r6;
}
function rs(t4, e9) {
  let n4 = null;
  return me2(t4) ? t4.forEach((r6) => {
    n4 || ts(r6) || (n4 = Kt2("UNSUPPORTED_ACCOUNTS", `${e9}, account ${r6} should be a string and conform to "namespace:chainId:address" format`));
  }) : n4 = Kt2("UNSUPPORTED_ACCOUNTS", `${e9}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n4;
}
function os(t4, e9) {
  let n4 = null;
  return Object.values(t4).forEach((r6) => {
    if (n4) return;
    const o4 = rs(r6?.accounts, `${e9} namespace`);
    o4 && (n4 = o4);
  }), n4;
}
function ss(t4, e9) {
  let n4 = null;
  return Hn(t4?.methods) ? Hn(t4?.events) || (n4 = Kt2("UNSUPPORTED_EVENTS", `${e9}, events should be an array of strings or empty array for no events`)) : n4 = Kt2("UNSUPPORTED_METHODS", `${e9}, methods should be an array of strings or empty array for no methods`), n4;
}
function Dn(t4, e9) {
  let n4 = null;
  return Object.values(t4).forEach((r6) => {
    if (n4) return;
    const o4 = ss(r6, `${e9}, namespace`);
    o4 && (n4 = o4);
  }), n4;
}
function Ea(t4, e9, n4) {
  let r6 = null;
  if (t4 && Ve(t4)) {
    const o4 = Dn(t4, e9);
    o4 && (r6 = o4);
    const s3 = ns(t4, e9, n4);
    s3 && (r6 = s3);
  } else r6 = Et("MISSING_OR_INVALID", `${e9}, ${n4} should be an object with data`);
  return r6;
}
function is(t4, e9) {
  let n4 = null;
  if (t4 && Ve(t4)) {
    const r6 = Dn(t4, e9);
    r6 && (n4 = r6);
    const o4 = os(t4, e9);
    o4 && (n4 = o4);
  } else n4 = Et("MISSING_OR_INVALID", `${e9}, namespaces should be an object with data`);
  return n4;
}
function fs(t4) {
  return it(t4.protocol, true);
}
function Ba(t4, e9) {
  let n4 = false;
  return e9 && !t4 ? n4 = true : t4 && me2(t4) && t4.length && t4.forEach((r6) => {
    n4 = fs(r6);
  }), n4;
}
function Ia(t4) {
  return typeof t4 == "number";
}
function Aa(t4) {
  return typeof t4 < "u" && typeof t4 !== null;
}
function Sa(t4) {
  return !(!t4 || typeof t4 != "object" || !t4.code || !qe(t4.code, false) || !t4.message || !it(t4.message, false));
}
function Na(t4) {
  return !(kt(t4) || !it(t4.method, false));
}
function Oa(t4) {
  return !(kt(t4) || kt(t4.result) && kt(t4.error) || !qe(t4.id, false) || !it(t4.jsonrpc, false));
}
function Ua(t4) {
  return !(kt(t4) || !it(t4.name, false));
}
function _a(t4, e9) {
  return !(!we(e9) || !Go(t4).includes(e9));
}
function Ta(t4, e9, n4) {
  return it(n4, false) ? Zo(t4, e9).includes(n4) : false;
}
function Ra(t4, e9, n4) {
  return it(n4, false) ? Wo(t4, e9).includes(n4) : false;
}
function cs(t4, e9, n4) {
  let r6 = null;
  const o4 = $a(t4), s3 = Ca(e9), i6 = Object.keys(o4), f12 = Object.keys(s3), a4 = as(Object.keys(t4)), l6 = as(Object.keys(e9)), c6 = a4.filter((u6) => !l6.includes(u6));
  return c6.length && (r6 = Et("NON_CONFORMING_NAMESPACES", `${n4} namespaces keys don't satisfy requiredNamespaces.
      Required: ${c6.toString()}
      Received: ${Object.keys(e9).toString()}`)), It(i6, f12) || (r6 = Et("NON_CONFORMING_NAMESPACES", `${n4} namespaces chains don't satisfy required namespaces.
      Required: ${i6.toString()}
      Approved: ${f12.toString()}`)), Object.keys(e9).forEach((u6) => {
    if (!u6.includes(":") || r6) return;
    const h7 = qt(e9[u6].accounts);
    h7.includes(u6) || (r6 = Et("NON_CONFORMING_NAMESPACES", `${n4} namespaces accounts don't satisfy namespace accounts for ${u6}
        Required: ${u6}
        Approved: ${h7.toString()}`));
  }), i6.forEach((u6) => {
    r6 || (It(o4[u6].methods, s3[u6].methods) ? It(o4[u6].events, s3[u6].events) || (r6 = Et("NON_CONFORMING_NAMESPACES", `${n4} namespaces events don't satisfy namespace events for ${u6}`)) : r6 = Et("NON_CONFORMING_NAMESPACES", `${n4} namespaces methods don't satisfy namespace methods for ${u6}`));
  }), r6;
}
function $a(t4) {
  const e9 = {};
  return Object.keys(t4).forEach((n4) => {
    var r6;
    n4.includes(":") ? e9[n4] = t4[n4] : (r6 = t4[n4].chains) == null || r6.forEach((o4) => {
      e9[o4] = { methods: t4[n4].methods, events: t4[n4].events };
    });
  }), e9;
}
function as(t4) {
  return [...new Set(t4.map((e9) => e9.includes(":") ? e9.split(":")[0] : e9))];
}
function Ca(t4) {
  const e9 = {};
  return Object.keys(t4).forEach((n4) => {
    if (n4.includes(":")) e9[n4] = t4[n4];
    else {
      const r6 = qt(t4[n4].accounts);
      r6?.forEach((o4) => {
        e9[o4] = { accounts: t4[n4].accounts.filter((s3) => s3.includes(`${o4}:`)), methods: t4[n4].methods, events: t4[n4].events };
      });
    }
  }), e9;
}
function La(t4, e9) {
  return qe(t4, false) && t4 <= e9.max && t4 >= e9.min;
}
function ja() {
  const t4 = Pt();
  return new Promise((e9) => {
    switch (t4) {
      case J2.browser:
        e9(us());
        break;
      case J2.reactNative:
        e9(ls());
        break;
      case J2.node:
        e9(ds());
        break;
      default:
        e9(true);
    }
  });
}
function us() {
  return zt() && navigator?.onLine;
}
async function ls() {
  if (Bt() && typeof global < "u" && global != null && global.NetInfo) {
    const t4 = await (global == null ? void 0 : global.NetInfo.fetch());
    return t4?.isConnected;
  }
  return true;
}
function ds() {
  return true;
}
function ka(t4) {
  switch (Pt()) {
    case J2.browser:
      hs(t4);
      break;
    case J2.reactNative:
      ps(t4);
      break;
    case J2.node:
      break;
  }
}
function hs(t4) {
  !Bt() && zt() && (window.addEventListener("online", () => t4(true)), window.addEventListener("offline", () => t4(false)));
}
function ps(t4) {
  Bt() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e9) => t4(e9?.isConnected));
}
function Pa() {
  var t4;
  return zt() && (0, import_window_getters2.getDocument)() ? ((t4 = (0, import_window_getters2.getDocument)()) == null ? void 0 : t4.visibilityState) === "visible" : true;
}
var Mn = {};
var Ha = class {
  static get(e9) {
    return Mn[e9];
  }
  static set(e9, n4) {
    Mn[e9] = n4;
  }
  static delete(e9) {
    delete Mn[e9];
  }
};
function gs(t4) {
  const e9 = esm_default4.decode(t4);
  if (e9.length < 33) throw new Error("Too short to contain a public key");
  return e9.slice(1, 33);
}
function bs({ publicKey: t4, signature: e9, payload: n4 }) {
  var r6;
  const o4 = Vn(n4.method), s3 = 128 | parseInt(((r6 = n4.version) == null ? void 0 : r6.toString()) || "4"), i6 = Ma(n4.address), f12 = n4.era === "00" ? new Uint8Array([0]) : Vn(n4.era);
  if (f12.length !== 1 && f12.length !== 2) throw new Error("Invalid era length");
  const a4 = parseInt(n4.nonce, 16), l6 = new Uint8Array([a4 & 255, a4 >> 8 & 255]), c6 = BigInt(`0x${Da(n4.tip)}`), u6 = qa(c6), h7 = new Uint8Array([0, ...t4, i6, ...e9, ...f12, ...l6, ...u6, ...o4]), g3 = Va(h7.length + 1);
  return new Uint8Array([...g3, s3, ...h7]);
}
function ys(t4) {
  const e9 = Vn(t4), n4 = (0, import_blakejs2.blake2b)(e9, void 0, 32);
  return "0x" + Buffer.from(n4).toString("hex");
}
function Vn(t4) {
  return new Uint8Array(t4.replace(/^0x/, "").match(/.{1,2}/g).map((e9) => parseInt(e9, 16)));
}
function Da(t4) {
  return t4.startsWith("0x") ? t4.slice(2) : t4;
}
function Ma(t4) {
  const e9 = esm_default4.decode(t4)[0];
  return e9 === 42 ? 0 : e9 === 60 ? 2 : 1;
}
function Va(t4) {
  if (t4 < 64) return new Uint8Array([t4 << 2]);
  if (t4 < 16384) {
    const e9 = t4 << 2 | 1;
    return new Uint8Array([e9 & 255, e9 >> 8 & 255]);
  } else if (t4 < 1 << 30) {
    const e9 = t4 << 2 | 2;
    return new Uint8Array([e9 & 255, e9 >> 8 & 255, e9 >> 16 & 255, e9 >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function qa(t4) {
  if (t4 < BigInt(1) << BigInt(6)) return new Uint8Array([Number(t4 << BigInt(2))]);
  if (t4 < BigInt(1) << BigInt(14)) {
    const e9 = t4 << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e9 & BigInt(255)), Number(e9 >> BigInt(8) & BigInt(255))]);
  } else if (t4 < BigInt(1) << BigInt(30)) {
    const e9 = t4 << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e9 & BigInt(255)), Number(e9 >> BigInt(8) & BigInt(255)), Number(e9 >> BigInt(16) & BigInt(255)), Number(e9 >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function Ka(t4) {
  const e9 = Uint8Array.from(Buffer.from(t4.signature, "hex")), n4 = gs(t4.transaction.address), r6 = bs({ publicKey: n4, signature: e9, payload: t4.transaction }), o4 = Buffer.from(r6).toString("hex");
  return ys(o4);
}

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
init_esm();
var import_window_getters3 = __toESM(require_cjs4());
var ze = "wc";
var Le3 = 2;
var he3 = "core";
var B = `${ze}@2:${he3}:`;
var Et2 = { name: he3, logger: "error" };
var It2 = { database: ":memory:" };
var Tt3 = "crypto";
var ke3 = "client_ed25519_seed";
var Ct3 = import_time3.ONE_DAY;
var Pt2 = "keychain";
var St3 = "0.3";
var Ot3 = "messages";
var Rt3 = "0.3";
var je3 = import_time3.SIX_HOURS;
var At3 = "publisher";
var xt3 = "irn";
var Nt3 = "error";
var Ue3 = "wss://relay.walletconnect.org";
var $t3 = "relayer";
var C2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt2 = "_subscription";
var L = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt2 = 0.1;
var _e3 = "2.21.5";
var Q3 = { link_mode: "link_mode", relay: "relay" };
var le3 = { inbound: "inbound", outbound: "outbound" };
var kt2 = "0.3";
var jt3 = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut3 = "subscription";
var Ft = "0.3";
var Js = import_time3.FIVE_SECONDS * 1e3;
var Mt3 = "pairing";
var Kt3 = "0.3";
var se3 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var re = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F3 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt2 = "history";
var Vt2 = "0.3";
var qt2 = "expirer";
var M2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt3 = "0.3";
var Wt3 = "verify-api";
var Qs = "https://verify.walletconnect.com";
var Ht3 = "https://verify.walletconnect.org";
var ue3 = Ht3;
var Yt3 = `${ue3}/v3`;
var Jt3 = [Qs, Ht3];
var Xt3 = "echo";
var Zt3 = "https://echo.walletconnect.com";
var G3 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y3 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var tr2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var ir2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var sr2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var rr2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt2 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii2 = "https://pulse.walletconnect.org/batch";
function nr(r6, e9) {
  if (r6.length >= 255) throw new TypeError("Alphabet too long");
  for (var t4 = new Uint8Array(256), i6 = 0; i6 < t4.length; i6++) t4[i6] = 255;
  for (var s3 = 0; s3 < r6.length; s3++) {
    var n4 = r6.charAt(s3), o4 = n4.charCodeAt(0);
    if (t4[o4] !== 255) throw new TypeError(n4 + " is ambiguous");
    t4[o4] = s3;
  }
  var a4 = r6.length, c6 = r6.charAt(0), h7 = Math.log(a4) / Math.log(256), l6 = Math.log(256) / Math.log(a4);
  function d5(u6) {
    if (u6 instanceof Uint8Array || (ArrayBuffer.isView(u6) ? u6 = new Uint8Array(u6.buffer, u6.byteOffset, u6.byteLength) : Array.isArray(u6) && (u6 = Uint8Array.from(u6))), !(u6 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u6.length === 0) return "";
    for (var b5 = 0, x5 = 0, I7 = 0, D9 = u6.length; I7 !== D9 && u6[I7] === 0; ) I7++, b5++;
    for (var j6 = (D9 - I7) * l6 + 1 >>> 0, T6 = new Uint8Array(j6); I7 !== D9; ) {
      for (var q5 = u6[I7], J5 = 0, K4 = j6 - 1; (q5 !== 0 || J5 < x5) && K4 !== -1; K4--, J5++) q5 += 256 * T6[K4] >>> 0, T6[K4] = q5 % a4 >>> 0, q5 = q5 / a4 >>> 0;
      if (q5 !== 0) throw new Error("Non-zero carry");
      x5 = J5, I7++;
    }
    for (var H4 = j6 - x5; H4 !== j6 && T6[H4] === 0; ) H4++;
    for (var me7 = c6.repeat(b5); H4 < j6; ++H4) me7 += r6.charAt(T6[H4]);
    return me7;
  }
  function g3(u6) {
    if (typeof u6 != "string") throw new TypeError("Expected String");
    if (u6.length === 0) return new Uint8Array();
    var b5 = 0;
    if (u6[b5] !== " ") {
      for (var x5 = 0, I7 = 0; u6[b5] === c6; ) x5++, b5++;
      for (var D9 = (u6.length - b5) * h7 + 1 >>> 0, j6 = new Uint8Array(D9); u6[b5]; ) {
        var T6 = t4[u6.charCodeAt(b5)];
        if (T6 === 255) return;
        for (var q5 = 0, J5 = D9 - 1; (T6 !== 0 || q5 < I7) && J5 !== -1; J5--, q5++) T6 += a4 * j6[J5] >>> 0, j6[J5] = T6 % 256 >>> 0, T6 = T6 / 256 >>> 0;
        if (T6 !== 0) throw new Error("Non-zero carry");
        I7 = q5, b5++;
      }
      if (u6[b5] !== " ") {
        for (var K4 = D9 - I7; K4 !== D9 && j6[K4] === 0; ) K4++;
        for (var H4 = new Uint8Array(x5 + (D9 - K4)), me7 = x5; K4 !== D9; ) H4[me7++] = j6[K4++];
        return H4;
      }
    }
  }
  function _4(u6) {
    var b5 = g3(u6);
    if (b5) return b5;
    throw new Error(`Non-${e9} character`);
  }
  return { encode: d5, decodeUnsafe: g3, decode: _4 };
}
var or2 = nr;
var ar = or2;
var si2 = (r6) => {
  if (r6 instanceof Uint8Array && r6.constructor.name === "Uint8Array") return r6;
  if (r6 instanceof ArrayBuffer) return new Uint8Array(r6);
  if (ArrayBuffer.isView(r6)) return new Uint8Array(r6.buffer, r6.byteOffset, r6.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var cr2 = (r6) => new TextEncoder().encode(r6);
var hr2 = (r6) => new TextDecoder().decode(r6);
var lr = class {
  constructor(e9, t4, i6) {
    this.name = e9, this.prefix = t4, this.baseEncode = i6;
  }
  encode(e9) {
    if (e9 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e9)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ur = class {
  constructor(e9, t4, i6) {
    if (this.name = e9, this.prefix = t4, t4.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t4.codePointAt(0), this.baseDecode = i6;
  }
  decode(e9) {
    if (typeof e9 == "string") {
      if (e9.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e9)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e9.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e9) {
    return ri2(this, e9);
  }
};
var dr2 = class {
  constructor(e9) {
    this.decoders = e9;
  }
  or(e9) {
    return ri2(this, e9);
  }
  decode(e9) {
    const t4 = e9[0], i6 = this.decoders[t4];
    if (i6) return i6.decode(e9);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e9)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r6, e9) => new dr2({ ...r6.decoders || { [r6.prefix]: r6 }, ...e9.decoders || { [e9.prefix]: e9 } });
var gr2 = class {
  constructor(e9, t4, i6, s3) {
    this.name = e9, this.prefix = t4, this.baseEncode = i6, this.baseDecode = s3, this.encoder = new lr(e9, t4, i6), this.decoder = new ur(e9, t4, s3);
  }
  encode(e9) {
    return this.encoder.encode(e9);
  }
  decode(e9) {
    return this.decoder.decode(e9);
  }
};
var Ee = ({ name: r6, prefix: e9, encode: t4, decode: i6 }) => new gr2(r6, e9, t4, i6);
var de3 = ({ prefix: r6, name: e9, alphabet: t4 }) => {
  const { encode: i6, decode: s3 } = ar(t4, e9);
  return Ee({ prefix: r6, name: e9, encode: i6, decode: (n4) => si2(s3(n4)) });
};
var pr2 = (r6, e9, t4, i6) => {
  const s3 = {};
  for (let l6 = 0; l6 < e9.length; ++l6) s3[e9[l6]] = l6;
  let n4 = r6.length;
  for (; r6[n4 - 1] === "="; ) --n4;
  const o4 = new Uint8Array(n4 * t4 / 8 | 0);
  let a4 = 0, c6 = 0, h7 = 0;
  for (let l6 = 0; l6 < n4; ++l6) {
    const d5 = s3[r6[l6]];
    if (d5 === void 0) throw new SyntaxError(`Non-${i6} character`);
    c6 = c6 << t4 | d5, a4 += t4, a4 >= 8 && (a4 -= 8, o4[h7++] = 255 & c6 >> a4);
  }
  if (a4 >= t4 || 255 & c6 << 8 - a4) throw new SyntaxError("Unexpected end of data");
  return o4;
};
var yr3 = (r6, e9, t4) => {
  const i6 = e9[e9.length - 1] === "=", s3 = (1 << t4) - 1;
  let n4 = "", o4 = 0, a4 = 0;
  for (let c6 = 0; c6 < r6.length; ++c6) for (a4 = a4 << 8 | r6[c6], o4 += 8; o4 > t4; ) o4 -= t4, n4 += e9[s3 & a4 >> o4];
  if (o4 && (n4 += e9[s3 & a4 << t4 - o4]), i6) for (; n4.length * t4 & 7; ) n4 += "=";
  return n4;
};
var P2 = ({ name: r6, prefix: e9, bitsPerChar: t4, alphabet: i6 }) => Ee({ prefix: e9, name: r6, encode(s3) {
  return yr3(s3, i6, t4);
}, decode(s3) {
  return pr2(s3, i6, t4, r6);
} });
var br2 = Ee({ prefix: "\0", name: "identity", encode: (r6) => hr2(r6), decode: (r6) => cr2(r6) });
var mr3 = Object.freeze({ __proto__: null, identity: br2 });
var fr2 = P2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Dr2 = Object.freeze({ __proto__: null, base2: fr2 });
var vr3 = P2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var wr3 = Object.freeze({ __proto__: null, base8: vr3 });
var _r3 = de3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Er3 = Object.freeze({ __proto__: null, base10: _r3 });
var Ir3 = P2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Tr3 = P2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Cr2 = Object.freeze({ __proto__: null, base16: Ir3, base16upper: Tr3 });
var Pr2 = P2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Sr3 = P2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Or3 = P2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Rr3 = P2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ar3 = P2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var xr3 = P2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Nr3 = P2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var $r3 = P2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var zr = P2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Lr2 = Object.freeze({ __proto__: null, base32: Pr2, base32upper: Sr3, base32pad: Or3, base32padupper: Rr3, base32hex: Ar3, base32hexupper: xr3, base32hexpad: Nr3, base32hexpadupper: $r3, base32z: zr });
var kr2 = de3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jr2 = de3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ur3 = Object.freeze({ __proto__: null, base36: kr2, base36upper: jr2 });
var Fr = de3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Mr2 = de3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Kr = Object.freeze({ __proto__: null, base58btc: Fr, base58flickr: Mr2 });
var Br3 = P2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Vr2 = P2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var qr2 = P2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gr2 = P2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Wr2 = Object.freeze({ __proto__: null, base64: Br3, base64pad: Vr2, base64url: qr2, base64urlpad: Gr2 });
var ni2 = Array.from("");
var Hr2 = ni2.reduce((r6, e9, t4) => (r6[t4] = e9, r6), []);
var Yr = ni2.reduce((r6, e9, t4) => (r6[e9.codePointAt(0)] = t4, r6), []);
function Jr(r6) {
  return r6.reduce((e9, t4) => (e9 += Hr2[t4], e9), "");
}
function Xr2(r6) {
  const e9 = [];
  for (const t4 of r6) {
    const i6 = Yr[t4.codePointAt(0)];
    if (i6 === void 0) throw new Error(`Non-base256emoji character: ${t4}`);
    e9.push(i6);
  }
  return new Uint8Array(e9);
}
var Zr2 = Ee({ prefix: "", name: "base256emoji", encode: Jr, decode: Xr2 });
var Qr3 = Object.freeze({ __proto__: null, base256emoji: Zr2 });
var en3 = ai2;
var oi2 = 128;
var tn3 = 127;
var sn4 = ~tn3;
var rn3 = Math.pow(2, 31);
function ai2(r6, e9, t4) {
  e9 = e9 || [], t4 = t4 || 0;
  for (var i6 = t4; r6 >= rn3; ) e9[t4++] = r6 & 255 | oi2, r6 /= 128;
  for (; r6 & sn4; ) e9[t4++] = r6 & 255 | oi2, r6 >>>= 7;
  return e9[t4] = r6 | 0, ai2.bytes = t4 - i6 + 1, e9;
}
var nn3 = Me2;
var on3 = 128;
var ci2 = 127;
function Me2(r6, i6) {
  var t4 = 0, i6 = i6 || 0, s3 = 0, n4 = i6, o4, a4 = r6.length;
  do {
    if (n4 >= a4) throw Me2.bytes = 0, new RangeError("Could not decode varint");
    o4 = r6[n4++], t4 += s3 < 28 ? (o4 & ci2) << s3 : (o4 & ci2) * Math.pow(2, s3), s3 += 7;
  } while (o4 >= on3);
  return Me2.bytes = n4 - i6, t4;
}
var an2 = Math.pow(2, 7);
var cn3 = Math.pow(2, 14);
var hn2 = Math.pow(2, 21);
var ln2 = Math.pow(2, 28);
var un2 = Math.pow(2, 35);
var dn2 = Math.pow(2, 42);
var gn2 = Math.pow(2, 49);
var pn2 = Math.pow(2, 56);
var yn3 = Math.pow(2, 63);
var bn3 = function(r6) {
  return r6 < an2 ? 1 : r6 < cn3 ? 2 : r6 < hn2 ? 3 : r6 < ln2 ? 4 : r6 < un2 ? 5 : r6 < dn2 ? 6 : r6 < gn2 ? 7 : r6 < pn2 ? 8 : r6 < yn3 ? 9 : 10;
};
var mn3 = { encode: en3, decode: nn3, encodingLength: bn3 };
var hi2 = mn3;
var li2 = (r6, e9, t4 = 0) => (hi2.encode(r6, e9, t4), e9);
var ui2 = (r6) => hi2.encodingLength(r6);
var Ke3 = (r6, e9) => {
  const t4 = e9.byteLength, i6 = ui2(r6), s3 = i6 + ui2(t4), n4 = new Uint8Array(s3 + t4);
  return li2(r6, n4, 0), li2(t4, n4, i6), n4.set(e9, s3), new fn3(r6, t4, e9, n4);
};
var fn3 = class {
  constructor(e9, t4, i6, s3) {
    this.code = e9, this.size = t4, this.digest = i6, this.bytes = s3;
  }
};
var di2 = ({ name: r6, code: e9, encode: t4 }) => new Dn2(r6, e9, t4);
var Dn2 = class {
  constructor(e9, t4, i6) {
    this.name = e9, this.code = t4, this.encode = i6;
  }
  digest(e9) {
    if (e9 instanceof Uint8Array) {
      const t4 = this.encode(e9);
      return t4 instanceof Uint8Array ? Ke3(this.code, t4) : t4.then((i6) => Ke3(this.code, i6));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r6) => async (e9) => new Uint8Array(await crypto.subtle.digest(r6, e9));
var vn3 = di2({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var wn3 = di2({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var _n3 = Object.freeze({ __proto__: null, sha256: vn3, sha512: wn3 });
var pi2 = 0;
var En3 = "identity";
var yi3 = si2;
var In3 = (r6) => Ke3(pi2, yi3(r6));
var Tn3 = { code: pi2, name: En3, encode: yi3, digest: In3 };
var Cn2 = Object.freeze({ __proto__: null, identity: Tn3 });
new TextEncoder(), new TextDecoder();
var bi3 = { ...mr3, ...Dr2, ...wr3, ...Er3, ...Cr2, ...Lr2, ...Ur3, ...Kr, ...Wr2, ...Qr3 };
({ ..._n3, ...Cn2 });
function mi3(r6) {
  return globalThis.Buffer != null ? new Uint8Array(r6.buffer, r6.byteOffset, r6.byteLength) : r6;
}
function Pn2(r6 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? mi3(globalThis.Buffer.allocUnsafe(r6)) : new Uint8Array(r6);
}
function fi2(r6, e9, t4, i6) {
  return { name: r6, prefix: e9, encoder: { name: r6, prefix: e9, encode: t4 }, decoder: { decode: i6 } };
}
var Di3 = fi2("utf8", "u", (r6) => "u" + new TextDecoder("utf8").decode(r6), (r6) => new TextEncoder().encode(r6.substring(1)));
var Be3 = fi2("ascii", "a", (r6) => {
  let e9 = "a";
  for (let t4 = 0; t4 < r6.length; t4++) e9 += String.fromCharCode(r6[t4]);
  return e9;
}, (r6) => {
  r6 = r6.substring(1);
  const e9 = Pn2(r6.length);
  for (let t4 = 0; t4 < r6.length; t4++) e9[t4] = r6.charCodeAt(t4);
  return e9;
});
var Sn3 = { utf8: Di3, "utf-8": Di3, hex: bi3.base16, latin1: Be3, ascii: Be3, binary: Be3, ...bi3 };
function On3(r6, e9 = "utf8") {
  const t4 = Sn3[e9];
  if (!t4) throw new Error(`Unsupported encoding "${e9}"`);
  return (e9 === "utf8" || e9 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? mi3(globalThis.Buffer.from(r6, "utf-8")) : t4.decoder.decode(`${t4.prefix}${r6}`);
}
var Rn3 = Object.defineProperty;
var An3 = (r6, e9, t4) => e9 in r6 ? Rn3(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var W3 = (r6, e9, t4) => An3(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var vi3 = class {
  constructor(e9, t4) {
    this.core = e9, this.logger = t4, W3(this, "keychain", /* @__PURE__ */ new Map()), W3(this, "name", Pt2), W3(this, "version", St3), W3(this, "initialized", false), W3(this, "storagePrefix", B), W3(this, "init", async () => {
      if (!this.initialized) {
        const i6 = await this.getKeyChain();
        typeof i6 < "u" && (this.keychain = i6), this.initialized = true;
      }
    }), W3(this, "has", (i6) => (this.isInitialized(), this.keychain.has(i6))), W3(this, "set", async (i6, s3) => {
      this.isInitialized(), this.keychain.set(i6, s3), await this.persist();
    }), W3(this, "get", (i6) => {
      this.isInitialized();
      const s3 = this.keychain.get(i6);
      if (typeof s3 > "u") {
        const { message: n4 } = Et("NO_MATCHING_KEY", `${this.name}: ${i6}`);
        throw new Error(n4);
      }
      return s3;
    }), W3(this, "del", async (i6) => {
      this.isInitialized(), this.keychain.delete(i6), await this.persist();
    }), this.core = e9, this.logger = E(t4, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e9) {
    await this.core.storage.setItem(this.storageKey, Ys(e9));
  }
  async getKeyChain() {
    const e9 = await this.core.storage.getItem(this.storageKey);
    return typeof e9 < "u" ? Xs(e9) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
};
var xn3 = Object.defineProperty;
var Nn3 = (r6, e9, t4) => e9 in r6 ? xn3(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var S2 = (r6, e9, t4) => Nn3(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var wi3 = class {
  constructor(e9, t4, i6) {
    this.core = e9, this.logger = t4, S2(this, "name", Tt3), S2(this, "keychain"), S2(this, "randomSessionIdentifier", qc()), S2(this, "initialized", false), S2(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S2(this, "hasKeys", (s3) => (this.isInitialized(), this.keychain.has(s3))), S2(this, "getClientId", async () => {
      this.isInitialized();
      const s3 = await this.getClientSeed(), n4 = Po(s3);
      return Qe(n4.publicKey);
    }), S2(this, "generateKeyPair", () => {
      this.isInitialized();
      const s3 = Vc();
      return this.setPrivateKey(s3.publicKey, s3.privateKey);
    }), S2(this, "signJWT", async (s3) => {
      this.isInitialized();
      const n4 = await this.getClientSeed(), o4 = Po(n4), a4 = this.randomSessionIdentifier, c6 = Ct3;
      return await Qo(a4, s3, c6, o4);
    }), S2(this, "generateSharedKey", (s3, n4, o4) => {
      this.isInitialized();
      const a4 = this.getPrivateKey(s3), c6 = Kc(a4, n4);
      return this.setSymKey(c6, o4);
    }), S2(this, "setSymKey", async (s3, n4) => {
      this.isInitialized();
      const o4 = n4 || Fc(s3);
      return await this.keychain.set(o4, s3), o4;
    }), S2(this, "deleteKeyPair", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S2(this, "deleteSymKey", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S2(this, "encode", async (s3, n4, o4) => {
      this.isInitialized();
      const a4 = Ho(o4), c6 = safeJsonStringify(n4);
      if (Qc(a4)) return Wc(c6, o4?.encoding);
      if (Jc(a4)) {
        const g3 = a4.senderPublicKey, _4 = a4.receiverPublicKey;
        s3 = await this.generateSharedKey(g3, _4);
      }
      const h7 = this.getSymKey(s3), { type: l6, senderPublicKey: d5 } = a4;
      return Gc({ type: l6, symKey: h7, message: c6, senderPublicKey: d5, encoding: o4?.encoding });
    }), S2(this, "decode", async (s3, n4, o4) => {
      this.isInitialized();
      const a4 = Xc(n4, o4);
      if (Qc(a4)) {
        const c6 = Yc(n4, o4?.encoding);
        return safeJsonParse(c6);
      }
      if (Jc(a4)) {
        const c6 = a4.receiverPublicKey, h7 = a4.senderPublicKey;
        s3 = await this.generateSharedKey(c6, h7);
      }
      try {
        const c6 = this.getSymKey(s3), h7 = Zc({ symKey: c6, encoded: n4, encoding: o4?.encoding });
        return safeJsonParse(h7);
      } catch (c6) {
        this.logger.error(`Failed to decode message from topic: '${s3}', clientId: '${await this.getClientId()}'`), this.logger.error(c6);
      }
    }), S2(this, "getPayloadType", (s3, n4 = Qt) => {
      const o4 = Me({ encoded: s3, encoding: n4 });
      return Vt(o4.type);
    }), S2(this, "getPayloadSenderPublicKey", (s3, n4 = Qt) => {
      const o4 = Me({ encoded: s3, encoding: n4 });
      return o4.senderPublicKey ? toString4(o4.senderPublicKey, tt) : void 0;
    }), this.core = e9, this.logger = E(t4, this.name), this.keychain = i6 || new vi3(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e9, t4) {
    return await this.keychain.set(e9, t4), e9;
  }
  getPrivateKey(e9) {
    return this.keychain.get(e9);
  }
  async getClientSeed() {
    let e9 = "";
    try {
      e9 = this.keychain.get(ke3);
    } catch {
      e9 = qc(), await this.keychain.set(ke3, e9);
    }
    return On3(e9, "base16");
  }
  getSymKey(e9) {
    return this.keychain.get(e9);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
};
var $n2 = Object.defineProperty;
var zn3 = Object.defineProperties;
var Ln2 = Object.getOwnPropertyDescriptors;
var _i3 = Object.getOwnPropertySymbols;
var kn2 = Object.prototype.hasOwnProperty;
var jn2 = Object.prototype.propertyIsEnumerable;
var Ve2 = (r6, e9, t4) => e9 in r6 ? $n2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var Un3 = (r6, e9) => {
  for (var t4 in e9 || (e9 = {})) kn2.call(e9, t4) && Ve2(r6, t4, e9[t4]);
  if (_i3) for (var t4 of _i3(e9)) jn2.call(e9, t4) && Ve2(r6, t4, e9[t4]);
  return r6;
};
var Fn3 = (r6, e9) => zn3(r6, Ln2(e9));
var k3 = (r6, e9, t4) => Ve2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Ei3 = class extends y2 {
  constructor(e9, t4) {
    super(e9, t4), this.logger = e9, this.core = t4, k3(this, "messages", /* @__PURE__ */ new Map()), k3(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k3(this, "name", Ot3), k3(this, "version", Rt3), k3(this, "initialized", false), k3(this, "storagePrefix", B), k3(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i6 = await this.getRelayerMessages();
          typeof i6 < "u" && (this.messages = i6);
          const s3 = await this.getRelayerMessagesWithoutClientAck();
          typeof s3 < "u" && (this.messagesWithoutClientAck = s3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i6) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i6);
        } finally {
          this.initialized = true;
        }
      }
    }), k3(this, "set", async (i6, s3, n4) => {
      this.isInitialized();
      const o4 = zc(s3);
      let a4 = this.messages.get(i6);
      if (typeof a4 > "u" && (a4 = {}), typeof a4[o4] < "u") return o4;
      if (a4[o4] = s3, this.messages.set(i6, a4), n4 === le3.inbound) {
        const c6 = this.messagesWithoutClientAck.get(i6) || {};
        this.messagesWithoutClientAck.set(i6, Fn3(Un3({}, c6), { [o4]: s3 }));
      }
      return await this.persist(), o4;
    }), k3(this, "get", (i6) => {
      this.isInitialized();
      let s3 = this.messages.get(i6);
      return typeof s3 > "u" && (s3 = {}), s3;
    }), k3(this, "getWithoutAck", (i6) => {
      this.isInitialized();
      const s3 = {};
      for (const n4 of i6) {
        const o4 = this.messagesWithoutClientAck.get(n4) || {};
        s3[n4] = Object.values(o4);
      }
      return s3;
    }), k3(this, "has", (i6, s3) => {
      this.isInitialized();
      const n4 = this.get(i6), o4 = zc(s3);
      return typeof n4[o4] < "u";
    }), k3(this, "ack", async (i6, s3) => {
      this.isInitialized();
      const n4 = this.messagesWithoutClientAck.get(i6);
      if (typeof n4 > "u") return;
      const o4 = zc(s3);
      delete n4[o4], Object.keys(n4).length === 0 ? this.messagesWithoutClientAck.delete(i6) : this.messagesWithoutClientAck.set(i6, n4), await this.persist();
    }), k3(this, "del", async (i6) => {
      this.isInitialized(), this.messages.delete(i6), this.messagesWithoutClientAck.delete(i6), await this.persist();
    }), this.logger = E(e9, this.name), this.core = t4;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e9) {
    await this.core.storage.setItem(this.storageKey, Ys(e9));
  }
  async setRelayerMessagesWithoutClientAck(e9) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, Ys(e9));
  }
  async getRelayerMessages() {
    const e9 = await this.core.storage.getItem(this.storageKey);
    return typeof e9 < "u" ? Xs(e9) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e9 = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e9 < "u" ? Xs(e9) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
};
var Mn2 = Object.defineProperty;
var Kn3 = Object.defineProperties;
var Bn3 = Object.getOwnPropertyDescriptors;
var Ii3 = Object.getOwnPropertySymbols;
var Vn2 = Object.prototype.hasOwnProperty;
var qn3 = Object.prototype.propertyIsEnumerable;
var qe2 = (r6, e9, t4) => e9 in r6 ? Mn2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var Ie3 = (r6, e9) => {
  for (var t4 in e9 || (e9 = {})) Vn2.call(e9, t4) && qe2(r6, t4, e9[t4]);
  if (Ii3) for (var t4 of Ii3(e9)) qn3.call(e9, t4) && qe2(r6, t4, e9[t4]);
  return r6;
};
var Ge = (r6, e9) => Kn3(r6, Bn3(e9));
var V2 = (r6, e9, t4) => qe2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Gn = class extends m {
  constructor(e9, t4) {
    super(e9, t4), this.relayer = e9, this.logger = t4, V2(this, "events", new import_events3.EventEmitter()), V2(this, "name", At3), V2(this, "queue", /* @__PURE__ */ new Map()), V2(this, "publishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), V2(this, "initialPublishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), V2(this, "needsTransportRestart", false), V2(this, "publish", async (i6, s3, n4) => {
      var o4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i6, message: s3, opts: n4 } });
      const a4 = n4?.ttl || je3, c6 = ea(n4), h7 = n4?.prompt || false, l6 = n4?.tag || 0, d5 = n4?.id || getBigIntRpcId().toString(), g3 = { topic: i6, message: s3, opts: { ttl: a4, relay: c6, prompt: h7, tag: l6, id: d5, attestation: n4?.attestation, tvf: n4?.tvf } }, _4 = `Failed to publish payload, please try again. id:${d5} tag:${l6}`;
      try {
        const u6 = new Promise(async (b5) => {
          const x5 = ({ id: D9 }) => {
            g3.opts.id === D9 && (this.removeRequestFromQueue(D9), this.relayer.events.removeListener(C2.publish, x5), b5(g3));
          };
          this.relayer.events.on(C2.publish, x5);
          const I7 = ni(new Promise((D9, j6) => {
            this.rpcPublish({ topic: i6, message: s3, ttl: a4, prompt: h7, tag: l6, id: d5, attestation: n4?.attestation, tvf: n4?.tvf }).then(D9).catch((T6) => {
              this.logger.warn(T6, T6?.message), j6(T6);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d5} tag:${l6}`);
          try {
            await I7, this.events.removeListener(C2.publish, x5);
          } catch (D9) {
            this.queue.set(d5, Ge(Ie3({}, g3), { attempt: 1 })), this.logger.warn(D9, D9?.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d5, topic: i6, message: s3, opts: n4 } }), await ni(u6, this.publishTimeout, _4);
      } catch (u6) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u6), (o4 = n4?.internal) != null && o4.throwOnFailedPublish) throw u6;
      } finally {
        this.queue.delete(d5);
      }
    }), V2(this, "on", (i6, s3) => {
      this.events.on(i6, s3);
    }), V2(this, "once", (i6, s3) => {
      this.events.once(i6, s3);
    }), V2(this, "off", (i6, s3) => {
      this.events.off(i6, s3);
    }), V2(this, "removeListener", (i6, s3) => {
      this.events.removeListener(i6, s3);
    }), this.relayer = e9, this.logger = E(t4, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e9) {
    var t4, i6, s3, n4;
    const { topic: o4, message: a4, ttl: c6 = je3, prompt: h7, tag: l6, id: d5, attestation: g3, tvf: _4 } = e9, u6 = { method: na(ea().protocol).publish, params: Ie3({ topic: o4, message: a4, ttl: c6, prompt: h7, tag: l6, attestation: g3 }, _4), id: d5 };
    kt((t4 = u6.params) == null ? void 0 : t4.prompt) && ((i6 = u6.params) == null || delete i6.prompt), kt((s3 = u6.params) == null ? void 0 : s3.tag) && ((n4 = u6.params) == null || delete n4.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u6 });
    const b5 = await this.relayer.request(u6);
    return this.relayer.events.emit(C2.publish, e9), this.logger.debug("Successfully Published Payload"), b5;
  }
  removeRequestFromQueue(e9) {
    this.queue.delete(e9);
  }
  checkQueue() {
    this.queue.forEach(async (e9, t4) => {
      const i6 = e9.attempt + 1;
      this.queue.set(t4, Ge(Ie3({}, e9), { attempt: i6 }));
      const { topic: s3, message: n4, opts: o4, attestation: a4 } = e9;
      this.logger.warn({}, `Publisher: queue->publishing: ${e9.opts.id}, tag: ${e9.opts.tag}, attempt: ${i6}`), await this.rpcPublish(Ge(Ie3({}, e9), { topic: s3, message: n4, ttl: o4.ttl, prompt: o4.prompt, tag: o4.tag, id: o4.id, attestation: a4, tvf: o4.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e9.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C2.message_ack, (e9) => {
      this.removeRequestFromQueue(e9.id.toString());
    });
  }
};
var Wn = Object.defineProperty;
var Hn2 = (r6, e9, t4) => e9 in r6 ? Wn(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var ne3 = (r6, e9, t4) => Hn2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Yn = class {
  constructor() {
    ne3(this, "map", /* @__PURE__ */ new Map()), ne3(this, "set", (e9, t4) => {
      const i6 = this.get(e9);
      this.exists(e9, t4) || this.map.set(e9, [...i6, t4]);
    }), ne3(this, "get", (e9) => this.map.get(e9) || []), ne3(this, "exists", (e9, t4) => this.get(e9).includes(t4)), ne3(this, "delete", (e9, t4) => {
      if (typeof t4 > "u") {
        this.map.delete(e9);
        return;
      }
      if (!this.map.has(e9)) return;
      const i6 = this.get(e9);
      if (!this.exists(e9, t4)) return;
      const s3 = i6.filter((n4) => n4 !== t4);
      if (!s3.length) {
        this.map.delete(e9);
        return;
      }
      this.map.set(e9, s3);
    }), ne3(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Jn2 = Object.defineProperty;
var Xn = Object.defineProperties;
var Zn = Object.getOwnPropertyDescriptors;
var Ti3 = Object.getOwnPropertySymbols;
var Qn2 = Object.prototype.hasOwnProperty;
var eo3 = Object.prototype.propertyIsEnumerable;
var We = (r6, e9, t4) => e9 in r6 ? Jn2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var ge2 = (r6, e9) => {
  for (var t4 in e9 || (e9 = {})) Qn2.call(e9, t4) && We(r6, t4, e9[t4]);
  if (Ti3) for (var t4 of Ti3(e9)) eo3.call(e9, t4) && We(r6, t4, e9[t4]);
  return r6;
};
var He3 = (r6, e9) => Xn(r6, Zn(e9));
var f4 = (r6, e9, t4) => We(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Ci3 = class extends P {
  constructor(e9, t4) {
    super(e9, t4), this.relayer = e9, this.logger = t4, f4(this, "subscriptions", /* @__PURE__ */ new Map()), f4(this, "topicMap", new Yn()), f4(this, "events", new import_events3.EventEmitter()), f4(this, "name", Ut3), f4(this, "version", Ft), f4(this, "pending", /* @__PURE__ */ new Map()), f4(this, "cached", []), f4(this, "initialized", false), f4(this, "storagePrefix", B), f4(this, "subscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), f4(this, "initialSubscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), f4(this, "clientId"), f4(this, "batchSubscribeTopicsLimit", 500), f4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f4(this, "subscribe", async (i6, s3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i6, opts: s3 } });
      try {
        const n4 = ea(s3), o4 = { topic: i6, relay: n4, transportType: s3?.transportType };
        this.pending.set(i6, o4);
        const a4 = await this.rpcSubscribe(i6, n4, s3);
        return typeof a4 == "string" && (this.onSubscribe(a4, o4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i6, opts: s3 } })), a4;
      } catch (n4) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n4), n4;
      }
    }), f4(this, "unsubscribe", async (i6, s3) => {
      this.isInitialized(), typeof s3?.id < "u" ? await this.unsubscribeById(i6, s3.id, s3) : await this.unsubscribeByTopic(i6, s3);
    }), f4(this, "isSubscribed", (i6) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i6));
    })), f4(this, "isKnownTopic", (i6) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i6) || this.pending.has(i6) || this.cached.some((n4) => n4.topic === i6));
    })), f4(this, "on", (i6, s3) => {
      this.events.on(i6, s3);
    }), f4(this, "once", (i6, s3) => {
      this.events.once(i6, s3);
    }), f4(this, "off", (i6, s3) => {
      this.events.off(i6, s3);
    }), f4(this, "removeListener", (i6, s3) => {
      this.events.removeListener(i6, s3);
    }), f4(this, "start", async () => {
      await this.onConnect();
    }), f4(this, "stop", async () => {
      await this.onDisconnect();
    }), f4(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f4(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i6 = [];
      this.pending.forEach((s3) => {
        i6.push(s3);
      }), await this.batchSubscribe(i6);
    }), f4(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (i6) => {
        const s3 = $.created;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i6 }), await this.persist();
      }), this.events.on($.deleted, async (i6) => {
        const s3 = $.deleted;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i6 }), await this.persist();
      });
    }), this.relayer = e9, this.logger = E(t4, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e9, t4) {
    let i6 = false;
    try {
      i6 = this.getSubscription(e9).topic === t4;
    } catch {
    }
    return i6;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e9, t4) {
    const i6 = this.topicMap.get(e9);
    await Promise.all(i6.map(async (s3) => await this.unsubscribeById(e9, s3, t4)));
  }
  async unsubscribeById(e9, t4, i6) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e9, id: t4, opts: i6 } });
    try {
      const s3 = ea(i6);
      await this.restartToComplete({ topic: e9, id: t4, relay: s3 }), await this.rpcUnsubscribe(e9, t4, s3);
      const n4 = Kt2("USER_DISCONNECTED", `${this.name}, ${e9}`);
      await this.onUnsubscribe(e9, t4, n4), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e9, id: t4, opts: i6 } });
    } catch (s3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s3), s3;
    }
  }
  async rpcSubscribe(e9, t4, i6) {
    var s3;
    (!i6 || i6?.transportType === Q3.relay) && await this.restartToComplete({ topic: e9, id: e9, relay: t4 });
    const n4 = { method: na(t4.protocol).subscribe, params: { topic: e9 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n4 });
    const o4 = (s3 = i6?.internal) == null ? void 0 : s3.throwOnFailedPublish;
    try {
      const a4 = await this.getSubscriptionId(e9);
      if (i6?.transportType === Q3.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n4).catch((l6) => this.logger.warn(l6));
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), a4;
      const c6 = new Promise(async (l6) => {
        const d5 = (g3) => {
          g3.topic === e9 && (this.events.removeListener($.created, d5), l6(g3.id));
        };
        this.events.on($.created, d5);
        try {
          const g3 = await ni(new Promise((_4, u6) => {
            this.relayer.request(n4).catch((b5) => {
              this.logger.warn(b5, b5?.message), u6(b5);
            }).then(_4);
          }), this.initialSubscribeTimeout, `Subscribing to ${e9} failed, please try again`);
          this.events.removeListener($.created, d5), l6(g3);
        } catch {
        }
      }), h7 = await ni(c6, this.subscribeTimeout, `Subscribing to ${e9} failed, please try again`);
      if (!h7 && o4) throw new Error(`Subscribing to ${e9} failed, please try again`);
      return h7 ? a4 : null;
    } catch (a4) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C2.connection_stalled), o4) throw a4;
    }
    return null;
  }
  async rpcBatchSubscribe(e9) {
    if (!e9.length) return;
    const t4 = e9[0].relay, i6 = { method: na(t4.protocol).batchSubscribe, params: { topics: e9.map((s3) => s3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i6 });
    try {
      await await ni(new Promise((s3) => {
        this.relayer.request(i6).catch((n4) => this.logger.warn(n4)).then(s3);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e9) {
    if (!e9.length) return;
    const t4 = e9[0].relay, i6 = { method: na(t4.protocol).batchFetchMessages, params: { topics: e9.map((n4) => n4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i6 });
    let s3;
    try {
      s3 = await await ni(new Promise((n4, o4) => {
        this.relayer.request(i6).catch((a4) => {
          this.logger.warn(a4), o4(a4);
        }).then(n4);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
    return s3;
  }
  rpcUnsubscribe(e9, t4, i6) {
    const s3 = { method: na(i6.protocol).unsubscribe, params: { topic: e9, id: t4 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s3 }), this.relayer.request(s3);
  }
  onSubscribe(e9, t4) {
    this.setSubscription(e9, He3(ge2({}, t4), { id: e9 })), this.pending.delete(t4.topic);
  }
  onBatchSubscribe(e9) {
    e9.length && e9.forEach((t4) => {
      this.setSubscription(t4.id, ge2({}, t4)), this.pending.delete(t4.topic);
    });
  }
  async onUnsubscribe(e9, t4, i6) {
    this.events.removeAllListeners(t4), this.hasSubscription(t4, e9) && this.deleteSubscription(t4, i6), await this.relayer.messages.del(e9);
  }
  async setRelayerSubscriptions(e9) {
    await this.relayer.core.storage.setItem(this.storageKey, e9);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e9, t4) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e9, subscription: t4 }), this.addSubscription(e9, t4);
  }
  addSubscription(e9, t4) {
    this.subscriptions.set(e9, ge2({}, t4)), this.topicMap.set(t4.topic, e9), this.events.emit($.created, t4);
  }
  getSubscription(e9) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e9 });
    const t4 = this.subscriptions.get(e9);
    if (!t4) {
      const { message: i6 } = Et("NO_MATCHING_KEY", `${this.name}: ${e9}`);
      throw new Error(i6);
    }
    return t4;
  }
  deleteSubscription(e9, t4) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e9, reason: t4 });
    const i6 = this.getSubscription(e9);
    this.subscriptions.delete(e9), this.topicMap.delete(i6.topic, e9), this.events.emit($.deleted, He3(ge2({}, i6), { reason: t4 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e9 = [...this.cached], t4 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i6 = 0; i6 < t4; i6++) {
        const s3 = e9.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s3);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e9 = await this.getRelayerSubscriptions();
      if (typeof e9 > "u" || !e9.length) return;
      if (this.subscriptions.size) {
        const { message: t4 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t4), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t4);
      }
      this.cached = e9, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e9) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e9);
    }
  }
  async batchSubscribe(e9) {
    e9.length && (await this.rpcBatchSubscribe(e9), this.onBatchSubscribe(await Promise.all(e9.map(async (t4) => He3(ge2({}, t4), { id: await this.getSubscriptionId(t4.topic) })))));
  }
  async batchFetchMessages(e9) {
    if (!e9.length) return;
    this.logger.trace(`Fetching batch messages for ${e9.length} subscriptions`);
    const t4 = await this.rpcBatchFetchMessages(e9);
    t4 && t4.messages && (await pi((0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t4.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
  async restartToComplete(e9) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e9), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e9) {
    return zc(e9 + await this.getClientId());
  }
};
var to3 = Object.defineProperty;
var Pi3 = Object.getOwnPropertySymbols;
var io3 = Object.prototype.hasOwnProperty;
var so3 = Object.prototype.propertyIsEnumerable;
var Ye2 = (r6, e9, t4) => e9 in r6 ? to3(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var Si3 = (r6, e9) => {
  for (var t4 in e9 || (e9 = {})) io3.call(e9, t4) && Ye2(r6, t4, e9[t4]);
  if (Pi3) for (var t4 of Pi3(e9)) so3.call(e9, t4) && Ye2(r6, t4, e9[t4]);
  return r6;
};
var y3 = (r6, e9, t4) => Ye2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Oi3 = class extends d {
  constructor(e9) {
    super(e9), y3(this, "protocol", "wc"), y3(this, "version", 2), y3(this, "core"), y3(this, "logger"), y3(this, "events", new import_events3.EventEmitter()), y3(this, "provider"), y3(this, "messages"), y3(this, "subscriber"), y3(this, "publisher"), y3(this, "name", $t3), y3(this, "transportExplicitlyClosed", false), y3(this, "initialized", false), y3(this, "connectionAttemptInProgress", false), y3(this, "relayUrl"), y3(this, "projectId"), y3(this, "packageName"), y3(this, "bundleId"), y3(this, "hasExperiencedNetworkDisruption", false), y3(this, "pingTimeout"), y3(this, "heartBeatTimeout", (0, import_time3.toMiliseconds)(import_time3.THIRTY_SECONDS + import_time3.FIVE_SECONDS)), y3(this, "reconnectTimeout"), y3(this, "connectPromise"), y3(this, "reconnectInProgress", false), y3(this, "requestsInFlight", []), y3(this, "connectTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), y3(this, "request", async (t4) => {
      var i6, s3;
      this.logger.debug("Publishing Request Payload");
      const n4 = t4.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n4, method: t4.method, topic: (i6 = t4.params) == null ? void 0 : i6.topic }, "relayer.request - publishing...");
        const o4 = `${n4}:${((s3 = t4.params) == null ? void 0 : s3.tag) || ""}`;
        this.requestsInFlight.push(o4);
        const a4 = await this.provider.request(t4);
        return this.requestsInFlight = this.requestsInFlight.filter((c6) => c6 !== o4), a4;
      } catch (o4) {
        throw this.logger.debug(`Failed to Publish Request: ${n4}`), o4;
      }
    }), y3(this, "resetPingTimeout", () => {
      Ye() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t4, i6, s3, n4;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n4 = (s3 = (i6 = (t4 = this.provider) == null ? void 0 : t4.connection) == null ? void 0 : i6.socket) == null ? void 0 : s3.terminate) == null || n4.call(s3);
        } catch (o4) {
          this.logger.warn(o4, o4?.message);
        }
      }, this.heartBeatTimeout));
    }), y3(this, "onPayloadHandler", (t4) => {
      this.onProviderPayload(t4), this.resetPingTimeout();
    }), y3(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C2.connect);
    }), y3(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y3(this, "onProviderErrorHandler", (t4) => {
      this.logger.fatal(`Fatal socket error: ${t4.message}`), this.events.emit(C2.error, t4), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y3(this, "registerProviderListeners", () => {
      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);
    }), this.core = e9.core, this.logger = typeof e9.logger < "u" && typeof e9.logger != "string" ? E(e9.logger, this.name) : (0, import_pino.default)(k({ level: e9.logger || Nt3 })), this.messages = new Ei3(this.logger, e9.core), this.subscriber = new Ci3(this, this.logger), this.publisher = new Gn(this, this.logger), this.relayUrl = e9?.relayUrl || Ue3, this.projectId = e9.projectId, Ms() ? this.packageName = qs() : Vs() && (this.bundleId = qs()), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e9) => this.logger.warn(e9, e9?.message));
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e9, t4, i6;
    return ((i6 = (t4 = (e9 = this.provider) == null ? void 0 : e9.connection) == null ? void 0 : t4.socket) == null ? void 0 : i6.readyState) === 1 || false;
  }
  get connecting() {
    var e9, t4, i6;
    return ((i6 = (t4 = (e9 = this.provider) == null ? void 0 : e9.connection) == null ? void 0 : t4.socket) == null ? void 0 : i6.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e9, t4, i6) {
    this.isInitialized(), await this.publisher.publish(e9, t4, i6), await this.recordMessageEvent({ topic: e9, message: t4, publishedAt: Date.now(), transportType: Q3.relay }, le3.outbound);
  }
  async subscribe(e9, t4) {
    var i6, s3, n4;
    this.isInitialized(), (!(t4 != null && t4.transportType) || t4?.transportType === "relay") && await this.toEstablishConnection();
    const o4 = typeof ((i6 = t4?.internal) == null ? void 0 : i6.throwOnFailedPublish) > "u" ? true : (s3 = t4?.internal) == null ? void 0 : s3.throwOnFailedPublish;
    let a4 = ((n4 = this.subscriber.topicMap.get(e9)) == null ? void 0 : n4[0]) || "", c6;
    const h7 = (l6) => {
      l6.topic === e9 && (this.subscriber.off($.created, h7), c6());
    };
    return await Promise.all([new Promise((l6) => {
      c6 = l6, this.subscriber.on($.created, h7);
    }), new Promise(async (l6, d5) => {
      a4 = await this.subscriber.subscribe(e9, Si3({ internal: { throwOnFailedPublish: o4 } }, t4)).catch((g3) => {
        o4 && d5(g3);
      }) || a4, l6();
    })]), a4;
  }
  async unsubscribe(e9, t4) {
    this.isInitialized(), await this.subscriber.unsubscribe(e9, t4);
  }
  on(e9, t4) {
    this.events.on(e9, t4);
  }
  once(e9, t4) {
    this.events.once(e9, t4);
  }
  off(e9, t4) {
    this.events.off(e9, t4);
  }
  removeListener(e9, t4) {
    this.events.removeListener(e9, t4);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ni(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e9) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t4, i6) => {
      await this.connect(e9).then(t4).catch(i6).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e9) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e9 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await ja()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e9) {
    if (e9?.length === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t4 = e9.sort((i6, s3) => i6.publishedAt - s3.publishedAt);
    this.logger.debug(`Batch of ${t4.length} message events sorted`);
    for (const i6 of t4) try {
      await this.onMessageEvent(i6);
    } catch (s3) {
      this.logger.warn(s3, "Error while processing batch message event: " + s3?.message);
    }
    this.logger.trace(`Batch of ${t4.length} message events processed`);
  }
  async onLinkMessageEvent(e9, t4) {
    const { topic: i6 } = e9;
    if (!t4.sessionExists) {
      const s3 = ii(import_time3.FIVE_MINUTES), n4 = { topic: i6, expiry: s3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i6, n4);
    }
    this.events.emit(C2.message, e9), await this.recordMessageEvent(e9, le3.inbound);
  }
  async connect(e9) {
    await this.confirmOnlineStateOrThrow(), e9 && e9 !== this.relayUrl && (this.relayUrl = e9, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t4 = 1;
    for (; t4 < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t4}...`), await this.createProvider(), await new Promise(async (i6, s3) => {
          const n4 = () => {
            s3(new Error("Connection interrupted while trying to connect"));
          };
          this.provider.once(L.disconnect, n4), await ni(new Promise((o4, a4) => {
            this.provider.connect().then(o4).catch(a4);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o4) => {
            s3(o4);
          }).finally(() => {
            this.provider.off(L.disconnect, n4), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o4, a4) => {
            const c6 = () => {
              s3(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L.disconnect, c6), await this.subscriber.start().then(o4).catch(a4).finally(() => {
              this.provider.off(L.disconnect, c6);
            });
          }), this.hasExperiencedNetworkDisruption = false, i6();
        });
      } catch (i6) {
        await this.subscriber.stop();
        const s3 = i6;
        this.logger.warn({}, s3.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t4}`);
        break;
      }
      await new Promise((i6) => setTimeout(i6, (0, import_time3.toMiliseconds)(t4 * 1))), t4++;
    }
  }
  startPingTimeout() {
    var e9, t4, i6, s3, n4;
    if (Ye()) try {
      (t4 = (e9 = this.provider) == null ? void 0 : e9.connection) != null && t4.socket && ((n4 = (s3 = (i6 = this.provider) == null ? void 0 : i6.connection) == null ? void 0 : s3.socket) == null || n4.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o4) {
      this.logger.warn(o4, o4?.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e9 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(zs({ sdkVersion: _e3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e9, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e9, t4) {
    const { topic: i6, message: s3 } = e9;
    await this.messages.set(i6, s3, t4);
  }
  async shouldIgnoreMessageEvent(e9) {
    const { topic: t4, message: i6 } = e9;
    if (!i6 || i6.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i6}`), true;
    if (!await this.subscriber.isKnownTopic(t4)) return this.logger.warn(`Ignoring message for unknown topic ${t4}`), true;
    const s3 = this.messages.has(t4, i6);
    return s3 && this.logger.warn(`Ignoring duplicate message: ${i6}`), s3;
  }
  async onProviderPayload(e9) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e9 }), isJsonRpcRequest(e9)) {
      if (!e9.method.endsWith(zt2)) return;
      const t4 = e9.params, { topic: i6, message: s3, publishedAt: n4, attestation: o4 } = t4.data, a4 = { topic: i6, message: s3, publishedAt: n4, transportType: Q3.relay, attestation: o4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Si3({ type: "event", event: t4.id }, a4)), this.events.emit(t4.id, a4), await this.acknowledgePayload(e9), await this.onMessageEvent(a4);
    } else isJsonRpcResponse(e9) && this.events.emit(C2.message_ack, e9);
  }
  async onMessageEvent(e9) {
    await this.shouldIgnoreMessageEvent(e9) || (await this.recordMessageEvent(e9, le3.inbound), this.events.emit(C2.message, e9));
  }
  async acknowledgePayload(e9) {
    const t4 = formatJsonRpcResult(e9.id, true);
    await this.provider.connection.send(t4);
  }
  unregisterProviderListeners() {
    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e9 = await ja();
    ka(async (t4) => {
      e9 !== t4 && (e9 = t4, t4 ? await this.transportOpen().catch((i6) => this.logger.error(i6, i6?.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && Pa()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t4) {
        this.logger.warn(t4, t4?.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C2.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e9) => this.logger.error(e9, e9?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time3.toMiliseconds)(Lt2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function ro3(r6, e9) {
  return r6 === e9 || Number.isNaN(r6) && Number.isNaN(e9);
}
function Ri3(r6) {
  return Object.getOwnPropertySymbols(r6).filter((e9) => Object.prototype.propertyIsEnumerable.call(r6, e9));
}
function Ai3(r6) {
  return r6 == null ? r6 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r6);
}
var no3 = "[object RegExp]";
var oo3 = "[object String]";
var ao3 = "[object Number]";
var co3 = "[object Boolean]";
var xi3 = "[object Arguments]";
var ho3 = "[object Symbol]";
var lo3 = "[object Date]";
var uo3 = "[object Map]";
var go3 = "[object Set]";
var po3 = "[object Array]";
var yo3 = "[object Function]";
var bo3 = "[object ArrayBuffer]";
var Je = "[object Object]";
var mo3 = "[object Error]";
var fo3 = "[object DataView]";
var Do2 = "[object Uint8Array]";
var vo3 = "[object Uint8ClampedArray]";
var wo3 = "[object Uint16Array]";
var _o3 = "[object Uint32Array]";
var Eo3 = "[object BigUint64Array]";
var Io3 = "[object Int8Array]";
var To3 = "[object Int16Array]";
var Co3 = "[object Int32Array]";
var Po3 = "[object BigInt64Array]";
var So3 = "[object Float32Array]";
var Oo3 = "[object Float64Array]";
function Ro3() {
}
function Ni3(r6) {
  if (!r6 || typeof r6 != "object") return false;
  const e9 = Object.getPrototypeOf(r6);
  return e9 === null || e9 === Object.prototype || Object.getPrototypeOf(e9) === null ? Object.prototype.toString.call(r6) === "[object Object]" : false;
}
function Ao3(r6, e9, t4) {
  return pe3(r6, e9, void 0, void 0, void 0, void 0, t4);
}
function pe3(r6, e9, t4, i6, s3, n4, o4) {
  const a4 = o4(r6, e9, t4, i6, s3, n4);
  if (a4 !== void 0) return a4;
  if (typeof r6 == typeof e9) switch (typeof r6) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r6 === e9;
    case "number":
      return r6 === e9 || Object.is(r6, e9);
    case "function":
      return r6 === e9;
    case "object":
      return ye2(r6, e9, n4, o4);
  }
  return ye2(r6, e9, n4, o4);
}
function ye2(r6, e9, t4, i6) {
  if (Object.is(r6, e9)) return true;
  let s3 = Ai3(r6), n4 = Ai3(e9);
  if (s3 === xi3 && (s3 = Je), n4 === xi3 && (n4 = Je), s3 !== n4) return false;
  switch (s3) {
    case oo3:
      return r6.toString() === e9.toString();
    case ao3: {
      const c6 = r6.valueOf(), h7 = e9.valueOf();
      return ro3(c6, h7);
    }
    case co3:
    case lo3:
    case ho3:
      return Object.is(r6.valueOf(), e9.valueOf());
    case no3:
      return r6.source === e9.source && r6.flags === e9.flags;
    case yo3:
      return r6 === e9;
  }
  t4 = t4 ?? /* @__PURE__ */ new Map();
  const o4 = t4.get(r6), a4 = t4.get(e9);
  if (o4 != null && a4 != null) return o4 === e9;
  t4.set(r6, e9), t4.set(e9, r6);
  try {
    switch (s3) {
      case uo3: {
        if (r6.size !== e9.size) return false;
        for (const [c6, h7] of r6.entries()) if (!e9.has(c6) || !pe3(h7, e9.get(c6), c6, r6, e9, t4, i6)) return false;
        return true;
      }
      case go3: {
        if (r6.size !== e9.size) return false;
        const c6 = Array.from(r6.values()), h7 = Array.from(e9.values());
        for (let l6 = 0; l6 < c6.length; l6++) {
          const d5 = c6[l6], g3 = h7.findIndex((_4) => pe3(d5, _4, void 0, r6, e9, t4, i6));
          if (g3 === -1) return false;
          h7.splice(g3, 1);
        }
        return true;
      }
      case po3:
      case Do2:
      case vo3:
      case wo3:
      case _o3:
      case Eo3:
      case Io3:
      case To3:
      case Co3:
      case Po3:
      case So3:
      case Oo3: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r6) !== Buffer.isBuffer(e9) || r6.length !== e9.length) return false;
        for (let c6 = 0; c6 < r6.length; c6++) if (!pe3(r6[c6], e9[c6], c6, r6, e9, t4, i6)) return false;
        return true;
      }
      case bo3:
        return r6.byteLength !== e9.byteLength ? false : ye2(new Uint8Array(r6), new Uint8Array(e9), t4, i6);
      case fo3:
        return r6.byteLength !== e9.byteLength || r6.byteOffset !== e9.byteOffset ? false : ye2(new Uint8Array(r6), new Uint8Array(e9), t4, i6);
      case mo3:
        return r6.name === e9.name && r6.message === e9.message;
      case Je: {
        if (!(ye2(r6.constructor, e9.constructor, t4, i6) || Ni3(r6) && Ni3(e9))) return false;
        const h7 = [...Object.keys(r6), ...Ri3(r6)], l6 = [...Object.keys(e9), ...Ri3(e9)];
        if (h7.length !== l6.length) return false;
        for (let d5 = 0; d5 < h7.length; d5++) {
          const g3 = h7[d5], _4 = r6[g3];
          if (!Object.hasOwn(e9, g3)) return false;
          const u6 = e9[g3];
          if (!pe3(_4, u6, g3, r6, e9, t4, i6)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t4.delete(r6), t4.delete(e9);
  }
}
function xo3(r6, e9) {
  return Ao3(r6, e9, Ro3);
}
var No3 = Object.defineProperty;
var $i3 = Object.getOwnPropertySymbols;
var $o3 = Object.prototype.hasOwnProperty;
var zo2 = Object.prototype.propertyIsEnumerable;
var Xe2 = (r6, e9, t4) => e9 in r6 ? No3(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var zi3 = (r6, e9) => {
  for (var t4 in e9 || (e9 = {})) $o3.call(e9, t4) && Xe2(r6, t4, e9[t4]);
  if ($i3) for (var t4 of $i3(e9)) zo2.call(e9, t4) && Xe2(r6, t4, e9[t4]);
  return r6;
};
var z = (r6, e9, t4) => Xe2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Li3 = class extends f3 {
  constructor(e9, t4, i6, s3 = B, n4 = void 0) {
    super(e9, t4, i6, s3), this.core = e9, this.logger = t4, this.name = i6, z(this, "map", /* @__PURE__ */ new Map()), z(this, "version", kt2), z(this, "cached", []), z(this, "initialized", false), z(this, "getKey"), z(this, "storagePrefix", B), z(this, "recentlyDeleted", []), z(this, "recentlyDeletedLimit", 200), z(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o4) => {
        this.getKey && o4 !== null && !kt(o4) ? this.map.set(this.getKey(o4), o4) : wa(o4) ? this.map.set(o4.id, o4) : xa(o4) && this.map.set(o4.topic, o4);
      }), this.cached = [], this.initialized = true);
    }), z(this, "set", async (o4, a4) => {
      this.isInitialized(), this.map.has(o4) ? await this.update(o4, a4) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o4, value: a4 }), this.map.set(o4, a4), await this.persist());
    }), z(this, "get", (o4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o4 }), this.getData(o4))), z(this, "getAll", (o4) => (this.isInitialized(), o4 ? this.values.filter((a4) => Object.keys(o4).every((c6) => xo3(a4[c6], o4[c6]))) : this.values)), z(this, "update", async (o4, a4) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o4, update: a4 });
      const c6 = zi3(zi3({}, this.getData(o4)), a4);
      this.map.set(o4, c6), await this.persist();
    }), z(this, "delete", async (o4, a4) => {
      this.isInitialized(), this.map.has(o4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o4, reason: a4 }), this.map.delete(o4), this.addToRecentlyDeleted(o4), await this.persist());
    }), this.logger = E(t4, this.name), this.storagePrefix = s3, this.getKey = n4;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e9) {
    this.recentlyDeleted.push(e9), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e9) {
    await this.core.storage.setItem(this.storageKey, e9);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e9) {
    const t4 = this.map.get(e9);
    if (!t4) {
      if (this.recentlyDeleted.includes(e9)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e9}`);
        throw this.logger.error(s3), new Error(s3);
      }
      const { message: i6 } = Et("NO_MATCHING_KEY", `${this.name}: ${e9}`);
      throw this.logger.error(i6), new Error(i6);
    }
    return t4;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e9 = await this.getDataStore();
      if (typeof e9 > "u" || !e9.length) return;
      if (this.map.size) {
        const { message: t4 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t4), new Error(t4);
      }
      this.cached = e9, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e9) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e9);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
};
var Lo3 = Object.defineProperty;
var ko2 = (r6, e9, t4) => e9 in r6 ? Lo3(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var p2 = (r6, e9, t4) => ko2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var ki3 = class {
  constructor(e9, t4) {
    this.core = e9, this.logger = t4, p2(this, "name", Mt3), p2(this, "version", Kt3), p2(this, "events", new import_events3.default()), p2(this, "pairings"), p2(this, "initialized", false), p2(this, "storagePrefix", B), p2(this, "ignoredPayloadTypes", [ee]), p2(this, "registeredMethods", []), p2(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p2(this, "register", ({ methods: i6 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i6])];
    }), p2(this, "create", async (i6) => {
      this.isInitialized();
      const s3 = qc(), n4 = await this.core.crypto.setSymKey(s3), o4 = ii(import_time3.FIVE_MINUTES), a4 = { protocol: xt3 }, c6 = { topic: n4, expiry: o4, relay: a4, active: false, methods: i6?.methods }, h7 = oa({ protocol: this.core.protocol, version: this.core.version, topic: n4, symKey: s3, relay: a4, expiryTimestamp: o4, methods: i6?.methods });
      return this.events.emit(re.create, c6), this.core.expirer.set(n4, o4), await this.pairings.set(n4, c6), await this.core.relayer.subscribe(n4, { transportType: i6?.transportType }), { topic: n4, uri: h7 };
    }), p2(this, "pair", async (i6) => {
      this.isInitialized();
      const s3 = this.core.eventClient.createEvent({ properties: { topic: i6?.uri, trace: [G3.pairing_started] } });
      this.isValidPair(i6, s3);
      const { topic: n4, symKey: o4, relay: a4, expiryTimestamp: c6, methods: h7 } = ra(i6.uri);
      s3.props.properties.topic = n4, s3.addTrace(G3.pairing_uri_validation_success), s3.addTrace(G3.pairing_uri_not_expired);
      let l6;
      if (this.pairings.keys.includes(n4)) {
        if (l6 = this.pairings.get(n4), s3.addTrace(G3.existing_pairing), l6.active) throw s3.setError(Y3.active_pairing_already_exists), new Error(`Pairing already exists: ${n4}. Please try again with a new connection URI.`);
        s3.addTrace(G3.pairing_not_expired);
      }
      const d5 = c6 || ii(import_time3.FIVE_MINUTES), g3 = { topic: n4, relay: a4, expiry: d5, active: false, methods: h7 };
      this.core.expirer.set(n4, d5), await this.pairings.set(n4, g3), s3.addTrace(G3.store_new_pairing), i6.activatePairing && await this.activate({ topic: n4 }), this.events.emit(re.create, g3), s3.addTrace(G3.emit_inactive_pairing), this.core.crypto.keychain.has(n4) || await this.core.crypto.setSymKey(o4, n4), s3.addTrace(G3.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s3.setError(Y3.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n4, { relay: a4 });
      } catch (_4) {
        throw s3.setError(Y3.subscribe_pairing_topic_failure), _4;
      }
      return s3.addTrace(G3.subscribe_pairing_topic_success), g3;
    }), p2(this, "activate", async ({ topic: i6 }) => {
      this.isInitialized();
      const s3 = ii(import_time3.FIVE_MINUTES);
      this.core.expirer.set(i6, s3), await this.pairings.update(i6, { active: true, expiry: s3 });
    }), p2(this, "ping", async (i6) => {
      this.isInitialized(), await this.isValidPing(i6), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s3 } = i6;
      if (this.pairings.keys.includes(s3)) {
        const n4 = await this.sendRequest(s3, "wc_pairingPing", {}), { done: o4, resolve: a4, reject: c6 } = ei();
        this.events.once(ci("pairing_ping", n4), ({ error: h7 }) => {
          h7 ? c6(h7) : a4();
        }), await o4();
      }
    }), p2(this, "updateExpiry", async ({ topic: i6, expiry: s3 }) => {
      this.isInitialized(), await this.pairings.update(i6, { expiry: s3 });
    }), p2(this, "updateMetadata", async ({ topic: i6, metadata: s3 }) => {
      this.isInitialized(), await this.pairings.update(i6, { peerMetadata: s3 });
    }), p2(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p2(this, "disconnect", async (i6) => {
      this.isInitialized(), await this.isValidDisconnect(i6);
      const { topic: s3 } = i6;
      this.pairings.keys.includes(s3) && (await this.sendRequest(s3, "wc_pairingDelete", Kt2("USER_DISCONNECTED")), await this.deletePairing(s3));
    }), p2(this, "formatUriFromPairing", (i6) => {
      this.isInitialized();
      const { topic: s3, relay: n4, expiry: o4, methods: a4 } = i6, c6 = this.core.crypto.keychain.get(s3);
      return oa({ protocol: this.core.protocol, version: this.core.version, topic: s3, symKey: c6, relay: n4, expiryTimestamp: o4, methods: a4 });
    }), p2(this, "sendRequest", async (i6, s3, n4) => {
      const o4 = formatJsonRpcRequest(s3, n4), a4 = await this.core.crypto.encode(i6, o4), c6 = se3[s3].req;
      return this.core.history.set(i6, o4), this.core.relayer.publish(i6, a4, c6), o4.id;
    }), p2(this, "sendResult", async (i6, s3, n4) => {
      const o4 = formatJsonRpcResult(i6, n4), a4 = await this.core.crypto.encode(s3, o4), c6 = (await this.core.history.get(s3, i6)).request.method, h7 = se3[c6].res;
      await this.core.relayer.publish(s3, a4, h7), await this.core.history.resolve(o4);
    }), p2(this, "sendError", async (i6, s3, n4) => {
      const o4 = formatJsonRpcError(i6, n4), a4 = await this.core.crypto.encode(s3, o4), c6 = (await this.core.history.get(s3, i6)).request.method, h7 = se3[c6] ? se3[c6].res : se3.unregistered_method.res;
      await this.core.relayer.publish(s3, a4, h7), await this.core.history.resolve(o4);
    }), p2(this, "deletePairing", async (i6, s3) => {
      await this.core.relayer.unsubscribe(i6), await Promise.all([this.pairings.delete(i6, Kt2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i6), s3 ? Promise.resolve() : this.core.expirer.del(i6)]);
    }), p2(this, "cleanup", async () => {
      const i6 = this.pairings.getAll().filter((s3) => fi(s3.expiry));
      await Promise.all(i6.map((s3) => this.deletePairing(s3.topic)));
    }), p2(this, "onRelayEventRequest", async (i6) => {
      const { topic: s3, payload: n4 } = i6;
      switch (n4.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s3, n4);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s3, n4);
        default:
          return await this.onUnknownRpcMethodRequest(s3, n4);
      }
    }), p2(this, "onRelayEventResponse", async (i6) => {
      const { topic: s3, payload: n4 } = i6, o4 = (await this.core.history.get(s3, n4.id)).request.method;
      switch (o4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s3, n4);
        default:
          return this.onUnknownRpcMethodResponse(o4);
      }
    }), p2(this, "onPairingPingRequest", async (i6, s3) => {
      const { id: n4 } = s3;
      try {
        this.isValidPing({ topic: i6 }), await this.sendResult(n4, i6, true), this.events.emit(re.ping, { id: n4, topic: i6 });
      } catch (o4) {
        await this.sendError(n4, i6, o4), this.logger.error(o4);
      }
    }), p2(this, "onPairingPingResponse", (i6, s3) => {
      const { id: n4 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(ci("pairing_ping", n4), {}) : isJsonRpcError(s3) && this.events.emit(ci("pairing_ping", n4), { error: s3.error });
      }, 500);
    }), p2(this, "onPairingDeleteRequest", async (i6, s3) => {
      const { id: n4 } = s3;
      try {
        this.isValidDisconnect({ topic: i6 }), await this.deletePairing(i6), this.events.emit(re.delete, { id: n4, topic: i6 });
      } catch (o4) {
        await this.sendError(n4, i6, o4), this.logger.error(o4);
      }
    }), p2(this, "onUnknownRpcMethodRequest", async (i6, s3) => {
      const { id: n4, method: o4 } = s3;
      try {
        if (this.registeredMethods.includes(o4)) return;
        const a4 = Kt2("WC_METHOD_UNSUPPORTED", o4);
        await this.sendError(n4, i6, a4), this.logger.error(a4);
      } catch (a4) {
        await this.sendError(n4, i6, a4), this.logger.error(a4);
      }
    }), p2(this, "onUnknownRpcMethodResponse", (i6) => {
      this.registeredMethods.includes(i6) || this.logger.error(Kt2("WC_METHOD_UNSUPPORTED", i6));
    }), p2(this, "isValidPair", (i6, s3) => {
      var n4;
      if (!Aa(i6)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `pair() params: ${i6}`);
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a4);
      }
      if (!ma(i6.uri)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `pair() uri: ${i6.uri}`);
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a4);
      }
      const o4 = ra(i6?.uri);
      if (!((n4 = o4?.relay) != null && n4.protocol)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a4);
      }
      if (!(o4 != null && o4.symKey)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s3.setError(Y3.malformed_pairing_uri), new Error(a4);
      }
      if (o4 != null && o4.expiryTimestamp && (0, import_time3.toMiliseconds)(o4?.expiryTimestamp) < Date.now()) {
        s3.setError(Y3.pairing_expired);
        const { message: a4 } = Et("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a4);
      }
    }), p2(this, "isValidPing", async (i6) => {
      if (!Aa(i6)) {
        const { message: n4 } = Et("MISSING_OR_INVALID", `ping() params: ${i6}`);
        throw new Error(n4);
      }
      const { topic: s3 } = i6;
      await this.isValidPairingTopic(s3);
    }), p2(this, "isValidDisconnect", async (i6) => {
      if (!Aa(i6)) {
        const { message: n4 } = Et("MISSING_OR_INVALID", `disconnect() params: ${i6}`);
        throw new Error(n4);
      }
      const { topic: s3 } = i6;
      await this.isValidPairingTopic(s3);
    }), p2(this, "isValidPairingTopic", async (i6) => {
      if (!it(i6, false)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${i6}`);
        throw new Error(s3);
      }
      if (!this.pairings.keys.includes(i6)) {
        const { message: s3 } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i6}`);
        throw new Error(s3);
      }
      if (fi(this.pairings.get(i6).expiry)) {
        await this.deletePairing(i6);
        const { message: s3 } = Et("EXPIRED", `pairing topic: ${i6}`);
        throw new Error(s3);
      }
    }), this.core = e9, this.logger = E(t4, this.name), this.pairings = new Li3(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C2.message, async (e9) => {
      const { topic: t4, message: i6, transportType: s3 } = e9;
      if (this.pairings.keys.includes(t4) && s3 !== Q3.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i6))) try {
        const n4 = await this.core.crypto.decode(t4, i6);
        isJsonRpcRequest(n4) ? (this.core.history.set(t4, n4), await this.onRelayEventRequest({ topic: t4, payload: n4 })) : isJsonRpcResponse(n4) && (await this.core.history.resolve(n4), await this.onRelayEventResponse({ topic: t4, payload: n4 }), this.core.history.delete(t4, n4.id)), await this.core.relayer.messages.ack(t4, i6);
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M2.expired, async (e9) => {
      const { topic: t4 } = si(e9.target);
      t4 && this.pairings.keys.includes(t4) && (await this.deletePairing(t4, true), this.events.emit(re.expire, { topic: t4 }));
    });
  }
};
var jo2 = Object.defineProperty;
var Uo3 = (r6, e9, t4) => e9 in r6 ? jo2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var O2 = (r6, e9, t4) => Uo3(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var ji3 = class extends I {
  constructor(e9, t4) {
    super(e9, t4), this.core = e9, this.logger = t4, O2(this, "records", /* @__PURE__ */ new Map()), O2(this, "events", new import_events3.EventEmitter()), O2(this, "name", Bt2), O2(this, "version", Vt2), O2(this, "cached", []), O2(this, "initialized", false), O2(this, "storagePrefix", B), O2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i6) => this.records.set(i6.id, i6)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), O2(this, "set", (i6, s3, n4) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i6, request: s3, chainId: n4 }), this.records.has(s3.id)) return;
      const o4 = { id: s3.id, topic: i6, request: { method: s3.method, params: s3.params || null }, chainId: n4, expiry: ii(import_time3.THIRTY_DAYS) };
      this.records.set(o4.id, o4), this.persist(), this.events.emit(F3.created, o4);
    }), O2(this, "resolve", async (i6) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i6 }), !this.records.has(i6.id)) return;
      const s3 = await this.getRecord(i6.id);
      typeof s3.response > "u" && (s3.response = isJsonRpcError(i6) ? { error: i6.error } : { result: i6.result }, this.records.set(s3.id, s3), this.persist(), this.events.emit(F3.updated, s3));
    }), O2(this, "get", async (i6, s3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i6, id: s3 }), await this.getRecord(s3))), O2(this, "delete", (i6, s3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s3 }), this.values.forEach((n4) => {
        if (n4.topic === i6) {
          if (typeof s3 < "u" && n4.id !== s3) return;
          this.records.delete(n4.id), this.events.emit(F3.deleted, n4);
        }
      }), this.persist();
    }), O2(this, "exists", async (i6, s3) => (this.isInitialized(), this.records.has(s3) ? (await this.getRecord(s3)).topic === i6 : false)), O2(this, "on", (i6, s3) => {
      this.events.on(i6, s3);
    }), O2(this, "once", (i6, s3) => {
      this.events.once(i6, s3);
    }), O2(this, "off", (i6, s3) => {
      this.events.off(i6, s3);
    }), O2(this, "removeListener", (i6, s3) => {
      this.events.removeListener(i6, s3);
    }), this.logger = E(t4, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e9 = [];
    return this.values.forEach((t4) => {
      if (typeof t4.response < "u") return;
      const i6 = { topic: t4.topic, request: formatJsonRpcRequest(t4.request.method, t4.request.params, t4.id), chainId: t4.chainId };
      return e9.push(i6);
    }), e9;
  }
  async setJsonRpcRecords(e9) {
    await this.core.storage.setItem(this.storageKey, e9);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e9) {
    this.isInitialized();
    const t4 = this.records.get(e9);
    if (!t4) {
      const { message: i6 } = Et("NO_MATCHING_KEY", `${this.name}: ${e9}`);
      throw new Error(i6);
    }
    return t4;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F3.sync);
  }
  async restore() {
    try {
      const e9 = await this.getJsonRpcRecords();
      if (typeof e9 > "u" || !e9.length) return;
      if (this.records.size) {
        const { message: t4 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t4), new Error(t4);
      }
      this.cached = e9, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e9) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e9);
    }
  }
  registerEventListeners() {
    this.events.on(F3.created, (e9) => {
      const t4 = F3.created;
      this.logger.info(`Emitting ${t4}`), this.logger.debug({ type: "event", event: t4, record: e9 });
    }), this.events.on(F3.updated, (e9) => {
      const t4 = F3.updated;
      this.logger.info(`Emitting ${t4}`), this.logger.debug({ type: "event", event: t4, record: e9 });
    }), this.events.on(F3.deleted, (e9) => {
      const t4 = F3.deleted;
      this.logger.info(`Emitting ${t4}`), this.logger.debug({ type: "event", event: t4, record: e9 });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e9 = false;
      this.records.forEach((t4) => {
        (0, import_time3.toMiliseconds)(t4.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t4.id}`), this.records.delete(t4.id), this.events.emit(F3.deleted, t4, false), e9 = true);
      }), e9 && this.persist();
    } catch (e9) {
      this.logger.warn(e9);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
};
var Fo2 = Object.defineProperty;
var Mo2 = (r6, e9, t4) => e9 in r6 ? Fo2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var A2 = (r6, e9, t4) => Mo2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Ui3 = class extends S {
  constructor(e9, t4) {
    super(e9, t4), this.core = e9, this.logger = t4, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events3.EventEmitter()), A2(this, "name", qt2), A2(this, "version", Gt3), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B), A2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i6) => this.expirations.set(i6.target, i6)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A2(this, "has", (i6) => {
      try {
        const s3 = this.formatTarget(i6);
        return typeof this.getExpiration(s3) < "u";
      } catch {
        return false;
      }
    }), A2(this, "set", (i6, s3) => {
      this.isInitialized();
      const n4 = this.formatTarget(i6), o4 = { target: n4, expiry: s3 };
      this.expirations.set(n4, o4), this.checkExpiry(n4, o4), this.events.emit(M2.created, { target: n4, expiration: o4 });
    }), A2(this, "get", (i6) => {
      this.isInitialized();
      const s3 = this.formatTarget(i6);
      return this.getExpiration(s3);
    }), A2(this, "del", (i6) => {
      if (this.isInitialized(), this.has(i6)) {
        const s3 = this.formatTarget(i6), n4 = this.getExpiration(s3);
        this.expirations.delete(s3), this.events.emit(M2.deleted, { target: s3, expiration: n4 });
      }
    }), A2(this, "on", (i6, s3) => {
      this.events.on(i6, s3);
    }), A2(this, "once", (i6, s3) => {
      this.events.once(i6, s3);
    }), A2(this, "off", (i6, s3) => {
      this.events.off(i6, s3);
    }), A2(this, "removeListener", (i6, s3) => {
      this.events.removeListener(i6, s3);
    }), this.logger = E(t4, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e9) {
    if (typeof e9 == "string") return ri(e9);
    if (typeof e9 == "number") return oi(e9);
    const { message: t4 } = Et("UNKNOWN_TYPE", `Target type: ${typeof e9}`);
    throw new Error(t4);
  }
  async setExpirations(e9) {
    await this.core.storage.setItem(this.storageKey, e9);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M2.sync);
  }
  async restore() {
    try {
      const e9 = await this.getExpirations();
      if (typeof e9 > "u" || !e9.length) return;
      if (this.expirations.size) {
        const { message: t4 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t4), new Error(t4);
      }
      this.cached = e9, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e9) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e9);
    }
  }
  getExpiration(e9) {
    const t4 = this.expirations.get(e9);
    if (!t4) {
      const { message: i6 } = Et("NO_MATCHING_KEY", `${this.name}: ${e9}`);
      throw this.logger.warn(i6), new Error(i6);
    }
    return t4;
  }
  checkExpiry(e9, t4) {
    const { expiry: i6 } = t4;
    (0, import_time3.toMiliseconds)(i6) - Date.now() <= 0 && this.expire(e9, t4);
  }
  expire(e9, t4) {
    this.expirations.delete(e9), this.events.emit(M2.expired, { target: e9, expiration: t4 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e9, t4) => this.checkExpiry(t4, e9));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M2.created, (e9) => {
      const t4 = M2.created;
      this.logger.info(`Emitting ${t4}`), this.logger.debug({ type: "event", event: t4, data: e9 }), this.persist();
    }), this.events.on(M2.expired, (e9) => {
      const t4 = M2.expired;
      this.logger.info(`Emitting ${t4}`), this.logger.debug({ type: "event", event: t4, data: e9 }), this.persist();
    }), this.events.on(M2.deleted, (e9) => {
      const t4 = M2.deleted;
      this.logger.info(`Emitting ${t4}`), this.logger.debug({ type: "event", event: t4, data: e9 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e9 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e9);
    }
  }
};
var Ko2 = Object.defineProperty;
var Bo3 = (r6, e9, t4) => e9 in r6 ? Ko2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var w = (r6, e9, t4) => Bo3(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Fi3 = class extends M {
  constructor(e9, t4, i6) {
    super(e9, t4, i6), this.core = e9, this.logger = t4, this.store = i6, w(this, "name", Wt3), w(this, "abortController"), w(this, "isDevEnv"), w(this, "verifyUrlV3", Yt3), w(this, "storagePrefix", B), w(this, "version", Le3), w(this, "publicKey"), w(this, "fetchPromise"), w(this, "init", async () => {
      var s3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time3.toMiliseconds)((s3 = this.publicKey) == null ? void 0 : s3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w(this, "register", async (s3) => {
      if (!zt() || this.isDevEnv) return;
      const n4 = window.location.origin, { id: o4, decryptedId: a4 } = s3, c6 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n4}&id=${o4}&decryptedId=${a4}`;
      try {
        const h7 = (0, import_window_getters3.getDocument)(), l6 = this.startAbortTimer(import_time3.ONE_SECOND * 5), d5 = await new Promise((g3, _4) => {
          const u6 = () => {
            window.removeEventListener("message", x5), h7.body.removeChild(b5), _4("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u6);
          const b5 = h7.createElement("iframe");
          b5.src = c6, b5.style.display = "none", b5.addEventListener("error", u6, { signal: this.abortController.signal });
          const x5 = (I7) => {
            if (I7.data && typeof I7.data == "string") try {
              const D9 = JSON.parse(I7.data);
              if (D9.type === "verify_attestation") {
                if (sn(D9.attestation).payload.id !== o4) return;
                clearInterval(l6), h7.body.removeChild(b5), this.abortController.signal.removeEventListener("abort", u6), window.removeEventListener("message", x5), g3(D9.attestation === null ? "" : D9.attestation);
              }
            } catch (D9) {
              this.logger.warn(D9);
            }
          };
          h7.body.appendChild(b5), window.addEventListener("message", x5, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d5), d5;
      } catch (h7) {
        this.logger.warn(h7);
      }
      return "";
    }), w(this, "resolve", async (s3) => {
      if (this.isDevEnv) return "";
      const { attestationId: n4, hash: o4, encryptedId: a4 } = s3;
      if (n4 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n4) {
        if (sn(n4).payload.id !== a4) return;
        const h7 = await this.isValidJwtAttestation(n4);
        if (h7) {
          if (!h7.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h7;
        }
      }
      if (!o4) return;
      const c6 = this.getVerifyUrl(s3?.verifyUrl);
      return this.fetchAttestation(o4, c6);
    }), w(this, "fetchAttestation", async (s3, n4) => {
      this.logger.debug(`resolving attestation: ${s3} from url: ${n4}`);
      const o4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), a4 = await fetch(`${n4}/attestation/${s3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o4), a4.status === 200 ? await a4.json() : void 0;
    }), w(this, "getVerifyUrl", (s3) => {
      let n4 = s3 || ue3;
      return Jt3.includes(n4) || (this.logger.info(`verify url: ${n4}, not included in trusted list, assigning default: ${ue3}`), n4 = ue3), n4;
    }), w(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s3 = this.startAbortTimer(import_time3.FIVE_SECONDS), n4 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s3), await n4.json();
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), w(this, "persistPublicKey", async (s3) => {
      this.logger.debug("persisting public key to local storage", s3), await this.store.setItem(this.storeKey, s3), this.publicKey = s3;
    }), w(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w(this, "isValidJwtAttestation", async (s3) => {
      const n4 = await this.getPublicKey();
      try {
        if (n4) return this.validateAttestation(s3, n4);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
      const o4 = await this.fetchAndPersistPublicKey();
      try {
        if (o4) return this.validateAttestation(s3, o4);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
    }), w(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n4) => {
        const o4 = await this.fetchPublicKey();
        o4 && (await this.persistPublicKey(o4), n4(o4));
      });
      const s3 = await this.fetchPromise;
      return this.fetchPromise = void 0, s3;
    }), w(this, "validateAttestation", (s3, n4) => {
      const o4 = ta(s3, n4.publicKey), a4 = { hasExpired: (0, import_time3.toMiliseconds)(o4.exp) < Date.now(), payload: o4 };
      if (a4.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a4.payload.origin, isScam: a4.payload.isScam, isVerified: a4.payload.isVerified };
    }), this.logger = E(t4, this.name), this.abortController = new AbortController(), this.isDevEnv = hi(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e9) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e9));
  }
};
var Vo2 = Object.defineProperty;
var qo2 = (r6, e9, t4) => e9 in r6 ? Vo2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var Mi3 = (r6, e9, t4) => qo2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Ki3 = class extends O {
  constructor(e9, t4) {
    super(e9, t4), this.projectId = e9, this.logger = t4, Mi3(this, "context", Xt3), Mi3(this, "registerDeviceToken", async (i6) => {
      const { clientId: s3, token: n4, notificationType: o4, enableEncrypted: a4 = false } = i6, c6 = `${Zt3}/${this.projectId}/clients`;
      await fetch(c6, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s3, type: o4, token: n4, always_raw: a4 }) });
    }), this.logger = E(t4, this.context);
  }
};
var Go2 = Object.defineProperty;
var Bi3 = Object.getOwnPropertySymbols;
var Wo2 = Object.prototype.hasOwnProperty;
var Ho2 = Object.prototype.propertyIsEnumerable;
var Ze2 = (r6, e9, t4) => e9 in r6 ? Go2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var be2 = (r6, e9) => {
  for (var t4 in e9 || (e9 = {})) Wo2.call(e9, t4) && Ze2(r6, t4, e9[t4]);
  if (Bi3) for (var t4 of Bi3(e9)) Ho2.call(e9, t4) && Ze2(r6, t4, e9[t4]);
  return r6;
};
var E2 = (r6, e9, t4) => Ze2(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Vi3 = class extends R {
  constructor(e9, t4, i6 = true) {
    super(e9, t4, i6), this.core = e9, this.logger = t4, E2(this, "context", ei2), E2(this, "storagePrefix", B), E2(this, "storageVersion", Qt2), E2(this, "events", /* @__PURE__ */ new Map()), E2(this, "shouldPersist", false), E2(this, "init", async () => {
      if (!hi()) try {
        const s3 = { eventId: di(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: cr(this.core.relayer.protocol, this.core.relayer.version, _e3) } } };
        await this.sendEvent([s3]);
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), E2(this, "createEvent", (s3) => {
      const { event: n4 = "ERROR", type: o4 = "", properties: { topic: a4, trace: c6 } } = s3, h7 = di(), l6 = this.core.projectId || "", d5 = Date.now(), g3 = be2({ eventId: h7, timestamp: d5, props: { event: n4, type: o4, properties: { topic: a4, trace: c6 } }, bundleId: l6, domain: this.getAppDomain() }, this.setMethods(h7));
      return this.telemetryEnabled && (this.events.set(h7, g3), this.shouldPersist = true), g3;
    }), E2(this, "getEvent", (s3) => {
      const { eventId: n4, topic: o4 } = s3;
      if (n4) return this.events.get(n4);
      const a4 = Array.from(this.events.values()).find((c6) => c6.props.properties.topic === o4);
      if (a4) return be2(be2({}, a4), this.setMethods(a4.eventId));
    }), E2(this, "deleteEvent", (s3) => {
      const { eventId: n4 } = s3;
      this.events.delete(n4), this.shouldPersist = true;
    }), E2(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s3) => {
          (0, import_time3.fromMiliseconds)(Date.now()) - (0, import_time3.fromMiliseconds)(s3.timestamp) > ti && (this.events.delete(s3.eventId), this.shouldPersist = true);
        });
      });
    }), E2(this, "setMethods", (s3) => ({ addTrace: (n4) => this.addTrace(s3, n4), setError: (n4) => this.setError(s3, n4) })), E2(this, "addTrace", (s3, n4) => {
      const o4 = this.events.get(s3);
      o4 && (o4.props.properties.trace.push(n4), this.events.set(s3, o4), this.shouldPersist = true);
    }), E2(this, "setError", (s3, n4) => {
      const o4 = this.events.get(s3);
      o4 && (o4.props.type = n4, o4.timestamp = Date.now(), this.events.set(s3, o4), this.shouldPersist = true);
    }), E2(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E2(this, "restore", async () => {
      try {
        const s3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s3.length) return;
        s3.forEach((n4) => {
          this.events.set(n4.eventId, be2(be2({}, n4), this.setMethods(n4.eventId)));
        });
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), E2(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s3 = [];
      for (const [n4, o4] of this.events) o4.props.type && s3.push(o4);
      if (s3.length !== 0) try {
        if ((await this.sendEvent(s3)).ok) for (const n4 of s3) this.events.delete(n4.eventId), this.shouldPersist = true;
      } catch (n4) {
        this.logger.warn(n4);
      }
    }), E2(this, "sendEvent", async (s3) => {
      const n4 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e3}${n4}`, { method: "POST", body: JSON.stringify(s3) });
    }), E2(this, "getAppDomain", () => sr().url), this.logger = E(t4, this.context), this.telemetryEnabled = i6, i6 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Yo2 = Object.defineProperty;
var qi3 = Object.getOwnPropertySymbols;
var Jo3 = Object.prototype.hasOwnProperty;
var Xo2 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r6, e9, t4) => e9 in r6 ? Yo2(r6, e9, { enumerable: true, configurable: true, writable: true, value: t4 }) : r6[e9] = t4;
var Gi3 = (r6, e9) => {
  for (var t4 in e9 || (e9 = {})) Jo3.call(e9, t4) && Qe3(r6, t4, e9[t4]);
  if (qi3) for (var t4 of qi3(e9)) Xo2.call(e9, t4) && Qe3(r6, t4, e9[t4]);
  return r6;
};
var v2 = (r6, e9, t4) => Qe3(r6, typeof e9 != "symbol" ? e9 + "" : e9, t4);
var Te2 = class _Te extends h2 {
  constructor(e9) {
    var t4;
    super(e9), v2(this, "protocol", ze), v2(this, "version", Le3), v2(this, "name", he3), v2(this, "relayUrl"), v2(this, "projectId"), v2(this, "customStoragePrefix"), v2(this, "events", new import_events3.EventEmitter()), v2(this, "logger"), v2(this, "heartbeat"), v2(this, "relayer"), v2(this, "crypto"), v2(this, "storage"), v2(this, "history"), v2(this, "expirer"), v2(this, "pairing"), v2(this, "verify"), v2(this, "echoClient"), v2(this, "linkModeSupportedApps"), v2(this, "eventClient"), v2(this, "initialized", false), v2(this, "logChunkController"), v2(this, "on", (a4, c6) => this.events.on(a4, c6)), v2(this, "once", (a4, c6) => this.events.once(a4, c6)), v2(this, "off", (a4, c6) => this.events.off(a4, c6)), v2(this, "removeListener", (a4, c6) => this.events.removeListener(a4, c6)), v2(this, "dispatchEnvelope", ({ topic: a4, message: c6, sessionExists: h7 }) => {
      if (!a4 || !c6) return;
      const l6 = { topic: a4, message: c6, publishedAt: Date.now(), transportType: Q3.link_mode };
      this.relayer.onLinkMessageEvent(l6, { sessionExists: h7 });
    });
    const i6 = this.getGlobalCore(e9?.customStoragePrefix);
    if (i6) try {
      return this.customStoragePrefix = i6.customStoragePrefix, this.logger = i6.logger, this.heartbeat = i6.heartbeat, this.crypto = i6.crypto, this.history = i6.history, this.expirer = i6.expirer, this.storage = i6.storage, this.relayer = i6.relayer, this.pairing = i6.pairing, this.verify = i6.verify, this.echoClient = i6.echoClient, this.linkModeSupportedApps = i6.linkModeSupportedApps, this.eventClient = i6.eventClient, this.initialized = i6.initialized, this.logChunkController = i6.logChunkController, i6;
    } catch (a4) {
      console.warn("Failed to copy global core", a4);
    }
    this.projectId = e9?.projectId, this.relayUrl = e9?.relayUrl || Ue3, this.customStoragePrefix = e9 != null && e9.customStoragePrefix ? `:${e9.customStoragePrefix}` : "";
    const s3 = k({ level: typeof e9?.logger == "string" && e9.logger ? e9.logger : Et2.logger, name: he3 }), { logger: n4, chunkLoggerController: o4 } = A({ opts: s3, maxSizeInBytes: e9?.maxLogBlobSizeInBytes, loggerOverride: e9?.logger });
    this.logChunkController = o4, (t4 = this.logChunkController) != null && t4.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a4, c6;
      (a4 = this.logChunkController) != null && a4.downloadLogsBlobInBrowser && ((c6 = this.logChunkController) == null || c6.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(n4, this.name), this.heartbeat = new i(), this.crypto = new wi3(this, this.logger, e9?.keychain), this.history = new ji3(this, this.logger), this.expirer = new Ui3(this, this.logger), this.storage = e9 != null && e9.storage ? e9.storage : new h(Gi3(Gi3({}, It2), e9?.storageOptions)), this.relayer = new Oi3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ki3(this, this.logger), this.verify = new Fi3(this, this.logger, this.storage), this.echoClient = new Ki3(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Vi3(this, this.logger, e9?.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e9) {
    const t4 = new _Te(e9);
    await t4.initialize();
    const i6 = await t4.crypto.getClientId();
    return await t4.storage.setItem(jt3, i6), t4;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e9;
    return (e9 = this.logChunkController) == null ? void 0 : e9.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e9) {
    this.linkModeSupportedApps.includes(e9) || (this.linkModeSupportedApps.push(e9), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e9) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e9), this.logger.error(e9.message), e9;
    }
  }
  getGlobalCore(e9 = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t4 = `_walletConnectCore_${e9}`, i6 = `${t4}_count`;
      return globalThis[i6] = (globalThis[i6] || 0) + 1, globalThis[i6] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i6]} times.`), globalThis[t4];
    } catch (t4) {
      console.warn("Failed to get global WalletConnect core", t4);
      return;
    }
  }
  setGlobalCore(e9) {
    var t4;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i6 = `_walletConnectCore_${((t4 = e9.opts) == null ? void 0 : t4.customStoragePrefix) || ""}`;
      globalThis[i6] = e9;
    } catch (i6) {
      console.warn("Failed to set global WalletConnect core", i6);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Zo2 = Te2;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
init_esm();
var Ce4 = "wc";
var ke4 = 2;
var De2 = "client";
var me3 = `${Ce4}@${ke4}:${De2}:`;
var we2 = { name: De2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Le4 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ht3 = "proposal";
var Me3 = "Proposal expired";
var dt3 = "session";
var X3 = import_time4.SEVEN_DAYS;
var ut3 = "engine";
var N3 = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time4.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time4.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e4 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var $2 = { idle: "IDLE", active: "ACTIVE" };
var gt3 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
var yt = "request";
var mt3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var wt3 = "wc";
var _t3 = "auth";
var Et3 = "authKeys";
var ft = "pairingTopics";
var St4 = "requests";
var ae3 = `${wt3}@${1.5}:${_t3}:`;
var ce3 = `${ae3}:PUB_KEY`;
var Os = Object.defineProperty;
var bs2 = Object.defineProperties;
var As = Object.getOwnPropertyDescriptors;
var Rt4 = Object.getOwnPropertySymbols;
var xs3 = Object.prototype.hasOwnProperty;
var Vs2 = Object.prototype.propertyIsEnumerable;
var $e3 = (S7, o4, t4) => o4 in S7 ? Os(S7, o4, { enumerable: true, configurable: true, writable: true, value: t4 }) : S7[o4] = t4;
var I2 = (S7, o4) => {
  for (var t4 in o4 || (o4 = {})) xs3.call(o4, t4) && $e3(S7, t4, o4[t4]);
  if (Rt4) for (var t4 of Rt4(o4)) Vs2.call(o4, t4) && $e3(S7, t4, o4[t4]);
  return S7;
};
var x = (S7, o4) => bs2(S7, As(o4));
var c2 = (S7, o4, t4) => $e3(S7, typeof o4 != "symbol" ? o4 + "" : o4, t4);
var Cs2 = class extends V {
  constructor(o4) {
    super(o4), c2(this, "name", ut3), c2(this, "events", new import_events4.default()), c2(this, "initialized", false), c2(this, "requestQueue", { state: $2.idle, queue: [] }), c2(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c2(this, "emittedSessionRequests", new gi({ limit: 500 })), c2(this, "requestQueueDelay", import_time4.ONE_SECOND), c2(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c2(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c2(this, "recentlyDeletedLimit", 200), c2(this, "relayMessageCache", []), c2(this, "pendingSessions", /* @__PURE__ */ new Map()), c2(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N3) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay)));
    }), c2(this, "connect", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const e9 = x(I2({}, t4), { requiredNamespaces: t4.requiredNamespaces || {}, optionalNamespaces: t4.optionalNamespaces || {} });
      await this.isValidConnect(e9), e9.optionalNamespaces = ba(e9.requiredNamespaces, e9.optionalNamespaces), e9.requiredNamespaces = {};
      const { pairingTopic: s3, requiredNamespaces: i6, optionalNamespaces: r6, sessionProperties: n4, scopedProperties: a4, relays: l6 } = e9;
      let p7 = s3, h7, u6 = false;
      try {
        if (p7) {
          const T6 = this.client.core.pairing.pairings.get(p7);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u6 = T6.active;
        }
      } catch (T6) {
        throw this.client.logger.error(`connect() -> pairing.get(${p7}) failed`), T6;
      }
      if (!p7 || !u6) {
        const { topic: T6, uri: K4 } = await this.client.core.pairing.create();
        p7 = T6, h7 = K4;
      }
      if (!p7) {
        const { message: T6 } = Et("NO_MATCHING_KEY", `connect() pairing topic: ${p7}`);
        throw new Error(T6);
      }
      const d5 = await this.client.core.crypto.generateKeyPair(), w6 = N3.wc_sessionPropose.req.ttl || import_time4.FIVE_MINUTES, m5 = ii(w6), y8 = x(I2(I2({ requiredNamespaces: i6, optionalNamespaces: r6, relays: l6 ?? [{ protocol: xt3 }], proposer: { publicKey: d5, metadata: this.client.metadata }, expiryTimestamp: m5, pairingTopic: p7 }, n4 && { sessionProperties: n4 }), a4 && { scopedProperties: a4 }), { id: payloadId() }), E7 = ci("session_connect", y8.id), { reject: _4, resolve: V7, done: C8 } = ei(w6, Me3), v7 = ({ id: T6 }) => {
        T6 === y8.id && (this.client.events.off("proposal_expire", v7), this.pendingSessions.delete(y8.id), this.events.emit(E7, { error: { message: Me3, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", v7), this.events.once(E7, ({ error: T6, session: K4 }) => {
        this.client.events.off("proposal_expire", v7), T6 ? _4(T6) : K4 && V7(K4);
      }), await this.sendRequest({ topic: p7, method: "wc_sessionPropose", params: y8, throwOnFailedPublish: true, clientRpcId: y8.id }), await this.setProposal(y8.id, y8), { uri: h7, approval: C8 };
    }), c2(this, "pair", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t4);
      } catch (e9) {
        throw this.client.logger.error("pair() failed"), e9;
      }
    }), c2(this, "approve", async (t4) => {
      var e9, s3, i6;
      const r6 = this.client.core.eventClient.createEvent({ properties: { topic: (e9 = t4?.id) == null ? void 0 : e9.toString(), trace: [tr2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q5) {
        throw r6.setError(ir2.no_internet_connection), q5;
      }
      try {
        await this.isValidProposalId(t4?.id);
      } catch (q5) {
        throw this.client.logger.error(`approve() -> proposal.get(${t4?.id}) failed`), r6.setError(ir2.proposal_not_found), q5;
      }
      try {
        await this.isValidApprove(t4);
      } catch (q5) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r6.setError(ir2.session_approve_namespace_validation_failure), q5;
      }
      const { id: n4, relayProtocol: a4, namespaces: l6, sessionProperties: p7, scopedProperties: h7, sessionConfig: u6 } = t4, d5 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r6.eventId });
      const { pairingTopic: w6, proposer: m5, requiredNamespaces: y8, optionalNamespaces: E7 } = d5;
      let _4 = (s3 = this.client.core.eventClient) == null ? void 0 : s3.getEvent({ topic: w6 });
      _4 || (_4 = (i6 = this.client.core.eventClient) == null ? void 0 : i6.createEvent({ type: tr2.session_approve_started, properties: { topic: w6, trace: [tr2.session_approve_started, tr2.session_namespaces_validation_success] } }));
      const V7 = await this.client.core.crypto.generateKeyPair(), C8 = m5.publicKey, v7 = await this.client.core.crypto.generateSharedKey(V7, C8), T6 = I2(I2(I2({ relay: { protocol: a4 ?? "irn" }, namespaces: l6, controller: { publicKey: V7, metadata: this.client.metadata }, expiry: ii(X3) }, p7 && { sessionProperties: p7 }), h7 && { scopedProperties: h7 }), u6 && { sessionConfig: u6 }), K4 = Q3.relay;
      _4.addTrace(tr2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(v7, { transportType: K4 });
      } catch (q5) {
        throw _4.setError(ir2.subscribe_session_topic_failure), q5;
      }
      _4.addTrace(tr2.subscribe_session_topic_success);
      const fe7 = x(I2({}, T6), { topic: v7, requiredNamespaces: y8, optionalNamespaces: E7, pairingTopic: w6, acknowledged: false, self: T6.controller, peer: { publicKey: m5.publicKey, metadata: m5.metadata }, controller: V7, transportType: Q3.relay });
      await this.client.session.set(v7, fe7), _4.addTrace(tr2.store_session);
      try {
        _4.addTrace(tr2.publishing_session_settle), await this.sendRequest({ topic: v7, method: "wc_sessionSettle", params: T6, throwOnFailedPublish: true }).catch((q5) => {
          throw _4?.setError(ir2.session_settle_publish_failure), q5;
        }), _4.addTrace(tr2.session_settle_publish_success), _4.addTrace(tr2.publishing_session_approve), await this.sendResult({ id: n4, topic: w6, result: { relay: { protocol: a4 ?? "irn" }, responderPublicKey: V7 }, throwOnFailedPublish: true }).catch((q5) => {
          throw _4?.setError(ir2.session_approve_publish_failure), q5;
        }), _4.addTrace(tr2.session_approve_publish_success);
      } catch (q5) {
        throw this.client.logger.error(q5), this.client.session.delete(v7, Kt2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(v7), q5;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _4.eventId }), await this.client.core.pairing.updateMetadata({ topic: w6, metadata: m5.metadata }), await this.deleteProposal(n4), await this.client.core.pairing.activate({ topic: w6 }), await this.setExpiry(v7, ii(X3)), { topic: v7, acknowledged: () => Promise.resolve(this.client.session.get(v7)) };
    }), c2(this, "reject", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t4);
      } catch (r6) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r6;
      }
      const { id: e9, reason: s3 } = t4;
      let i6;
      try {
        i6 = this.client.proposal.get(e9).pairingTopic;
      } catch (r6) {
        throw this.client.logger.error(`reject() -> proposal.get(${e9}) failed`), r6;
      }
      i6 && await this.sendError({ id: e9, topic: i6, error: s3, rpcOpts: N3.wc_sessionPropose.reject }), await this.deleteProposal(e9);
    }), c2(this, "update", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t4);
      } catch (h7) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h7;
      }
      const { topic: e9, namespaces: s3 } = t4, { done: i6, resolve: r6, reject: n4 } = ei(), a4 = payloadId(), l6 = getBigIntRpcId().toString(), p7 = this.client.session.get(e9).namespaces;
      return this.events.once(ci("session_update", a4), ({ error: h7 }) => {
        h7 ? n4(h7) : r6();
      }), await this.client.session.update(e9, { namespaces: s3 }), await this.sendRequest({ topic: e9, method: "wc_sessionUpdate", params: { namespaces: s3 }, throwOnFailedPublish: true, clientRpcId: a4, relayRpcId: l6 }).catch((h7) => {
        this.client.logger.error(h7), this.client.session.update(e9, { namespaces: p7 }), n4(h7);
      }), { acknowledged: i6 };
    }), c2(this, "extend", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t4);
      } catch (a4) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a4;
      }
      const { topic: e9 } = t4, s3 = payloadId(), { done: i6, resolve: r6, reject: n4 } = ei();
      return this.events.once(ci("session_extend", s3), ({ error: a4 }) => {
        a4 ? n4(a4) : r6();
      }), await this.setExpiry(e9, ii(X3)), this.sendRequest({ topic: e9, method: "wc_sessionExtend", params: {}, clientRpcId: s3, throwOnFailedPublish: true }).catch((a4) => {
        n4(a4);
      }), { acknowledged: i6 };
    }), c2(this, "request", async (t4) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t4);
      } catch (y8) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), y8;
      }
      const { chainId: e9, request: s3, topic: i6, expiry: r6 = N3.wc_sessionRequest.req.ttl } = t4, n4 = this.client.session.get(i6);
      n4?.transportType === Q3.relay && await this.confirmOnlineStateOrThrow();
      const a4 = payloadId(), l6 = getBigIntRpcId().toString(), { done: p7, resolve: h7, reject: u6 } = ei(r6, "Request expired. Please try again.");
      this.events.once(ci("session_request", a4), ({ error: y8, result: E7 }) => {
        y8 ? u6(y8) : h7(E7);
      });
      const d5 = "wc_sessionRequest", w6 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      if (w6) return await this.sendRequest({ clientRpcId: a4, relayRpcId: l6, topic: i6, method: d5, params: { request: x(I2({}, s3), { expiryTimestamp: ii(r6) }), chainId: e9 }, expiry: r6, throwOnFailedPublish: true, appLink: w6 }).catch((y8) => u6(y8)), this.client.events.emit("session_request_sent", { topic: i6, request: s3, chainId: e9, id: a4 }), await p7();
      const m5 = { request: x(I2({}, s3), { expiryTimestamp: ii(r6) }), chainId: e9 };
      return await Promise.all([new Promise(async (y8) => {
        await this.sendRequest({ clientRpcId: a4, relayRpcId: l6, topic: i6, method: d5, params: m5, expiry: r6, throwOnFailedPublish: true, tvf: this.getTVFParams(a4, m5) }).catch((E7) => u6(E7)), this.client.events.emit("session_request_sent", { topic: i6, request: s3, chainId: e9, id: a4 }), y8();
      }), new Promise(async (y8) => {
        var E7;
        if (!((E7 = n4.sessionConfig) != null && E7.disableDeepLink)) {
          const _4 = await ui(this.client.core.storage, Le4);
          await ai({ id: a4, topic: i6, wcDeepLink: _4 });
        }
        y8();
      }), p7()]).then((y8) => y8[2]);
    }), c2(this, "respond", async (t4) => {
      this.isInitialized(), await this.isValidRespond(t4);
      const { topic: e9, response: s3 } = t4, { id: i6 } = s3, r6 = this.client.session.get(e9);
      r6.transportType === Q3.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r6.peer.metadata, r6.transportType);
      isJsonRpcResult(s3) ? await this.sendResult({ id: i6, topic: e9, result: s3.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s3) && await this.sendError({ id: i6, topic: e9, error: s3.error, appLink: n4 }), this.cleanupAfterResponse(t4);
    }), c2(this, "ping", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t4);
      } catch (s3) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s3;
      }
      const { topic: e9 } = t4;
      if (this.client.session.keys.includes(e9)) {
        const s3 = payloadId(), i6 = getBigIntRpcId().toString(), { done: r6, resolve: n4, reject: a4 } = ei();
        this.events.once(ci("session_ping", s3), ({ error: l6 }) => {
          l6 ? a4(l6) : n4();
        }), await Promise.all([this.sendRequest({ topic: e9, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s3, relayRpcId: i6 }), r6()]);
      } else this.client.core.pairing.pairings.keys.includes(e9) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: e9 }));
    }), c2(this, "emit", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t4);
      const { topic: e9, event: s3, chainId: i6 } = t4, r6 = getBigIntRpcId().toString(), n4 = payloadId();
      await this.sendRequest({ topic: e9, method: "wc_sessionEvent", params: { event: s3, chainId: i6 }, throwOnFailedPublish: true, relayRpcId: r6, clientRpcId: n4 });
    }), c2(this, "disconnect", async (t4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t4);
      const { topic: e9 } = t4;
      if (this.client.session.keys.includes(e9)) await this.sendRequest({ topic: e9, method: "wc_sessionDelete", params: Kt2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e9, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(e9)) await this.client.core.pairing.disconnect({ topic: e9 });
      else {
        const { message: s3 } = Et("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e9}`);
        throw new Error(s3);
      }
    }), c2(this, "find", (t4) => (this.isInitialized(), this.client.session.getAll().filter((e9) => ya(e9, t4)))), c2(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c2(this, "authenticate", async (t4, e9) => {
      var s3;
      this.isInitialized(), this.isValidAuthenticate(t4);
      const i6 = e9 && this.client.core.linkModeSupportedApps.includes(e9) && ((s3 = this.client.metadata.redirect) == null ? void 0 : s3.linkMode), r6 = i6 ? Q3.link_mode : Q3.relay;
      r6 === Q3.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a4 = "", uri: l6, domain: p7, nonce: h7, type: u6, exp: d5, nbf: w6, methods: m5 = [], expiry: y8 } = t4, E7 = [...t4.resources || []], { topic: _4, uri: V7 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r6 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: _4, uri: V7 } });
      const C8 = await this.client.core.crypto.generateKeyPair(), v7 = Fc(C8);
      if (await Promise.all([this.client.auth.authKeys.set(ce3, { responseTopic: v7, publicKey: C8 }), this.client.auth.pairingTopics.set(v7, { topic: v7, pairingTopic: _4 })]), await this.client.core.relayer.subscribe(v7, { transportType: r6 }), this.client.logger.info(`sending request to new pairing topic: ${_4}`), m5.length > 0) {
        const { namespace: O6 } = Fe(n4[0]);
        let k8 = Ef(O6, "request", m5);
        Oe(E7) && (k8 = Bf(k8, E7.pop())), E7.push(k8);
      }
      const T6 = y8 && y8 > N3.wc_sessionAuthenticate.req.ttl ? y8 : N3.wc_sessionAuthenticate.req.ttl, K4 = { authPayload: { type: u6 ?? "caip122", chains: n4, statement: a4, aud: l6, domain: p7, version: "1", nonce: h7, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d5, nbf: w6, resources: E7 }, requester: { publicKey: C8, metadata: this.client.metadata }, expiryTimestamp: ii(T6) }, fe7 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m5])], events: ["chainChanged", "accountsChanged"] } }, q5 = { requiredNamespaces: {}, optionalNamespaces: fe7, relays: [{ protocol: "irn" }], pairingTopic: _4, proposer: { publicKey: C8, metadata: this.client.metadata }, expiryTimestamp: ii(N3.wc_sessionPropose.req.ttl), id: payloadId() }, { done: It5, resolve: Ue7, reject: Se5 } = ei(T6, "Request expired"), te4 = payloadId(), le7 = ci("session_connect", q5.id), Re6 = ci("session_request", te4), pe7 = async ({ error: O6, session: k8 }) => {
        this.events.off(Re6, ve4), O6 ? Se5(O6) : k8 && Ue7({ session: k8 });
      }, ve4 = async (O6) => {
        var k8, Ge4, je7;
        if (await this.deletePendingAuthRequest(te4, { message: "fulfilled", code: 0 }), O6.error) {
          const ie7 = Kt2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O6.error.code === ie7.code ? void 0 : (this.events.off(le7, pe7), Se5(O6.error.message));
        }
        await this.deleteProposal(q5.id), this.events.off(le7, pe7);
        const { cacaos: Fe6, responder: Q8 } = O6.result, Te5 = [], Qe6 = [];
        for (const ie7 of Fe6) {
          await yf({ cacao: ie7, projectId: this.client.core.projectId }) || (this.client.logger.error(ie7, "Signature verification failed"), Se5(Kt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe5 } = ie7, Pe7 = Oe(qe5.resources), He7 = [Vr(qe5.iss)], Tt7 = dn(qe5.iss);
          if (Pe7) {
            const Ne4 = If(Pe7), qt4 = Af(Pe7);
            Te5.push(...Ne4), He7.push(...qt4);
          }
          for (const Ne4 of He7) Qe6.push(`${Ne4}:${Tt7}`);
        }
        const se7 = await this.client.core.crypto.generateSharedKey(C8, Q8.publicKey);
        let he7;
        Te5.length > 0 && (he7 = { topic: se7, acknowledged: true, self: { publicKey: C8, metadata: this.client.metadata }, peer: Q8, controller: Q8.publicKey, expiry: ii(X3), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: _4, namespaces: ga([...new Set(Te5)], [...new Set(Qe6)]), transportType: r6 }, await this.client.core.relayer.subscribe(se7, { transportType: r6 }), await this.client.session.set(se7, he7), _4 && await this.client.core.pairing.updateMetadata({ topic: _4, metadata: Q8.metadata }), he7 = this.client.session.get(se7)), (k8 = this.client.metadata.redirect) != null && k8.linkMode && (Ge4 = Q8.metadata.redirect) != null && Ge4.linkMode && (je7 = Q8.metadata.redirect) != null && je7.universal && e9 && (this.client.core.addLinkModeSupportedApp(Q8.metadata.redirect.universal), this.client.session.update(se7, { transportType: Q3.link_mode })), Ue7({ auths: Fe6, session: he7 });
      };
      this.events.once(le7, pe7), this.events.once(Re6, ve4);
      let Ie7;
      try {
        if (i6) {
          const O6 = formatJsonRpcRequest("wc_sessionAuthenticate", K4, te4);
          this.client.core.history.set(_4, O6);
          const k8 = await this.client.core.crypto.encode("", O6, { type: ge, encoding: De });
          Ie7 = sa(e9, _4, k8);
        } else await Promise.all([this.sendRequest({ topic: _4, method: "wc_sessionAuthenticate", params: K4, expiry: t4.expiry, throwOnFailedPublish: true, clientRpcId: te4 }), this.sendRequest({ topic: _4, method: "wc_sessionPropose", params: q5, expiry: N3.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q5.id })]);
      } catch (O6) {
        throw this.events.off(le7, pe7), this.events.off(Re6, ve4), O6;
      }
      return await this.setProposal(q5.id, q5), await this.setAuthRequest(te4, { request: x(I2({}, K4), { verifyContext: {} }), pairingTopic: _4, transportType: r6 }), { uri: Ie7 ?? V7, response: It5 };
    }), c2(this, "approveSessionAuthenticate", async (t4) => {
      const { id: e9, auths: s3 } = t4, i6 = this.client.core.eventClient.createEvent({ properties: { topic: e9.toString(), trace: [sr2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y8) {
        throw i6.setError(rr2.no_internet_connection), y8;
      }
      const r6 = this.getPendingAuthRequest(e9);
      if (!r6) throw i6.setError(rr2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${e9}`);
      const n4 = r6.transportType || Q3.relay;
      n4 === Q3.relay && await this.confirmOnlineStateOrThrow();
      const a4 = r6.requester.publicKey, l6 = await this.client.core.crypto.generateKeyPair(), p7 = Fc(a4), h7 = { type: ee, receiverPublicKey: a4, senderPublicKey: l6 }, u6 = [], d5 = [];
      for (const y8 of s3) {
        if (!await yf({ cacao: y8, projectId: this.client.core.projectId })) {
          i6.setError(rr2.invalid_cacao);
          const v7 = Kt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: e9, topic: p7, error: v7, encodeOpts: h7 }), new Error(v7.message);
        }
        i6.addTrace(sr2.cacaos_verified);
        const { p: E7 } = y8, _4 = Oe(E7.resources), V7 = [Vr(E7.iss)], C8 = dn(E7.iss);
        if (_4) {
          const v7 = If(_4), T6 = Af(_4);
          u6.push(...v7), V7.push(...T6);
        }
        for (const v7 of V7) d5.push(`${v7}:${C8}`);
      }
      const w6 = await this.client.core.crypto.generateSharedKey(l6, a4);
      i6.addTrace(sr2.create_authenticated_session_topic);
      let m5;
      if (u6?.length > 0) {
        m5 = { topic: w6, acknowledged: true, self: { publicKey: l6, metadata: this.client.metadata }, peer: { publicKey: a4, metadata: r6.requester.metadata }, controller: a4, expiry: ii(X3), authentication: s3, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r6.pairingTopic, namespaces: ga([...new Set(u6)], [...new Set(d5)]), transportType: n4 }, i6.addTrace(sr2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w6, { transportType: n4 });
        } catch (y8) {
          throw i6.setError(rr2.subscribe_authenticated_session_topic_failure), y8;
        }
        i6.addTrace(sr2.subscribe_authenticated_session_topic_success), await this.client.session.set(w6, m5), i6.addTrace(sr2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r6.pairingTopic, metadata: r6.requester.metadata });
      }
      i6.addTrace(sr2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p7, id: e9, result: { cacaos: s3, responder: { publicKey: l6, metadata: this.client.metadata } }, encodeOpts: h7, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r6.requester.metadata, n4) });
      } catch (y8) {
        throw i6.setError(rr2.authenticated_session_approve_publish_failure), y8;
      }
      return await this.client.auth.requests.delete(e9, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r6.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i6.eventId }), { session: m5 };
    }), c2(this, "rejectSessionAuthenticate", async (t4) => {
      this.isInitialized();
      const { id: e9, reason: s3 } = t4, i6 = this.getPendingAuthRequest(e9);
      if (!i6) throw new Error(`Could not find pending auth request with id ${e9}`);
      i6.transportType === Q3.relay && await this.confirmOnlineStateOrThrow();
      const r6 = i6.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a4 = Fc(r6), l6 = { type: ee, receiverPublicKey: r6, senderPublicKey: n4 };
      await this.sendError({ id: e9, topic: a4, error: s3, encodeOpts: l6, rpcOpts: N3.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i6.requester.metadata, i6.transportType) }), await this.client.auth.requests.delete(e9, { message: "rejected", code: 0 }), await this.deleteProposal(e9);
    }), c2(this, "formatAuthMessage", (t4) => {
      this.isInitialized();
      const { request: e9, iss: s3 } = t4;
      return qr(e9, s3);
    }), c2(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const t4 = this.relayMessageCache.shift();
          t4 && await this.onRelayMessage(t4);
        } catch (t4) {
          this.client.logger.error(t4);
        }
      }, 50);
    }), c2(this, "cleanupDuplicatePairings", async (t4) => {
      if (t4.pairingTopic) try {
        const e9 = this.client.core.pairing.pairings.get(t4.pairingTopic), s3 = this.client.core.pairing.pairings.getAll().filter((i6) => {
          var r6, n4;
          return ((r6 = i6.peerMetadata) == null ? void 0 : r6.url) && ((n4 = i6.peerMetadata) == null ? void 0 : n4.url) === t4.peer.metadata.url && i6.topic && i6.topic !== e9.topic;
        });
        if (s3.length === 0) return;
        this.client.logger.info(`Cleaning up ${s3.length} duplicate pairing(s)`), await Promise.all(s3.map((i6) => this.client.core.pairing.disconnect({ topic: i6.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (e9) {
        this.client.logger.error(e9);
      }
    }), c2(this, "deleteSession", async (t4) => {
      var e9;
      const { topic: s3, expirerHasDeleted: i6 = false, emitEvent: r6 = true, id: n4 = 0 } = t4, { self: a4 } = this.client.session.get(s3);
      await this.client.core.relayer.unsubscribe(s3), await this.client.session.delete(s3, Kt2("USER_DISCONNECTED")), this.addToRecentlyDeleted(s3, "session"), this.client.core.crypto.keychain.has(a4.publicKey) && await this.client.core.crypto.deleteKeyPair(a4.publicKey), this.client.core.crypto.keychain.has(s3) && await this.client.core.crypto.deleteSymKey(s3), i6 || this.client.core.expirer.del(s3), this.client.core.storage.removeItem(Le4).catch((l6) => this.client.logger.warn(l6)), this.getPendingSessionRequests().forEach((l6) => {
        l6.topic === s3 && this.deletePendingSessionRequest(l6.id, Kt2("USER_DISCONNECTED"));
      }), s3 === ((e9 = this.sessionRequestQueue.queue[0]) == null ? void 0 : e9.topic) && (this.sessionRequestQueue.state = $2.idle), r6 && this.client.events.emit("session_delete", { id: n4, topic: s3 });
    }), c2(this, "deleteProposal", async (t4, e9) => {
      if (e9) try {
        const s3 = this.client.proposal.get(t4), i6 = this.client.core.eventClient.getEvent({ topic: s3.pairingTopic });
        i6?.setError(ir2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(t4, Kt2("USER_DISCONNECTED")), e9 ? Promise.resolve() : this.client.core.expirer.del(t4)]), this.addToRecentlyDeleted(t4, "proposal");
    }), c2(this, "deletePendingSessionRequest", async (t4, e9, s3 = false) => {
      await Promise.all([this.client.pendingRequest.delete(t4, e9), s3 ? Promise.resolve() : this.client.core.expirer.del(t4)]), this.addToRecentlyDeleted(t4, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i6) => i6.id !== t4), s3 && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: t4 }));
    }), c2(this, "deletePendingAuthRequest", async (t4, e9, s3 = false) => {
      await Promise.all([this.client.auth.requests.delete(t4, e9), s3 ? Promise.resolve() : this.client.core.expirer.del(t4)]);
    }), c2(this, "setExpiry", async (t4, e9) => {
      this.client.session.keys.includes(t4) && (this.client.core.expirer.set(t4, e9), await this.client.session.update(t4, { expiry: e9 }));
    }), c2(this, "setProposal", async (t4, e9) => {
      this.client.core.expirer.set(t4, ii(N3.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t4, e9);
    }), c2(this, "setAuthRequest", async (t4, e9) => {
      const { request: s3, pairingTopic: i6, transportType: r6 = Q3.relay } = e9;
      this.client.core.expirer.set(t4, s3.expiryTimestamp), await this.client.auth.requests.set(t4, { authPayload: s3.authPayload, requester: s3.requester, expiryTimestamp: s3.expiryTimestamp, id: t4, pairingTopic: i6, verifyContext: s3.verifyContext, transportType: r6 });
    }), c2(this, "setPendingSessionRequest", async (t4) => {
      const { id: e9, topic: s3, params: i6, verifyContext: r6 } = t4, n4 = i6.request.expiryTimestamp || ii(N3.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(e9, n4), await this.client.pendingRequest.set(e9, { id: e9, topic: s3, params: i6, verifyContext: r6 });
    }), c2(this, "sendRequest", async (t4) => {
      const { topic: e9, method: s3, params: i6, expiry: r6, relayRpcId: n4, clientRpcId: a4, throwOnFailedPublish: l6, appLink: p7, tvf: h7 } = t4, u6 = formatJsonRpcRequest(s3, i6, a4);
      let d5;
      const w6 = !!p7;
      try {
        const E7 = w6 ? De : Qt;
        d5 = await this.client.core.crypto.encode(e9, u6, { encoding: E7 });
      } catch (E7) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e9} failed`), E7;
      }
      let m5;
      if (mt3.includes(s3)) {
        const E7 = zc(JSON.stringify(u6)), _4 = zc(d5);
        m5 = await this.client.core.verify.register({ id: _4, decryptedId: E7 });
      }
      const y8 = N3[s3].req;
      if (y8.attestation = m5, r6 && (y8.ttl = r6), n4 && (y8.id = n4), this.client.core.history.set(e9, u6), w6) {
        const E7 = sa(p7, e9, d5);
        await global.Linking.openURL(E7, this.client.name);
      } else {
        const E7 = N3[s3].req;
        r6 && (E7.ttl = r6), n4 && (E7.id = n4), E7.tvf = x(I2({}, h7), { correlationId: u6.id }), l6 ? (E7.internal = x(I2({}, E7.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e9, d5, E7)) : this.client.core.relayer.publish(e9, d5, E7).catch((_4) => this.client.logger.error(_4));
      }
      return u6.id;
    }), c2(this, "sendResult", async (t4) => {
      const { id: e9, topic: s3, result: i6, throwOnFailedPublish: r6, encodeOpts: n4, appLink: a4 } = t4, l6 = formatJsonRpcResult(e9, i6);
      let p7;
      const h7 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w6 = h7 ? De : Qt;
        p7 = await this.client.core.crypto.encode(s3, l6, x(I2({}, n4 || {}), { encoding: w6 }));
      } catch (w6) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s3} failed`), w6;
      }
      let u6, d5;
      try {
        u6 = await this.client.core.history.get(s3, e9);
        const w6 = u6.request;
        try {
          d5 = this.getTVFParams(e9, w6.params, i6);
        } catch (m5) {
          this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${m5?.message}`);
        }
      } catch (w6) {
        throw this.client.logger.error(`sendResult() -> history.get(${s3}, ${e9}) failed`), w6;
      }
      if (h7) {
        const w6 = sa(a4, s3, p7);
        await global.Linking.openURL(w6, this.client.name);
      } else {
        const w6 = u6.request.method, m5 = N3[w6].res;
        m5.tvf = x(I2({}, d5), { correlationId: e9 }), r6 ? (m5.internal = x(I2({}, m5.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s3, p7, m5)) : this.client.core.relayer.publish(s3, p7, m5).catch((y8) => this.client.logger.error(y8));
      }
      await this.client.core.history.resolve(l6);
    }), c2(this, "sendError", async (t4) => {
      const { id: e9, topic: s3, error: i6, encodeOpts: r6, rpcOpts: n4, appLink: a4 } = t4, l6 = formatJsonRpcError(e9, i6);
      let p7;
      const h7 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d5 = h7 ? De : Qt;
        p7 = await this.client.core.crypto.encode(s3, l6, x(I2({}, r6 || {}), { encoding: d5 }));
      } catch (d5) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s3} failed`), d5;
      }
      let u6;
      try {
        u6 = await this.client.core.history.get(s3, e9);
      } catch (d5) {
        throw this.client.logger.error(`sendError() -> history.get(${s3}, ${e9}) failed`), d5;
      }
      if (h7) {
        const d5 = sa(a4, s3, p7);
        await global.Linking.openURL(d5, this.client.name);
      } else {
        const d5 = u6.request.method, w6 = n4 || N3[d5].res;
        this.client.core.relayer.publish(s3, p7, w6);
      }
      await this.client.core.history.resolve(l6);
    }), c2(this, "cleanup", async () => {
      const t4 = [], e9 = [];
      this.client.session.getAll().forEach((s3) => {
        let i6 = false;
        fi(s3.expiry) && (i6 = true), this.client.core.crypto.keychain.has(s3.topic) || (i6 = true), i6 && t4.push(s3.topic);
      }), this.client.proposal.getAll().forEach((s3) => {
        fi(s3.expiryTimestamp) && e9.push(s3.id);
      }), await Promise.all([...t4.map((s3) => this.deleteSession({ topic: s3 })), ...e9.map((s3) => this.deleteProposal(s3))]);
    }), c2(this, "onProviderMessageEvent", async (t4) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t4) : await this.onRelayMessage(t4);
    }), c2(this, "onRelayEventRequest", async (t4) => {
      this.requestQueue.queue.push(t4), await this.processRequestsQueue();
    }), c2(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $2.active;
        const t4 = this.requestQueue.queue.shift();
        if (t4) try {
          await this.processRequest(t4);
        } catch (e9) {
          this.client.logger.warn(e9);
        }
      }
      this.requestQueue.state = $2.idle;
    }), c2(this, "processRequest", async (t4) => {
      const { topic: e9, payload: s3, attestation: i6, transportType: r6, encryptedId: n4 } = t4, a4 = s3.method;
      if (!this.shouldIgnorePairingRequest({ topic: e9, requestMethod: a4 })) switch (a4) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: e9, payload: s3, attestation: i6, encryptedId: n4 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(e9, s3);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(e9, s3);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(e9, s3);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(e9, s3);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(e9, s3);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: e9, payload: s3, attestation: i6, encryptedId: n4, transportType: r6 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(e9, s3);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: e9, payload: s3, attestation: i6, encryptedId: n4, transportType: r6 });
        default:
          return this.client.logger.info(`Unsupported request method ${a4}`);
      }
    }), c2(this, "onRelayEventResponse", async (t4) => {
      const { topic: e9, payload: s3, transportType: i6 } = t4, r6 = (await this.client.core.history.get(e9, s3.id)).request.method;
      switch (r6) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(e9, s3, i6);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(e9, s3);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(e9, s3);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(e9, s3);
        case "wc_sessionPing":
          return this.onSessionPingResponse(e9, s3);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(e9, s3);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(e9, s3);
        default:
          return this.client.logger.info(`Unsupported response method ${r6}`);
      }
    }), c2(this, "onRelayEventUnknownPayload", (t4) => {
      const { topic: e9 } = t4, { message: s3 } = Et("MISSING_OR_INVALID", `Decoded payload on topic ${e9} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s3);
    }), c2(this, "shouldIgnorePairingRequest", (t4) => {
      const { topic: e9, requestMethod: s3 } = t4, i6 = this.expectedPairingMethodMap.get(e9);
      return !i6 || i6.includes(s3) ? false : !!(i6.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c2(this, "onSessionProposeRequest", async (t4) => {
      const { topic: e9, payload: s3, attestation: i6, encryptedId: r6 } = t4, { params: n4, id: a4 } = s3;
      try {
        const l6 = this.client.core.eventClient.getEvent({ topic: e9 });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l6?.setError(Y3.proposal_listener_not_found)), this.isValidConnect(I2({}, s3.params));
        const p7 = n4.expiryTimestamp || ii(N3.wc_sessionPropose.req.ttl), h7 = I2({ id: a4, pairingTopic: e9, expiryTimestamp: p7, attestation: i6, encryptedId: r6 }, n4);
        await this.setProposal(a4, h7);
        const u6 = await this.getVerifyContext({ attestationId: i6, hash: zc(JSON.stringify(s3)), encryptedId: r6, metadata: h7.proposer.metadata });
        l6?.addTrace(G3.emit_session_proposal), this.client.events.emit("session_proposal", { id: a4, params: h7, verifyContext: u6 });
      } catch (l6) {
        await this.sendError({ id: a4, topic: e9, error: l6, rpcOpts: N3.wc_sessionPropose.autoReject }), this.client.logger.error(l6);
      }
    }), c2(this, "onSessionProposeResponse", async (t4, e9, s3) => {
      const { id: i6 } = e9;
      if (isJsonRpcResult(e9)) {
        const { result: r6 } = e9;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r6 });
        const n4 = this.client.proposal.get(i6);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a4 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a4 });
        const l6 = r6.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l6 });
        const p7 = await this.client.core.crypto.generateSharedKey(a4, l6);
        this.pendingSessions.set(i6, { sessionTopic: p7, pairingTopic: t4, proposalId: i6, publicKey: a4 });
        const h7 = await this.client.core.relayer.subscribe(p7, { transportType: s3 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h7 }), await this.client.core.pairing.activate({ topic: t4 });
      } else if (isJsonRpcError(e9)) {
        await this.deleteProposal(i6);
        const r6 = ci("session_connect", i6);
        if (this.events.listenerCount(r6) === 0) throw new Error(`emitting ${r6} without any listeners, 954`);
        this.events.emit(r6, { error: e9.error });
      }
    }), c2(this, "onSessionSettleRequest", async (t4, e9) => {
      const { id: s3, params: i6 } = e9;
      try {
        this.isValidSessionSettleRequest(i6);
        const { relay: r6, controller: n4, expiry: a4, namespaces: l6, sessionProperties: p7, scopedProperties: h7, sessionConfig: u6 } = e9.params, d5 = [...this.pendingSessions.values()].find((y8) => y8.sessionTopic === t4);
        if (!d5) return this.client.logger.error(`Pending session not found for topic ${t4}`);
        const w6 = this.client.proposal.get(d5.proposalId), m5 = x(I2(I2(I2({ topic: t4, relay: r6, expiry: a4, namespaces: l6, acknowledged: true, pairingTopic: d5.pairingTopic, requiredNamespaces: w6.requiredNamespaces, optionalNamespaces: w6.optionalNamespaces, controller: n4.publicKey, self: { publicKey: d5.publicKey, metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, p7 && { sessionProperties: p7 }), h7 && { scopedProperties: h7 }), u6 && { sessionConfig: u6 }), { transportType: Q3.relay });
        await this.client.session.set(m5.topic, m5), await this.setExpiry(m5.topic, m5.expiry), await this.client.core.pairing.updateMetadata({ topic: d5.pairingTopic, metadata: m5.peer.metadata }), this.client.events.emit("session_connect", { session: m5 }), this.events.emit(ci("session_connect", d5.proposalId), { session: m5 }), this.pendingSessions.delete(d5.proposalId), this.deleteProposal(d5.proposalId, false), this.cleanupDuplicatePairings(m5), await this.sendResult({ id: e9.id, topic: t4, result: true });
      } catch (r6) {
        await this.sendError({ id: s3, topic: t4, error: r6 }), this.client.logger.error(r6);
      }
    }), c2(this, "onSessionSettleResponse", async (t4, e9) => {
      const { id: s3 } = e9;
      isJsonRpcResult(e9) ? (await this.client.session.update(t4, { acknowledged: true }), this.events.emit(ci("session_approve", s3), {})) : isJsonRpcError(e9) && (await this.client.session.delete(t4, Kt2("USER_DISCONNECTED")), this.events.emit(ci("session_approve", s3), { error: e9.error }));
    }), c2(this, "onSessionUpdateRequest", async (t4, e9) => {
      const { params: s3, id: i6 } = e9;
      try {
        const r6 = `${t4}_session_update`, n4 = Ha.get(r6);
        if (n4 && this.isRequestOutOfSync(n4, i6)) {
          this.client.logger.warn(`Discarding out of sync request - ${i6}`), this.sendError({ id: i6, topic: t4, error: Kt2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I2({ topic: t4 }, s3));
        try {
          Ha.set(r6, i6), await this.client.session.update(t4, { namespaces: s3.namespaces }), await this.sendResult({ id: i6, topic: t4, result: true });
        } catch (a4) {
          throw Ha.delete(r6), a4;
        }
        this.client.events.emit("session_update", { id: i6, topic: t4, params: s3 });
      } catch (r6) {
        await this.sendError({ id: i6, topic: t4, error: r6 }), this.client.logger.error(r6);
      }
    }), c2(this, "isRequestOutOfSync", (t4, e9) => e9.toString().slice(0, -3) < t4.toString().slice(0, -3)), c2(this, "onSessionUpdateResponse", (t4, e9) => {
      const { id: s3 } = e9, i6 = ci("session_update", s3);
      if (this.events.listenerCount(i6) === 0) throw new Error(`emitting ${i6} without any listeners`);
      isJsonRpcResult(e9) ? this.events.emit(ci("session_update", s3), {}) : isJsonRpcError(e9) && this.events.emit(ci("session_update", s3), { error: e9.error });
    }), c2(this, "onSessionExtendRequest", async (t4, e9) => {
      const { id: s3 } = e9;
      try {
        this.isValidExtend({ topic: t4 }), await this.setExpiry(t4, ii(X3)), await this.sendResult({ id: s3, topic: t4, result: true }), this.client.events.emit("session_extend", { id: s3, topic: t4 });
      } catch (i6) {
        await this.sendError({ id: s3, topic: t4, error: i6 }), this.client.logger.error(i6);
      }
    }), c2(this, "onSessionExtendResponse", (t4, e9) => {
      const { id: s3 } = e9, i6 = ci("session_extend", s3);
      if (this.events.listenerCount(i6) === 0) throw new Error(`emitting ${i6} without any listeners`);
      isJsonRpcResult(e9) ? this.events.emit(ci("session_extend", s3), {}) : isJsonRpcError(e9) && this.events.emit(ci("session_extend", s3), { error: e9.error });
    }), c2(this, "onSessionPingRequest", async (t4, e9) => {
      const { id: s3 } = e9;
      try {
        this.isValidPing({ topic: t4 }), await this.sendResult({ id: s3, topic: t4, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s3, topic: t4 });
      } catch (i6) {
        await this.sendError({ id: s3, topic: t4, error: i6 }), this.client.logger.error(i6);
      }
    }), c2(this, "onSessionPingResponse", (t4, e9) => {
      const { id: s3 } = e9, i6 = ci("session_ping", s3);
      setTimeout(() => {
        if (this.events.listenerCount(i6) === 0) throw new Error(`emitting ${i6} without any listeners 2176`);
        isJsonRpcResult(e9) ? this.events.emit(ci("session_ping", s3), {}) : isJsonRpcError(e9) && this.events.emit(ci("session_ping", s3), { error: e9.error });
      }, 500);
    }), c2(this, "onSessionDeleteRequest", async (t4, e9) => {
      const { id: s3 } = e9;
      try {
        this.isValidDisconnect({ topic: t4, reason: e9.params }), Promise.all([new Promise((i6) => {
          this.client.core.relayer.once(C2.publish, async () => {
            i6(await this.deleteSession({ topic: t4, id: s3 }));
          });
        }), this.sendResult({ id: s3, topic: t4, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t4, error: Kt2("USER_DISCONNECTED") })]).catch((i6) => this.client.logger.error(i6));
      } catch (i6) {
        this.client.logger.error(i6);
      }
    }), c2(this, "onSessionRequest", async (t4) => {
      var e9, s3, i6;
      const { topic: r6, payload: n4, attestation: a4, encryptedId: l6, transportType: p7 } = t4, { id: h7, params: u6 } = n4;
      try {
        await this.isValidRequest(I2({ topic: r6 }, u6));
        const d5 = this.client.session.get(r6), w6 = await this.getVerifyContext({ attestationId: a4, hash: zc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u6, h7))), encryptedId: l6, metadata: d5.peer.metadata, transportType: p7 }), m5 = { id: h7, topic: r6, params: u6, verifyContext: w6 };
        await this.setPendingSessionRequest(m5), p7 === Q3.link_mode && (e9 = d5.peer.metadata.redirect) != null && e9.universal && this.client.core.addLinkModeSupportedApp((s3 = d5.peer.metadata.redirect) == null ? void 0 : s3.universal), (i6 = this.client.signConfig) != null && i6.disableRequestQueue ? this.emitSessionRequest(m5) : (this.addSessionRequestToSessionRequestQueue(m5), this.processSessionRequestQueue());
      } catch (d5) {
        await this.sendError({ id: h7, topic: r6, error: d5 }), this.client.logger.error(d5);
      }
    }), c2(this, "onSessionRequestResponse", (t4, e9) => {
      const { id: s3 } = e9, i6 = ci("session_request", s3);
      if (this.events.listenerCount(i6) === 0) throw new Error(`emitting ${i6} without any listeners`);
      isJsonRpcResult(e9) ? this.events.emit(ci("session_request", s3), { result: e9.result }) : isJsonRpcError(e9) && this.events.emit(ci("session_request", s3), { error: e9.error });
    }), c2(this, "onSessionEventRequest", async (t4, e9) => {
      const { id: s3, params: i6 } = e9;
      try {
        const r6 = `${t4}_session_event_${i6.event.name}`, n4 = Ha.get(r6);
        if (n4 && this.isRequestOutOfSync(n4, s3)) {
          this.client.logger.info(`Discarding out of sync request - ${s3}`);
          return;
        }
        this.isValidEmit(I2({ topic: t4 }, i6)), this.client.events.emit("session_event", { id: s3, topic: t4, params: i6 }), Ha.set(r6, s3);
      } catch (r6) {
        await this.sendError({ id: s3, topic: t4, error: r6 }), this.client.logger.error(r6);
      }
    }), c2(this, "onSessionAuthenticateResponse", (t4, e9) => {
      const { id: s3 } = e9;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t4, payload: e9 }), isJsonRpcResult(e9) ? this.events.emit(ci("session_request", s3), { result: e9.result }) : isJsonRpcError(e9) && this.events.emit(ci("session_request", s3), { error: e9.error });
    }), c2(this, "onSessionAuthenticateRequest", async (t4) => {
      var e9;
      const { topic: s3, payload: i6, attestation: r6, encryptedId: n4, transportType: a4 } = t4;
      try {
        const { requester: l6, authPayload: p7, expiryTimestamp: h7 } = i6.params, u6 = await this.getVerifyContext({ attestationId: r6, hash: zc(JSON.stringify(i6)), encryptedId: n4, metadata: l6.metadata, transportType: a4 }), d5 = { requester: l6, pairingTopic: s3, id: i6.id, authPayload: p7, verifyContext: u6, expiryTimestamp: h7 };
        await this.setAuthRequest(i6.id, { request: d5, pairingTopic: s3, transportType: a4 }), a4 === Q3.link_mode && (e9 = l6.metadata.redirect) != null && e9.universal && this.client.core.addLinkModeSupportedApp(l6.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s3, params: i6.params, id: i6.id, verifyContext: u6 });
      } catch (l6) {
        this.client.logger.error(l6);
        const p7 = i6.params.requester.publicKey, h7 = await this.client.core.crypto.generateKeyPair(), u6 = this.getAppLinkIfEnabled(i6.params.requester.metadata, a4), d5 = { type: ee, receiverPublicKey: p7, senderPublicKey: h7 };
        await this.sendError({ id: i6.id, topic: s3, error: l6, encodeOpts: d5, rpcOpts: N3.wc_sessionAuthenticate.autoReject, appLink: u6 });
      }
    }), c2(this, "addSessionRequestToSessionRequestQueue", (t4) => {
      this.sessionRequestQueue.queue.push(t4);
    }), c2(this, "cleanupAfterResponse", (t4) => {
      this.deletePendingSessionRequest(t4.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay));
    }), c2(this, "cleanupPendingSentRequestsForTopic", ({ topic: t4, error: e9 }) => {
      const s3 = this.client.core.history.pending;
      s3.length > 0 && s3.filter((i6) => i6.topic === t4 && i6.request.method === "wc_sessionRequest").forEach((i6) => {
        const r6 = i6.request.id, n4 = ci("session_request", r6);
        if (this.events.listenerCount(n4) === 0) throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(ci("session_request", i6.request.id), { error: e9 });
      });
    }), c2(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t4 = this.sessionRequestQueue.queue[0];
      if (!t4) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.emitSessionRequest(t4);
      } catch (e9) {
        this.client.logger.error(e9);
      }
    }), c2(this, "emitSessionRequest", (t4) => {
      if (this.emittedSessionRequests.has(t4.id)) {
        this.client.logger.warn({ id: t4.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t4.id}`);
        return;
      }
      this.sessionRequestQueue.state = $2.active, this.emittedSessionRequests.add(t4.id), this.client.events.emit("session_request", t4);
    }), c2(this, "onPairingCreated", (t4) => {
      if (t4.methods && this.expectedPairingMethodMap.set(t4.topic, t4.methods), t4.active) return;
      const e9 = this.client.proposal.getAll().find((s3) => s3.pairingTopic === t4.topic);
      e9 && this.onSessionProposeRequest({ topic: t4.topic, payload: formatJsonRpcRequest("wc_sessionPropose", x(I2({}, e9), { requiredNamespaces: e9.requiredNamespaces, optionalNamespaces: e9.optionalNamespaces, relays: e9.relays, proposer: e9.proposer, sessionProperties: e9.sessionProperties, scopedProperties: e9.scopedProperties }), e9.id), attestation: e9.attestation, encryptedId: e9.encryptedId });
    }), c2(this, "isValidConnect", async (t4) => {
      if (!Aa(t4)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t4)}`);
        throw new Error(l6);
      }
      const { pairingTopic: e9, requiredNamespaces: s3, optionalNamespaces: i6, sessionProperties: r6, scopedProperties: n4, relays: a4 } = t4;
      if (kt(e9) || await this.isValidPairingTopic(e9), !Ba(a4, true)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", `connect() relays: ${a4}`);
        throw new Error(l6);
      }
      if (!kt(s3) && Ve(s3) !== 0) {
        const l6 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l6) : this.client.logger.warn(l6), this.validateNamespaces(s3, "requiredNamespaces");
      }
      if (!kt(i6) && Ve(i6) !== 0 && this.validateNamespaces(i6, "optionalNamespaces"), kt(r6) || this.validateSessionProps(r6, "sessionProperties"), !kt(n4)) {
        this.validateSessionProps(n4, "scopedProperties");
        const l6 = Object.keys(s3 || {}).concat(Object.keys(i6 || {}));
        if (!Object.keys(n4).every((p7) => l6.includes(p7.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(n4)}, required/optional namespaces: ${JSON.stringify(l6)}`);
      }
    }), c2(this, "validateNamespaces", (t4, e9) => {
      const s3 = Ea(t4, "connect()", e9);
      if (s3) throw new Error(s3.message);
    }), c2(this, "isValidApprove", async (t4) => {
      if (!Aa(t4)) throw new Error(Et("MISSING_OR_INVALID", `approve() params: ${t4}`).message);
      const { id: e9, namespaces: s3, relayProtocol: i6, sessionProperties: r6, scopedProperties: n4 } = t4;
      this.checkRecentlyDeleted(e9), await this.isValidProposalId(e9);
      const a4 = this.client.proposal.get(e9), l6 = is(s3, "approve()");
      if (l6) throw new Error(l6.message);
      const p7 = cs(a4.requiredNamespaces, s3, "approve()");
      if (p7) throw new Error(p7.message);
      if (!it(i6, true)) {
        const { message: h7 } = Et("MISSING_OR_INVALID", `approve() relayProtocol: ${i6}`);
        throw new Error(h7);
      }
      if (kt(r6) || this.validateSessionProps(r6, "sessionProperties"), !kt(n4)) {
        this.validateSessionProps(n4, "scopedProperties");
        const h7 = new Set(Object.keys(s3));
        if (!Object.keys(n4).every((u6) => h7.has(u6.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(n4)}, approved namespaces: ${Array.from(h7).join(", ")}`);
      }
    }), c2(this, "isValidReject", async (t4) => {
      if (!Aa(t4)) {
        const { message: i6 } = Et("MISSING_OR_INVALID", `reject() params: ${t4}`);
        throw new Error(i6);
      }
      const { id: e9, reason: s3 } = t4;
      if (this.checkRecentlyDeleted(e9), await this.isValidProposalId(e9), !Sa(s3)) {
        const { message: i6 } = Et("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s3)}`);
        throw new Error(i6);
      }
    }), c2(this, "isValidSessionSettleRequest", (t4) => {
      if (!Aa(t4)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t4}`);
        throw new Error(l6);
      }
      const { relay: e9, controller: s3, namespaces: i6, expiry: r6 } = t4;
      if (!fs(e9)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l6);
      }
      const n4 = va(s3, "onSessionSettleRequest()");
      if (n4) throw new Error(n4.message);
      const a4 = is(i6, "onSessionSettleRequest()");
      if (a4) throw new Error(a4.message);
      if (fi(r6)) {
        const { message: l6 } = Et("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l6);
      }
    }), c2(this, "isValidUpdate", async (t4) => {
      if (!Aa(t4)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `update() params: ${t4}`);
        throw new Error(a4);
      }
      const { topic: e9, namespaces: s3 } = t4;
      this.checkRecentlyDeleted(e9), await this.isValidSessionTopic(e9);
      const i6 = this.client.session.get(e9), r6 = is(s3, "update()");
      if (r6) throw new Error(r6.message);
      const n4 = cs(i6.requiredNamespaces, s3, "update()");
      if (n4) throw new Error(n4.message);
    }), c2(this, "isValidExtend", async (t4) => {
      if (!Aa(t4)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `extend() params: ${t4}`);
        throw new Error(s3);
      }
      const { topic: e9 } = t4;
      this.checkRecentlyDeleted(e9), await this.isValidSessionTopic(e9);
    }), c2(this, "isValidRequest", async (t4) => {
      if (!Aa(t4)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `request() params: ${t4}`);
        throw new Error(a4);
      }
      const { topic: e9, request: s3, chainId: i6, expiry: r6 } = t4;
      this.checkRecentlyDeleted(e9), await this.isValidSessionTopic(e9);
      const { namespaces: n4 } = this.client.session.get(e9);
      if (!_a(n4, i6)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `request() chainId: ${i6}`);
        throw new Error(a4);
      }
      if (!Na(s3)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `request() ${JSON.stringify(s3)}`);
        throw new Error(a4);
      }
      if (!Ta(n4, i6, s3.method)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `request() method: ${s3.method}`);
        throw new Error(a4);
      }
      if (r6 && !La(r6, _e4)) {
        const { message: a4 } = Et("MISSING_OR_INVALID", `request() expiry: ${r6}. Expiry must be a number (in seconds) between ${_e4.min} and ${_e4.max}`);
        throw new Error(a4);
      }
    }), c2(this, "isValidRespond", async (t4) => {
      var e9;
      if (!Aa(t4)) {
        const { message: r6 } = Et("MISSING_OR_INVALID", `respond() params: ${t4}`);
        throw new Error(r6);
      }
      const { topic: s3, response: i6 } = t4;
      try {
        await this.isValidSessionTopic(s3);
      } catch (r6) {
        throw (e9 = t4?.response) != null && e9.id && this.cleanupAfterResponse(t4), r6;
      }
      if (!Oa(i6)) {
        const { message: r6 } = Et("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i6)}`);
        throw new Error(r6);
      }
    }), c2(this, "isValidPing", async (t4) => {
      if (!Aa(t4)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `ping() params: ${t4}`);
        throw new Error(s3);
      }
      const { topic: e9 } = t4;
      await this.isValidSessionOrPairingTopic(e9);
    }), c2(this, "isValidEmit", async (t4) => {
      if (!Aa(t4)) {
        const { message: n4 } = Et("MISSING_OR_INVALID", `emit() params: ${t4}`);
        throw new Error(n4);
      }
      const { topic: e9, event: s3, chainId: i6 } = t4;
      await this.isValidSessionTopic(e9);
      const { namespaces: r6 } = this.client.session.get(e9);
      if (!_a(r6, i6)) {
        const { message: n4 } = Et("MISSING_OR_INVALID", `emit() chainId: ${i6}`);
        throw new Error(n4);
      }
      if (!Ua(s3)) {
        const { message: n4 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(n4);
      }
      if (!Ra(r6, i6, s3.name)) {
        const { message: n4 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(n4);
      }
    }), c2(this, "isValidDisconnect", async (t4) => {
      if (!Aa(t4)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `disconnect() params: ${t4}`);
        throw new Error(s3);
      }
      const { topic: e9 } = t4;
      await this.isValidSessionOrPairingTopic(e9);
    }), c2(this, "isValidAuthenticate", (t4) => {
      const { chains: e9, uri: s3, domain: i6, nonce: r6 } = t4;
      if (!Array.isArray(e9) || e9.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!it(s3, false)) throw new Error("uri is required parameter");
      if (!it(i6, false)) throw new Error("domain is required parameter");
      if (!it(r6, false)) throw new Error("nonce is required parameter");
      if ([...new Set(e9.map((a4) => Fe(a4).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = Fe(e9[0]);
      if (n4 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c2(this, "getVerifyContext", async (t4) => {
      const { attestationId: e9, hash: s3, encryptedId: i6, metadata: r6, transportType: n4 } = t4, a4 = { verified: { verifyUrl: r6.verifyUrl || ue3, validation: "UNKNOWN", origin: r6.url || "" } };
      try {
        if (n4 === Q3.link_mode) {
          const p7 = this.getAppLinkIfEnabled(r6, n4);
          return a4.verified.validation = p7 && new URL(p7).origin === new URL(r6.url).origin ? "VALID" : "INVALID", a4;
        }
        const l6 = await this.client.core.verify.resolve({ attestationId: e9, hash: s3, encryptedId: i6, verifyUrl: r6.verifyUrl });
        l6 && (a4.verified.origin = l6.origin, a4.verified.isScam = l6.isScam, a4.verified.validation = l6.origin === new URL(r6.url).origin ? "VALID" : "INVALID");
      } catch (l6) {
        this.client.logger.warn(l6);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a4)}`), a4;
    }), c2(this, "validateSessionProps", (t4, e9) => {
      Object.values(t4).forEach((s3, i6) => {
        if (s3 == null) {
          const { message: r6 } = Et("MISSING_OR_INVALID", `${e9} must contain an existing value for each key. Received: ${s3} for key ${Object.keys(t4)[i6]}`);
          throw new Error(r6);
        }
      });
    }), c2(this, "getPendingAuthRequest", (t4) => {
      const e9 = this.client.auth.requests.get(t4);
      return typeof e9 == "object" ? e9 : void 0;
    }), c2(this, "addToRecentlyDeleted", (t4, e9) => {
      if (this.recentlyDeletedMap.set(t4, e9), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s3 = 0;
        const i6 = this.recentlyDeletedLimit / 2;
        for (const r6 of this.recentlyDeletedMap.keys()) {
          if (s3++ >= i6) break;
          this.recentlyDeletedMap.delete(r6);
        }
      }
    }), c2(this, "checkRecentlyDeleted", (t4) => {
      const e9 = this.recentlyDeletedMap.get(t4);
      if (e9) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${e9}: ${t4}`);
        throw new Error(s3);
      }
    }), c2(this, "isLinkModeEnabled", (t4, e9) => {
      var s3, i6, r6, n4, a4, l6, p7, h7, u6;
      return !t4 || e9 !== Q3.link_mode ? false : ((i6 = (s3 = this.client.metadata) == null ? void 0 : s3.redirect) == null ? void 0 : i6.linkMode) === true && ((n4 = (r6 = this.client.metadata) == null ? void 0 : r6.redirect) == null ? void 0 : n4.universal) !== void 0 && ((l6 = (a4 = this.client.metadata) == null ? void 0 : a4.redirect) == null ? void 0 : l6.universal) !== "" && ((p7 = t4?.redirect) == null ? void 0 : p7.universal) !== void 0 && ((h7 = t4?.redirect) == null ? void 0 : h7.universal) !== "" && ((u6 = t4?.redirect) == null ? void 0 : u6.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t4.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c2(this, "getAppLinkIfEnabled", (t4, e9) => {
      var s3;
      return this.isLinkModeEnabled(t4, e9) ? (s3 = t4?.redirect) == null ? void 0 : s3.universal : void 0;
    }), c2(this, "handleLinkModeMessage", ({ url: t4 }) => {
      if (!t4 || !t4.includes("wc_ev") || !t4.includes("topic")) return;
      const e9 = li(t4, "topic") || "", s3 = decodeURIComponent(li(t4, "wc_ev") || ""), i6 = this.client.session.keys.includes(e9);
      i6 && this.client.session.update(e9, { transportType: Q3.link_mode }), this.client.core.dispatchEnvelope({ topic: e9, message: s3, sessionExists: i6 });
    }), c2(this, "registerLinkModeListeners", async () => {
      var t4;
      if (hi() || Bt() && (t4 = this.client.metadata.redirect) != null && t4.linkMode) {
        const e9 = global == null ? void 0 : global.Linking;
        if (typeof e9 < "u") {
          e9.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s3 = await e9.getInitialURL();
          s3 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s3 });
          }, 50);
        }
      }
    }), c2(this, "getTVFParams", (t4, e9, s3) => {
      var i6, r6, n4;
      if (!((i6 = e9.request) != null && i6.method)) return {};
      const a4 = { correlationId: t4, rpcMethods: [e9.request.method], chainId: e9.chainId };
      try {
        const l6 = this.extractTxHashesFromResult(e9.request, s3);
        a4.txHashes = l6, a4.contractAddresses = this.isValidContractData(e9.request.params) ? [(n4 = (r6 = e9.request.params) == null ? void 0 : r6[0]) == null ? void 0 : n4.to] : [];
      } catch (l6) {
        this.client.logger.warn("Error getting TVF params", l6);
      }
      return a4;
    }), c2(this, "isValidContractData", (t4) => {
      var e9;
      if (!t4) return false;
      try {
        const s3 = t4?.data || ((e9 = t4?.[0]) == null ? void 0 : e9.data);
        if (!s3.startsWith("0x")) return false;
        const i6 = s3.slice(2);
        return /^[0-9a-fA-F]*$/.test(i6) ? i6.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c2(this, "extractTxHashesFromResult", (t4, e9) => {
      var s3;
      try {
        if (!e9) return [];
        const i6 = t4.method, r6 = gt3[i6];
        if (i6 === "sui_signTransaction") return [ff(e9.transactionBytes)];
        if (i6 === "near_signTransaction") return [cf(e9)];
        if (i6 === "near_signTransactions") return e9.map((a4) => cf(a4));
        if (i6 === "xrpl_signTransactionFor" || i6 === "xrpl_signTransaction") return [(s3 = e9.tx_json) == null ? void 0 : s3.hash];
        if (i6 === "polkadot_signTransaction") return [Ka({ transaction: t4.params.transactionPayload, signature: e9.signature })];
        if (i6 === "algo_signTxn") return me2(e9) ? e9.map((a4) => af(a4)) : [af(e9)];
        if (i6 === "cosmos_signDirect") return [uf(e9)];
        if (typeof e9 == "string") return [e9];
        const n4 = e9[r6.key];
        if (me2(n4)) return i6 === "solana_signAllTransactions" ? n4.map((a4) => sf(a4)) : n4;
        if (typeof n4 == "string") return [n4];
      } catch (i6) {
        this.client.logger.warn("Error extracting tx hashes from result", i6);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const o4 = this.client.session.keys, t4 = this.client.core.relayer.messages.getWithoutAck(o4);
      for (const [e9, s3] of Object.entries(t4)) for (const i6 of s3) try {
        await this.onProviderMessageEvent({ topic: e9, message: i6, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${e9}, message: ${i6}`);
      }
    } catch (o4) {
      this.client.logger.warn("processPendingMessageEvents failed", o4);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o4 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(o4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C2.message, (o4) => {
      this.onProviderMessageEvent(o4);
    });
  }
  async onRelayMessage(o4) {
    const { topic: t4, message: e9, attestation: s3, transportType: i6 } = o4, { publicKey: r6 } = this.client.auth.authKeys.keys.includes(ce3) ? this.client.auth.authKeys.get(ce3) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const n4 = await this.client.core.crypto.decode(t4, e9, { receiverPublicKey: r6, encoding: i6 === Q3.link_mode ? De : Qt });
      isJsonRpcRequest(n4) ? (this.client.core.history.set(t4, n4), await this.onRelayEventRequest({ topic: t4, payload: n4, attestation: s3, transportType: i6, encryptedId: zc(e9) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: t4, payload: n4, transportType: i6 }), this.client.core.history.delete(t4, n4.id)) : await this.onRelayEventUnknownPayload({ topic: t4, payload: n4, transportType: i6 }), await this.client.core.relayer.messages.ack(t4, e9);
    } catch (n4) {
      this.client.logger.error(n4);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M2.expired, async (o4) => {
      const { topic: t4, id: e9 } = si(o4.target);
      if (e9 && this.client.pendingRequest.keys.includes(e9)) return await this.deletePendingSessionRequest(e9, Et("EXPIRED"), true);
      if (e9 && this.client.auth.requests.keys.includes(e9)) return await this.deletePendingAuthRequest(e9, Et("EXPIRED"), true);
      t4 ? this.client.session.keys.includes(t4) && (await this.deleteSession({ topic: t4, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t4 })) : e9 && (await this.deleteProposal(e9, true), this.client.events.emit("proposal_expire", { id: e9 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(re.create, (o4) => this.onPairingCreated(o4)), this.client.core.pairing.events.on(re.delete, (o4) => {
      this.addToRecentlyDeleted(o4.topic, "pairing");
    });
  }
  isValidPairingTopic(o4) {
    if (!it(o4, false)) {
      const { message: t4 } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${o4}`);
      throw new Error(t4);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o4)) {
      const { message: t4 } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o4}`);
      throw new Error(t4);
    }
    if (fi(this.client.core.pairing.pairings.get(o4).expiry)) {
      const { message: t4 } = Et("EXPIRED", `pairing topic: ${o4}`);
      throw new Error(t4);
    }
  }
  async isValidSessionTopic(o4) {
    if (!it(o4, false)) {
      const { message: t4 } = Et("MISSING_OR_INVALID", `session topic should be a string: ${o4}`);
      throw new Error(t4);
    }
    if (this.checkRecentlyDeleted(o4), !this.client.session.keys.includes(o4)) {
      const { message: t4 } = Et("NO_MATCHING_KEY", `session topic doesn't exist: ${o4}`);
      throw new Error(t4);
    }
    if (fi(this.client.session.get(o4).expiry)) {
      await this.deleteSession({ topic: o4 });
      const { message: t4 } = Et("EXPIRED", `session topic: ${o4}`);
      throw new Error(t4);
    }
    if (!this.client.core.crypto.keychain.has(o4)) {
      const { message: t4 } = Et("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o4}`);
      throw await this.deleteSession({ topic: o4 }), new Error(t4);
    }
  }
  async isValidSessionOrPairingTopic(o4) {
    if (this.checkRecentlyDeleted(o4), this.client.session.keys.includes(o4)) await this.isValidSessionTopic(o4);
    else if (this.client.core.pairing.pairings.keys.includes(o4)) this.isValidPairingTopic(o4);
    else if (it(o4, false)) {
      const { message: t4 } = Et("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o4}`);
      throw new Error(t4);
    } else {
      const { message: t4 } = Et("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o4}`);
      throw new Error(t4);
    }
  }
  async isValidProposalId(o4) {
    if (!Ia(o4)) {
      const { message: t4 } = Et("MISSING_OR_INVALID", `proposal id should be a number: ${o4}`);
      throw new Error(t4);
    }
    if (!this.client.proposal.keys.includes(o4)) {
      const { message: t4 } = Et("NO_MATCHING_KEY", `proposal id doesn't exist: ${o4}`);
      throw new Error(t4);
    }
    if (fi(this.client.proposal.get(o4).expiryTimestamp)) {
      await this.deleteProposal(o4);
      const { message: t4 } = Et("EXPIRED", `proposal id: ${o4}`);
      throw new Error(t4);
    }
  }
};
var ks2 = class extends Li3 {
  constructor(o4, t4) {
    super(o4, t4, ht3, me3), this.core = o4, this.logger = t4;
  }
};
var vt3 = class extends Li3 {
  constructor(o4, t4) {
    super(o4, t4, dt3, me3), this.core = o4, this.logger = t4;
  }
};
var Ds = class extends Li3 {
  constructor(o4, t4) {
    super(o4, t4, yt, me3, (e9) => e9.id), this.core = o4, this.logger = t4;
  }
};
var Ls2 = class extends Li3 {
  constructor(o4, t4) {
    super(o4, t4, Et3, ae3, () => ce3), this.core = o4, this.logger = t4;
  }
};
var Ms2 = class extends Li3 {
  constructor(o4, t4) {
    super(o4, t4, ft, ae3), this.core = o4, this.logger = t4;
  }
};
var $s2 = class extends Li3 {
  constructor(o4, t4) {
    super(o4, t4, St4, ae3, (e9) => e9.id), this.core = o4, this.logger = t4;
  }
};
var Ks2 = Object.defineProperty;
var Us = (S7, o4, t4) => o4 in S7 ? Ks2(S7, o4, { enumerable: true, configurable: true, writable: true, value: t4 }) : S7[o4] = t4;
var Ke4 = (S7, o4, t4) => Us(S7, typeof o4 != "symbol" ? o4 + "" : o4, t4);
var Gs2 = class {
  constructor(o4, t4) {
    this.core = o4, this.logger = t4, Ke4(this, "authKeys"), Ke4(this, "pairingTopics"), Ke4(this, "requests"), this.authKeys = new Ls2(this.core, this.logger), this.pairingTopics = new Ms2(this.core, this.logger), this.requests = new $s2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var js2 = Object.defineProperty;
var Fs = (S7, o4, t4) => o4 in S7 ? js2(S7, o4, { enumerable: true, configurable: true, writable: true, value: t4 }) : S7[o4] = t4;
var f5 = (S7, o4, t4) => Fs(S7, typeof o4 != "symbol" ? o4 + "" : o4, t4);
var Ee2 = class _Ee extends J {
  constructor(o4) {
    super(o4), f5(this, "protocol", Ce4), f5(this, "version", ke4), f5(this, "name", we2.name), f5(this, "metadata"), f5(this, "core"), f5(this, "logger"), f5(this, "events", new import_events4.EventEmitter()), f5(this, "engine"), f5(this, "session"), f5(this, "proposal"), f5(this, "pendingRequest"), f5(this, "auth"), f5(this, "signConfig"), f5(this, "on", (e9, s3) => this.events.on(e9, s3)), f5(this, "once", (e9, s3) => this.events.once(e9, s3)), f5(this, "off", (e9, s3) => this.events.off(e9, s3)), f5(this, "removeListener", (e9, s3) => this.events.removeListener(e9, s3)), f5(this, "removeAllListeners", (e9) => this.events.removeAllListeners(e9)), f5(this, "connect", async (e9) => {
      try {
        return await this.engine.connect(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "pair", async (e9) => {
      try {
        return await this.engine.pair(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "approve", async (e9) => {
      try {
        return await this.engine.approve(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "reject", async (e9) => {
      try {
        return await this.engine.reject(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "update", async (e9) => {
      try {
        return await this.engine.update(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "extend", async (e9) => {
      try {
        return await this.engine.extend(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "request", async (e9) => {
      try {
        return await this.engine.request(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "respond", async (e9) => {
      try {
        return await this.engine.respond(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "ping", async (e9) => {
      try {
        return await this.engine.ping(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "emit", async (e9) => {
      try {
        return await this.engine.emit(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "disconnect", async (e9) => {
      try {
        return await this.engine.disconnect(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "find", (e9) => {
      try {
        return this.engine.find(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e9) {
        throw this.logger.error(e9.message), e9;
      }
    }), f5(this, "authenticate", async (e9, s3) => {
      try {
        return await this.engine.authenticate(e9, s3);
      } catch (i6) {
        throw this.logger.error(i6.message), i6;
      }
    }), f5(this, "formatAuthMessage", (e9) => {
      try {
        return this.engine.formatAuthMessage(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "approveSessionAuthenticate", async (e9) => {
      try {
        return await this.engine.approveSessionAuthenticate(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "rejectSessionAuthenticate", async (e9) => {
      try {
        return await this.engine.rejectSessionAuthenticate(e9);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), this.name = o4?.name || we2.name, this.metadata = Ks(o4?.metadata), this.signConfig = o4?.signConfig;
    const t4 = typeof o4?.logger < "u" && typeof o4?.logger != "string" ? o4.logger : (0, import_pino.default)(k({ level: o4?.logger || we2.logger }));
    this.core = o4?.core || new Zo2(o4), this.logger = E(t4, this.name), this.session = new vt3(this.core, this.logger), this.proposal = new ks2(this.core, this.logger), this.pendingRequest = new Ds(this.core, this.logger), this.engine = new Cs2(this), this.auth = new Gs2(this.core, this.logger);
  }
  static async init(o4) {
    const t4 = new _Ee(o4);
    return await t4.initialize(), t4;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (o4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o4.message), o4;
    }
  }
};

// node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/dist/index.es.js
var import_time5 = __toESM(require_cjs());
var import_window_getters4 = __toESM(require_cjs6());
var import_window_metadata3 = __toESM(require_cjs7());

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType3 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction3(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber4(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber4(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType3[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList3(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction3 = defineFormatter3("transaction", formatTransaction3);
function formatAuthorizationList3(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock3(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction3(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock3 = defineFormatter3("block", formatBlock3);

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount3(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex3(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber4(count);
}

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction3 = 6;
var bytesPerFieldElement3 = 32;
var fieldElementsPerBlob3 = 4096;
var bytesPerBlob3 = bytesPerFieldElement3 * fieldElementsPerBlob3;
var maxBytesPerTransaction3 = bytesPerBlob3 * blobsPerTransaction3 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob3 * blobsPerTransaction3;

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/formatters/log.js
function formatLog3(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace3 = new LruMap3(128);

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses3 = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt3(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog3(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber4(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses3[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType3[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt3 = defineFormatter3("transactionReceipt", formatTransactionReceipt3);

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier3 = numberToHex3(0, {
  size: 32
});

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache3 = new LruMap3(8192);

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore3() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache3 = createIdStore3();

// node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager3(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap3(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc3() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount3(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager3 = createNonceManager3({
  source: jsonRpc3()
});

// node_modules/@walletconnect/universal-provider/node_modules/ox/_esm/core/Hash.js
function keccak2566(value2, options = {}) {
  const { as: as3 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from3(value2));
  if (as3 === "Bytes")
    return bytes;
  return fromBytes3(bytes);
}

// node_modules/@walletconnect/universal-provider/node_modules/ox/_esm/core/internal/lru.js
var LruMap6 = class extends Map {
  constructor(size10) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size10;
  }
  get(key) {
    const value2 = super.get(key);
    if (super.has(key) && value2 !== void 0) {
      this.delete(key);
      super.set(key, value2);
    }
    return value2;
  }
  set(key, value2) {
    super.set(key, value2);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@walletconnect/universal-provider/node_modules/ox/_esm/core/Caches.js
var caches3 = {
  checksum: new LruMap6(8192)
};
var checksum5 = caches3.checksum;

// node_modules/@walletconnect/universal-provider/node_modules/ox/_esm/core/Address.js
var addressRegex3 = /^0x[a-fA-F0-9]{40}$/;
function assert3(value2, options = {}) {
  const { strict = true } = options;
  if (!addressRegex3.test(value2))
    throw new InvalidAddressError6({
      address: value2,
      cause: new InvalidInputError3()
    });
  if (strict) {
    if (value2.toLowerCase() === value2)
      return;
    if (checksum6(value2) !== value2)
      throw new InvalidAddressError6({
        address: value2,
        cause: new InvalidChecksumError3()
      });
  }
}
function checksum6(address) {
  if (checksum5.has(address))
    return checksum5.get(address);
  assert3(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2566(fromString5(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i6 = 0; i6 < 40; i6 += 2) {
    if (hash[i6 >> 1] >> 4 >= 8 && characters[i6]) {
      characters[i6] = characters[i6].toUpperCase();
    }
    if ((hash[i6 >> 1] & 15) >= 8 && characters[i6 + 1]) {
      characters[i6 + 1] = characters[i6 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum5.set(address, result);
  return result;
}
var InvalidAddressError6 = class extends BaseError4 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError3 = class extends BaseError4 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError3 = class extends BaseError4 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@walletconnect/universal-provider/node_modules/ox/_esm/core/Solidity.js
var arrayRegex6 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex6 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex6 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt85 = 2n ** (8n - 1n) - 1n;
var maxInt165 = 2n ** (16n - 1n) - 1n;
var maxInt245 = 2n ** (24n - 1n) - 1n;
var maxInt325 = 2n ** (32n - 1n) - 1n;
var maxInt405 = 2n ** (40n - 1n) - 1n;
var maxInt485 = 2n ** (48n - 1n) - 1n;
var maxInt565 = 2n ** (56n - 1n) - 1n;
var maxInt645 = 2n ** (64n - 1n) - 1n;
var maxInt725 = 2n ** (72n - 1n) - 1n;
var maxInt805 = 2n ** (80n - 1n) - 1n;
var maxInt885 = 2n ** (88n - 1n) - 1n;
var maxInt965 = 2n ** (96n - 1n) - 1n;
var maxInt1045 = 2n ** (104n - 1n) - 1n;
var maxInt1125 = 2n ** (112n - 1n) - 1n;
var maxInt1205 = 2n ** (120n - 1n) - 1n;
var maxInt1285 = 2n ** (128n - 1n) - 1n;
var maxInt1365 = 2n ** (136n - 1n) - 1n;
var maxInt1445 = 2n ** (144n - 1n) - 1n;
var maxInt1525 = 2n ** (152n - 1n) - 1n;
var maxInt1605 = 2n ** (160n - 1n) - 1n;
var maxInt1685 = 2n ** (168n - 1n) - 1n;
var maxInt1765 = 2n ** (176n - 1n) - 1n;
var maxInt1845 = 2n ** (184n - 1n) - 1n;
var maxInt1925 = 2n ** (192n - 1n) - 1n;
var maxInt2005 = 2n ** (200n - 1n) - 1n;
var maxInt2085 = 2n ** (208n - 1n) - 1n;
var maxInt2165 = 2n ** (216n - 1n) - 1n;
var maxInt2245 = 2n ** (224n - 1n) - 1n;
var maxInt2325 = 2n ** (232n - 1n) - 1n;
var maxInt2405 = 2n ** (240n - 1n) - 1n;
var maxInt2485 = 2n ** (248n - 1n) - 1n;
var maxInt2565 = 2n ** (256n - 1n) - 1n;
var minInt85 = -(2n ** (8n - 1n));
var minInt165 = -(2n ** (16n - 1n));
var minInt245 = -(2n ** (24n - 1n));
var minInt325 = -(2n ** (32n - 1n));
var minInt405 = -(2n ** (40n - 1n));
var minInt485 = -(2n ** (48n - 1n));
var minInt565 = -(2n ** (56n - 1n));
var minInt645 = -(2n ** (64n - 1n));
var minInt725 = -(2n ** (72n - 1n));
var minInt805 = -(2n ** (80n - 1n));
var minInt885 = -(2n ** (88n - 1n));
var minInt965 = -(2n ** (96n - 1n));
var minInt1045 = -(2n ** (104n - 1n));
var minInt1125 = -(2n ** (112n - 1n));
var minInt1205 = -(2n ** (120n - 1n));
var minInt1285 = -(2n ** (128n - 1n));
var minInt1365 = -(2n ** (136n - 1n));
var minInt1445 = -(2n ** (144n - 1n));
var minInt1525 = -(2n ** (152n - 1n));
var minInt1605 = -(2n ** (160n - 1n));
var minInt1685 = -(2n ** (168n - 1n));
var minInt1765 = -(2n ** (176n - 1n));
var minInt1845 = -(2n ** (184n - 1n));
var minInt1925 = -(2n ** (192n - 1n));
var minInt2005 = -(2n ** (200n - 1n));
var minInt2085 = -(2n ** (208n - 1n));
var minInt2165 = -(2n ** (216n - 1n));
var minInt2245 = -(2n ** (224n - 1n));
var minInt2325 = -(2n ** (232n - 1n));
var minInt2405 = -(2n ** (240n - 1n));
var minInt2485 = -(2n ** (248n - 1n));
var minInt2565 = -(2n ** (256n - 1n));
var maxUint85 = 2n ** 8n - 1n;
var maxUint165 = 2n ** 16n - 1n;
var maxUint245 = 2n ** 24n - 1n;
var maxUint325 = 2n ** 32n - 1n;
var maxUint405 = 2n ** 40n - 1n;
var maxUint485 = 2n ** 48n - 1n;
var maxUint565 = 2n ** 56n - 1n;
var maxUint645 = 2n ** 64n - 1n;
var maxUint725 = 2n ** 72n - 1n;
var maxUint805 = 2n ** 80n - 1n;
var maxUint885 = 2n ** 88n - 1n;
var maxUint965 = 2n ** 96n - 1n;
var maxUint1045 = 2n ** 104n - 1n;
var maxUint1125 = 2n ** 112n - 1n;
var maxUint1205 = 2n ** 120n - 1n;
var maxUint1285 = 2n ** 128n - 1n;
var maxUint1365 = 2n ** 136n - 1n;
var maxUint1445 = 2n ** 144n - 1n;
var maxUint1525 = 2n ** 152n - 1n;
var maxUint1605 = 2n ** 160n - 1n;
var maxUint1685 = 2n ** 168n - 1n;
var maxUint1765 = 2n ** 176n - 1n;
var maxUint1845 = 2n ** 184n - 1n;
var maxUint1925 = 2n ** 192n - 1n;
var maxUint2005 = 2n ** 200n - 1n;
var maxUint2085 = 2n ** 208n - 1n;
var maxUint2165 = 2n ** 216n - 1n;
var maxUint2245 = 2n ** 224n - 1n;
var maxUint2325 = 2n ** 232n - 1n;
var maxUint2405 = 2n ** 240n - 1n;
var maxUint2485 = 2n ** 248n - 1n;
var maxUint2566 = 2n ** 256n - 1n;

// node_modules/@walletconnect/universal-provider/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor3 = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError3({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError6({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError3({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError3({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value2) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value2;
    this.position++;
  },
  pushUint16(value2) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value2);
    this.position += 2;
  },
  pushUint24(value2) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value2 >> 8);
    this.dataView.setUint8(this.position + 2, value2 & ~4294967040);
    this.position += 3;
  },
  pushUint32(value2) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value2);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectByte();
    this.position++;
    return value2;
  },
  readBytes(length, size10) {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectBytes(length);
    this.position += size10 ?? length;
    return value2;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint8();
    this.position += 1;
    return value2;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint16();
    this.position += 2;
    return value2;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint24();
    this.position += 3;
    return value2;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint32();
    this.position += 4;
    return value2;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError3 = class extends BaseError4 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError6 = class extends BaseError4 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError3 = class extends BaseError4 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@walletconnect/universal-provider/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked6(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError3({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i6 = 0; i6 < types.length; i6++) {
    const type = types[i6];
    const value2 = values[i6];
    data.push(encodePacked6.encode(type, value2));
  }
  return concat3(...data);
}
(function(encodePacked7) {
  function encode12(type, value2, isArray = false) {
    if (type === "address") {
      const address = value2;
      assert3(address);
      return padLeft3(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString6(value2);
    if (type === "bytes")
      return value2;
    if (type === "bool")
      return padLeft3(fromBoolean3(value2), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex6);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size10 = Number.parseInt(bits) / 8;
      return fromNumber3(value2, {
        size: isArray ? 32 : size10,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex6);
    if (bytesMatch) {
      const [_type, size10] = bytesMatch;
      if (Number.parseInt(size10) !== (value2.length - 2) / 2)
        throw new BytesSizeMismatchError6({
          expectedSize: Number.parseInt(size10),
          value: value2
        });
      return padRight3(value2, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex6);
    if (arrayMatch && Array.isArray(value2)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i6 = 0; i6 < value2.length; i6++) {
        data.push(encode12(childType, value2[i6], true));
      }
      if (data.length === 0)
        return "0x";
      return concat3(...data);
    }
    throw new InvalidTypeError3(type);
  }
  encodePacked7.encode = encode12;
})(encodePacked6 || (encodePacked6 = {}));
var BytesSizeMismatchError6 = class extends BaseError4 {
  constructor({ expectedSize, value: value2 }) {
    super(`Size of bytes "${value2}" (bytes${size4(value2)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError3 = class extends BaseError4 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError3 = class extends BaseError4 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@walletconnect/universal-provider/node_modules/base-x/src/esm/index.js
function base3(ALPHABET4) {
  if (ALPHABET4.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j6 = 0; j6 < BASE_MAP.length; j6++) {
    BASE_MAP[j6] = 255;
  }
  for (let i6 = 0; i6 < ALPHABET4.length; i6++) {
    const x5 = ALPHABET4.charAt(i6);
    const xc5 = x5.charCodeAt(0);
    if (BASE_MAP[xc5] !== 255) {
      throw new TypeError(x5 + " is ambiguous");
    }
    BASE_MAP[xc5] = i6;
  }
  const BASE = ALPHABET4.length;
  const LEADER = ALPHABET4.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode12(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size10 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size10);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i6 = 0;
      for (let it1 = size10 - 1; (carry !== 0 || i6 < length) && it1 !== -1; it1--, i6++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i6;
      pbegin++;
    }
    let it22 = size10 - length;
    while (it22 !== size10 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size10; ++it22) {
      str += ALPHABET4.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size10 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size10);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i6 = 0;
      for (let it32 = size10 - 1; (carry !== 0 || i6 < length) && it32 !== -1; it32--, i6++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i6;
      psz++;
    }
    let it4 = size10 - length;
    while (it4 !== size10 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size10 - it4));
    let j6 = zeroes;
    while (it4 !== size10) {
      vch[j6++] = b256[it4++];
    }
    return vch;
  }
  function decode7(string4) {
    const buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode12,
    decodeUnsafe,
    decode: decode7
  };
}
var esm_default5 = base3;

// node_modules/@walletconnect/universal-provider/node_modules/bs58/src/esm/index.js
var ALPHABET3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default6 = esm_default5(ALPHABET3);

// node_modules/@walletconnect/universal-provider/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array3(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@walletconnect/universal-provider/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe3(size10 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array3(globalThis.Buffer.allocUnsafe(size10));
  }
  return new Uint8Array(size10);
}

// node_modules/@walletconnect/universal-provider/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec3(name, prefix, encode12, decode7) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode12
    },
    decoder: { decode: decode7 }
  };
}
var string3 = createCodec3("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii3 = createCodec3("ascii", "a", (buf) => {
  let string4 = "a";
  for (let i6 = 0; i6 < buf.length; i6++) {
    string4 += String.fromCharCode(buf[i6]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe3(str.length);
  for (let i6 = 0; i6 < str.length; i6++) {
    buf[i6] = str.charCodeAt(i6);
  }
  return buf;
});
var BASES3 = {
  utf8: string3,
  "utf-8": string3,
  hex: bases.base16,
  latin1: ascii3,
  ascii: ascii3,
  binary: ascii3,
  ...bases
};

// node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs3 = __toESM(require_blakejs());
var xe2 = ":";
function Fe3(t4) {
  const [e9, n4] = t4.split(xe2);
  return { namespace: e9, reference: n4 };
}
function ct3(t4 = [], e9 = []) {
  return [.../* @__PURE__ */ new Set([...t4, ...e9])];
}
var Be4 = BigInt(2 ** 32 - 1);
var yr4 = BigInt(32);
function mr4(t4, e9 = false) {
  return e9 ? { h: Number(t4 & Be4), l: Number(t4 >> yr4 & Be4) } : { h: Number(t4 >> yr4 & Be4) | 0, l: Number(t4 & Be4) | 0 };
}
function wr4(t4, e9 = false) {
  const n4 = t4.length;
  let r6 = new Uint32Array(n4), o4 = new Uint32Array(n4);
  for (let s3 = 0; s3 < n4; s3++) {
    const { h: i6, l: f12 } = mr4(t4[s3], e9);
    [r6[s3], o4[s3]] = [i6, f12];
  }
  return [r6, o4];
}
var xr4 = (t4, e9, n4) => t4 >>> n4;
var vr4 = (t4, e9, n4) => t4 << 32 - n4 | e9 >>> n4;
var At4 = (t4, e9, n4) => t4 >>> n4 | e9 << 32 - n4;
var St5 = (t4, e9, n4) => t4 << 32 - n4 | e9 >>> n4;
var se4 = (t4, e9, n4) => t4 << 64 - n4 | e9 >>> n4 - 32;
var ie4 = (t4, e9, n4) => t4 >>> n4 - 32 | e9 << 64 - n4;
var bi4 = (t4, e9) => e9;
var yi4 = (t4, e9) => t4;
var mi4 = (t4, e9, n4) => t4 << n4 | e9 >>> 32 - n4;
var wi4 = (t4, e9, n4) => e9 << n4 | t4 >>> 32 - n4;
var xi4 = (t4, e9, n4) => e9 << n4 - 32 | t4 >>> 64 - n4;
var vi4 = (t4, e9, n4) => t4 << n4 - 32 | e9 >>> 64 - n4;
function dt4(t4, e9, n4, r6) {
  const o4 = (e9 >>> 0) + (r6 >>> 0);
  return { h: t4 + n4 + (o4 / 2 ** 32 | 0) | 0, l: o4 | 0 };
}
var tn4 = (t4, e9, n4) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0);
var en4 = (t4, e9, n4, r6) => e9 + n4 + r6 + (t4 / 2 ** 32 | 0) | 0;
var Ei4 = (t4, e9, n4, r6) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0) + (r6 >>> 0);
var Bi4 = (t4, e9, n4, r6, o4) => e9 + n4 + r6 + o4 + (t4 / 2 ** 32 | 0) | 0;
var Ii4 = (t4, e9, n4, r6, o4) => (t4 >>> 0) + (e9 >>> 0) + (n4 >>> 0) + (r6 >>> 0) + (o4 >>> 0);
var Ai4 = (t4, e9, n4, r6, o4, s3) => e9 + n4 + r6 + o4 + s3 + (t4 / 2 ** 32 | 0) | 0;
var Gt4 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn4(t4) {
  return t4 instanceof Uint8Array || ArrayBuffer.isView(t4) && t4.constructor.name === "Uint8Array";
}
function mt4(t4) {
  if (!Number.isSafeInteger(t4) || t4 < 0) throw new Error("positive integer expected, got " + t4);
}
function at3(t4, ...e9) {
  if (!nn4(t4)) throw new Error("Uint8Array expected");
  if (e9.length > 0 && !e9.includes(t4.length)) throw new Error("Uint8Array expected of length " + e9 + ", got length=" + t4.length);
}
function rn4(t4) {
  if (typeof t4 != "function" || typeof t4.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt4(t4.outputLen), mt4(t4.blockLen);
}
function Nt4(t4, e9 = true) {
  if (t4.destroyed) throw new Error("Hash instance has been destroyed");
  if (e9 && t4.finished) throw new Error("Hash#digest() has already been called");
}
function on4(t4, e9) {
  at3(t4);
  const n4 = e9.outputLen;
  if (t4.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function fe4(t4) {
  return new Uint32Array(t4.buffer, t4.byteOffset, Math.floor(t4.byteLength / 4));
}
function ut4(...t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9].fill(0);
}
function sn5(t4) {
  return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
}
function gt4(t4, e9) {
  return t4 << 32 - e9 | t4 >>> e9;
}
var Er4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br4(t4) {
  return t4 << 24 & 4278190080 | t4 << 8 & 16711680 | t4 >>> 8 & 65280 | t4 >>> 24 & 255;
}
var wt4 = Er4 ? (t4) => t4 : (t4) => Br4(t4);
function Si4(t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9] = Br4(t4[e9]);
  return t4;
}
var Ot4 = Er4 ? (t4) => t4 : Si4;
var Ir4 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni4 = Array.from({ length: 256 }, (t4, e9) => e9.toString(16).padStart(2, "0"));
function ce4(t4) {
  if (at3(t4), Ir4) return t4.toHex();
  let e9 = "";
  for (let n4 = 0; n4 < t4.length; n4++) e9 += Ni4[t4[n4]];
  return e9;
}
var xt4 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar4(t4) {
  if (t4 >= xt4._0 && t4 <= xt4._9) return t4 - xt4._0;
  if (t4 >= xt4.A && t4 <= xt4.F) return t4 - (xt4.A - 10);
  if (t4 >= xt4.a && t4 <= xt4.f) return t4 - (xt4.a - 10);
}
function fn4(t4) {
  if (typeof t4 != "string") throw new Error("hex string expected, got " + typeof t4);
  if (Ir4) return Uint8Array.fromHex(t4);
  const e9 = t4.length, n4 = e9 / 2;
  if (e9 % 2) throw new Error("hex string expected, got unpadded hex of length " + e9);
  const r6 = new Uint8Array(n4);
  for (let o4 = 0, s3 = 0; o4 < n4; o4++, s3 += 2) {
    const i6 = Ar4(t4.charCodeAt(s3)), f12 = Ar4(t4.charCodeAt(s3 + 1));
    if (i6 === void 0 || f12 === void 0) {
      const a4 = t4[s3] + t4[s3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a4 + '" at index ' + s3);
    }
    r6[o4] = i6 * 16 + f12;
  }
  return r6;
}
function Oi4(t4) {
  if (typeof t4 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t4));
}
function ht4(t4) {
  return typeof t4 == "string" && (t4 = Oi4(t4)), at3(t4), t4;
}
function Ht4(...t4) {
  let e9 = 0;
  for (let r6 = 0; r6 < t4.length; r6++) {
    const o4 = t4[r6];
    at3(o4), e9 += o4.length;
  }
  const n4 = new Uint8Array(e9);
  for (let r6 = 0, o4 = 0; r6 < t4.length; r6++) {
    const s3 = t4[r6];
    n4.set(s3, o4), o4 += s3.length;
  }
  return n4;
}
var Ie4 = class {
};
function ae4(t4) {
  const e9 = (r6) => t4().update(ht4(r6)).digest(), n4 = t4();
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = () => t4(), e9;
}
function Ui4(t4) {
  const e9 = (r6, o4) => t4(o4).update(ht4(r6)).digest(), n4 = t4({});
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = (r6) => t4(r6), e9;
}
function Zt4(t4 = 32) {
  if (Gt4 && typeof Gt4.getRandomValues == "function") return Gt4.getRandomValues(new Uint8Array(t4));
  if (Gt4 && typeof Gt4.randomBytes == "function") return Uint8Array.from(Gt4.randomBytes(t4));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i4 = BigInt(0);
var ue4 = BigInt(1);
var Ti4 = BigInt(2);
var Ri4 = BigInt(7);
var $i4 = BigInt(256);
var Ci4 = BigInt(113);
var Sr4 = [];
var Nr4 = [];
var Or4 = [];
for (let t4 = 0, e9 = ue4, n4 = 1, r6 = 0; t4 < 24; t4++) {
  [n4, r6] = [r6, (2 * n4 + 3 * r6) % 5], Sr4.push(2 * (5 * r6 + n4)), Nr4.push((t4 + 1) * (t4 + 2) / 2 % 64);
  let o4 = _i4;
  for (let s3 = 0; s3 < 7; s3++) e9 = (e9 << ue4 ^ (e9 >> Ri4) * Ci4) % $i4, e9 & Ti4 && (o4 ^= ue4 << (ue4 << BigInt(s3)) - ue4);
  Or4.push(o4);
}
var Ur4 = wr4(Or4, true);
var Li4 = Ur4[0];
var ji4 = Ur4[1];
var _r4 = (t4, e9, n4) => n4 > 32 ? xi4(t4, e9, n4) : mi4(t4, e9, n4);
var Tr4 = (t4, e9, n4) => n4 > 32 ? vi4(t4, e9, n4) : wi4(t4, e9, n4);
function ki4(t4, e9 = 24) {
  const n4 = new Uint32Array(10);
  for (let r6 = 24 - e9; r6 < 24; r6++) {
    for (let i6 = 0; i6 < 10; i6++) n4[i6] = t4[i6] ^ t4[i6 + 10] ^ t4[i6 + 20] ^ t4[i6 + 30] ^ t4[i6 + 40];
    for (let i6 = 0; i6 < 10; i6 += 2) {
      const f12 = (i6 + 8) % 10, a4 = (i6 + 2) % 10, l6 = n4[a4], c6 = n4[a4 + 1], u6 = _r4(l6, c6, 1) ^ n4[f12], h7 = Tr4(l6, c6, 1) ^ n4[f12 + 1];
      for (let g3 = 0; g3 < 50; g3 += 10) t4[i6 + g3] ^= u6, t4[i6 + g3 + 1] ^= h7;
    }
    let o4 = t4[2], s3 = t4[3];
    for (let i6 = 0; i6 < 24; i6++) {
      const f12 = Nr4[i6], a4 = _r4(o4, s3, f12), l6 = Tr4(o4, s3, f12), c6 = Sr4[i6];
      o4 = t4[c6], s3 = t4[c6 + 1], t4[c6] = a4, t4[c6 + 1] = l6;
    }
    for (let i6 = 0; i6 < 50; i6 += 10) {
      for (let f12 = 0; f12 < 10; f12++) n4[f12] = t4[i6 + f12];
      for (let f12 = 0; f12 < 10; f12++) t4[i6 + f12] ^= ~n4[(f12 + 2) % 10] & n4[(f12 + 4) % 10];
    }
    t4[0] ^= Li4[r6], t4[1] ^= ji4[r6];
  }
  ut4(n4);
}
var qn4 = class _qn extends Ie4 {
  constructor(e9, n4, r6, o4 = false, s3 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e9, this.suffix = n4, this.outputLen = r6, this.enableXOF = o4, this.rounds = s3, mt4(r6), !(0 < e9 && e9 < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe4(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot4(this.state32), ki4(this.state32, this.rounds), Ot4(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e9) {
    Nt4(this), e9 = ht4(e9), at3(e9);
    const { blockLen: n4, state: r6 } = this, o4 = e9.length;
    for (let s3 = 0; s3 < o4; ) {
      const i6 = Math.min(n4 - this.pos, o4 - s3);
      for (let f12 = 0; f12 < i6; f12++) r6[this.pos++] ^= e9[s3++];
      this.pos === n4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e9, suffix: n4, pos: r6, blockLen: o4 } = this;
    e9[r6] ^= n4, (n4 & 128) !== 0 && r6 === o4 - 1 && this.keccak(), e9[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(e9) {
    Nt4(this, false), at3(e9), this.finish();
    const n4 = this.state, { blockLen: r6 } = this;
    for (let o4 = 0, s3 = e9.length; o4 < s3; ) {
      this.posOut >= r6 && this.keccak();
      const i6 = Math.min(r6 - this.posOut, s3 - o4);
      e9.set(n4.subarray(this.posOut, this.posOut + i6), o4), this.posOut += i6, o4 += i6;
    }
    return e9;
  }
  xofInto(e9) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e9);
  }
  xof(e9) {
    return mt4(e9), this.xofInto(new Uint8Array(e9));
  }
  digestInto(e9) {
    if (on4(e9, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e9), this.destroy(), e9;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut4(this.state);
  }
  _cloneInto(e9) {
    const { blockLen: n4, suffix: r6, outputLen: o4, rounds: s3, enableXOF: i6 } = this;
    return e9 || (e9 = new _qn(n4, r6, o4, i6, s3)), e9.state32.set(this.state32), e9.pos = this.pos, e9.posOut = this.posOut, e9.finished = this.finished, e9.rounds = s3, e9.suffix = r6, e9.outputLen = o4, e9.enableXOF = i6, e9.destroyed = this.destroyed, e9;
  }
};
var Pi4 = (t4, e9, n4) => ae4(() => new qn4(e9, t4, n4));
var Hi3 = Pi4(1, 136, 256 / 8);
function Di4(t4, e9, n4, r6) {
  if (typeof t4.setBigUint64 == "function") return t4.setBigUint64(e9, n4, r6);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i6 = Number(n4 >> o4 & s3), f12 = Number(n4 & s3), a4 = r6 ? 4 : 0, l6 = r6 ? 0 : 4;
  t4.setUint32(e9 + a4, i6, r6), t4.setUint32(e9 + l6, f12, r6);
}
function Mi4(t4, e9, n4) {
  return t4 & e9 ^ ~t4 & n4;
}
function Vi4(t4, e9, n4) {
  return t4 & e9 ^ t4 & n4 ^ e9 & n4;
}
var Rr4 = class extends Ie4 {
  constructor(e9, n4, r6, o4) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e9, this.outputLen = n4, this.padOffset = r6, this.isLE = o4, this.buffer = new Uint8Array(e9), this.view = sn5(this.buffer);
  }
  update(e9) {
    Nt4(this), e9 = ht4(e9), at3(e9);
    const { view: n4, buffer: r6, blockLen: o4 } = this, s3 = e9.length;
    for (let i6 = 0; i6 < s3; ) {
      const f12 = Math.min(o4 - this.pos, s3 - i6);
      if (f12 === o4) {
        const a4 = sn5(e9);
        for (; o4 <= s3 - i6; i6 += o4) this.process(a4, i6);
        continue;
      }
      r6.set(e9.subarray(i6, i6 + f12), this.pos), this.pos += f12, i6 += f12, this.pos === o4 && (this.process(n4, 0), this.pos = 0);
    }
    return this.length += e9.length, this.roundClean(), this;
  }
  digestInto(e9) {
    Nt4(this), on4(e9, this), this.finished = true;
    const { buffer: n4, view: r6, blockLen: o4, isLE: s3 } = this;
    let { pos: i6 } = this;
    n4[i6++] = 128, ut4(this.buffer.subarray(i6)), this.padOffset > o4 - i6 && (this.process(r6, 0), i6 = 0);
    for (let u6 = i6; u6 < o4; u6++) n4[u6] = 0;
    Di4(r6, o4 - 8, BigInt(this.length * 8), s3), this.process(r6, 0);
    const f12 = sn5(e9), a4 = this.outputLen;
    if (a4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l6 = a4 / 4, c6 = this.get();
    if (l6 > c6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u6 = 0; u6 < l6; u6++) f12.setUint32(4 * u6, c6[u6], s3);
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
  _cloneInto(e9) {
    e9 || (e9 = new this.constructor()), e9.set(...this.get());
    const { blockLen: n4, buffer: r6, length: o4, finished: s3, destroyed: i6, pos: f12 } = this;
    return e9.destroyed = i6, e9.finished = s3, e9.length = o4, e9.pos = f12, o4 % n4 && e9.buffer.set(r6), e9;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut4 = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W4 = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y4 = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi4 = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t4 = new Uint32Array(64);
var Ki4 = class extends Rr4 {
  constructor(e9 = 32) {
    super(64, e9, 8, false), this.A = Ut4[0] | 0, this.B = Ut4[1] | 0, this.C = Ut4[2] | 0, this.D = Ut4[3] | 0, this.E = Ut4[4] | 0, this.F = Ut4[5] | 0, this.G = Ut4[6] | 0, this.H = Ut4[7] | 0;
  }
  get() {
    const { A: e9, B: n4, C: r6, D: o4, E: s3, F: i6, G: f12, H: a4 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4) {
    this.A = e9 | 0, this.B = n4 | 0, this.C = r6 | 0, this.D = o4 | 0, this.E = s3 | 0, this.F = i6 | 0, this.G = f12 | 0, this.H = a4 | 0;
  }
  process(e9, n4) {
    for (let u6 = 0; u6 < 16; u6++, n4 += 4) _t4[u6] = e9.getUint32(n4, false);
    for (let u6 = 16; u6 < 64; u6++) {
      const h7 = _t4[u6 - 15], g3 = _t4[u6 - 2], w6 = gt4(h7, 7) ^ gt4(h7, 18) ^ h7 >>> 3, y8 = gt4(g3, 17) ^ gt4(g3, 19) ^ g3 >>> 10;
      _t4[u6] = y8 + _t4[u6 - 7] + w6 + _t4[u6 - 16] | 0;
    }
    let { A: r6, B: o4, C: s3, D: i6, E: f12, F: a4, G: l6, H: c6 } = this;
    for (let u6 = 0; u6 < 64; u6++) {
      const h7 = gt4(f12, 6) ^ gt4(f12, 11) ^ gt4(f12, 25), g3 = c6 + h7 + Mi4(f12, a4, l6) + qi4[u6] + _t4[u6] | 0, y8 = (gt4(r6, 2) ^ gt4(r6, 13) ^ gt4(r6, 22)) + Vi4(r6, o4, s3) | 0;
      c6 = l6, l6 = a4, a4 = f12, f12 = i6 + g3 | 0, i6 = s3, s3 = o4, o4 = r6, r6 = g3 + y8 | 0;
    }
    r6 = r6 + this.A | 0, o4 = o4 + this.B | 0, s3 = s3 + this.C | 0, i6 = i6 + this.D | 0, f12 = f12 + this.E | 0, a4 = a4 + this.F | 0, l6 = l6 + this.G | 0, c6 = c6 + this.H | 0, this.set(r6, o4, s3, i6, f12, a4, l6, c6);
  }
  roundClean() {
    ut4(_t4);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut4(this.buffer);
  }
};
var $r4 = wr4(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t4) => BigInt(t4)));
var Fi4 = $r4[0];
var zi4 = $r4[1];
var Tt4 = new Uint32Array(80);
var Rt5 = new Uint32Array(80);
var cn4 = class extends Rr4 {
  constructor(e9 = 64) {
    super(128, e9, 16, false), this.Ah = Y4[0] | 0, this.Al = Y4[1] | 0, this.Bh = Y4[2] | 0, this.Bl = Y4[3] | 0, this.Ch = Y4[4] | 0, this.Cl = Y4[5] | 0, this.Dh = Y4[6] | 0, this.Dl = Y4[7] | 0, this.Eh = Y4[8] | 0, this.El = Y4[9] | 0, this.Fh = Y4[10] | 0, this.Fl = Y4[11] | 0, this.Gh = Y4[12] | 0, this.Gl = Y4[13] | 0, this.Hh = Y4[14] | 0, this.Hl = Y4[15] | 0;
  }
  get() {
    const { Ah: e9, Al: n4, Bh: r6, Bl: o4, Ch: s3, Cl: i6, Dh: f12, Dl: a4, Eh: l6, El: c6, Fh: u6, Fl: h7, Gh: g3, Gl: w6, Hh: y8, Hl: x5 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5) {
    this.Ah = e9 | 0, this.Al = n4 | 0, this.Bh = r6 | 0, this.Bl = o4 | 0, this.Ch = s3 | 0, this.Cl = i6 | 0, this.Dh = f12 | 0, this.Dl = a4 | 0, this.Eh = l6 | 0, this.El = c6 | 0, this.Fh = u6 | 0, this.Fl = h7 | 0, this.Gh = g3 | 0, this.Gl = w6 | 0, this.Hh = y8 | 0, this.Hl = x5 | 0;
  }
  process(e9, n4) {
    for (let L6 = 0; L6 < 16; L6++, n4 += 4) Tt4[L6] = e9.getUint32(n4), Rt5[L6] = e9.getUint32(n4 += 4);
    for (let L6 = 16; L6 < 80; L6++) {
      const V7 = Tt4[L6 - 15] | 0, _4 = Rt5[L6 - 15] | 0, k8 = At4(V7, _4, 1) ^ At4(V7, _4, 8) ^ xr4(V7, _4, 7), j6 = St5(V7, _4, 1) ^ St5(V7, _4, 8) ^ vr4(V7, _4, 7), $7 = Tt4[L6 - 2] | 0, d5 = Rt5[L6 - 2] | 0, m5 = At4($7, d5, 19) ^ se4($7, d5, 61) ^ xr4($7, d5, 6), p7 = St5($7, d5, 19) ^ ie4($7, d5, 61) ^ vr4($7, d5, 6), b5 = Ei4(j6, p7, Rt5[L6 - 7], Rt5[L6 - 16]), v7 = Bi4(b5, k8, m5, Tt4[L6 - 7], Tt4[L6 - 16]);
      Tt4[L6] = v7 | 0, Rt5[L6] = b5 | 0;
    }
    let { Ah: r6, Al: o4, Bh: s3, Bl: i6, Ch: f12, Cl: a4, Dh: l6, Dl: c6, Eh: u6, El: h7, Fh: g3, Fl: w6, Gh: y8, Gl: x5, Hh: R6, Hl: M7 } = this;
    for (let L6 = 0; L6 < 80; L6++) {
      const V7 = At4(u6, h7, 14) ^ At4(u6, h7, 18) ^ se4(u6, h7, 41), _4 = St5(u6, h7, 14) ^ St5(u6, h7, 18) ^ ie4(u6, h7, 41), k8 = u6 & g3 ^ ~u6 & y8, j6 = h7 & w6 ^ ~h7 & x5, $7 = Ii4(M7, _4, j6, zi4[L6], Rt5[L6]), d5 = Ai4($7, R6, V7, k8, Fi4[L6], Tt4[L6]), m5 = $7 | 0, p7 = At4(r6, o4, 28) ^ se4(r6, o4, 34) ^ se4(r6, o4, 39), b5 = St5(r6, o4, 28) ^ ie4(r6, o4, 34) ^ ie4(r6, o4, 39), v7 = r6 & s3 ^ r6 & f12 ^ s3 & f12, B7 = o4 & i6 ^ o4 & a4 ^ i6 & a4;
      R6 = y8 | 0, M7 = x5 | 0, y8 = g3 | 0, x5 = w6 | 0, g3 = u6 | 0, w6 = h7 | 0, { h: u6, l: h7 } = dt4(l6 | 0, c6 | 0, d5 | 0, m5 | 0), l6 = f12 | 0, c6 = a4 | 0, f12 = s3 | 0, a4 = i6 | 0, s3 = r6 | 0, i6 = o4 | 0;
      const E7 = tn4(m5, b5, B7);
      r6 = en4(E7, d5, p7, v7), o4 = E7 | 0;
    }
    ({ h: r6, l: o4 } = dt4(this.Ah | 0, this.Al | 0, r6 | 0, o4 | 0)), { h: s3, l: i6 } = dt4(this.Bh | 0, this.Bl | 0, s3 | 0, i6 | 0), { h: f12, l: a4 } = dt4(this.Ch | 0, this.Cl | 0, f12 | 0, a4 | 0), { h: l6, l: c6 } = dt4(this.Dh | 0, this.Dl | 0, l6 | 0, c6 | 0), { h: u6, l: h7 } = dt4(this.Eh | 0, this.El | 0, u6 | 0, h7 | 0), { h: g3, l: w6 } = dt4(this.Fh | 0, this.Fl | 0, g3 | 0, w6 | 0), { h: y8, l: x5 } = dt4(this.Gh | 0, this.Gl | 0, y8 | 0, x5 | 0), { h: R6, l: M7 } = dt4(this.Hh | 0, this.Hl | 0, R6 | 0, M7 | 0), this.set(r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5, R6, M7);
  }
  roundClean() {
    ut4(Tt4, Rt5);
  }
  destroy() {
    ut4(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi4 = class extends cn4 {
  constructor() {
    super(48), this.Ah = W4[0] | 0, this.Al = W4[1] | 0, this.Bh = W4[2] | 0, this.Bl = W4[3] | 0, this.Ch = W4[4] | 0, this.Cl = W4[5] | 0, this.Dh = W4[6] | 0, this.Dl = W4[7] | 0, this.Eh = W4[8] | 0, this.El = W4[9] | 0, this.Fh = W4[10] | 0, this.Fl = W4[11] | 0, this.Gh = W4[12] | 0, this.Gl = W4[13] | 0, this.Hh = W4[14] | 0, this.Hl = W4[15] | 0;
  }
};
var X4 = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi3 = class extends cn4 {
  constructor() {
    super(32), this.Ah = X4[0] | 0, this.Al = X4[1] | 0, this.Bh = X4[2] | 0, this.Bl = X4[3] | 0, this.Ch = X4[4] | 0, this.Cl = X4[5] | 0, this.Dh = X4[6] | 0, this.Dl = X4[7] | 0, this.Eh = X4[8] | 0, this.El = X4[9] | 0, this.Fh = X4[10] | 0, this.Fl = X4[11] | 0, this.Gh = X4[12] | 0, this.Gl = X4[13] | 0, this.Hh = X4[14] | 0, this.Hl = X4[15] | 0;
  }
};
var Ae3 = ae4(() => new Ki4());
var Wi4 = ae4(() => new cn4());
var Yi3 = ae4(() => new Gi4());
var Xi3 = ae4(() => new Zi3());
var Ji3 = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F4 = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N4 = new Uint32Array(32);
function $t4(t4, e9, n4, r6, o4, s3) {
  const i6 = o4[s3], f12 = o4[s3 + 1];
  let a4 = N4[2 * t4], l6 = N4[2 * t4 + 1], c6 = N4[2 * e9], u6 = N4[2 * e9 + 1], h7 = N4[2 * n4], g3 = N4[2 * n4 + 1], w6 = N4[2 * r6], y8 = N4[2 * r6 + 1], x5 = tn4(a4, c6, i6);
  l6 = en4(x5, l6, u6, f12), a4 = x5 | 0, { Dh: y8, Dl: w6 } = { Dh: y8 ^ l6, Dl: w6 ^ a4 }, { Dh: y8, Dl: w6 } = { Dh: bi4(y8, w6), Dl: yi4(y8) }, { h: g3, l: h7 } = dt4(g3, h7, y8, w6), { Bh: u6, Bl: c6 } = { Bh: u6 ^ g3, Bl: c6 ^ h7 }, { Bh: u6, Bl: c6 } = { Bh: At4(u6, c6, 24), Bl: St5(u6, c6, 24) }, N4[2 * t4] = a4, N4[2 * t4 + 1] = l6, N4[2 * e9] = c6, N4[2 * e9 + 1] = u6, N4[2 * n4] = h7, N4[2 * n4 + 1] = g3, N4[2 * r6] = w6, N4[2 * r6 + 1] = y8;
}
function Ct4(t4, e9, n4, r6, o4, s3) {
  const i6 = o4[s3], f12 = o4[s3 + 1];
  let a4 = N4[2 * t4], l6 = N4[2 * t4 + 1], c6 = N4[2 * e9], u6 = N4[2 * e9 + 1], h7 = N4[2 * n4], g3 = N4[2 * n4 + 1], w6 = N4[2 * r6], y8 = N4[2 * r6 + 1], x5 = tn4(a4, c6, i6);
  l6 = en4(x5, l6, u6, f12), a4 = x5 | 0, { Dh: y8, Dl: w6 } = { Dh: y8 ^ l6, Dl: w6 ^ a4 }, { Dh: y8, Dl: w6 } = { Dh: At4(y8, w6, 16), Dl: St5(y8, w6, 16) }, { h: g3, l: h7 } = dt4(g3, h7, y8, w6), { Bh: u6, Bl: c6 } = { Bh: u6 ^ g3, Bl: c6 ^ h7 }, { Bh: u6, Bl: c6 } = { Bh: se4(u6, c6, 63), Bl: ie4(u6, c6, 63) }, N4[2 * t4] = a4, N4[2 * t4 + 1] = l6, N4[2 * e9] = c6, N4[2 * e9 + 1] = u6, N4[2 * n4] = h7, N4[2 * n4 + 1] = g3, N4[2 * r6] = w6, N4[2 * r6 + 1] = y8;
}
function Qi3(t4, e9 = {}, n4, r6, o4) {
  if (mt4(n4), t4 < 0 || t4 > n4) throw new Error("outputLen bigger than keyLen");
  const { key: s3, salt: i6, personalization: f12 } = e9;
  if (s3 !== void 0 && (s3.length < 1 || s3.length > n4)) throw new Error("key length must be undefined or 1.." + n4);
  if (i6 !== void 0 && i6.length !== r6) throw new Error("salt must be undefined or " + r6);
  if (f12 !== void 0 && f12.length !== o4) throw new Error("personalization must be undefined or " + o4);
}
var tf3 = class extends Ie4 {
  constructor(e9, n4) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt4(e9), mt4(n4), this.blockLen = e9, this.outputLen = n4, this.buffer = new Uint8Array(e9), this.buffer32 = fe4(this.buffer);
  }
  update(e9) {
    Nt4(this), e9 = ht4(e9), at3(e9);
    const { blockLen: n4, buffer: r6, buffer32: o4 } = this, s3 = e9.length, i6 = e9.byteOffset, f12 = e9.buffer;
    for (let a4 = 0; a4 < s3; ) {
      this.pos === n4 && (Ot4(o4), this.compress(o4, 0, false), Ot4(o4), this.pos = 0);
      const l6 = Math.min(n4 - this.pos, s3 - a4), c6 = i6 + a4;
      if (l6 === n4 && !(c6 % 4) && a4 + l6 < s3) {
        const u6 = new Uint32Array(f12, c6, Math.floor((s3 - a4) / 4));
        Ot4(u6);
        for (let h7 = 0; a4 + n4 < s3; h7 += o4.length, a4 += n4) this.length += n4, this.compress(u6, h7, false);
        Ot4(u6);
        continue;
      }
      r6.set(e9.subarray(a4, a4 + l6), this.pos), this.pos += l6, this.length += l6, a4 += l6;
    }
    return this;
  }
  digestInto(e9) {
    Nt4(this), on4(e9, this);
    const { pos: n4, buffer32: r6 } = this;
    this.finished = true, ut4(this.buffer.subarray(n4)), Ot4(r6), this.compress(r6, 0, true), Ot4(r6);
    const o4 = fe4(e9);
    this.get().forEach((s3, i6) => o4[i6] = wt4(s3));
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
  _cloneInto(e9) {
    const { buffer: n4, length: r6, finished: o4, destroyed: s3, outputLen: i6, pos: f12 } = this;
    return e9 || (e9 = new this.constructor({ dkLen: i6 })), e9.set(...this.get()), e9.buffer.set(n4), e9.destroyed = s3, e9.finished = o4, e9.length = r6, e9.pos = f12, e9.outputLen = i6, e9;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef3 = class extends tf3 {
  constructor(e9 = {}) {
    const n4 = e9.dkLen === void 0 ? 64 : e9.dkLen;
    super(128, n4), this.v0l = F4[0] | 0, this.v0h = F4[1] | 0, this.v1l = F4[2] | 0, this.v1h = F4[3] | 0, this.v2l = F4[4] | 0, this.v2h = F4[5] | 0, this.v3l = F4[6] | 0, this.v3h = F4[7] | 0, this.v4l = F4[8] | 0, this.v4h = F4[9] | 0, this.v5l = F4[10] | 0, this.v5h = F4[11] | 0, this.v6l = F4[12] | 0, this.v6h = F4[13] | 0, this.v7l = F4[14] | 0, this.v7h = F4[15] | 0, Qi3(n4, e9, 64, 16, 16);
    let { key: r6, personalization: o4, salt: s3 } = e9, i6 = 0;
    if (r6 !== void 0 && (r6 = ht4(r6), i6 = r6.length), this.v0l ^= this.outputLen | i6 << 8 | 65536 | 1 << 24, s3 !== void 0) {
      s3 = ht4(s3);
      const f12 = fe4(s3);
      this.v4l ^= wt4(f12[0]), this.v4h ^= wt4(f12[1]), this.v5l ^= wt4(f12[2]), this.v5h ^= wt4(f12[3]);
    }
    if (o4 !== void 0) {
      o4 = ht4(o4);
      const f12 = fe4(o4);
      this.v6l ^= wt4(f12[0]), this.v6h ^= wt4(f12[1]), this.v7l ^= wt4(f12[2]), this.v7h ^= wt4(f12[3]);
    }
    if (r6 !== void 0) {
      const f12 = new Uint8Array(this.blockLen);
      f12.set(r6), this.update(f12);
    }
  }
  get() {
    let { v0l: e9, v0h: n4, v1l: r6, v1h: o4, v2l: s3, v2h: i6, v3l: f12, v3h: a4, v4l: l6, v4h: c6, v5l: u6, v5h: h7, v6l: g3, v6h: w6, v7l: y8, v7h: x5 } = this;
    return [e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5];
  }
  set(e9, n4, r6, o4, s3, i6, f12, a4, l6, c6, u6, h7, g3, w6, y8, x5) {
    this.v0l = e9 | 0, this.v0h = n4 | 0, this.v1l = r6 | 0, this.v1h = o4 | 0, this.v2l = s3 | 0, this.v2h = i6 | 0, this.v3l = f12 | 0, this.v3h = a4 | 0, this.v4l = l6 | 0, this.v4h = c6 | 0, this.v5l = u6 | 0, this.v5h = h7 | 0, this.v6l = g3 | 0, this.v6h = w6 | 0, this.v7l = y8 | 0, this.v7h = x5 | 0;
  }
  compress(e9, n4, r6) {
    this.get().forEach((a4, l6) => N4[l6] = a4), N4.set(F4, 16);
    let { h: o4, l: s3 } = mr4(BigInt(this.length));
    N4[24] = F4[8] ^ s3, N4[25] = F4[9] ^ o4, r6 && (N4[28] = ~N4[28], N4[29] = ~N4[29]);
    let i6 = 0;
    const f12 = Ji3;
    for (let a4 = 0; a4 < 12; a4++) $t4(0, 4, 8, 12, e9, n4 + 2 * f12[i6++]), Ct4(0, 4, 8, 12, e9, n4 + 2 * f12[i6++]), $t4(1, 5, 9, 13, e9, n4 + 2 * f12[i6++]), Ct4(1, 5, 9, 13, e9, n4 + 2 * f12[i6++]), $t4(2, 6, 10, 14, e9, n4 + 2 * f12[i6++]), Ct4(2, 6, 10, 14, e9, n4 + 2 * f12[i6++]), $t4(3, 7, 11, 15, e9, n4 + 2 * f12[i6++]), Ct4(3, 7, 11, 15, e9, n4 + 2 * f12[i6++]), $t4(0, 5, 10, 15, e9, n4 + 2 * f12[i6++]), Ct4(0, 5, 10, 15, e9, n4 + 2 * f12[i6++]), $t4(1, 6, 11, 12, e9, n4 + 2 * f12[i6++]), Ct4(1, 6, 11, 12, e9, n4 + 2 * f12[i6++]), $t4(2, 7, 8, 13, e9, n4 + 2 * f12[i6++]), Ct4(2, 7, 8, 13, e9, n4 + 2 * f12[i6++]), $t4(3, 4, 9, 14, e9, n4 + 2 * f12[i6++]), Ct4(3, 4, 9, 14, e9, n4 + 2 * f12[i6++]);
    this.v0l ^= N4[0] ^ N4[16], this.v0h ^= N4[1] ^ N4[17], this.v1l ^= N4[2] ^ N4[18], this.v1h ^= N4[3] ^ N4[19], this.v2l ^= N4[4] ^ N4[20], this.v2h ^= N4[5] ^ N4[21], this.v3l ^= N4[6] ^ N4[22], this.v3h ^= N4[7] ^ N4[23], this.v4l ^= N4[8] ^ N4[24], this.v4h ^= N4[9] ^ N4[25], this.v5l ^= N4[10] ^ N4[26], this.v5h ^= N4[11] ^ N4[27], this.v6l ^= N4[12] ^ N4[28], this.v6h ^= N4[13] ^ N4[29], this.v7l ^= N4[14] ^ N4[30], this.v7h ^= N4[15] ^ N4[31], ut4(N4);
  }
  destroy() {
    this.destroyed = true, ut4(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf3 = Ui4((t4) => new ef3(t4));
function Qr4(t4) {
  return t4 instanceof Uint8Array || ArrayBuffer.isView(t4) && t4.constructor.name === "Uint8Array";
}
function bn4(t4) {
  if (typeof t4 != "boolean") throw new Error(`boolean expected, not ${t4}`);
}
function yn4(t4) {
  if (!Number.isSafeInteger(t4) || t4 < 0) throw new Error("positive integer expected, got " + t4);
}
function nt3(t4, ...e9) {
  if (!Qr4(t4)) throw new Error("Uint8Array expected");
  if (e9.length > 0 && !e9.includes(t4.length)) throw new Error("Uint8Array expected of length " + e9 + ", got length=" + t4.length);
}
function to4(t4, e9 = true) {
  if (t4.destroyed) throw new Error("Hash instance has been destroyed");
  if (e9 && t4.finished) throw new Error("Hash#digest() has already been called");
}
function Sf3(t4, e9) {
  nt3(t4);
  const n4 = e9.outputLen;
  if (t4.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function jt4(t4) {
  return new Uint32Array(t4.buffer, t4.byteOffset, Math.floor(t4.byteLength / 4));
}
function Wt4(...t4) {
  for (let e9 = 0; e9 < t4.length; e9++) t4[e9].fill(0);
}
function Nf3(t4) {
  return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
}
var Of3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf3(t4) {
  if (typeof t4 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t4));
}
function mn4(t4) {
  if (typeof t4 == "string") t4 = Uf3(t4);
  else if (Qr4(t4)) t4 = wn4(t4);
  else throw new Error("Uint8Array expected, got " + typeof t4);
  return t4;
}
function _f3(t4, e9) {
  if (e9 == null || typeof e9 != "object") throw new Error("options must be defined");
  return Object.assign(t4, e9);
}
function Tf3(t4, e9) {
  if (t4.length !== e9.length) return false;
  let n4 = 0;
  for (let r6 = 0; r6 < t4.length; r6++) n4 |= t4[r6] ^ e9[r6];
  return n4 === 0;
}
var Rf3 = (t4, e9) => {
  function n4(r6, ...o4) {
    if (nt3(r6), !Of3) throw new Error("Non little-endian hardware is not yet supported");
    if (t4.nonceLength !== void 0) {
      const c6 = o4[0];
      if (!c6) throw new Error("nonce / iv required");
      t4.varSizeNonce ? nt3(c6) : nt3(c6, t4.nonceLength);
    }
    const s3 = t4.tagLength;
    s3 && o4[1] !== void 0 && nt3(o4[1]);
    const i6 = e9(r6, ...o4), f12 = (c6, u6) => {
      if (u6 !== void 0) {
        if (c6 !== 2) throw new Error("cipher output not supported");
        nt3(u6);
      }
    };
    let a4 = false;
    return { encrypt(c6, u6) {
      if (a4) throw new Error("cannot encrypt() twice with same key + nonce");
      return a4 = true, nt3(c6), f12(i6.encrypt.length, u6), i6.encrypt(c6, u6);
    }, decrypt(c6, u6) {
      if (nt3(c6), s3 && c6.length < s3) throw new Error("invalid ciphertext length: smaller than tagLength=" + s3);
      return f12(i6.decrypt.length, u6), i6.decrypt(c6, u6);
    } };
  }
  return Object.assign(n4, t4), n4;
};
function eo4(t4, e9, n4 = true) {
  if (e9 === void 0) return new Uint8Array(t4);
  if (e9.length !== t4) throw new Error("invalid output length, expected " + t4 + ", got: " + e9.length);
  if (n4 && !Cf3(e9)) throw new Error("invalid output, must be aligned");
  return e9;
}
function no4(t4, e9, n4, r6) {
  if (typeof t4.setBigUint64 == "function") return t4.setBigUint64(e9, n4, r6);
  const o4 = BigInt(32), s3 = BigInt(4294967295), i6 = Number(n4 >> o4 & s3), f12 = Number(n4 & s3), a4 = r6 ? 4 : 0, l6 = r6 ? 0 : 4;
  t4.setUint32(e9 + a4, i6, r6), t4.setUint32(e9 + l6, f12, r6);
}
function $f3(t4, e9, n4) {
  bn4(n4);
  const r6 = new Uint8Array(16), o4 = Nf3(r6);
  return no4(o4, 0, BigInt(e9), n4), no4(o4, 8, BigInt(t4), n4), r6;
}
function Cf3(t4) {
  return t4.byteOffset % 4 === 0;
}
function wn4(t4) {
  return Uint8Array.from(t4);
}
var ro4 = (t4) => Uint8Array.from(t4.split("").map((e9) => e9.charCodeAt(0)));
var Lf3 = ro4("expand 16-byte k");
var jf3 = ro4("expand 32-byte k");
var kf3 = jt4(Lf3);
var Pf3 = jt4(jf3);
function D3(t4, e9) {
  return t4 << e9 | t4 >>> 32 - e9;
}
function xn4(t4) {
  return t4.byteOffset % 4 === 0;
}
var Ue4 = 64;
var Hf3 = 16;
var oo4 = 2 ** 32 - 1;
var so4 = new Uint32Array();
function Df3(t4, e9, n4, r6, o4, s3, i6, f12) {
  const a4 = o4.length, l6 = new Uint8Array(Ue4), c6 = jt4(l6), u6 = xn4(o4) && xn4(s3), h7 = u6 ? jt4(o4) : so4, g3 = u6 ? jt4(s3) : so4;
  for (let w6 = 0; w6 < a4; i6++) {
    if (t4(e9, n4, r6, c6, i6, f12), i6 >= oo4) throw new Error("arx: counter overflow");
    const y8 = Math.min(Ue4, a4 - w6);
    if (u6 && y8 === Ue4) {
      const x5 = w6 / 4;
      if (w6 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R6 = 0, M7; R6 < Hf3; R6++) M7 = x5 + R6, g3[M7] = h7[M7] ^ c6[R6];
      w6 += Ue4;
      continue;
    }
    for (let x5 = 0, R6; x5 < y8; x5++) R6 = w6 + x5, s3[R6] = o4[R6] ^ l6[x5];
    w6 += y8;
  }
}
function Mf3(t4, e9) {
  const { allowShortKeys: n4, extendNonceFn: r6, counterLength: o4, counterRight: s3, rounds: i6 } = _f3({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e9);
  if (typeof t4 != "function") throw new Error("core must be a function");
  return yn4(o4), yn4(i6), bn4(s3), bn4(n4), (f12, a4, l6, c6, u6 = 0) => {
    nt3(f12), nt3(a4), nt3(l6);
    const h7 = l6.length;
    if (c6 === void 0 && (c6 = new Uint8Array(h7)), nt3(c6), yn4(u6), u6 < 0 || u6 >= oo4) throw new Error("arx: counter overflow");
    if (c6.length < h7) throw new Error(`arx: output (${c6.length}) is shorter than data (${h7})`);
    const g3 = [];
    let w6 = f12.length, y8, x5;
    if (w6 === 32) g3.push(y8 = wn4(f12)), x5 = Pf3;
    else if (w6 === 16 && n4) y8 = new Uint8Array(32), y8.set(f12), y8.set(f12, 16), x5 = kf3, g3.push(y8);
    else throw new Error(`arx: invalid 32-byte key, got length=${w6}`);
    xn4(a4) || g3.push(a4 = wn4(a4));
    const R6 = jt4(y8);
    if (r6) {
      if (a4.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r6(x5, R6, jt4(a4.subarray(0, 16)), R6), a4 = a4.subarray(16);
    }
    const M7 = 16 - o4;
    if (M7 !== a4.length) throw new Error(`arx: nonce must be ${M7} or 16 bytes`);
    if (M7 !== 12) {
      const V7 = new Uint8Array(12);
      V7.set(a4, s3 ? 0 : 12 - a4.length), a4 = V7, g3.push(a4);
    }
    const L6 = jt4(a4);
    return Df3(t4, x5, R6, L6, l6, c6, u6, i6), Wt4(...g3), c6;
  };
}
var G4 = (t4, e9) => t4[e9++] & 255 | (t4[e9++] & 255) << 8;
var Vf3 = class {
  constructor(e9) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e9 = mn4(e9), nt3(e9, 32);
    const n4 = G4(e9, 0), r6 = G4(e9, 2), o4 = G4(e9, 4), s3 = G4(e9, 6), i6 = G4(e9, 8), f12 = G4(e9, 10), a4 = G4(e9, 12), l6 = G4(e9, 14);
    this.r[0] = n4 & 8191, this.r[1] = (n4 >>> 13 | r6 << 3) & 8191, this.r[2] = (r6 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | s3 << 9) & 8191, this.r[4] = (s3 >>> 4 | i6 << 12) & 255, this.r[5] = i6 >>> 1 & 8190, this.r[6] = (i6 >>> 14 | f12 << 2) & 8191, this.r[7] = (f12 >>> 11 | a4 << 5) & 8065, this.r[8] = (a4 >>> 8 | l6 << 8) & 8191, this.r[9] = l6 >>> 5 & 127;
    for (let c6 = 0; c6 < 8; c6++) this.pad[c6] = G4(e9, 16 + 2 * c6);
  }
  process(e9, n4, r6 = false) {
    const o4 = r6 ? 0 : 2048, { h: s3, r: i6 } = this, f12 = i6[0], a4 = i6[1], l6 = i6[2], c6 = i6[3], u6 = i6[4], h7 = i6[5], g3 = i6[6], w6 = i6[7], y8 = i6[8], x5 = i6[9], R6 = G4(e9, n4 + 0), M7 = G4(e9, n4 + 2), L6 = G4(e9, n4 + 4), V7 = G4(e9, n4 + 6), _4 = G4(e9, n4 + 8), k8 = G4(e9, n4 + 10), j6 = G4(e9, n4 + 12), $7 = G4(e9, n4 + 14);
    let d5 = s3[0] + (R6 & 8191), m5 = s3[1] + ((R6 >>> 13 | M7 << 3) & 8191), p7 = s3[2] + ((M7 >>> 10 | L6 << 6) & 8191), b5 = s3[3] + ((L6 >>> 7 | V7 << 9) & 8191), v7 = s3[4] + ((V7 >>> 4 | _4 << 12) & 8191), B7 = s3[5] + (_4 >>> 1 & 8191), E7 = s3[6] + ((_4 >>> 14 | k8 << 2) & 8191), I7 = s3[7] + ((k8 >>> 11 | j6 << 5) & 8191), S7 = s3[8] + ((j6 >>> 8 | $7 << 8) & 8191), O6 = s3[9] + ($7 >>> 5 | o4), A8 = 0, T6 = A8 + d5 * f12 + m5 * (5 * x5) + p7 * (5 * y8) + b5 * (5 * w6) + v7 * (5 * g3);
    A8 = T6 >>> 13, T6 &= 8191, T6 += B7 * (5 * h7) + E7 * (5 * u6) + I7 * (5 * c6) + S7 * (5 * l6) + O6 * (5 * a4), A8 += T6 >>> 13, T6 &= 8191;
    let U6 = A8 + d5 * a4 + m5 * f12 + p7 * (5 * x5) + b5 * (5 * y8) + v7 * (5 * w6);
    A8 = U6 >>> 13, U6 &= 8191, U6 += B7 * (5 * g3) + E7 * (5 * h7) + I7 * (5 * u6) + S7 * (5 * c6) + O6 * (5 * l6), A8 += U6 >>> 13, U6 &= 8191;
    let C8 = A8 + d5 * l6 + m5 * a4 + p7 * f12 + b5 * (5 * x5) + v7 * (5 * y8);
    A8 = C8 >>> 13, C8 &= 8191, C8 += B7 * (5 * w6) + E7 * (5 * g3) + I7 * (5 * h7) + S7 * (5 * u6) + O6 * (5 * c6), A8 += C8 >>> 13, C8 &= 8191;
    let H4 = A8 + d5 * c6 + m5 * l6 + p7 * a4 + b5 * f12 + v7 * (5 * x5);
    A8 = H4 >>> 13, H4 &= 8191, H4 += B7 * (5 * y8) + E7 * (5 * w6) + I7 * (5 * g3) + S7 * (5 * h7) + O6 * (5 * u6), A8 += H4 >>> 13, H4 &= 8191;
    let q5 = A8 + d5 * u6 + m5 * c6 + p7 * l6 + b5 * a4 + v7 * f12;
    A8 = q5 >>> 13, q5 &= 8191, q5 += B7 * (5 * x5) + E7 * (5 * y8) + I7 * (5 * w6) + S7 * (5 * g3) + O6 * (5 * h7), A8 += q5 >>> 13, q5 &= 8191;
    let P6 = A8 + d5 * h7 + m5 * u6 + p7 * c6 + b5 * l6 + v7 * a4;
    A8 = P6 >>> 13, P6 &= 8191, P6 += B7 * f12 + E7 * (5 * x5) + I7 * (5 * y8) + S7 * (5 * w6) + O6 * (5 * g3), A8 += P6 >>> 13, P6 &= 8191;
    let K4 = A8 + d5 * g3 + m5 * h7 + p7 * u6 + b5 * c6 + v7 * l6;
    A8 = K4 >>> 13, K4 &= 8191, K4 += B7 * a4 + E7 * f12 + I7 * (5 * x5) + S7 * (5 * y8) + O6 * (5 * w6), A8 += K4 >>> 13, K4 &= 8191;
    let et3 = A8 + d5 * w6 + m5 * g3 + p7 * h7 + b5 * u6 + v7 * c6;
    A8 = et3 >>> 13, et3 &= 8191, et3 += B7 * l6 + E7 * a4 + I7 * f12 + S7 * (5 * x5) + O6 * (5 * y8), A8 += et3 >>> 13, et3 &= 8191;
    let Z5 = A8 + d5 * y8 + m5 * w6 + p7 * g3 + b5 * h7 + v7 * u6;
    A8 = Z5 >>> 13, Z5 &= 8191, Z5 += B7 * c6 + E7 * l6 + I7 * a4 + S7 * f12 + O6 * (5 * x5), A8 += Z5 >>> 13, Z5 &= 8191;
    let z6 = A8 + d5 * x5 + m5 * y8 + p7 * w6 + b5 * g3 + v7 * h7;
    A8 = z6 >>> 13, z6 &= 8191, z6 += B7 * u6 + E7 * c6 + I7 * l6 + S7 * a4 + O6 * f12, A8 += z6 >>> 13, z6 &= 8191, A8 = (A8 << 2) + A8 | 0, A8 = A8 + T6 | 0, T6 = A8 & 8191, A8 = A8 >>> 13, U6 += A8, s3[0] = T6, s3[1] = U6, s3[2] = C8, s3[3] = H4, s3[4] = q5, s3[5] = P6, s3[6] = K4, s3[7] = et3, s3[8] = Z5, s3[9] = z6;
  }
  finalize() {
    const { h: e9, pad: n4 } = this, r6 = new Uint16Array(10);
    let o4 = e9[1] >>> 13;
    e9[1] &= 8191;
    for (let f12 = 2; f12 < 10; f12++) e9[f12] += o4, o4 = e9[f12] >>> 13, e9[f12] &= 8191;
    e9[0] += o4 * 5, o4 = e9[0] >>> 13, e9[0] &= 8191, e9[1] += o4, o4 = e9[1] >>> 13, e9[1] &= 8191, e9[2] += o4, r6[0] = e9[0] + 5, o4 = r6[0] >>> 13, r6[0] &= 8191;
    for (let f12 = 1; f12 < 10; f12++) r6[f12] = e9[f12] + o4, o4 = r6[f12] >>> 13, r6[f12] &= 8191;
    r6[9] -= 8192;
    let s3 = (o4 ^ 1) - 1;
    for (let f12 = 0; f12 < 10; f12++) r6[f12] &= s3;
    s3 = ~s3;
    for (let f12 = 0; f12 < 10; f12++) e9[f12] = e9[f12] & s3 | r6[f12];
    e9[0] = (e9[0] | e9[1] << 13) & 65535, e9[1] = (e9[1] >>> 3 | e9[2] << 10) & 65535, e9[2] = (e9[2] >>> 6 | e9[3] << 7) & 65535, e9[3] = (e9[3] >>> 9 | e9[4] << 4) & 65535, e9[4] = (e9[4] >>> 12 | e9[5] << 1 | e9[6] << 14) & 65535, e9[5] = (e9[6] >>> 2 | e9[7] << 11) & 65535, e9[6] = (e9[7] >>> 5 | e9[8] << 8) & 65535, e9[7] = (e9[8] >>> 8 | e9[9] << 5) & 65535;
    let i6 = e9[0] + n4[0];
    e9[0] = i6 & 65535;
    for (let f12 = 1; f12 < 8; f12++) i6 = (e9[f12] + n4[f12] | 0) + (i6 >>> 16) | 0, e9[f12] = i6 & 65535;
    Wt4(r6);
  }
  update(e9) {
    to4(this), e9 = mn4(e9), nt3(e9);
    const { buffer: n4, blockLen: r6 } = this, o4 = e9.length;
    for (let s3 = 0; s3 < o4; ) {
      const i6 = Math.min(r6 - this.pos, o4 - s3);
      if (i6 === r6) {
        for (; r6 <= o4 - s3; s3 += r6) this.process(e9, s3);
        continue;
      }
      n4.set(e9.subarray(s3, s3 + i6), this.pos), this.pos += i6, s3 += i6, this.pos === r6 && (this.process(n4, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt4(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e9) {
    to4(this), Sf3(e9, this), this.finished = true;
    const { buffer: n4, h: r6 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n4[o4++] = 1; o4 < 16; o4++) n4[o4] = 0;
      this.process(n4, 0, true);
    }
    this.finalize();
    let s3 = 0;
    for (let i6 = 0; i6 < 8; i6++) e9[s3++] = r6[i6] >>> 0, e9[s3++] = r6[i6] >>> 8;
    return e9;
  }
  digest() {
    const { buffer: e9, outputLen: n4 } = this;
    this.digestInto(e9);
    const r6 = e9.slice(0, n4);
    return this.destroy(), r6;
  }
};
function qf3(t4) {
  const e9 = (r6, o4) => t4(o4).update(mn4(r6)).digest(), n4 = t4(new Uint8Array(32));
  return e9.outputLen = n4.outputLen, e9.blockLen = n4.blockLen, e9.create = (r6) => t4(r6), e9;
}
var Kf3 = qf3((t4) => new Vf3(t4));
function Ff3(t4, e9, n4, r6, o4, s3 = 20) {
  let i6 = t4[0], f12 = t4[1], a4 = t4[2], l6 = t4[3], c6 = e9[0], u6 = e9[1], h7 = e9[2], g3 = e9[3], w6 = e9[4], y8 = e9[5], x5 = e9[6], R6 = e9[7], M7 = o4, L6 = n4[0], V7 = n4[1], _4 = n4[2], k8 = i6, j6 = f12, $7 = a4, d5 = l6, m5 = c6, p7 = u6, b5 = h7, v7 = g3, B7 = w6, E7 = y8, I7 = x5, S7 = R6, O6 = M7, A8 = L6, T6 = V7, U6 = _4;
  for (let H4 = 0; H4 < s3; H4 += 2) k8 = k8 + m5 | 0, O6 = D3(O6 ^ k8, 16), B7 = B7 + O6 | 0, m5 = D3(m5 ^ B7, 12), k8 = k8 + m5 | 0, O6 = D3(O6 ^ k8, 8), B7 = B7 + O6 | 0, m5 = D3(m5 ^ B7, 7), j6 = j6 + p7 | 0, A8 = D3(A8 ^ j6, 16), E7 = E7 + A8 | 0, p7 = D3(p7 ^ E7, 12), j6 = j6 + p7 | 0, A8 = D3(A8 ^ j6, 8), E7 = E7 + A8 | 0, p7 = D3(p7 ^ E7, 7), $7 = $7 + b5 | 0, T6 = D3(T6 ^ $7, 16), I7 = I7 + T6 | 0, b5 = D3(b5 ^ I7, 12), $7 = $7 + b5 | 0, T6 = D3(T6 ^ $7, 8), I7 = I7 + T6 | 0, b5 = D3(b5 ^ I7, 7), d5 = d5 + v7 | 0, U6 = D3(U6 ^ d5, 16), S7 = S7 + U6 | 0, v7 = D3(v7 ^ S7, 12), d5 = d5 + v7 | 0, U6 = D3(U6 ^ d5, 8), S7 = S7 + U6 | 0, v7 = D3(v7 ^ S7, 7), k8 = k8 + p7 | 0, U6 = D3(U6 ^ k8, 16), I7 = I7 + U6 | 0, p7 = D3(p7 ^ I7, 12), k8 = k8 + p7 | 0, U6 = D3(U6 ^ k8, 8), I7 = I7 + U6 | 0, p7 = D3(p7 ^ I7, 7), j6 = j6 + b5 | 0, O6 = D3(O6 ^ j6, 16), S7 = S7 + O6 | 0, b5 = D3(b5 ^ S7, 12), j6 = j6 + b5 | 0, O6 = D3(O6 ^ j6, 8), S7 = S7 + O6 | 0, b5 = D3(b5 ^ S7, 7), $7 = $7 + v7 | 0, A8 = D3(A8 ^ $7, 16), B7 = B7 + A8 | 0, v7 = D3(v7 ^ B7, 12), $7 = $7 + v7 | 0, A8 = D3(A8 ^ $7, 8), B7 = B7 + A8 | 0, v7 = D3(v7 ^ B7, 7), d5 = d5 + m5 | 0, T6 = D3(T6 ^ d5, 16), E7 = E7 + T6 | 0, m5 = D3(m5 ^ E7, 12), d5 = d5 + m5 | 0, T6 = D3(T6 ^ d5, 8), E7 = E7 + T6 | 0, m5 = D3(m5 ^ E7, 7);
  let C8 = 0;
  r6[C8++] = i6 + k8 | 0, r6[C8++] = f12 + j6 | 0, r6[C8++] = a4 + $7 | 0, r6[C8++] = l6 + d5 | 0, r6[C8++] = c6 + m5 | 0, r6[C8++] = u6 + p7 | 0, r6[C8++] = h7 + b5 | 0, r6[C8++] = g3 + v7 | 0, r6[C8++] = w6 + B7 | 0, r6[C8++] = y8 + E7 | 0, r6[C8++] = x5 + I7 | 0, r6[C8++] = R6 + S7 | 0, r6[C8++] = M7 + O6 | 0, r6[C8++] = L6 + A8 | 0, r6[C8++] = V7 + T6 | 0, r6[C8++] = _4 + U6 | 0;
}
var zf3 = Mf3(Ff3, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf3 = new Uint8Array(16);
var io4 = (t4, e9) => {
  t4.update(e9);
  const n4 = e9.length % 16;
  n4 && t4.update(Gf3.subarray(n4));
};
var Zf3 = new Uint8Array(32);
function fo4(t4, e9, n4, r6, o4) {
  const s3 = t4(e9, n4, Zf3), i6 = Kf3.create(s3);
  o4 && io4(i6, o4), io4(i6, r6);
  const f12 = $f3(r6.length, o4 ? o4.length : 0, true);
  i6.update(f12);
  const a4 = i6.digest();
  return Wt4(s3, f12), a4;
}
var Wf3 = (t4) => (e9, n4, r6) => ({ encrypt(s3, i6) {
  const f12 = s3.length;
  i6 = eo4(f12 + 16, i6, false), i6.set(s3);
  const a4 = i6.subarray(0, -16);
  t4(e9, n4, a4, a4, 1);
  const l6 = fo4(t4, e9, n4, a4, r6);
  return i6.set(l6, f12), Wt4(l6), i6;
}, decrypt(s3, i6) {
  i6 = eo4(s3.length - 16, i6, false);
  const f12 = s3.subarray(0, -16), a4 = s3.subarray(-16), l6 = fo4(t4, e9, n4, f12, r6);
  if (!Tf3(a4, l6)) throw new Error("invalid tag");
  return i6.set(s3.subarray(0, -16)), t4(e9, n4, i6, i6, 1), Wt4(l6), i6;
} });
var co4 = Rf3({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf3(zf3));
var ao4 = class extends Ie4 {
  constructor(e9, n4) {
    super(), this.finished = false, this.destroyed = false, rn4(e9);
    const r6 = ht4(n4);
    if (this.iHash = e9.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, s3 = new Uint8Array(o4);
    s3.set(r6.length > o4 ? e9.create().update(r6).digest() : r6);
    for (let i6 = 0; i6 < s3.length; i6++) s3[i6] ^= 54;
    this.iHash.update(s3), this.oHash = e9.create();
    for (let i6 = 0; i6 < s3.length; i6++) s3[i6] ^= 106;
    this.oHash.update(s3), ut4(s3);
  }
  update(e9) {
    return Nt4(this), this.iHash.update(e9), this;
  }
  digestInto(e9) {
    Nt4(this), at3(e9, this.outputLen), this.finished = true, this.iHash.digestInto(e9), this.oHash.update(e9), this.oHash.digestInto(e9), this.destroy();
  }
  digest() {
    const e9 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e9), e9;
  }
  _cloneInto(e9) {
    e9 || (e9 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n4, iHash: r6, finished: o4, destroyed: s3, blockLen: i6, outputLen: f12 } = this;
    return e9 = e9, e9.finished = o4, e9.destroyed = s3, e9.blockLen = i6, e9.outputLen = f12, e9.oHash = n4._cloneInto(e9.oHash), e9.iHash = r6._cloneInto(e9.iHash), e9;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e5 = (t4, e9, n4) => new ao4(t4, e9).update(n4).digest();
_e5.create = (t4, e9) => new ao4(t4, e9);
var vn4 = Uint8Array.from([0]);
var uo4 = Uint8Array.of();
var En4 = BigInt(0);
var Bn4 = BigInt(1);
function Re3(t4, e9) {
  if (typeof e9 != "boolean") throw new Error(t4 + " boolean expected, got " + e9);
}
function $e4(t4) {
  const e9 = t4.toString(16);
  return e9.length & 1 ? "0" + e9 : e9;
}
function lo4(t4) {
  if (typeof t4 != "string") throw new Error("hex string expected, got " + typeof t4);
  return t4 === "" ? En4 : BigInt("0x" + t4);
}
function Ce5(t4) {
  return lo4(ce4(t4));
}
function Le5(t4) {
  return at3(t4), lo4(ce4(Uint8Array.from(t4).reverse()));
}
function In4(t4, e9) {
  return fn4(t4.toString(16).padStart(e9 * 2, "0"));
}
function An4(t4, e9) {
  return In4(t4, e9).reverse();
}
function rt3(t4, e9, n4) {
  let r6;
  if (typeof e9 == "string") try {
    r6 = fn4(e9);
  } catch (s3) {
    throw new Error(t4 + " must be hex string or Uint8Array, cause: " + s3);
  }
  else if (nn4(e9)) r6 = Uint8Array.from(e9);
  else throw new Error(t4 + " must be hex string or Uint8Array");
  const o4 = r6.length;
  if (typeof n4 == "number" && o4 !== n4) throw new Error(t4 + " of length " + n4 + " expected, got " + o4);
  return r6;
}
var Sn4 = (t4) => typeof t4 == "bigint" && En4 <= t4;
function Qf3(t4, e9, n4) {
  return Sn4(t4) && Sn4(e9) && Sn4(n4) && e9 <= t4 && t4 < n4;
}
function Nn4(t4, e9, n4, r6) {
  if (!Qf3(e9, n4, r6)) throw new Error("expected valid " + t4 + ": " + n4 + " <= n < " + r6 + ", got " + e9);
}
function tc3(t4) {
  let e9;
  for (e9 = 0; t4 > En4; t4 >>= Bn4, e9 += 1) ;
  return e9;
}
var je4 = (t4) => (Bn4 << BigInt(t4)) - Bn4;
function ec3(t4, e9, n4) {
  if (typeof t4 != "number" || t4 < 2) throw new Error("hashLen must be a number");
  if (typeof e9 != "number" || e9 < 2) throw new Error("qByteLen must be a number");
  if (typeof n4 != "function") throw new Error("hmacFn must be a function");
  const r6 = (g3) => new Uint8Array(g3), o4 = (g3) => Uint8Array.of(g3);
  let s3 = r6(t4), i6 = r6(t4), f12 = 0;
  const a4 = () => {
    s3.fill(1), i6.fill(0), f12 = 0;
  }, l6 = (...g3) => n4(i6, s3, ...g3), c6 = (g3 = r6(0)) => {
    i6 = l6(o4(0), g3), s3 = l6(), g3.length !== 0 && (i6 = l6(o4(1), g3), s3 = l6());
  }, u6 = () => {
    if (f12++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g3 = 0;
    const w6 = [];
    for (; g3 < e9; ) {
      s3 = l6();
      const y8 = s3.slice();
      w6.push(y8), g3 += s3.length;
    }
    return Ht4(...w6);
  };
  return (g3, w6) => {
    a4(), c6(g3);
    let y8;
    for (; !(y8 = w6(u6())); ) c6();
    return a4(), y8;
  };
}
function ke5(t4, e9, n4 = {}) {
  if (!t4 || typeof t4 != "object") throw new Error("expected valid options object");
  function r6(o4, s3, i6) {
    const f12 = t4[o4];
    if (i6 && f12 === void 0) return;
    const a4 = typeof f12;
    if (a4 !== s3 || f12 === null) throw new Error(`param "${o4}" is invalid: expected ${s3}, got ${a4}`);
  }
  Object.entries(e9).forEach(([o4, s3]) => r6(o4, s3, false)), Object.entries(n4).forEach(([o4, s3]) => r6(o4, s3, true));
}
function ho4(t4) {
  const e9 = /* @__PURE__ */ new WeakMap();
  return (n4, ...r6) => {
    const o4 = e9.get(n4);
    if (o4 !== void 0) return o4;
    const s3 = t4(n4, ...r6);
    return e9.set(n4, s3), s3;
  };
}
var ot3 = BigInt(0);
var Q4 = BigInt(1);
var Dt3 = BigInt(2);
var nc3 = BigInt(3);
var po4 = BigInt(4);
var go4 = BigInt(5);
var bo4 = BigInt(8);
function lt4(t4, e9) {
  const n4 = t4 % e9;
  return n4 >= ot3 ? n4 : e9 + n4;
}
function pt4(t4, e9, n4) {
  let r6 = t4;
  for (; e9-- > ot3; ) r6 *= r6, r6 %= n4;
  return r6;
}
function yo4(t4, e9) {
  if (t4 === ot3) throw new Error("invert: expected non-zero number");
  if (e9 <= ot3) throw new Error("invert: expected positive modulus, got " + e9);
  let n4 = lt4(t4, e9), r6 = e9, o4 = ot3, s3 = Q4;
  for (; n4 !== ot3; ) {
    const f12 = r6 / n4, a4 = r6 % n4, l6 = o4 - s3 * f12;
    r6 = n4, n4 = a4, o4 = s3, s3 = l6;
  }
  if (r6 !== Q4) throw new Error("invert: does not exist");
  return lt4(o4, e9);
}
function mo4(t4, e9) {
  const n4 = (t4.ORDER + Q4) / po4, r6 = t4.pow(e9, n4);
  if (!t4.eql(t4.sqr(r6), e9)) throw new Error("Cannot find square root");
  return r6;
}
function rc3(t4, e9) {
  const n4 = (t4.ORDER - go4) / bo4, r6 = t4.mul(e9, Dt3), o4 = t4.pow(r6, n4), s3 = t4.mul(e9, o4), i6 = t4.mul(t4.mul(s3, Dt3), o4), f12 = t4.mul(s3, t4.sub(i6, t4.ONE));
  if (!t4.eql(t4.sqr(f12), e9)) throw new Error("Cannot find square root");
  return f12;
}
function oc3(t4) {
  if (t4 < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e9 = t4 - Q4, n4 = 0;
  for (; e9 % Dt3 === ot3; ) e9 /= Dt3, n4++;
  let r6 = Dt3;
  const o4 = Yt4(t4);
  for (; xo4(o4, r6) === 1; ) if (r6++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n4 === 1) return mo4;
  let s3 = o4.pow(r6, e9);
  const i6 = (e9 + Q4) / Dt3;
  return function(a4, l6) {
    if (a4.is0(l6)) return l6;
    if (xo4(a4, l6) !== 1) throw new Error("Cannot find square root");
    let c6 = n4, u6 = a4.mul(a4.ONE, s3), h7 = a4.pow(l6, e9), g3 = a4.pow(l6, i6);
    for (; !a4.eql(h7, a4.ONE); ) {
      if (a4.is0(h7)) return a4.ZERO;
      let w6 = 1, y8 = a4.sqr(h7);
      for (; !a4.eql(y8, a4.ONE); ) if (w6++, y8 = a4.sqr(y8), w6 === c6) throw new Error("Cannot find square root");
      const x5 = Q4 << BigInt(c6 - w6 - 1), R6 = a4.pow(u6, x5);
      c6 = w6, u6 = a4.sqr(R6), h7 = a4.mul(h7, u6), g3 = a4.mul(g3, R6);
    }
    return g3;
  };
}
function sc3(t4) {
  return t4 % po4 === nc3 ? mo4 : t4 % bo4 === go4 ? rc3 : oc3(t4);
}
var ic3 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc3(t4) {
  const e9 = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n4 = ic3.reduce((r6, o4) => (r6[o4] = "function", r6), e9);
  return ke5(t4, n4), t4;
}
function cc3(t4, e9, n4) {
  if (n4 < ot3) throw new Error("invalid exponent, negatives unsupported");
  if (n4 === ot3) return t4.ONE;
  if (n4 === Q4) return e9;
  let r6 = t4.ONE, o4 = e9;
  for (; n4 > ot3; ) n4 & Q4 && (r6 = t4.mul(r6, o4)), o4 = t4.sqr(o4), n4 >>= Q4;
  return r6;
}
function wo4(t4, e9, n4 = false) {
  const r6 = new Array(e9.length).fill(n4 ? t4.ZERO : void 0), o4 = e9.reduce((i6, f12, a4) => t4.is0(f12) ? i6 : (r6[a4] = i6, t4.mul(i6, f12)), t4.ONE), s3 = t4.inv(o4);
  return e9.reduceRight((i6, f12, a4) => t4.is0(f12) ? i6 : (r6[a4] = t4.mul(i6, r6[a4]), t4.mul(i6, f12)), s3), r6;
}
function xo4(t4, e9) {
  const n4 = (t4.ORDER - Q4) / Dt3, r6 = t4.pow(e9, n4), o4 = t4.eql(r6, t4.ONE), s3 = t4.eql(r6, t4.ZERO), i6 = t4.eql(r6, t4.neg(t4.ONE));
  if (!o4 && !s3 && !i6) throw new Error("invalid Legendre symbol result");
  return o4 ? 1 : s3 ? 0 : -1;
}
function ac3(t4, e9) {
  e9 !== void 0 && mt4(e9);
  const n4 = e9 !== void 0 ? e9 : t4.toString(2).length, r6 = Math.ceil(n4 / 8);
  return { nBitLength: n4, nByteLength: r6 };
}
function Yt4(t4, e9, n4 = false, r6 = {}) {
  if (t4 <= ot3) throw new Error("invalid field: expected ORDER > 0, got " + t4);
  let o4, s3;
  if (typeof e9 == "object" && e9 != null) {
    if (r6.sqrt || n4) throw new Error("cannot specify opts in two arguments");
    const c6 = e9;
    c6.BITS && (o4 = c6.BITS), c6.sqrt && (s3 = c6.sqrt), typeof c6.isLE == "boolean" && (n4 = c6.isLE);
  } else typeof e9 == "number" && (o4 = e9), r6.sqrt && (s3 = r6.sqrt);
  const { nBitLength: i6, nByteLength: f12 } = ac3(t4, o4);
  if (f12 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a4;
  const l6 = Object.freeze({ ORDER: t4, isLE: n4, BITS: i6, BYTES: f12, MASK: je4(i6), ZERO: ot3, ONE: Q4, create: (c6) => lt4(c6, t4), isValid: (c6) => {
    if (typeof c6 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c6);
    return ot3 <= c6 && c6 < t4;
  }, is0: (c6) => c6 === ot3, isValidNot0: (c6) => !l6.is0(c6) && l6.isValid(c6), isOdd: (c6) => (c6 & Q4) === Q4, neg: (c6) => lt4(-c6, t4), eql: (c6, u6) => c6 === u6, sqr: (c6) => lt4(c6 * c6, t4), add: (c6, u6) => lt4(c6 + u6, t4), sub: (c6, u6) => lt4(c6 - u6, t4), mul: (c6, u6) => lt4(c6 * u6, t4), pow: (c6, u6) => cc3(l6, c6, u6), div: (c6, u6) => lt4(c6 * yo4(u6, t4), t4), sqrN: (c6) => c6 * c6, addN: (c6, u6) => c6 + u6, subN: (c6, u6) => c6 - u6, mulN: (c6, u6) => c6 * u6, inv: (c6) => yo4(c6, t4), sqrt: s3 || ((c6) => (a4 || (a4 = sc3(t4)), a4(l6, c6))), toBytes: (c6) => n4 ? An4(c6, f12) : In4(c6, f12), fromBytes: (c6) => {
    if (c6.length !== f12) throw new Error("Field.fromBytes: expected " + f12 + " bytes, got " + c6.length);
    return n4 ? Le5(c6) : Ce5(c6);
  }, invertBatch: (c6) => wo4(l6, c6), cmov: (c6, u6, h7) => h7 ? u6 : c6 });
  return Object.freeze(l6);
}
function vo4(t4) {
  if (typeof t4 != "bigint") throw new Error("field order must be bigint");
  const e9 = t4.toString(2).length;
  return Math.ceil(e9 / 8);
}
function Eo4(t4) {
  const e9 = vo4(t4);
  return e9 + Math.ceil(e9 / 2);
}
function uc3(t4, e9, n4 = false) {
  const r6 = t4.length, o4 = vo4(e9), s3 = Eo4(e9);
  if (r6 < 16 || r6 < s3 || r6 > 1024) throw new Error("expected " + s3 + "-1024 bytes of input, got " + r6);
  const i6 = n4 ? Le5(t4) : Ce5(t4), f12 = lt4(i6, e9 - Q4) + Q4;
  return n4 ? An4(f12, o4) : In4(f12, o4);
}
var Xt4 = BigInt(0);
var Mt4 = BigInt(1);
function le4(t4, e9) {
  const n4 = e9.negate();
  return t4 ? n4 : e9;
}
function lc3(t4, e9, n4) {
  const r6 = e9 === "pz" ? (i6) => i6.pz : (i6) => i6.ez, o4 = wo4(t4.Fp, n4.map(r6));
  return n4.map((i6, f12) => i6.toAffine(o4[f12])).map(t4.fromAffine);
}
function Bo4(t4, e9) {
  if (!Number.isSafeInteger(t4) || t4 <= 0 || t4 > e9) throw new Error("invalid window size, expected [1.." + e9 + "], got W=" + t4);
}
function On4(t4, e9) {
  Bo4(t4, e9);
  const n4 = Math.ceil(e9 / t4) + 1, r6 = 2 ** (t4 - 1), o4 = 2 ** t4, s3 = je4(t4), i6 = BigInt(t4);
  return { windows: n4, windowSize: r6, mask: s3, maxNumber: o4, shiftBy: i6 };
}
function Io4(t4, e9, n4) {
  const { windowSize: r6, mask: o4, maxNumber: s3, shiftBy: i6 } = n4;
  let f12 = Number(t4 & o4), a4 = t4 >> i6;
  f12 > r6 && (f12 -= s3, a4 += Mt4);
  const l6 = e9 * r6, c6 = l6 + Math.abs(f12) - 1, u6 = f12 === 0, h7 = f12 < 0, g3 = e9 % 2 !== 0;
  return { nextN: a4, offset: c6, isZero: u6, isNeg: h7, isNegF: g3, offsetF: l6 };
}
function dc3(t4, e9) {
  if (!Array.isArray(t4)) throw new Error("array expected");
  t4.forEach((n4, r6) => {
    if (!(n4 instanceof e9)) throw new Error("invalid point at index " + r6);
  });
}
function hc3(t4, e9) {
  if (!Array.isArray(t4)) throw new Error("array of scalars expected");
  t4.forEach((n4, r6) => {
    if (!e9.isValid(n4)) throw new Error("invalid scalar at index " + r6);
  });
}
var Un4 = /* @__PURE__ */ new WeakMap();
var Ao4 = /* @__PURE__ */ new WeakMap();
function _n4(t4) {
  return Ao4.get(t4) || 1;
}
function So4(t4) {
  if (t4 !== Xt4) throw new Error("invalid wNAF");
}
function pc3(t4, e9) {
  return { constTimeNegate: le4, hasPrecomputes(n4) {
    return _n4(n4) !== 1;
  }, unsafeLadder(n4, r6, o4 = t4.ZERO) {
    let s3 = n4;
    for (; r6 > Xt4; ) r6 & Mt4 && (o4 = o4.add(s3)), s3 = s3.double(), r6 >>= Mt4;
    return o4;
  }, precomputeWindow(n4, r6) {
    const { windows: o4, windowSize: s3 } = On4(r6, e9), i6 = [];
    let f12 = n4, a4 = f12;
    for (let l6 = 0; l6 < o4; l6++) {
      a4 = f12, i6.push(a4);
      for (let c6 = 1; c6 < s3; c6++) a4 = a4.add(f12), i6.push(a4);
      f12 = a4.double();
    }
    return i6;
  }, wNAF(n4, r6, o4) {
    let s3 = t4.ZERO, i6 = t4.BASE;
    const f12 = On4(n4, e9);
    for (let a4 = 0; a4 < f12.windows; a4++) {
      const { nextN: l6, offset: c6, isZero: u6, isNeg: h7, isNegF: g3, offsetF: w6 } = Io4(o4, a4, f12);
      o4 = l6, u6 ? i6 = i6.add(le4(g3, r6[w6])) : s3 = s3.add(le4(h7, r6[c6]));
    }
    return So4(o4), { p: s3, f: i6 };
  }, wNAFUnsafe(n4, r6, o4, s3 = t4.ZERO) {
    const i6 = On4(n4, e9);
    for (let f12 = 0; f12 < i6.windows && o4 !== Xt4; f12++) {
      const { nextN: a4, offset: l6, isZero: c6, isNeg: u6 } = Io4(o4, f12, i6);
      if (o4 = a4, !c6) {
        const h7 = r6[l6];
        s3 = s3.add(u6 ? h7.negate() : h7);
      }
    }
    return So4(o4), s3;
  }, getPrecomputes(n4, r6, o4) {
    let s3 = Un4.get(r6);
    return s3 || (s3 = this.precomputeWindow(r6, n4), n4 !== 1 && (typeof o4 == "function" && (s3 = o4(s3)), Un4.set(r6, s3))), s3;
  }, wNAFCached(n4, r6, o4) {
    const s3 = _n4(n4);
    return this.wNAF(s3, this.getPrecomputes(s3, n4, o4), r6);
  }, wNAFCachedUnsafe(n4, r6, o4, s3) {
    const i6 = _n4(n4);
    return i6 === 1 ? this.unsafeLadder(n4, r6, s3) : this.wNAFUnsafe(i6, this.getPrecomputes(i6, n4, o4), r6, s3);
  }, setWindowSize(n4, r6) {
    Bo4(r6, e9), Ao4.set(n4, r6), Un4.delete(n4);
  } };
}
function gc3(t4, e9, n4, r6) {
  let o4 = e9, s3 = t4.ZERO, i6 = t4.ZERO;
  for (; n4 > Xt4 || r6 > Xt4; ) n4 & Mt4 && (s3 = s3.add(o4)), r6 & Mt4 && (i6 = i6.add(o4)), o4 = o4.double(), n4 >>= Mt4, r6 >>= Mt4;
  return { p1: s3, p2: i6 };
}
function bc3(t4, e9, n4, r6) {
  dc3(n4, t4), hc3(r6, e9);
  const o4 = n4.length, s3 = r6.length;
  if (o4 !== s3) throw new Error("arrays of points and scalars must have equal length");
  const i6 = t4.ZERO, f12 = tc3(BigInt(o4));
  let a4 = 1;
  f12 > 12 ? a4 = f12 - 3 : f12 > 4 ? a4 = f12 - 2 : f12 > 0 && (a4 = 2);
  const l6 = je4(a4), c6 = new Array(Number(l6) + 1).fill(i6), u6 = Math.floor((e9.BITS - 1) / a4) * a4;
  let h7 = i6;
  for (let g3 = u6; g3 >= 0; g3 -= a4) {
    c6.fill(i6);
    for (let y8 = 0; y8 < s3; y8++) {
      const x5 = r6[y8], R6 = Number(x5 >> BigInt(g3) & l6);
      c6[R6] = c6[R6].add(n4[y8]);
    }
    let w6 = i6;
    for (let y8 = c6.length - 1, x5 = i6; y8 > 0; y8--) x5 = x5.add(c6[y8]), w6 = w6.add(x5);
    if (h7 = h7.add(w6), g3 !== 0) for (let y8 = 0; y8 < a4; y8++) h7 = h7.double();
  }
  return h7;
}
function No4(t4, e9) {
  if (e9) {
    if (e9.ORDER !== t4) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc3(e9), e9;
  } else return Yt4(t4);
}
function yc3(t4, e9, n4 = {}) {
  if (!e9 || typeof e9 != "object") throw new Error(`expected valid ${t4} CURVE object`);
  for (const f12 of ["p", "n", "h"]) {
    const a4 = e9[f12];
    if (!(typeof a4 == "bigint" && a4 > Xt4)) throw new Error(`CURVE.${f12} must be positive bigint`);
  }
  const r6 = No4(e9.p, n4.Fp), o4 = No4(e9.n, n4.Fn), i6 = ["Gx", "Gy", "a", t4 === "weierstrass" ? "b" : "d"];
  for (const f12 of i6) if (!r6.isValid(e9[f12])) throw new Error(`CURVE.${f12} must be valid field element of CURVE.Fp`);
  return { Fp: r6, Fn: o4 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de4 = BigInt(0);
var Jt4 = BigInt(1);
var Pe4 = BigInt(2);
function mc3(t4) {
  return ke5(t4, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t4 });
}
function wc3(t4) {
  const e9 = mc3(t4), { P: n4, type: r6, adjustScalarBytes: o4, powPminus2: s3, randomBytes: i6 } = e9, f12 = r6 === "x25519";
  if (!f12 && r6 !== "x448") throw new Error("invalid type");
  const a4 = i6 || Zt4, l6 = f12 ? 255 : 448, c6 = f12 ? 32 : 56, u6 = BigInt(f12 ? 9 : 5), h7 = BigInt(f12 ? 121665 : 39081), g3 = f12 ? Pe4 ** BigInt(254) : Pe4 ** BigInt(447), w6 = f12 ? BigInt(8) * Pe4 ** BigInt(251) - Jt4 : BigInt(4) * Pe4 ** BigInt(445) - Jt4, y8 = g3 + w6 + Jt4, x5 = (d5) => lt4(d5, n4), R6 = M7(u6);
  function M7(d5) {
    return An4(x5(d5), c6);
  }
  function L6(d5) {
    const m5 = rt3("u coordinate", d5, c6);
    return f12 && (m5[31] &= 127), x5(Le5(m5));
  }
  function V7(d5) {
    return Le5(o4(rt3("scalar", d5, c6)));
  }
  function _4(d5, m5) {
    const p7 = $7(L6(m5), V7(d5));
    if (p7 === de4) throw new Error("invalid private or public key received");
    return M7(p7);
  }
  function k8(d5) {
    return _4(d5, R6);
  }
  function j6(d5, m5, p7) {
    const b5 = x5(d5 * (m5 - p7));
    return m5 = x5(m5 - b5), p7 = x5(p7 + b5), { x_2: m5, x_3: p7 };
  }
  function $7(d5, m5) {
    Nn4("u", d5, de4, n4), Nn4("scalar", m5, g3, y8);
    const p7 = m5, b5 = d5;
    let v7 = Jt4, B7 = de4, E7 = d5, I7 = Jt4, S7 = de4;
    for (let A8 = BigInt(l6 - 1); A8 >= de4; A8--) {
      const T6 = p7 >> A8 & Jt4;
      S7 ^= T6, { x_2: v7, x_3: E7 } = j6(S7, v7, E7), { x_2: B7, x_3: I7 } = j6(S7, B7, I7), S7 = T6;
      const U6 = v7 + B7, C8 = x5(U6 * U6), H4 = v7 - B7, q5 = x5(H4 * H4), P6 = C8 - q5, K4 = E7 + I7, et3 = E7 - I7, Z5 = x5(et3 * U6), z6 = x5(K4 * H4), Ft3 = Z5 + z6, yt4 = Z5 - z6;
      E7 = x5(Ft3 * Ft3), I7 = x5(b5 * x5(yt4 * yt4)), v7 = x5(C8 * q5), B7 = x5(P6 * (C8 + x5(h7 * P6)));
    }
    ({ x_2: v7, x_3: E7 } = j6(S7, v7, E7)), { x_2: B7, x_3: I7 } = j6(S7, B7, I7);
    const O6 = s3(B7);
    return x5(v7 * O6);
  }
  return { scalarMult: _4, scalarMultBase: k8, getSharedSecret: (d5, m5) => _4(d5, m5), getPublicKey: (d5) => k8(d5), utils: { randomPrivateKey: () => a4(c6) }, GuBytes: R6.slice() };
}
BigInt(0);
var xc3 = BigInt(1);
var Oo4 = BigInt(2);
var vc3 = BigInt(3);
var Ec3 = BigInt(5);
var Bc3 = BigInt(8);
var Uo4 = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc3, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic3(t4) {
  const e9 = BigInt(10), n4 = BigInt(20), r6 = BigInt(40), o4 = BigInt(80), s3 = Uo4.p, f12 = t4 * t4 % s3 * t4 % s3, a4 = pt4(f12, Oo4, s3) * f12 % s3, l6 = pt4(a4, xc3, s3) * t4 % s3, c6 = pt4(l6, Ec3, s3) * l6 % s3, u6 = pt4(c6, e9, s3) * c6 % s3, h7 = pt4(u6, n4, s3) * u6 % s3, g3 = pt4(h7, r6, s3) * h7 % s3, w6 = pt4(g3, o4, s3) * g3 % s3, y8 = pt4(w6, o4, s3) * g3 % s3, x5 = pt4(y8, e9, s3) * c6 % s3;
  return { pow_p_5_8: pt4(x5, Oo4, s3) * t4 % s3, b2: f12 };
}
function Ac3(t4) {
  return t4[0] &= 248, t4[31] &= 127, t4[31] |= 64, t4;
}
var Tn4 = (() => {
  const t4 = Uo4.p;
  return wc3({ P: t4, type: "x25519", powPminus2: (e9) => {
    const { pow_p_5_8: n4, b2: r6 } = Ic3(e9);
    return lt4(pt4(n4, vc3, t4) * r6, t4);
  }, adjustScalarBytes: Ac3 });
})();
function _o4(t4) {
  t4.lowS !== void 0 && Re3("lowS", t4.lowS), t4.prehash !== void 0 && Re3("prehash", t4.prehash);
}
var Sc3 = class extends Error {
  constructor(e9 = "") {
    super(e9);
  }
};
var vt4 = { Err: Sc3, _tlv: { encode: (t4, e9) => {
  const { Err: n4 } = vt4;
  if (t4 < 0 || t4 > 256) throw new n4("tlv.encode: wrong tag");
  if (e9.length & 1) throw new n4("tlv.encode: unpadded data");
  const r6 = e9.length / 2, o4 = $e4(r6);
  if (o4.length / 2 & 128) throw new n4("tlv.encode: long form length too big");
  const s3 = r6 > 127 ? $e4(o4.length / 2 | 128) : "";
  return $e4(t4) + s3 + o4 + e9;
}, decode(t4, e9) {
  const { Err: n4 } = vt4;
  let r6 = 0;
  if (t4 < 0 || t4 > 256) throw new n4("tlv.encode: wrong tag");
  if (e9.length < 2 || e9[r6++] !== t4) throw new n4("tlv.decode: wrong tlv");
  const o4 = e9[r6++], s3 = !!(o4 & 128);
  let i6 = 0;
  if (!s3) i6 = o4;
  else {
    const a4 = o4 & 127;
    if (!a4) throw new n4("tlv.decode(long): indefinite length not supported");
    if (a4 > 4) throw new n4("tlv.decode(long): byte length is too big");
    const l6 = e9.subarray(r6, r6 + a4);
    if (l6.length !== a4) throw new n4("tlv.decode: length bytes not complete");
    if (l6[0] === 0) throw new n4("tlv.decode(long): zero leftmost byte");
    for (const c6 of l6) i6 = i6 << 8 | c6;
    if (r6 += a4, i6 < 128) throw new n4("tlv.decode(long): not minimal encoding");
  }
  const f12 = e9.subarray(r6, r6 + i6);
  if (f12.length !== i6) throw new n4("tlv.decode: wrong value length");
  return { v: f12, l: e9.subarray(r6 + i6) };
} }, _int: { encode(t4) {
  const { Err: e9 } = vt4;
  if (t4 < he4) throw new e9("integer: negative integers are not allowed");
  let n4 = $e4(t4);
  if (Number.parseInt(n4[0], 16) & 8 && (n4 = "00" + n4), n4.length & 1) throw new e9("unexpected DER parsing assertion: unpadded hex");
  return n4;
}, decode(t4) {
  const { Err: e9 } = vt4;
  if (t4[0] & 128) throw new e9("invalid signature integer: negative");
  if (t4[0] === 0 && !(t4[1] & 128)) throw new e9("invalid signature integer: unnecessary leading zero");
  return Ce5(t4);
} }, toSig(t4) {
  const { Err: e9, _int: n4, _tlv: r6 } = vt4, o4 = rt3("signature", t4), { v: s3, l: i6 } = r6.decode(48, o4);
  if (i6.length) throw new e9("invalid signature: left bytes after parsing");
  const { v: f12, l: a4 } = r6.decode(2, s3), { v: l6, l: c6 } = r6.decode(2, a4);
  if (c6.length) throw new e9("invalid signature: left bytes after parsing");
  return { r: n4.decode(f12), s: n4.decode(l6) };
}, hexFromSig(t4) {
  const { _tlv: e9, _int: n4 } = vt4, r6 = e9.encode(2, n4.encode(t4.r)), o4 = e9.encode(2, n4.encode(t4.s)), s3 = r6 + o4;
  return e9.encode(48, s3);
} };
var he4 = BigInt(0);
var pe4 = BigInt(1);
var Nc3 = BigInt(2);
var He4 = BigInt(3);
var Oc3 = BigInt(4);
function Uc3(t4, e9, n4) {
  function r6(o4) {
    const s3 = t4.sqr(o4), i6 = t4.mul(s3, o4);
    return t4.add(t4.add(i6, t4.mul(o4, e9)), n4);
  }
  return r6;
}
function To4(t4, e9, n4) {
  const { BYTES: r6 } = t4;
  function o4(s3) {
    let i6;
    if (typeof s3 == "bigint") i6 = s3;
    else {
      let f12 = rt3("private key", s3);
      if (e9) {
        if (!e9.includes(f12.length * 2)) throw new Error("invalid private key");
        const a4 = new Uint8Array(r6);
        a4.set(f12, a4.length - f12.length), f12 = a4;
      }
      try {
        i6 = t4.fromBytes(f12);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r6}, got ${typeof s3}`);
      }
    }
    if (n4 && (i6 = t4.create(i6)), !t4.isValidNot0(i6)) throw new Error("invalid private key: out of range [1..N-1]");
    return i6;
  }
  return o4;
}
function _c3(t4, e9 = {}) {
  const { Fp: n4, Fn: r6 } = yc3("weierstrass", t4, e9), { h: o4, n: s3 } = t4;
  ke5(e9, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i6 } = e9;
  if (i6 && (!n4.is0(t4.a) || typeof i6.beta != "bigint" || typeof i6.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f12() {
    if (!n4.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a4($7, d5, m5) {
    const { x: p7, y: b5 } = d5.toAffine(), v7 = n4.toBytes(p7);
    if (Re3("isCompressed", m5), m5) {
      f12();
      const B7 = !n4.isOdd(b5);
      return Ht4(Ro4(B7), v7);
    } else return Ht4(Uint8Array.of(4), v7, n4.toBytes(b5));
  }
  function l6($7) {
    at3($7);
    const d5 = n4.BYTES, m5 = d5 + 1, p7 = 2 * d5 + 1, b5 = $7.length, v7 = $7[0], B7 = $7.subarray(1);
    if (b5 === m5 && (v7 === 2 || v7 === 3)) {
      const E7 = n4.fromBytes(B7);
      if (!n4.isValid(E7)) throw new Error("bad point: is not on curve, wrong x");
      const I7 = h7(E7);
      let S7;
      try {
        S7 = n4.sqrt(I7);
      } catch (T6) {
        const U6 = T6 instanceof Error ? ": " + T6.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U6);
      }
      f12();
      const O6 = n4.isOdd(S7);
      return (v7 & 1) === 1 !== O6 && (S7 = n4.neg(S7)), { x: E7, y: S7 };
    } else if (b5 === p7 && v7 === 4) {
      const E7 = n4.fromBytes(B7.subarray(d5 * 0, d5 * 1)), I7 = n4.fromBytes(B7.subarray(d5 * 1, d5 * 2));
      if (!g3(E7, I7)) throw new Error("bad point: is not on curve");
      return { x: E7, y: I7 };
    } else throw new Error(`bad point: got length ${b5}, expected compressed=${m5} or uncompressed=${p7}`);
  }
  const c6 = e9.toBytes || a4, u6 = e9.fromBytes || l6, h7 = Uc3(n4, t4.a, t4.b);
  function g3($7, d5) {
    const m5 = n4.sqr(d5), p7 = h7($7);
    return n4.eql(m5, p7);
  }
  if (!g3(t4.Gx, t4.Gy)) throw new Error("bad curve params: generator point");
  const w6 = n4.mul(n4.pow(t4.a, He4), Oc3), y8 = n4.mul(n4.sqr(t4.b), BigInt(27));
  if (n4.is0(n4.add(w6, y8))) throw new Error("bad curve params: a or b");
  function x5($7, d5, m5 = false) {
    if (!n4.isValid(d5) || m5 && n4.is0(d5)) throw new Error(`bad point coordinate ${$7}`);
    return d5;
  }
  function R6($7) {
    if (!($7 instanceof _4)) throw new Error("ProjectivePoint expected");
  }
  const M7 = ho4(($7, d5) => {
    const { px: m5, py: p7, pz: b5 } = $7;
    if (n4.eql(b5, n4.ONE)) return { x: m5, y: p7 };
    const v7 = $7.is0();
    d5 == null && (d5 = v7 ? n4.ONE : n4.inv(b5));
    const B7 = n4.mul(m5, d5), E7 = n4.mul(p7, d5), I7 = n4.mul(b5, d5);
    if (v7) return { x: n4.ZERO, y: n4.ZERO };
    if (!n4.eql(I7, n4.ONE)) throw new Error("invZ was invalid");
    return { x: B7, y: E7 };
  }), L6 = ho4(($7) => {
    if ($7.is0()) {
      if (e9.allowInfinityPoint && !n4.is0($7.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d5, y: m5 } = $7.toAffine();
    if (!n4.isValid(d5) || !n4.isValid(m5)) throw new Error("bad point: x or y not field elements");
    if (!g3(d5, m5)) throw new Error("bad point: equation left != right");
    if (!$7.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V7($7, d5, m5, p7, b5) {
    return m5 = new _4(n4.mul(m5.px, $7), m5.py, m5.pz), d5 = le4(p7, d5), m5 = le4(b5, m5), d5.add(m5);
  }
  class _4 {
    constructor(d5, m5, p7) {
      this.px = x5("x", d5), this.py = x5("y", m5, true), this.pz = x5("z", p7), Object.freeze(this);
    }
    static fromAffine(d5) {
      const { x: m5, y: p7 } = d5 || {};
      if (!d5 || !n4.isValid(m5) || !n4.isValid(p7)) throw new Error("invalid affine point");
      if (d5 instanceof _4) throw new Error("projective point not allowed");
      return n4.is0(m5) && n4.is0(p7) ? _4.ZERO : new _4(m5, p7, n4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d5) {
      return lc3(_4, "pz", d5);
    }
    static fromBytes(d5) {
      return at3(d5), _4.fromHex(d5);
    }
    static fromHex(d5) {
      const m5 = _4.fromAffine(u6(rt3("pointHex", d5)));
      return m5.assertValidity(), m5;
    }
    static fromPrivateKey(d5) {
      const m5 = To4(r6, e9.allowedPrivateKeyLengths, e9.wrapPrivateKey);
      return _4.BASE.multiply(m5(d5));
    }
    static msm(d5, m5) {
      return bc3(_4, r6, d5, m5);
    }
    precompute(d5 = 8, m5 = true) {
      return j6.setWindowSize(this, d5), m5 || this.multiply(He4), this;
    }
    _setWindowSize(d5) {
      this.precompute(d5);
    }
    assertValidity() {
      L6(this);
    }
    hasEvenY() {
      const { y: d5 } = this.toAffine();
      if (!n4.isOdd) throw new Error("Field doesn't support isOdd");
      return !n4.isOdd(d5);
    }
    equals(d5) {
      R6(d5);
      const { px: m5, py: p7, pz: b5 } = this, { px: v7, py: B7, pz: E7 } = d5, I7 = n4.eql(n4.mul(m5, E7), n4.mul(v7, b5)), S7 = n4.eql(n4.mul(p7, E7), n4.mul(B7, b5));
      return I7 && S7;
    }
    negate() {
      return new _4(this.px, n4.neg(this.py), this.pz);
    }
    double() {
      const { a: d5, b: m5 } = t4, p7 = n4.mul(m5, He4), { px: b5, py: v7, pz: B7 } = this;
      let E7 = n4.ZERO, I7 = n4.ZERO, S7 = n4.ZERO, O6 = n4.mul(b5, b5), A8 = n4.mul(v7, v7), T6 = n4.mul(B7, B7), U6 = n4.mul(b5, v7);
      return U6 = n4.add(U6, U6), S7 = n4.mul(b5, B7), S7 = n4.add(S7, S7), E7 = n4.mul(d5, S7), I7 = n4.mul(p7, T6), I7 = n4.add(E7, I7), E7 = n4.sub(A8, I7), I7 = n4.add(A8, I7), I7 = n4.mul(E7, I7), E7 = n4.mul(U6, E7), S7 = n4.mul(p7, S7), T6 = n4.mul(d5, T6), U6 = n4.sub(O6, T6), U6 = n4.mul(d5, U6), U6 = n4.add(U6, S7), S7 = n4.add(O6, O6), O6 = n4.add(S7, O6), O6 = n4.add(O6, T6), O6 = n4.mul(O6, U6), I7 = n4.add(I7, O6), T6 = n4.mul(v7, B7), T6 = n4.add(T6, T6), O6 = n4.mul(T6, U6), E7 = n4.sub(E7, O6), S7 = n4.mul(T6, A8), S7 = n4.add(S7, S7), S7 = n4.add(S7, S7), new _4(E7, I7, S7);
    }
    add(d5) {
      R6(d5);
      const { px: m5, py: p7, pz: b5 } = this, { px: v7, py: B7, pz: E7 } = d5;
      let I7 = n4.ZERO, S7 = n4.ZERO, O6 = n4.ZERO;
      const A8 = t4.a, T6 = n4.mul(t4.b, He4);
      let U6 = n4.mul(m5, v7), C8 = n4.mul(p7, B7), H4 = n4.mul(b5, E7), q5 = n4.add(m5, p7), P6 = n4.add(v7, B7);
      q5 = n4.mul(q5, P6), P6 = n4.add(U6, C8), q5 = n4.sub(q5, P6), P6 = n4.add(m5, b5);
      let K4 = n4.add(v7, E7);
      return P6 = n4.mul(P6, K4), K4 = n4.add(U6, H4), P6 = n4.sub(P6, K4), K4 = n4.add(p7, b5), I7 = n4.add(B7, E7), K4 = n4.mul(K4, I7), I7 = n4.add(C8, H4), K4 = n4.sub(K4, I7), O6 = n4.mul(A8, P6), I7 = n4.mul(T6, H4), O6 = n4.add(I7, O6), I7 = n4.sub(C8, O6), O6 = n4.add(C8, O6), S7 = n4.mul(I7, O6), C8 = n4.add(U6, U6), C8 = n4.add(C8, U6), H4 = n4.mul(A8, H4), P6 = n4.mul(T6, P6), C8 = n4.add(C8, H4), H4 = n4.sub(U6, H4), H4 = n4.mul(A8, H4), P6 = n4.add(P6, H4), U6 = n4.mul(C8, P6), S7 = n4.add(S7, U6), U6 = n4.mul(K4, P6), I7 = n4.mul(q5, I7), I7 = n4.sub(I7, U6), U6 = n4.mul(q5, C8), O6 = n4.mul(K4, O6), O6 = n4.add(O6, U6), new _4(I7, S7, O6);
    }
    subtract(d5) {
      return this.add(d5.negate());
    }
    is0() {
      return this.equals(_4.ZERO);
    }
    multiply(d5) {
      const { endo: m5 } = e9;
      if (!r6.isValidNot0(d5)) throw new Error("invalid scalar: out of range");
      let p7, b5;
      const v7 = (B7) => j6.wNAFCached(this, B7, _4.normalizeZ);
      if (m5) {
        const { k1neg: B7, k1: E7, k2neg: I7, k2: S7 } = m5.splitScalar(d5), { p: O6, f: A8 } = v7(E7), { p: T6, f: U6 } = v7(S7);
        b5 = A8.add(U6), p7 = V7(m5.beta, O6, T6, B7, I7);
      } else {
        const { p: B7, f: E7 } = v7(d5);
        p7 = B7, b5 = E7;
      }
      return _4.normalizeZ([p7, b5])[0];
    }
    multiplyUnsafe(d5) {
      const { endo: m5 } = e9, p7 = this;
      if (!r6.isValid(d5)) throw new Error("invalid scalar: out of range");
      if (d5 === he4 || p7.is0()) return _4.ZERO;
      if (d5 === pe4) return p7;
      if (j6.hasPrecomputes(this)) return this.multiply(d5);
      if (m5) {
        const { k1neg: b5, k1: v7, k2neg: B7, k2: E7 } = m5.splitScalar(d5), { p1: I7, p2: S7 } = gc3(_4, p7, v7, E7);
        return V7(m5.beta, I7, S7, b5, B7);
      } else return j6.wNAFCachedUnsafe(p7, d5);
    }
    multiplyAndAddUnsafe(d5, m5, p7) {
      const b5 = this.multiplyUnsafe(m5).add(d5.multiplyUnsafe(p7));
      return b5.is0() ? void 0 : b5;
    }
    toAffine(d5) {
      return M7(this, d5);
    }
    isTorsionFree() {
      const { isTorsionFree: d5 } = e9;
      return o4 === pe4 ? true : d5 ? d5(_4, this) : j6.wNAFCachedUnsafe(this, s3).is0();
    }
    clearCofactor() {
      const { clearCofactor: d5 } = e9;
      return o4 === pe4 ? this : d5 ? d5(_4, this) : this.multiplyUnsafe(o4);
    }
    toBytes(d5 = true) {
      return Re3("isCompressed", d5), this.assertValidity(), c6(_4, this, d5);
    }
    toRawBytes(d5 = true) {
      return this.toBytes(d5);
    }
    toHex(d5 = true) {
      return ce4(this.toBytes(d5));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _4.BASE = new _4(t4.Gx, t4.Gy, n4.ONE), _4.ZERO = new _4(n4.ZERO, n4.ONE, n4.ZERO), _4.Fp = n4, _4.Fn = r6;
  const k8 = r6.BITS, j6 = pc3(_4, e9.endo ? Math.ceil(k8 / 2) : k8);
  return _4;
}
function Ro4(t4) {
  return Uint8Array.of(t4 ? 2 : 3);
}
function Tc3(t4, e9, n4 = {}) {
  ke5(e9, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r6 = e9.randomBytes || Zt4, o4 = e9.hmac || ((p7, ...b5) => _e5(e9.hash, p7, Ht4(...b5))), { Fp: s3, Fn: i6 } = t4, { ORDER: f12, BITS: a4 } = i6;
  function l6(p7) {
    const b5 = f12 >> pe4;
    return p7 > b5;
  }
  function c6(p7) {
    return l6(p7) ? i6.neg(p7) : p7;
  }
  function u6(p7, b5) {
    if (!i6.isValidNot0(b5)) throw new Error(`invalid signature ${p7}: out of range 1..CURVE.n`);
  }
  class h7 {
    constructor(b5, v7, B7) {
      u6("r", b5), u6("s", v7), this.r = b5, this.s = v7, B7 != null && (this.recovery = B7), Object.freeze(this);
    }
    static fromCompact(b5) {
      const v7 = i6.BYTES, B7 = rt3("compactSignature", b5, v7 * 2);
      return new h7(i6.fromBytes(B7.subarray(0, v7)), i6.fromBytes(B7.subarray(v7, v7 * 2)));
    }
    static fromDER(b5) {
      const { r: v7, s: B7 } = vt4.toSig(rt3("DER", b5));
      return new h7(v7, B7);
    }
    assertValidity() {
    }
    addRecoveryBit(b5) {
      return new h7(this.r, this.s, b5);
    }
    recoverPublicKey(b5) {
      const v7 = s3.ORDER, { r: B7, s: E7, recovery: I7 } = this;
      if (I7 == null || ![0, 1, 2, 3].includes(I7)) throw new Error("recovery id invalid");
      if (f12 * Nc3 < v7 && I7 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O6 = I7 === 2 || I7 === 3 ? B7 + f12 : B7;
      if (!s3.isValid(O6)) throw new Error("recovery id 2 or 3 invalid");
      const A8 = s3.toBytes(O6), T6 = t4.fromHex(Ht4(Ro4((I7 & 1) === 0), A8)), U6 = i6.inv(O6), C8 = L6(rt3("msgHash", b5)), H4 = i6.create(-C8 * U6), q5 = i6.create(E7 * U6), P6 = t4.BASE.multiplyUnsafe(H4).add(T6.multiplyUnsafe(q5));
      if (P6.is0()) throw new Error("point at infinify");
      return P6.assertValidity(), P6;
    }
    hasHighS() {
      return l6(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h7(this.r, i6.neg(this.s), this.recovery) : this;
    }
    toBytes(b5) {
      if (b5 === "compact") return Ht4(i6.toBytes(this.r), i6.toBytes(this.s));
      if (b5 === "der") return fn4(vt4.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce4(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce4(this.toBytes("compact"));
    }
  }
  const g3 = To4(i6, n4.allowedPrivateKeyLengths, n4.wrapPrivateKey), w6 = { isValidPrivateKey(p7) {
    try {
      return g3(p7), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g3, randomPrivateKey: () => {
    const p7 = f12;
    return uc3(r6(Eo4(p7)), p7);
  }, precompute(p7 = 8, b5 = t4.BASE) {
    return b5.precompute(p7, false);
  } };
  function y8(p7, b5 = true) {
    return t4.fromPrivateKey(p7).toBytes(b5);
  }
  function x5(p7) {
    if (typeof p7 == "bigint") return false;
    if (p7 instanceof t4) return true;
    const v7 = rt3("key", p7).length, B7 = s3.BYTES, E7 = B7 + 1, I7 = 2 * B7 + 1;
    if (!(n4.allowedPrivateKeyLengths || i6.BYTES === E7)) return v7 === E7 || v7 === I7;
  }
  function R6(p7, b5, v7 = true) {
    if (x5(p7) === true) throw new Error("first arg must be private key");
    if (x5(b5) === false) throw new Error("second arg must be public key");
    return t4.fromHex(b5).multiply(g3(p7)).toBytes(v7);
  }
  const M7 = e9.bits2int || function(p7) {
    if (p7.length > 8192) throw new Error("input is too large");
    const b5 = Ce5(p7), v7 = p7.length * 8 - a4;
    return v7 > 0 ? b5 >> BigInt(v7) : b5;
  }, L6 = e9.bits2int_modN || function(p7) {
    return i6.create(M7(p7));
  }, V7 = je4(a4);
  function _4(p7) {
    return Nn4("num < 2^" + a4, p7, he4, V7), i6.toBytes(p7);
  }
  function k8(p7, b5, v7 = j6) {
    if (["recovered", "canonical"].some((q5) => q5 in v7)) throw new Error("sign() legacy options not supported");
    const { hash: B7 } = e9;
    let { lowS: E7, prehash: I7, extraEntropy: S7 } = v7;
    E7 == null && (E7 = true), p7 = rt3("msgHash", p7), _o4(v7), I7 && (p7 = rt3("prehashed msgHash", B7(p7)));
    const O6 = L6(p7), A8 = g3(b5), T6 = [_4(A8), _4(O6)];
    if (S7 != null && S7 !== false) {
      const q5 = S7 === true ? r6(s3.BYTES) : S7;
      T6.push(rt3("extraEntropy", q5));
    }
    const U6 = Ht4(...T6), C8 = O6;
    function H4(q5) {
      const P6 = M7(q5);
      if (!i6.isValidNot0(P6)) return;
      const K4 = i6.inv(P6), et3 = t4.BASE.multiply(P6).toAffine(), Z5 = i6.create(et3.x);
      if (Z5 === he4) return;
      const z6 = i6.create(K4 * i6.create(C8 + Z5 * A8));
      if (z6 === he4) return;
      let Ft3 = (et3.x === Z5 ? 0 : 2) | Number(et3.y & pe4), yt4 = z6;
      return E7 && l6(z6) && (yt4 = c6(z6), Ft3 ^= 1), new h7(Z5, yt4, Ft3);
    }
    return { seed: U6, k2sig: H4 };
  }
  const j6 = { lowS: e9.lowS, prehash: false }, $7 = { lowS: e9.lowS, prehash: false };
  function d5(p7, b5, v7 = j6) {
    const { seed: B7, k2sig: E7 } = k8(p7, b5, v7);
    return ec3(e9.hash.outputLen, i6.BYTES, o4)(B7, E7);
  }
  t4.BASE.precompute(8);
  function m5(p7, b5, v7, B7 = $7) {
    const E7 = p7;
    b5 = rt3("msgHash", b5), v7 = rt3("publicKey", v7), _o4(B7);
    const { lowS: I7, prehash: S7, format: O6 } = B7;
    if ("strict" in B7) throw new Error("options.strict was renamed to lowS");
    if (O6 !== void 0 && !["compact", "der", "js"].includes(O6)) throw new Error('format must be "compact", "der" or "js"');
    const A8 = typeof E7 == "string" || nn4(E7), T6 = !A8 && !O6 && typeof E7 == "object" && E7 !== null && typeof E7.r == "bigint" && typeof E7.s == "bigint";
    if (!A8 && !T6) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U6, C8;
    try {
      if (T6) if (O6 === void 0 || O6 === "js") U6 = new h7(E7.r, E7.s);
      else throw new Error("invalid format");
      if (A8) {
        try {
          O6 !== "compact" && (U6 = h7.fromDER(E7));
        } catch (yt4) {
          if (!(yt4 instanceof vt4.Err)) throw yt4;
        }
        !U6 && O6 !== "der" && (U6 = h7.fromCompact(E7));
      }
      C8 = t4.fromHex(v7);
    } catch {
      return false;
    }
    if (!U6 || I7 && U6.hasHighS()) return false;
    S7 && (b5 = e9.hash(b5));
    const { r: H4, s: q5 } = U6, P6 = L6(b5), K4 = i6.inv(q5), et3 = i6.create(P6 * K4), Z5 = i6.create(H4 * K4), z6 = t4.BASE.multiplyUnsafe(et3).add(C8.multiplyUnsafe(Z5));
    return z6.is0() ? false : i6.create(z6.x) === H4;
  }
  return Object.freeze({ getPublicKey: y8, getSharedSecret: R6, sign: d5, verify: m5, utils: w6, Point: t4, Signature: h7 });
}
function Rc3(t4) {
  const e9 = { a: t4.a, b: t4.b, p: t4.Fp.ORDER, n: t4.n, h: t4.h, Gx: t4.Gx, Gy: t4.Gy }, n4 = t4.Fp, r6 = Yt4(e9.n, t4.nBitLength), o4 = { Fp: n4, Fn: r6, allowedPrivateKeyLengths: t4.allowedPrivateKeyLengths, allowInfinityPoint: t4.allowInfinityPoint, endo: t4.endo, wrapPrivateKey: t4.wrapPrivateKey, isTorsionFree: t4.isTorsionFree, clearCofactor: t4.clearCofactor, fromBytes: t4.fromBytes, toBytes: t4.toBytes };
  return { CURVE: e9, curveOpts: o4 };
}
function $c3(t4) {
  const { CURVE: e9, curveOpts: n4 } = Rc3(t4), r6 = { hash: t4.hash, hmac: t4.hmac, randomBytes: t4.randomBytes, lowS: t4.lowS, bits2int: t4.bits2int, bits2int_modN: t4.bits2int_modN };
  return { CURVE: e9, curveOpts: n4, ecdsaOpts: r6 };
}
function Cc3(t4, e9) {
  return Object.assign({}, e9, { ProjectivePoint: e9.Point, CURVE: t4 });
}
function Lc3(t4) {
  const { CURVE: e9, curveOpts: n4, ecdsaOpts: r6 } = $c3(t4), o4 = _c3(e9, n4), s3 = Tc3(o4, r6, n4);
  return Cc3(t4, s3);
}
function Rn4(t4, e9) {
  const n4 = (r6) => Lc3({ ...t4, hash: r6 });
  return { ...n4(e9), create: n4 };
}
var $o4 = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co4 = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo4 = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc3 = Yt4($o4.p);
var kc3 = Yt4(Co4.p);
var Pc3 = Yt4(Lo4.p);
var Hc3 = Rn4({ ...$o4, Fp: jc3, lowS: false }, Ae3);
Rn4({ ...Co4, Fp: kc3, lowS: false }, Yi3), Rn4({ ...Lo4, Fp: Pc3, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi4);
function Pn3(t4) {
  return t4.includes(":");
}
function Yo3(t4) {
  return Pn3(t4) ? t4.split(":")[0] : t4;
}
var Jo4 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function Kt4(t4, e9) {
  const { message: n4, code: r6 } = Jo4[t4];
  return { message: e9 ? `${n4} ${e9}` : n4, code: r6 };
}
function me4(t4, e9) {
  return Array.isArray(t4) ? typeof e9 < "u" && t4.length ? t4.every(e9) : true : false;
}
function Ve3(t4) {
  return Object.getPrototypeOf(t4) === Object.prototype && Object.keys(t4).length;
}

// node_modules/@walletconnect/universal-provider/dist/index.es.js
init_esm();
var import_events5 = __toESM(require_events());
var rt4 = "error";
var Lt3 = "wss://relay.walletconnect.org";
var Mt5 = "wc";
var Bt3 = "universal_provider";
var U3 = `${Mt5}@2:${Bt3}:`;
var nt4 = "https://rpc.walletconnect.org/v1/";
var I3 = "generic";
var Gt5 = `${nt4}bundler`;
var l2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function W5(i6) {
  return i6 == null || typeof i6 != "object" && typeof i6 != "function";
}
function at4(i6) {
  return Object.getOwnPropertySymbols(i6).filter((t4) => Object.prototype.propertyIsEnumerable.call(i6, t4));
}
function ct4(i6) {
  return i6 == null ? i6 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(i6);
}
var Jt5 = "[object RegExp]";
var ot4 = "[object String]";
var ht5 = "[object Number]";
var pt5 = "[object Boolean]";
var dt5 = "[object Arguments]";
var zt3 = "[object Symbol]";
var kt3 = "[object Date]";
var Wt5 = "[object Map]";
var Kt5 = "[object Set]";
var Vt3 = "[object Array]";
var Xt5 = "[object ArrayBuffer]";
var Yt5 = "[object Object]";
var Qt3 = "[object DataView]";
var Zt5 = "[object Uint8Array]";
var Tt5 = "[object Uint8ClampedArray]";
var te2 = "[object Uint16Array]";
var ee3 = "[object Uint32Array]";
var ie5 = "[object Int8Array]";
var se5 = "[object Int16Array]";
var re2 = "[object Int32Array]";
var ne5 = "[object Float32Array]";
var ae5 = "[object Float64Array]";
function K(i6) {
  return ArrayBuffer.isView(i6) && !(i6 instanceof DataView);
}
function ce5(i6, t4) {
  return $3(i6, void 0, i6, /* @__PURE__ */ new Map(), t4);
}
function $3(i6, t4, e9, s3 = /* @__PURE__ */ new Map(), n4 = void 0) {
  const a4 = n4?.(i6, t4, e9, s3);
  if (a4 != null) return a4;
  if (W5(i6)) return i6;
  if (s3.has(i6)) return s3.get(i6);
  if (Array.isArray(i6)) {
    const r6 = new Array(i6.length);
    s3.set(i6, r6);
    for (let c6 = 0; c6 < i6.length; c6++) r6[c6] = $3(i6[c6], c6, e9, s3, n4);
    return Object.hasOwn(i6, "index") && (r6.index = i6.index), Object.hasOwn(i6, "input") && (r6.input = i6.input), r6;
  }
  if (i6 instanceof Date) return new Date(i6.getTime());
  if (i6 instanceof RegExp) {
    const r6 = new RegExp(i6.source, i6.flags);
    return r6.lastIndex = i6.lastIndex, r6;
  }
  if (i6 instanceof Map) {
    const r6 = /* @__PURE__ */ new Map();
    s3.set(i6, r6);
    for (const [c6, o4] of i6) r6.set(c6, $3(o4, c6, e9, s3, n4));
    return r6;
  }
  if (i6 instanceof Set) {
    const r6 = /* @__PURE__ */ new Set();
    s3.set(i6, r6);
    for (const c6 of i6) r6.add($3(c6, void 0, e9, s3, n4));
    return r6;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(i6)) return i6.subarray();
  if (K(i6)) {
    const r6 = new (Object.getPrototypeOf(i6)).constructor(i6.length);
    s3.set(i6, r6);
    for (let c6 = 0; c6 < i6.length; c6++) r6[c6] = $3(i6[c6], c6, e9, s3, n4);
    return r6;
  }
  if (i6 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && i6 instanceof SharedArrayBuffer) return i6.slice(0);
  if (i6 instanceof DataView) {
    const r6 = new DataView(i6.buffer.slice(0), i6.byteOffset, i6.byteLength);
    return s3.set(i6, r6), y4(r6, i6, e9, s3, n4), r6;
  }
  if (typeof File < "u" && i6 instanceof File) {
    const r6 = new File([i6], i6.name, { type: i6.type });
    return s3.set(i6, r6), y4(r6, i6, e9, s3, n4), r6;
  }
  if (i6 instanceof Blob) {
    const r6 = new Blob([i6], { type: i6.type });
    return s3.set(i6, r6), y4(r6, i6, e9, s3, n4), r6;
  }
  if (i6 instanceof Error) {
    const r6 = new i6.constructor();
    return s3.set(i6, r6), r6.message = i6.message, r6.name = i6.name, r6.stack = i6.stack, r6.cause = i6.cause, y4(r6, i6, e9, s3, n4), r6;
  }
  if (typeof i6 == "object" && oe(i6)) {
    const r6 = Object.create(Object.getPrototypeOf(i6));
    return s3.set(i6, r6), y4(r6, i6, e9, s3, n4), r6;
  }
  return i6;
}
function y4(i6, t4, e9 = i6, s3, n4) {
  const a4 = [...Object.keys(t4), ...at4(t4)];
  for (let r6 = 0; r6 < a4.length; r6++) {
    const c6 = a4[r6], o4 = Object.getOwnPropertyDescriptor(i6, c6);
    (o4 == null || o4.writable) && (i6[c6] = $3(t4[c6], c6, e9, s3, n4));
  }
}
function oe(i6) {
  switch (ct4(i6)) {
    case dt5:
    case Vt3:
    case Xt5:
    case Qt3:
    case pt5:
    case kt3:
    case ne5:
    case ae5:
    case ie5:
    case se5:
    case re2:
    case Wt5:
    case ht5:
    case Yt5:
    case Jt5:
    case Kt5:
    case ot4:
    case zt3:
    case Zt5:
    case Tt5:
    case te2:
    case ee3:
      return true;
    default:
      return false;
  }
}
function he5(i6, t4) {
  return ce5(i6, (e9, s3, n4, a4) => {
    const r6 = t4?.(e9, s3, n4, a4);
    if (r6 != null) return r6;
    if (typeof i6 == "object") switch (Object.prototype.toString.call(i6)) {
      case ht5:
      case ot4:
      case pt5: {
        const c6 = new i6.constructor(i6?.valueOf());
        return y4(c6, i6), c6;
      }
      case dt5: {
        const c6 = {};
        return y4(c6, i6), c6.length = i6.length, c6[Symbol.iterator] = i6[Symbol.iterator], c6;
      }
      default:
        return;
    }
  });
}
function ut5(i6) {
  return he5(i6);
}
function lt5(i6) {
  return i6 !== null && typeof i6 == "object" && ct4(i6) === "[object Arguments]";
}
function ft2(i6) {
  return typeof i6 == "object" && i6 !== null;
}
function pe5() {
}
function de5(i6) {
  return K(i6);
}
function ue5(i6) {
  if (typeof i6 != "object" || i6 == null) return false;
  if (Object.getPrototypeOf(i6) === null) return true;
  if (Object.prototype.toString.call(i6) !== "[object Object]") {
    const e9 = i6[Symbol.toStringTag];
    return e9 == null || !Object.getOwnPropertyDescriptor(i6, Symbol.toStringTag)?.writable ? false : i6.toString() === `[object ${e9}]`;
  }
  let t4 = i6;
  for (; Object.getPrototypeOf(t4) !== null; ) t4 = Object.getPrototypeOf(t4);
  return Object.getPrototypeOf(i6) === t4;
}
function le5(i6) {
  if (W5(i6)) return i6;
  if (Array.isArray(i6) || K(i6) || i6 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && i6 instanceof SharedArrayBuffer) return i6.slice(0);
  const t4 = Object.getPrototypeOf(i6), e9 = t4.constructor;
  if (i6 instanceof Date || i6 instanceof Map || i6 instanceof Set) return new e9(i6);
  if (i6 instanceof RegExp) {
    const s3 = new e9(i6);
    return s3.lastIndex = i6.lastIndex, s3;
  }
  if (i6 instanceof DataView) return new e9(i6.buffer.slice(0));
  if (i6 instanceof Error) {
    const s3 = new e9(i6.message);
    return s3.stack = i6.stack, s3.name = i6.name, s3.cause = i6.cause, s3;
  }
  if (typeof File < "u" && i6 instanceof File) return new e9([i6], i6.name, { type: i6.type, lastModified: i6.lastModified });
  if (typeof i6 == "object") {
    const s3 = Object.create(t4);
    return Object.assign(s3, i6);
  }
  return i6;
}
function fe5(i6, ...t4) {
  const e9 = t4.slice(0, -1), s3 = t4[t4.length - 1];
  let n4 = i6;
  for (let a4 = 0; a4 < e9.length; a4++) {
    const r6 = e9[a4];
    n4 = x2(n4, r6, s3, /* @__PURE__ */ new Map());
  }
  return n4;
}
function x2(i6, t4, e9, s3) {
  if (W5(i6) && (i6 = Object(i6)), t4 == null || typeof t4 != "object") return i6;
  if (s3.has(t4)) return le5(s3.get(t4));
  if (s3.set(t4, i6), Array.isArray(t4)) {
    t4 = t4.slice();
    for (let a4 = 0; a4 < t4.length; a4++) t4[a4] = t4[a4] ?? void 0;
  }
  const n4 = [...Object.keys(t4), ...at4(t4)];
  for (let a4 = 0; a4 < n4.length; a4++) {
    const r6 = n4[a4];
    let c6 = t4[r6], o4 = i6[r6];
    if (lt5(c6) && (c6 = { ...c6 }), lt5(o4) && (o4 = { ...o4 }), typeof Buffer < "u" && Buffer.isBuffer(c6) && (c6 = ut5(c6)), Array.isArray(c6)) if (typeof o4 == "object" && o4 != null) {
      const v7 = [], w6 = Reflect.ownKeys(o4);
      for (let P6 = 0; P6 < w6.length; P6++) {
        const d5 = w6[P6];
        v7[d5] = o4[d5];
      }
      o4 = v7;
    } else o4 = [];
    const p7 = e9(o4, c6, r6, i6, t4, s3);
    p7 != null ? i6[r6] = p7 : Array.isArray(c6) || ft2(o4) && ft2(c6) ? i6[r6] = x2(o4, c6, e9, s3) : o4 == null && ue5(c6) ? i6[r6] = x2({}, c6, e9, s3) : o4 == null && de5(c6) ? i6[r6] = ut5(c6) : (o4 === void 0 || c6 !== void 0) && (i6[r6] = c6);
  }
  return i6;
}
function me5(i6, ...t4) {
  return fe5(i6, ...t4, pe5);
}
var ve2 = Object.defineProperty;
var ge3 = Object.defineProperties;
var Pe5 = Object.getOwnPropertyDescriptors;
var mt5 = Object.getOwnPropertySymbols;
var we3 = Object.prototype.hasOwnProperty;
var ye3 = Object.prototype.propertyIsEnumerable;
var vt5 = (i6, t4, e9) => t4 in i6 ? ve2(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var L2 = (i6, t4) => {
  for (var e9 in t4 || (t4 = {})) we3.call(t4, e9) && vt5(i6, e9, t4[e9]);
  if (mt5) for (var e9 of mt5(t4)) ye3.call(t4, e9) && vt5(i6, e9, t4[e9]);
  return i6;
};
var be3 = (i6, t4) => ge3(i6, Pe5(t4));
function u2(i6, t4, e9) {
  var s3;
  const n4 = Fe3(i6);
  return ((s3 = t4.rpcMap) == null ? void 0 : s3[n4.reference]) || `${nt4}?chainId=${n4.namespace}:${n4.reference}&projectId=${e9}`;
}
function b2(i6) {
  return i6.includes(":") ? i6.split(":")[1] : i6;
}
function gt5(i6) {
  return i6.map((t4) => `${t4.split(":")[0]}:${t4.split(":")[1]}`);
}
function Ie5(i6, t4) {
  const e9 = Object.keys(t4.namespaces).filter((n4) => n4.includes(i6));
  if (!e9.length) return [];
  const s3 = [];
  return e9.forEach((n4) => {
    const a4 = t4.namespaces[n4].accounts;
    s3.push(...a4);
  }), s3;
}
function Pt3(i6) {
  return Object.fromEntries(Object.entries(i6).filter(([t4, e9]) => {
    var s3, n4;
    return ((s3 = e9?.chains) == null ? void 0 : s3.length) && ((n4 = e9?.chains) == null ? void 0 : n4.length) > 0;
  }));
}
function M3(i6 = {}, t4 = {}) {
  const e9 = Pt3(wt5(i6)), s3 = Pt3(wt5(t4));
  return me5(e9, s3);
}
function wt5(i6) {
  var t4, e9, s3, n4, a4;
  const r6 = {};
  if (!Ve3(i6)) return r6;
  for (const [c6, o4] of Object.entries(i6)) {
    const p7 = Pn3(c6) ? [c6] : o4.chains, v7 = o4.methods || [], w6 = o4.events || [], P6 = o4.rpcMap || {}, d5 = Yo3(c6);
    r6[d5] = be3(L2(L2({}, r6[d5]), o4), { chains: ct3(p7, (t4 = r6[d5]) == null ? void 0 : t4.chains), methods: ct3(v7, (e9 = r6[d5]) == null ? void 0 : e9.methods), events: ct3(w6, (s3 = r6[d5]) == null ? void 0 : s3.events) }), (Ve3(P6) || Ve3(((n4 = r6[d5]) == null ? void 0 : n4.rpcMap) || {})) && (r6[d5].rpcMap = L2(L2({}, P6), (a4 = r6[d5]) == null ? void 0 : a4.rpcMap));
  }
  return r6;
}
function yt2(i6) {
  return i6.includes(":") ? i6.split(":")[2] : i6;
}
function bt2(i6) {
  const t4 = {};
  for (const [e9, s3] of Object.entries(i6)) {
    const n4 = s3.methods || [], a4 = s3.events || [], r6 = s3.accounts || [], c6 = Pn3(e9) ? [e9] : s3.chains ? s3.chains : gt5(s3.accounts);
    t4[e9] = { chains: c6, methods: n4, events: a4, accounts: r6 };
  }
  return t4;
}
function V3(i6) {
  return typeof i6 == "number" ? i6 : i6.includes("0x") ? parseInt(i6, 16) : (i6 = i6.includes(":") ? i6.split(":")[1] : i6, isNaN(Number(i6)) ? i6 : Number(i6));
}
var It3 = {};
var h3 = (i6) => It3[i6];
var X5 = (i6, t4) => {
  It3[i6] = t4;
};
var $e5 = Object.defineProperty;
var $t5 = Object.getOwnPropertySymbols;
var Oe2 = Object.prototype.hasOwnProperty;
var Ae4 = Object.prototype.propertyIsEnumerable;
var Ot5 = (i6, t4, e9) => t4 in i6 ? $e5(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var At5 = (i6, t4) => {
  for (var e9 in t4 || (t4 = {})) Oe2.call(t4, e9) && Ot5(i6, e9, t4[e9]);
  if ($t5) for (var e9 of $t5(t4)) Ae4.call(t4, e9) && Ot5(i6, e9, t4[e9]);
  return i6;
};
var Ct5 = "eip155";
var Ce6 = ["atomic", "flow-control", "paymasterService", "sessionKeys", "auxiliaryFunds"];
var Ee3 = (i6) => i6 && i6.startsWith("0x") ? BigInt(i6).toString(10) : i6;
var Y5 = (i6) => i6 && i6.startsWith("0x") ? i6 : `0x${BigInt(i6).toString(16)}`;
var Et4 = (i6) => Object.keys(i6).filter((t4) => Ce6.includes(t4)).reduce((t4, e9) => (t4[e9] = i6[e9], t4), {});
var He5 = (i6, t4, e9) => {
  const { sessionProperties: s3 = {}, scopedProperties: n4 = {} } = i6, a4 = {};
  if (!Ve3(n4) && !Ve3(s3)) return;
  const r6 = Et4(s3);
  for (const c6 of e9) {
    const o4 = Ee3(c6);
    if (!o4) continue;
    a4[Y5(o4)] = r6;
    const p7 = n4?.[`${Ct5}:${o4}`];
    if (p7) {
      const v7 = p7?.[`${Ct5}:${o4}:${t4}`];
      a4[Y5(o4)] = At5(At5({}, a4[Y5(o4)]), Et4(v7 || p7));
    }
  }
  for (const [c6, o4] of Object.entries(a4)) Object.keys(o4).length === 0 && delete a4[c6];
  return Object.keys(a4).length > 0 ? a4 : void 0;
};
var Se3 = Object.defineProperty;
var Ne2 = (i6, t4, e9) => t4 in i6 ? Se3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var O3 = (i6, t4, e9) => Ne2(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var De3 = class {
  constructor(t4) {
    O3(this, "name", "polkadot"), O3(this, "client"), O3(this, "httpProviders"), O3(this, "events"), O3(this, "namespace"), O3(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(t4, e9), this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t4}`);
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      const n4 = b2(e9);
      t4[n4] = this.createHttpProvider(n4, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace, this.client.core.projectId);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
};
var qe3 = Object.defineProperty;
var je5 = Object.defineProperties;
var Re4 = Object.getOwnPropertyDescriptors;
var Ht5 = Object.getOwnPropertySymbols;
var _e6 = Object.prototype.hasOwnProperty;
var Fe4 = Object.prototype.propertyIsEnumerable;
var Q5 = (i6, t4, e9) => t4 in i6 ? qe3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var St6 = (i6, t4) => {
  for (var e9 in t4 || (t4 = {})) _e6.call(t4, e9) && Q5(i6, e9, t4[e9]);
  if (Ht5) for (var e9 of Ht5(t4)) Fe4.call(t4, e9) && Q5(i6, e9, t4[e9]);
  return i6;
};
var Nt5 = (i6, t4) => je5(i6, Re4(t4));
var A4 = (i6, t4, e9) => Q5(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var Ue5 = class {
  constructor(t4) {
    A4(this, "name", "eip155"), A4(this, "client"), A4(this, "chainId"), A4(this, "namespace"), A4(this, "httpProviders"), A4(this, "events"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t4) {
    switch (t4.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t4);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t4);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t4);
    }
    return this.namespace.methods.includes(t4.request.method) ? await this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(parseInt(t4), e9), this.chainId = parseInt(t4), this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t4}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(`${this.name}:${t4}`, this.namespace, this.client.core.projectId);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      const n4 = parseInt(b2(e9));
      t4[n4] = this.createHttpProvider(n4, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t4 = this.chainId, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  async handleSwitchChain(t4) {
    var e9, s3;
    let n4 = t4.request.params ? (e9 = t4.request.params[0]) == null ? void 0 : e9.chainId : "0x0";
    n4 = n4.startsWith("0x") ? n4 : `0x${n4}`;
    const a4 = parseInt(n4, 16);
    if (this.isChainApproved(a4)) this.setDefaultChain(`${a4}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t4.topic, request: { method: t4.request.method, params: [{ chainId: n4 }] }, chainId: (s3 = this.namespace.chains) == null ? void 0 : s3[0] }), this.setDefaultChain(`${a4}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a4}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t4) {
    return this.namespace.chains.includes(`${this.name}:${t4}`);
  }
  async getCapabilities(t4) {
    var e9, s3, n4, a4, r6;
    const c6 = (s3 = (e9 = t4.request) == null ? void 0 : e9.params) == null ? void 0 : s3[0], o4 = ((a4 = (n4 = t4.request) == null ? void 0 : n4.params) == null ? void 0 : a4[1]) || [];
    if (!c6) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const p7 = this.client.session.get(t4.topic), v7 = ((r6 = p7?.sessionProperties) == null ? void 0 : r6.capabilities) || {}, w6 = `${c6}${o4.join(",")}`, P6 = v7?.[w6];
    if (P6) return P6;
    let d5;
    try {
      d5 = He5(p7, c6, o4);
    } catch (J5) {
      console.warn("Failed to extract capabilities from session", J5);
    }
    if (d5) return d5;
    const tt5 = await this.client.request(t4);
    try {
      await this.client.session.update(t4.topic, { sessionProperties: Nt5(St6({}, p7.sessionProperties || {}), { capabilities: Nt5(St6({}, v7 || {}), { [w6]: tt5 }) }) });
    } catch (J5) {
      console.warn("Failed to update session with capabilities", J5);
    }
    return tt5;
  }
  async getCallStatus(t4) {
    var e9, s3;
    const n4 = this.client.session.get(t4.topic), a4 = (e9 = n4.sessionProperties) == null ? void 0 : e9.bundler_name;
    if (a4) {
      const c6 = this.getBundlerUrl(t4.chainId, a4);
      try {
        return await this.getUserOperationReceipt(c6, t4);
      } catch (o4) {
        console.warn("Failed to fetch call status from bundler", o4, c6);
      }
    }
    const r6 = (s3 = n4.sessionProperties) == null ? void 0 : s3.bundler_url;
    if (r6) try {
      return await this.getUserOperationReceipt(r6, t4);
    } catch (c6) {
      console.warn("Failed to fetch call status from custom bundler", c6, r6);
    }
    if (this.namespace.methods.includes(t4.request.method)) return await this.client.request(t4);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t4, e9) {
    var s3;
    const n4 = new URL(t4), a4 = await fetch(n4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(s3 = e9.request.params) == null ? void 0 : s3[0]])) });
    if (!a4.ok) throw new Error(`Failed to fetch user operation receipt - ${a4.status}`);
    return await a4.json();
  }
  getBundlerUrl(t4, e9) {
    return `${Gt5}?projectId=${this.client.core.projectId}&chainId=${t4}&bundler=${e9}`;
  }
};
var xe3 = Object.defineProperty;
var Le6 = (i6, t4, e9) => t4 in i6 ? xe3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var C3 = (i6, t4, e9) => Le6(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var Me4 = class {
  constructor(t4) {
    C3(this, "name", "solana"), C3(this, "client"), C3(this, "httpProviders"), C3(this, "events"), C3(this, "namespace"), C3(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(t4, e9), this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t4}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      const n4 = b2(e9);
      t4[n4] = this.createHttpProvider(n4, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace, this.client.core.projectId);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
};
var Be5 = Object.defineProperty;
var Ge2 = (i6, t4, e9) => t4 in i6 ? Be5(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var E3 = (i6, t4, e9) => Ge2(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var Je2 = class {
  constructor(t4) {
    E3(this, "name", "cosmos"), E3(this, "client"), E3(this, "httpProviders"), E3(this, "events"), E3(this, "namespace"), E3(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(t4, e9), this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      const n4 = b2(e9);
      t4[n4] = this.createHttpProvider(n4, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace, this.client.core.projectId);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
};
var ze2 = Object.defineProperty;
var ke6 = (i6, t4, e9) => t4 in i6 ? ze2(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var H = (i6, t4, e9) => ke6(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var We2 = class {
  constructor(t4) {
    H(this, "name", "algorand"), H(this, "client"), H(this, "httpProviders"), H(this, "events"), H(this, "namespace"), H(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    if (!this.httpProviders[t4]) {
      const s3 = e9 || u2(`${this.name}:${t4}`, this.namespace, this.client.core.projectId);
      if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
      this.setHttpProvider(t4, s3);
    }
    this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      t4[e9] = this.createHttpProvider(e9, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace, this.client.core.projectId);
    return typeof s3 > "u" ? void 0 : new o(new f2(s3, h3("disableProviderPing")));
  }
};
var Ke6 = Object.defineProperty;
var Ve4 = (i6, t4, e9) => t4 in i6 ? Ke6(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var S3 = (i6, t4, e9) => Ve4(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var Xe3 = class {
  constructor(t4) {
    S3(this, "name", "cip34"), S3(this, "client"), S3(this, "httpProviders"), S3(this, "events"), S3(this, "namespace"), S3(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(t4, e9), this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      const s3 = this.getCardanoRPCUrl(e9), n4 = b2(e9);
      t4[n4] = this.createHttpProvider(n4, s3);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  getCardanoRPCUrl(t4) {
    const e9 = this.namespace.rpcMap;
    if (e9) return e9[t4];
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || this.getCardanoRPCUrl(t4);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
};
var Ye3 = Object.defineProperty;
var Qe4 = (i6, t4, e9) => t4 in i6 ? Ye3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var N5 = (i6, t4, e9) => Qe4(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var Ze3 = class {
  constructor(t4) {
    N5(this, "name", "elrond"), N5(this, "client"), N5(this, "httpProviders"), N5(this, "events"), N5(this, "namespace"), N5(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(t4, e9), this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t4}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      const n4 = b2(e9);
      t4[n4] = this.createHttpProvider(n4, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace, this.client.core.projectId);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
};
var Te3 = Object.defineProperty;
var ti2 = (i6, t4, e9) => t4 in i6 ? Te3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var D4 = (i6, t4, e9) => ti2(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var ei3 = class {
  constructor(t4) {
    D4(this, "name", "multiversx"), D4(this, "client"), D4(this, "httpProviders"), D4(this, "events"), D4(this, "namespace"), D4(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(t4, e9), this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t4}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      const n4 = b2(e9);
      t4[n4] = this.createHttpProvider(n4, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace, this.client.core.projectId);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
};
var ii3 = Object.defineProperty;
var si3 = (i6, t4, e9) => t4 in i6 ? ii3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var q = (i6, t4, e9) => si3(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var ri3 = class {
  constructor(t4) {
    q(this, "name", "near"), q(this, "client"), q(this, "httpProviders"), q(this, "events"), q(this, "namespace"), q(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    if (this.chainId = t4, !this.httpProviders[t4]) {
      const s3 = e9 || u2(`${this.name}:${t4}`, this.namespace);
      if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
      this.setHttpProvider(t4, s3);
    }
    this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      var s3;
      t4[e9] = this.createHttpProvider(e9, (s3 = this.namespace.rpcMap) == null ? void 0 : s3[e9]);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace);
    return typeof s3 > "u" ? void 0 : new o(new f2(s3, h3("disableProviderPing")));
  }
};
var ni3 = Object.defineProperty;
var ai3 = (i6, t4, e9) => t4 in i6 ? ni3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var j = (i6, t4, e9) => ai3(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var ci3 = class {
  constructor(t4) {
    j(this, "name", "tezos"), j(this, "client"), j(this, "httpProviders"), j(this, "events"), j(this, "namespace"), j(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace = Object.assign(this.namespace, t4);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider().request(t4.request);
  }
  setDefaultChain(t4, e9) {
    if (this.chainId = t4, !this.httpProviders[t4]) {
      const s3 = e9 || u2(`${this.name}:${t4}`, this.namespace);
      if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
      this.setHttpProvider(t4, s3);
    }
    this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t4 = {};
    return this.namespace.chains.forEach((e9) => {
      t4[e9] = this.createHttpProvider(e9);
    }), t4;
  }
  getHttpProvider() {
    const t4 = `${this.name}:${this.chainId}`, e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace);
    return typeof s3 > "u" ? void 0 : new o(new f2(s3));
  }
};
var oi3 = Object.defineProperty;
var hi3 = (i6, t4, e9) => t4 in i6 ? oi3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var R3 = (i6, t4, e9) => hi3(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var pi3 = class {
  constructor(t4) {
    R3(this, "name", I3), R3(this, "client"), R3(this, "httpProviders"), R3(this, "events"), R3(this, "namespace"), R3(this, "chainId"), this.namespace = t4.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t4) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t4.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t4.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t4.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t4.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t4) {
    return this.namespace.methods.includes(t4.request.method) ? this.client.request(t4) : this.getHttpProvider(t4.chainId).request(t4.request);
  }
  setDefaultChain(t4, e9) {
    this.httpProviders[t4] || this.setHttpProvider(t4, e9), this.chainId = t4, this.events.emit(l2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t4}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t4 = this.namespace.chains[0];
    if (!t4) throw new Error("ChainId not found");
    return t4.split(":")[1];
  }
  getAccounts() {
    const t4 = this.namespace.accounts;
    return t4 ? [...new Set(t4.filter((e9) => e9.split(":")[1] === this.chainId.toString()).map((e9) => e9.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t4, e9;
    const s3 = {};
    return (e9 = (t4 = this.namespace) == null ? void 0 : t4.accounts) == null || e9.forEach((n4) => {
      const a4 = Fe3(n4);
      s3[`${a4.namespace}:${a4.reference}`] = this.createHttpProvider(n4);
    }), s3;
  }
  getHttpProvider(t4) {
    const e9 = this.httpProviders[t4];
    if (typeof e9 > "u") throw new Error(`JSON-RPC provider for ${t4} not found`);
    return e9;
  }
  setHttpProvider(t4, e9) {
    const s3 = this.createHttpProvider(t4, e9);
    s3 && (this.httpProviders[t4] = s3);
  }
  createHttpProvider(t4, e9) {
    const s3 = e9 || u2(t4, this.namespace, this.client.core.projectId);
    if (!s3) throw new Error(`No RPC url provided for chainId: ${t4}`);
    return new o(new f2(s3, h3("disableProviderPing")));
  }
};
var di3 = Object.defineProperty;
var ui3 = Object.defineProperties;
var li3 = Object.getOwnPropertyDescriptors;
var Dt4 = Object.getOwnPropertySymbols;
var fi3 = Object.prototype.hasOwnProperty;
var mi5 = Object.prototype.propertyIsEnumerable;
var Z2 = (i6, t4, e9) => t4 in i6 ? di3(i6, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : i6[t4] = e9;
var B2 = (i6, t4) => {
  for (var e9 in t4 || (t4 = {})) fi3.call(t4, e9) && Z2(i6, e9, t4[e9]);
  if (Dt4) for (var e9 of Dt4(t4)) mi5.call(t4, e9) && Z2(i6, e9, t4[e9]);
  return i6;
};
var T2 = (i6, t4) => ui3(i6, li3(t4));
var f6 = (i6, t4, e9) => Z2(i6, typeof t4 != "symbol" ? t4 + "" : t4, e9);
var G5 = class _G {
  constructor(t4) {
    f6(this, "client"), f6(this, "namespaces"), f6(this, "optionalNamespaces"), f6(this, "sessionProperties"), f6(this, "scopedProperties"), f6(this, "events", new import_events5.default()), f6(this, "rpcProviders", {}), f6(this, "session"), f6(this, "providerOpts"), f6(this, "logger"), f6(this, "uri"), f6(this, "disableProviderPing", false), this.providerOpts = t4, this.logger = typeof t4?.logger < "u" && typeof t4?.logger != "string" ? t4.logger : (0, import_pino.default)(k({ level: t4?.logger || rt4 })), this.disableProviderPing = t4?.disableProviderPing || false;
  }
  static async init(t4) {
    const e9 = new _G(t4);
    return await e9.initialize(), e9;
  }
  async request(t4, e9, s3) {
    const [n4, a4] = this.validateChain(e9);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(n4).request({ request: B2({}, t4), chainId: `${n4}:${a4}`, topic: this.session.topic, expiry: s3 });
  }
  sendAsync(t4, e9, s3, n4) {
    const a4 = (/* @__PURE__ */ new Date()).getTime();
    this.request(t4, s3, n4).then((r6) => e9(null, formatJsonRpcResult(a4, r6))).catch((r6) => e9(r6, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t4;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t4 = this.session) == null ? void 0 : t4.topic, reason: Kt4("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t4) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t4), await this.cleanupPendingPairings(), !t4.skipPairing) return await this.pair(t4.pairingTopic);
  }
  async authenticate(t4, e9) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t4), await this.cleanupPendingPairings();
    const { uri: s3, response: n4 } = await this.client.authenticate(t4, e9);
    s3 && (this.uri = s3, this.events.emit("display_uri", s3));
    const a4 = await n4();
    if (this.session = a4.session, this.session) {
      const r6 = bt2(this.session.namespaces);
      this.namespaces = M3(this.namespaces, r6), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a4;
  }
  on(t4, e9) {
    this.events.on(t4, e9);
  }
  once(t4, e9) {
    this.events.once(t4, e9);
  }
  removeListener(t4, e9) {
    this.events.removeListener(t4, e9);
  }
  off(t4, e9) {
    this.events.off(t4, e9);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t4) {
    const { uri: e9, approval: s3 } = await this.client.connect({ pairingTopic: t4, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e9 && (this.uri = e9, this.events.emit("display_uri", e9));
    const n4 = await s3();
    this.session = n4;
    const a4 = bt2(n4.namespaces);
    return this.namespaces = M3(this.namespaces, a4), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t4, e9) {
    try {
      if (!this.session) return;
      const [s3, n4] = this.validateChain(t4), a4 = this.getProvider(s3);
      a4.name === I3 ? a4.setDefaultChain(`${s3}:${n4}`, e9) : a4.setDefaultChain(n4, e9);
    } catch (s3) {
      if (!/Please call connect/.test(s3.message)) throw s3;
    }
  }
  async cleanupPendingPairings(t4 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const e9 = this.client.pairing.getAll();
    if (me4(e9)) {
      for (const s3 of e9) t4.deletePairings ? this.client.core.expirer.set(s3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s3.topic);
      this.logger.info(`Inactive pairings cleared: ${e9.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t4, e9;
    if (this.client = this.providerOpts.client || await Ee2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || rt4, relayUrl: this.providerOpts.relayUrl || Lt3, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (s3) {
      throw this.logger.error("Failed to get session", s3), new Error(`The provided session: ${(e9 = (t4 = this.providerOpts) == null ? void 0 : t4.session) == null ? void 0 : e9.topic} doesn't exist in the Sign client`);
    }
    else {
      const s3 = this.client.session.getAll();
      this.session = s3[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t4 = [...new Set(Object.keys(this.session.namespaces).map((e9) => Yo3(e9)))];
    X5("client", this.client), X5("events", this.events), X5("disableProviderPing", this.disableProviderPing), t4.forEach((e9) => {
      if (!this.session) return;
      const s3 = Ie5(e9, this.session);
      if (s3?.length === 0) return;
      const n4 = gt5(s3), a4 = M3(this.namespaces, this.optionalNamespaces), r6 = T2(B2({}, a4[e9]), { accounts: s3, chains: n4 });
      switch (e9) {
        case "eip155":
          this.rpcProviders[e9] = new Ue5({ namespace: r6 });
          break;
        case "algorand":
          this.rpcProviders[e9] = new We2({ namespace: r6 });
          break;
        case "solana":
          this.rpcProviders[e9] = new Me4({ namespace: r6 });
          break;
        case "cosmos":
          this.rpcProviders[e9] = new Je2({ namespace: r6 });
          break;
        case "polkadot":
          this.rpcProviders[e9] = new De3({ namespace: r6 });
          break;
        case "cip34":
          this.rpcProviders[e9] = new Xe3({ namespace: r6 });
          break;
        case "elrond":
          this.rpcProviders[e9] = new Ze3({ namespace: r6 });
          break;
        case "multiversx":
          this.rpcProviders[e9] = new ei3({ namespace: r6 });
          break;
        case "near":
          this.rpcProviders[e9] = new ri3({ namespace: r6 });
          break;
        case "tezos":
          this.rpcProviders[e9] = new ci3({ namespace: r6 });
          break;
        default:
          this.rpcProviders[I3] ? this.rpcProviders[I3].updateNamespace(r6) : this.rpcProviders[I3] = new pi3({ namespace: r6 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t4) => {
      var e9;
      const { topic: s3 } = t4;
      s3 === ((e9 = this.session) == null ? void 0 : e9.topic) && this.events.emit("session_ping", t4);
    }), this.client.on("session_event", (t4) => {
      var e9;
      const { params: s3, topic: n4 } = t4;
      if (n4 !== ((e9 = this.session) == null ? void 0 : e9.topic)) return;
      const { event: a4 } = s3;
      if (a4.name === "accountsChanged") {
        const r6 = a4.data;
        r6 && me4(r6) && this.events.emit("accountsChanged", r6.map(yt2));
      } else if (a4.name === "chainChanged") {
        const r6 = s3.chainId, c6 = s3.event.data, o4 = Yo3(r6), p7 = V3(r6) !== V3(c6) ? `${o4}:${V3(c6)}` : r6;
        this.onChainChanged(p7);
      } else this.events.emit(a4.name, a4.data);
      this.events.emit("session_event", t4);
    }), this.client.on("session_update", ({ topic: t4, params: e9 }) => {
      var s3, n4;
      if (t4 !== ((s3 = this.session) == null ? void 0 : s3.topic)) return;
      const { namespaces: a4 } = e9, r6 = (n4 = this.client) == null ? void 0 : n4.session.get(t4);
      this.session = T2(B2({}, r6), { namespaces: a4 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t4, params: e9 });
    }), this.client.on("session_delete", async (t4) => {
      var e9;
      t4.topic === ((e9 = this.session) == null ? void 0 : e9.topic) && (await this.cleanup(), this.events.emit("session_delete", t4), this.events.emit("disconnect", T2(B2({}, Kt4("USER_DISCONNECTED")), { data: t4.topic })));
    }), this.on(l2.DEFAULT_CHAIN_CHANGED, (t4) => {
      this.onChainChanged(t4, true);
    });
  }
  getProvider(t4) {
    return this.rpcProviders[t4] || this.rpcProviders[I3];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t4) => {
      var e9;
      this.getProvider(t4).updateNamespace((e9 = this.session) == null ? void 0 : e9.namespaces[t4]);
    });
  }
  setNamespaces(t4) {
    const { namespaces: e9 = {}, optionalNamespaces: s3 = {}, sessionProperties: n4, scopedProperties: a4 } = t4;
    this.optionalNamespaces = M3(e9, s3), this.sessionProperties = n4, this.scopedProperties = a4;
  }
  validateChain(t4) {
    const [e9, s3] = t4?.split(":") || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e9, s3];
    if (e9 && !Object.keys(this.namespaces || {}).map((r6) => Yo3(r6)).includes(e9)) throw new Error(`Namespace '${e9}' is not configured. Please call connect() first with namespace config.`);
    if (e9 && s3) return [e9, s3];
    const n4 = Yo3(Object.keys(this.namespaces)[0]), a4 = this.rpcProviders[n4].getDefaultChain();
    return [n4, a4];
  }
  async requestAccounts() {
    const [t4] = this.validateChain();
    return await this.getProvider(t4).requestAccounts();
  }
  async onChainChanged(t4, e9 = false) {
    if (!this.namespaces) return;
    const [s3, n4] = this.validateChain(t4);
    if (!n4) return;
    this.updateNamespaceChain(s3, n4), this.events.emit("chainChanged", n4);
    const a4 = this.getProvider(s3).getDefaultChain();
    e9 || this.getProvider(s3).setDefaultChain(n4), this.emitAccountsChangedOnChainChange({ namespace: s3, previousChainId: a4, newChainId: t4 }), await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({ namespace: t4, previousChainId: e9, newChainId: s3 }) {
    var n4, a4;
    try {
      if (e9 === s3) return;
      const r6 = (a4 = (n4 = this.session) == null ? void 0 : n4.namespaces[t4]) == null ? void 0 : a4.accounts;
      if (!r6) return;
      const c6 = r6.filter((o4) => o4.includes(`${s3}:`)).map(yt2);
      if (!me4(c6)) return;
      this.events.emit("accountsChanged", c6);
    } catch (r6) {
      this.logger.warn("Failed to emit accountsChanged on chain change", r6);
    }
  }
  updateNamespaceChain(t4, e9) {
    if (!this.namespaces) return;
    const s3 = this.namespaces[t4] ? t4 : `${t4}:${e9}`, n4 = { chains: [], methods: [], events: [], defaultChain: e9 };
    this.namespaces[s3] ? this.namespaces[s3] && (this.namespaces[s3].defaultChain = e9) : this.namespaces[s3] = n4;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t4, e9) {
    var s3;
    const n4 = ((s3 = this.session) == null ? void 0 : s3.topic) || "";
    await this.client.core.storage.setItem(`${U3}/${t4}${n4}`, e9);
  }
  async getFromStore(t4) {
    var e9;
    const s3 = ((e9 = this.session) == null ? void 0 : e9.topic) || "";
    return await this.client.core.storage.getItem(`${U3}/${t4}${s3}`);
  }
  async deleteFromStore(t4) {
    var e9;
    const s3 = ((e9 = this.session) == null ? void 0 : e9.topic) || "";
    await this.client.core.storage.removeItem(`${U3}/${t4}${s3}`);
  }
  async cleanupStorage() {
    var t4;
    try {
      if (((t4 = this.client) == null ? void 0 : t4.session.length) > 0) return;
      const e9 = await this.client.core.storage.getKeys();
      for (const s3 of e9) s3.startsWith(U3) && await this.client.core.storage.removeItem(s3);
    } catch (e9) {
      this.logger.warn("Failed to cleanup storage", e9);
    }
  }
};
var vi5 = G5;

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var $4 = "wc";
var k4 = "ethereum_provider";
var q2 = `${$4}@2:${k4}:`;
var U4 = "https://rpc.walletconnect.org/v1/";
var f7 = ["eth_sendTransaction", "personal_sign"];
var A5 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"];
var C4 = ["chainChanged", "accountsChanged"];
var P3 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var D5 = async () => {
  const { createAppKit: s3 } = await import("./core-X7EM3XVQ.js");
  return s3;
};
var z2 = Object.defineProperty;
var L3 = Object.defineProperties;
var K2 = Object.getOwnPropertyDescriptors;
var M4 = Object.getOwnPropertySymbols;
var Q6 = Object.prototype.hasOwnProperty;
var V4 = Object.prototype.propertyIsEnumerable;
var _ = (s3, t4, e9) => t4 in s3 ? z2(s3, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : s3[t4] = e9;
var v3 = (s3, t4) => {
  for (var e9 in t4 || (t4 = {})) Q6.call(t4, e9) && _(s3, e9, t4[e9]);
  if (M4) for (var e9 of M4(t4)) V4.call(t4, e9) && _(s3, e9, t4[e9]);
  return s3;
};
var w2 = (s3, t4) => L3(s3, K2(t4));
var p3 = (s3, t4, e9) => _(s3, typeof t4 != "symbol" ? t4 + "" : t4, e9);
function I4(s3) {
  return Number(s3[0].split(":")[1]);
}
function E4(s3) {
  return `0x${s3.toString(16)}`;
}
function G6(s3) {
  const { chains: t4, optionalChains: e9, methods: n4, optionalMethods: i6, events: a4, optionalEvents: o4, rpcMap: u6 } = s3;
  if (!me(t4)) throw new Error("Invalid chains");
  const c6 = { chains: t4, methods: n4 || f7, events: a4 || C4, rpcMap: v3({}, t4.length ? { [I4(t4)]: u6[I4(t4)] } : {}) }, l6 = a4?.filter((d5) => !C4.includes(d5)), r6 = n4?.filter((d5) => !f7.includes(d5));
  if (!e9 && !o4 && !i6 && !(l6 != null && l6.length) && !(r6 != null && r6.length)) return { required: t4.length ? c6 : void 0 };
  const m5 = l6?.length && r6?.length || !e9, h7 = { chains: [...new Set(m5 ? c6.chains.concat(e9 || []) : e9)], methods: [...new Set(c6.methods.concat(i6 != null && i6.length ? i6 : A5))], events: [...new Set(c6.events.concat(o4 != null && o4.length ? o4 : P3))], rpcMap: u6 };
  return { required: t4.length ? c6 : void 0, optional: e9.length ? h7 : void 0 };
}
var b3 = class _b {
  constructor() {
    p3(this, "events", new import_events6.EventEmitter()), p3(this, "namespace", "eip155"), p3(this, "accounts", []), p3(this, "signer"), p3(this, "chainId", 1), p3(this, "modal"), p3(this, "rpc"), p3(this, "STORAGE_KEY", q2), p3(this, "on", (t4, e9) => (this.events.on(t4, e9), this)), p3(this, "once", (t4, e9) => (this.events.once(t4, e9), this)), p3(this, "removeListener", (t4, e9) => (this.events.removeListener(t4, e9), this)), p3(this, "off", (t4, e9) => (this.events.off(t4, e9), this)), p3(this, "parseAccount", (t4) => this.isCompatibleChainId(t4) ? this.parseAccountId(t4).address : t4), this.signer = {}, this.rpc = {};
  }
  static async init(t4) {
    const e9 = new _b();
    return await e9.initialize(t4), e9;
  }
  async request(t4, e9) {
    return await this.signer.request(t4, this.formatChainId(this.chainId), e9);
  }
  sendAsync(t4, e9, n4) {
    this.signer.sendAsync(t4, e9, this.formatChainId(this.chainId), n4);
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t4) {
    var e9;
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t4);
    const { required: n4, optional: i6 } = G6(this.rpc);
    try {
      const a4 = await new Promise(async (u6, c6) => {
        var l6, r6;
        this.rpc.showQrModal && ((l6 = this.modal) == null || l6.open(), (r6 = this.modal) == null || r6.subscribeState((h7) => {
          !h7.open && !this.signer.session && (this.signer.abortPairingAttempt(), c6(new Error("Connection request reset. Please try again.")));
        }));
        const m5 = t4 != null && t4.scopedProperties ? { [this.namespace]: t4.scopedProperties } : void 0;
        await this.signer.connect(w2(v3({ namespaces: v3({}, n4 && { [this.namespace]: n4 }) }, i6 && { optionalNamespaces: { [this.namespace]: i6 } }), { pairingTopic: t4?.pairingTopic, scopedProperties: m5 })).then((h7) => {
          u6(h7);
        }).catch((h7) => {
          var d5;
          (d5 = this.modal) == null || d5.showErrorMessage("Unable to connect"), c6(new Error(h7.message));
        });
      });
      if (!a4) return;
      const o4 = _s(a4.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o4), this.setAccounts(o4), this.events.emit("connect", { chainId: E4(this.chainId) });
    } catch (a4) {
      throw this.signer.logger.error(a4), a4;
    } finally {
      (e9 = this.modal) == null || e9.close();
    }
  }
  async authenticate(t4, e9) {
    var n4;
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts({ chains: t4?.chains });
    try {
      const i6 = await new Promise(async (o4, u6) => {
        var c6, l6;
        this.rpc.showQrModal && ((c6 = this.modal) == null || c6.open(), (l6 = this.modal) == null || l6.subscribeState((r6) => {
          !r6.open && !this.signer.session && (this.signer.abortPairingAttempt(), u6(new Error("Connection request reset. Please try again.")));
        })), await this.signer.authenticate(w2(v3({}, t4), { chains: this.rpc.chains }), e9).then((r6) => {
          o4(r6);
        }).catch((r6) => {
          var m5;
          (m5 = this.modal) == null || m5.showErrorMessage("Unable to connect"), u6(new Error(r6.message));
        });
      }), a4 = i6.session;
      if (a4) {
        const o4 = _s(a4.namespaces, [this.namespace]);
        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o4), this.setAccounts(o4), this.events.emit("connect", { chainId: E4(this.chainId) });
      }
      return i6;
    } catch (i6) {
      throw this.signer.logger.error(i6), i6;
    } finally {
      (n4 = this.modal) == null || n4.close();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t4) => {
      const { params: e9 } = t4, { event: n4 } = e9;
      n4.name === "accountsChanged" ? (this.accounts = this.parseAccounts(n4.data), this.events.emit("accountsChanged", this.accounts)) : n4.name === "chainChanged" ? this.setChainId(this.formatChainId(n4.data)) : this.events.emit(n4.name, n4.data), this.events.emit("session_event", t4);
    }), this.signer.on("accountsChanged", (t4) => {
      this.accounts = this.parseAccounts(t4), this.events.emit("accountsChanged", this.accounts);
    }), this.signer.on("chainChanged", (t4) => {
      const e9 = parseInt(t4);
      this.chainId = e9, this.events.emit("chainChanged", E4(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t4) => {
      this.events.emit("session_update", t4);
    }), this.signer.on("session_delete", (t4) => {
      this.reset(), this.events.emit("session_delete", t4), this.events.emit("disconnect", w2(v3({}, Kt("USER_DISCONNECTED")), { data: t4.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t4) => {
      this.events.emit("display_uri", t4);
    });
  }
  switchEthereumChain(t4) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t4.toString(16) }] });
  }
  isCompatibleChainId(t4) {
    return typeof t4 == "string" ? t4.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t4) {
    return `${this.namespace}:${t4}`;
  }
  parseChainId(t4) {
    return Number(t4.split(":")[1]);
  }
  setChainIds(t4) {
    const e9 = t4.filter((n4) => this.isCompatibleChainId(n4)).map((n4) => this.parseChainId(n4));
    e9.length && (this.chainId = e9[0], this.events.emit("chainChanged", E4(this.chainId)), this.persist());
  }
  setChainId(t4) {
    if (this.isCompatibleChainId(t4)) {
      const e9 = this.parseChainId(t4);
      this.chainId = e9, this.switchEthereumChain(e9);
    }
  }
  parseAccountId(t4) {
    const [e9, n4, i6] = t4.split(":");
    return { chainId: `${e9}:${n4}`, address: i6 };
  }
  setAccounts(t4) {
    this.accounts = t4.filter((e9) => this.parseChainId(this.parseAccountId(e9).chainId) === this.chainId).map((e9) => this.parseAccountId(e9).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t4) {
    var e9, n4;
    const i6 = (e9 = t4?.chains) != null ? e9 : [], a4 = (n4 = t4?.optionalChains) != null ? n4 : [], o4 = i6.concat(a4);
    if (!o4.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
    const u6 = i6.length ? t4?.methods || f7 : [], c6 = i6.length ? t4?.events || C4 : [], l6 = t4?.optionalMethods || [], r6 = t4?.optionalEvents || [], m5 = t4?.rpcMap || this.buildRpcMap(o4, t4.projectId), h7 = t4?.qrModalOptions || void 0;
    return { chains: i6?.map((d5) => this.formatChainId(d5)), optionalChains: a4.map((d5) => this.formatChainId(d5)), methods: u6, events: c6, optionalMethods: l6, optionalEvents: r6, rpcMap: m5, showQrModal: !!(t4 != null && t4.showQrModal), qrModalOptions: h7, projectId: t4.projectId, metadata: t4.metadata };
  }
  buildRpcMap(t4, e9) {
    const n4 = {};
    return t4.forEach((i6) => {
      n4[i6] = this.getRpcUrl(i6, e9);
    }), n4;
  }
  async initialize(t4) {
    if (this.rpc = this.getRpcConfig(t4), this.chainId = this.rpc.chains.length ? I4(this.rpc.chains) : I4(this.rpc.optionalChains), this.signer = await vi5.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t4.disableProviderPing, relayUrl: t4.relayUrl, storage: t4.storage, storageOptions: t4.storageOptions, customStoragePrefix: t4.customStoragePrefix, telemetryEnabled: t4.telemetryEnabled, logger: t4.logger }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let e9;
      try {
        const n4 = await D5(), { convertWCMToAppKitOptions: i6 } = await Promise.resolve().then(function() {
          return nt5;
        }), a4 = i6(w2(v3({}, this.rpc.qrModalOptions), { chains: [.../* @__PURE__ */ new Set([...this.rpc.chains, ...this.rpc.optionalChains])], metadata: this.rpc.metadata, projectId: this.rpc.projectId }));
        if (!a4.networks.length) throw new Error("No networks found for WalletConnect");
        e9 = n4(w2(v3({}, a4), { universalProvider: this.signer, manualWCControl: true }));
      } catch (n4) {
        throw console.warn(n4), new Error("To use QR modal, please install @reown/appkit package");
      }
      if (e9) try {
        this.modal = e9;
      } catch (n4) {
        throw this.signer.logger.error(n4), new Error("Could not generate WalletConnectModal Instance");
      }
    }
  }
  loadConnectOpts(t4) {
    if (!t4) return;
    const { chains: e9, optionalChains: n4, rpcMap: i6 } = t4;
    e9 && me(e9) && (this.rpc.chains = e9.map((a4) => this.formatChainId(a4)), e9.forEach((a4) => {
      this.rpc.rpcMap[a4] = i6?.[a4] || this.getRpcUrl(a4);
    })), n4 && me(n4) && (this.rpc.optionalChains = [], this.rpc.optionalChains = n4?.map((a4) => this.formatChainId(a4)), n4.forEach((a4) => {
      this.rpc.rpcMap[a4] = i6?.[a4] || this.getRpcUrl(a4);
    }));
  }
  getRpcUrl(t4, e9) {
    var n4;
    return ((n4 = this.rpc.rpcMap) == null ? void 0 : n4[t4]) || `${U4}?chainId=eip155:${t4}&projectId=${e9 || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (this.session) try {
      const t4 = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), e9 = this.session.namespaces[`${this.namespace}:${t4}`] ? this.session.namespaces[`${this.namespace}:${t4}`] : this.session.namespaces[this.namespace];
      this.setChainIds(t4 ? [this.formatChainId(t4)] : e9?.accounts), this.setAccounts(e9?.accounts);
    } catch (t4) {
      this.signer.logger.error("Failed to load persisted session, clearing state..."), this.signer.logger.error(t4), await this.disconnect().catch((e9) => this.signer.logger.warn(e9));
    }
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t4) {
    return typeof t4 == "string" || t4 instanceof String ? [this.parseAccount(t4)] : t4.map((e9) => this.parseAccount(e9));
  }
};
var H2 = Object.defineProperty;
var B3 = Object.defineProperties;
var F5 = Object.getOwnPropertyDescriptors;
var S4 = Object.getOwnPropertySymbols;
var X6 = Object.prototype.hasOwnProperty;
var J3 = Object.prototype.propertyIsEnumerable;
var T3 = (s3, t4, e9) => t4 in s3 ? H2(s3, t4, { enumerable: true, configurable: true, writable: true, value: e9 }) : s3[t4] = e9;
var R4 = (s3, t4) => {
  for (var e9 in t4 || (t4 = {})) X6.call(t4, e9) && T3(s3, e9, t4[e9]);
  if (S4) for (var e9 of S4(t4)) J3.call(t4, e9) && T3(s3, e9, t4[e9]);
  return s3;
};
var Z3 = (s3, t4) => B3(s3, F5(t4));
function tt3(s3) {
  if (s3) return { "--w3m-font-family": s3["--wcm-font-family"], "--w3m-accent": s3["--wcm-accent-color"], "--w3m-color-mix": s3["--wcm-background-color"], "--w3m-z-index": s3["--wcm-z-index"] ? Number(s3["--wcm-z-index"]) : void 0, "--w3m-qr-color": s3["--wcm-accent-color"], "--w3m-font-size-master": s3["--wcm-text-medium-regular-size"], "--w3m-border-radius-master": s3["--wcm-container-border-radius"], "--w3m-color-mix-strength": 0 };
}
var et = (s3) => {
  const [t4, e9] = s3.split(":");
  return W6({ id: e9, caipNetworkId: s3, chainNamespace: t4, name: "", nativeCurrency: { name: "", symbol: "", decimals: 8 }, rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } } });
};
function st(s3) {
  var t4, e9, n4, i6, a4, o4, u6;
  const c6 = (t4 = s3.chains) == null ? void 0 : t4.map(et).filter(Boolean);
  if (c6.length === 0) throw new Error("At least one chain must be specified");
  const l6 = c6.find((m5) => {
    var h7;
    return m5.id === ((h7 = s3.defaultChain) == null ? void 0 : h7.id);
  }), r6 = { projectId: s3.projectId, networks: c6, themeMode: s3.themeMode, themeVariables: tt3(s3.themeVariables), chainImages: s3.chainImages, connectorImages: s3.walletImages, defaultNetwork: l6, metadata: Z3(R4({}, s3.metadata), { name: ((e9 = s3.metadata) == null ? void 0 : e9.name) || "WalletConnect", description: ((n4 = s3.metadata) == null ? void 0 : n4.description) || "Connect to WalletConnect-compatible wallets", url: ((i6 = s3.metadata) == null ? void 0 : i6.url) || "https://walletconnect.org", icons: ((a4 = s3.metadata) == null ? void 0 : a4.icons) || ["https://walletconnect.org/walletconnect-logo.png"] }), showWallets: true, featuredWalletIds: s3.explorerRecommendedWalletIds === "NONE" ? [] : Array.isArray(s3.explorerRecommendedWalletIds) ? s3.explorerRecommendedWalletIds : [], excludeWalletIds: s3.explorerExcludedWalletIds === "ALL" ? [] : Array.isArray(s3.explorerExcludedWalletIds) ? s3.explorerExcludedWalletIds : [], enableEIP6963: false, enableInjected: false, enableCoinbase: true, enableWalletConnect: true, features: { email: false, socials: false } };
  if ((o4 = s3.mobileWallets) != null && o4.length || (u6 = s3.desktopWallets) != null && u6.length) {
    const m5 = [...(s3.mobileWallets || []).map((g3) => ({ id: g3.id, name: g3.name, links: g3.links })), ...(s3.desktopWallets || []).map((g3) => ({ id: g3.id, name: g3.name, links: { native: g3.links.native, universal: g3.links.universal } }))], h7 = [...r6.featuredWalletIds || [], ...r6.excludeWalletIds || []], d5 = m5.filter((g3) => !h7.includes(g3.id));
    d5.length && (r6.customWallets = d5);
  }
  return r6;
}
function W6(s3) {
  return R4({ formatters: void 0, fees: void 0, serializers: void 0 }, s3);
}
var nt5 = Object.freeze({ __proto__: null, convertWCMToAppKitOptions: st, defineChain: W6 });

// node_modules/@dynamic-labs/ethereum/src/walletConnect/WalletConnectProvider/WalletConnectProvider.js
var _a2;
var WalletConnectProvider = class {
  constructor() {
    throw new Error("WalletConnectProvider is not instantiable");
  }
  static getMappedChainsByPreferredOrder() {
    const allChains = _a2.enabledNetworks.map((network) => `eip155:${network.chainId}`);
    const reorderedChains = _a2.preferredChains.filter((chain) => allChains.includes(chain));
    const remainingChains = allChains.filter((chain) => !_a2.preferredChains.includes(chain));
    return [...reorderedChains, ...remainingChains].map((chain) => Number(chain.split(":")[1]));
  }
};
_a2 = WalletConnectProvider;
WalletConnectProvider.isInitializing = false;
WalletConnectProvider.isInitialized = false;
WalletConnectProvider.enabledNetworks = [];
WalletConnectProvider.preferredChains = [];
WalletConnectProvider.evmNetworkRpcMap = {};
WalletConnectProvider.eventListenersSetup = false;
WalletConnectProvider.accountChangedHandler = () => {
};
WalletConnectProvider.chainChangedHandler = () => {
};
WalletConnectProvider.disconnectHandler = () => {
};
WalletConnectProvider.init = (...args_1) => __awaiter(void 0, [...args_1], void 0, function* ({ storePrefix = "dynamic-wc2" } = {}) {
  logger3.debug("[WalletConnectProvider] init", {
    isInitialized: _a2.isInitialized,
    isInitializing: _a2.isInitializing
  });
  if (_a2.isInitializing || _a2.isInitialized) {
    return;
  }
  _a2.isInitializing = true;
  logger3.debug("[WalletConnectProvider] initializing");
  _a2.providerInitPromise = b3.init({
    customStoragePrefix: storePrefix,
    disableProviderPing: true,
    optionalChains: _a2.getMappedChainsByPreferredOrder(),
    optionalEvents: ["chainChanged", "accountsChanged"],
    optionalMethods: [
      "eth_chainId",
      "eth_signTypedData",
      "eth_signTransaction",
      "eth_sign",
      "personal_sign",
      "eth_sendTransaction",
      "eth_signTypedData_v4",
      "wallet_switchEthereumChain",
      "wallet_addEthereumChain"
    ],
    projectId: _a2.projectId,
    rpcMap: _a2.evmNetworkRpcMap,
    showQrModal: false
  });
  _a2.provider = yield _a2.providerInitPromise;
  _a2.isInitialized = true;
  _a2.isInitializing = false;
  logger3.debug("[WalletConnectProvider] initialized");
});
WalletConnectProvider.connect = (_b) => __awaiter(void 0, [_b], void 0, function* ({ deepLinks, deepLinkPreference, connectionOpts }) {
  const handleDisplayURI = (uri) => {
    var _b2;
    logger3.debug("[WalletConnectProvider] handleDisplayURI", uri);
    _a2.connectionUri = uri;
    performPlatformSpecificConnectionMethod(_a2.connectionUri, deepLinks, {
      onDesktopUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDesktopUri,
      onDisplayUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDisplayUri
    }, deepLinkPreference);
    logger3.debug("[WalletConnectProvider] removing display_uri event listener");
    (_b2 = _a2.provider) === null || _b2 === void 0 ? void 0 : _b2.off("display_uri", handleDisplayURI);
  };
  if (!_a2.provider) {
    logger3.error("[WalletConnectProvider] connect - provider is not initialized");
    throw new DynamicError("WalletConnectProvider is not initialized");
  }
  if (_a2.connectionUri) {
    handleDisplayURI(_a2.connectionUri);
    return;
  }
  logger3.debug("[WalletConnectProvider] adding display_uri event listener");
  _a2.provider.on("display_uri", handleDisplayURI);
  try {
    const result = yield _a2.provider.enable();
    logger3.debug("[WalletConnectProvider] connected to WalletConnect", result);
    return result;
  } catch (error) {
    logger3.error("[WalletConnectProvider] Failed to connect to WalletConnect", error);
    if (typeof error !== "object" || error === null || !("message" in error) || typeof error.message !== "string") {
      throw error;
    }
    const customError = new DynamicError(error.message);
    if (error.message.includes("rejected")) {
      customError.code = ErrorCode.CONNECTION_REJECTED;
    } else if (error.message.includes("expired")) {
      customError.code = ErrorCode.CONNECTION_PROPOSAL_EXPIRED;
    }
    throw customError;
  } finally {
    _a2.connectionUri = void 0;
  }
});
WalletConnectProvider.disconnect = () => __awaiter(void 0, void 0, void 0, function* () {
  if (!_a2.provider) {
    logger3.debug("[WalletConnectProvider] disconnect - provider is not initialized");
    return;
  }
  _a2.connectionUri = void 0;
  logger3.debug("[WalletConnectProvider] disconnecting from WalletConnect");
  try {
    yield _a2.provider.disconnect();
  } catch (error) {
    logger3.error("[WalletConnectProvider] Failed to disconnect from WalletConnect", error);
  }
});
WalletConnectProvider.awaitAndGetProvider = () => __awaiter(void 0, void 0, void 0, function* () {
  return _a2.providerInitPromise;
});
WalletConnectProvider.getProvider = () => _a2.provider;
WalletConnectProvider.getConnectionUri = () => _a2.connectionUri;
WalletConnectProvider.handleChainChangedEvent = (chain, onChainChanged) => {
  logger3.debug("[WalletConnectProvider] handling chain change event", {
    chain
  });
  const chainId = parseIntSafe(chain);
  if (!chainId) {
    return;
  }
  onChainChanged === null || onChainChanged === void 0 ? void 0 : onChainChanged(chainId);
};
WalletConnectProvider.handleAccountChangedEvent = (accounts, onAccountChanged) => {
  logger3.debug("[WalletConnectProvider] handling account change event", {
    accounts
  });
  const [account] = accounts;
  const address = account.includes(":") ? account.split(":").pop() : account;
  if (!address) {
    return;
  }
  onAccountChanged === null || onAccountChanged === void 0 ? void 0 : onAccountChanged(address);
};
WalletConnectProvider.setupEventListeners = ({ onChainChanged, onAccountChanged, onDisconnect }) => {
  if (!_a2.provider || _a2.eventListenersSetup) {
    return;
  }
  _a2.chainChangedHandler = (chainId) => {
    _a2.handleChainChangedEvent(chainId, onChainChanged);
  };
  _a2.accountChangedHandler = (account) => {
    _a2.handleAccountChangedEvent(account, onAccountChanged);
  };
  _a2.disconnectHandler = () => {
    logger3.debug("[WalletConnectProvider] handling disconnect event");
    onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect();
  };
  _a2.provider.on("accountsChanged", _a2.accountChangedHandler);
  _a2.provider.on("chainChanged", _a2.chainChangedHandler);
  _a2.provider.on("disconnect", _a2.disconnectHandler);
  _a2.eventListenersSetup = true;
};
WalletConnectProvider.teardownEventListeners = () => {
  if (!_a2.provider || !_a2.eventListenersSetup) {
    return;
  }
  _a2.provider.off("accountsChanged", _a2.accountChangedHandler);
  _a2.provider.off("chainChanged", _a2.chainChangedHandler);
  _a2.provider.off("disconnect", _a2.disconnectHandler);
  _a2.eventListenersSetup = false;
};

// node_modules/@dynamic-labs/ethereum/src/walletConnect/WalletConnectConnector/WalletConnectConnector.js
var WC_CURRENT_CHAIN_KEY = "dynamic-wc2-current-chain";
var WalletConnectConnector = class extends EthereumWalletConnector {
  constructor(opts) {
    super(opts);
    this.canConnectViaQrCode = true;
    this.isWalletConnect = true;
    this.canHandleMultipleConnections = false;
    this.name = opts.walletName;
    this.deepLinkPreference = opts.deepLinkPreference || "native";
    const storedChainId = StorageService.getItem(WC_CURRENT_CHAIN_KEY);
    if (storedChainId) {
      this.currentChainId = parseIntSafe(storedChainId);
    }
    if (!opts.projectId) {
      throw new DynamicError("WalletConnect project ID is required");
    }
    WalletConnectProvider.projectId = opts.projectId;
    WalletConnectProvider.enabledNetworks = opts.evmNetworks;
    WalletConnectProvider.preferredChains = opts.walletConnectPreferredChains || [];
    WalletConnectProvider.evmNetworkRpcMap = this.evmNetworkRpcMap();
  }
  init() {
    return __awaiter(this, void 0, void 0, function* () {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] init called", {
        isInitialized: WalletConnectProvider.isInitialized,
        isInitializing: WalletConnectProvider.isInitializing
      });
      if (WalletConnectProvider.isInitialized || WalletConnectProvider.isInitializing) {
        logger.debug("[WalletConnect] init - already initialized or initializing - skipping");
        return;
      }
      logger.debug("[WalletConnect] init");
      this.walletConnectorEventsEmitter.emit("connectorInitStarted", "walletconnect");
      try {
        yield WalletConnectProvider.init();
      } catch (error) {
        logger.error("[WalletConnect] init - error", error);
        throw new DynamicError("WalletConnectProvider failed to initialize");
      }
      this.setupWCEventListeners();
      this.walletConnectorEventsEmitter.emit("connectorInitCompleted", "walletconnect");
    });
  }
  setupWCEventListeners() {
    logger.debug("[WalletConnect] setupWCEventListeners");
    WalletConnectProvider.teardownEventListeners();
    WalletConnectProvider.setupEventListeners({
      onAccountChanged: (account) => {
        logger.debug("[WalletConnect] onAccountChanged", { account });
        this.emit("accountChange", { accounts: [account] });
      },
      onChainChanged: (chainId) => {
        logger.debug("[WalletConnect] onChainChange", { chainId });
        if (chainId === this.currentChainId) {
          logger.debug(`[WalletConnect] onChainChange - ignoring chainChanged event with same chain id as current chain id: ${chainId}`);
          return;
        }
        this.currentChainId = chainId;
        this.emit("chainChange", { chain: String(chainId) });
      },
      onDisconnect: () => {
        logger.debug("[WalletConnect] onDisconnect");
        this.endSession();
        this.emit("disconnect");
      }
    });
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      logger.debug("[WalletConnect] endSession");
      this.currentChainId = void 0;
      yield WalletConnectProvider.disconnect();
    });
  }
  getAddress(opts) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a4, _b;
      logger.debug("[WalletConnect] getAddress", opts);
      logger.logVerboseTroubleshootingMessage("[WalletConnectConnector] getAddress", {
        inAppBrowserUrl: (_a4 = this.metadata) === null || _a4 === void 0 ? void 0 : _a4.inAppBrowserUrl,
        isMobile: isMobile(),
        mobileExperience: this.mobileExperience
      });
      if (isMobile() && ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.inAppBrowserUrl) && this.mobileExperience === "in-app-browser") {
        const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
        const { href } = PlatformService.getUrl();
        const deepLink = inAppBrowserCompiledTemplate({
          encodedDappURI: encodeURIComponent(href)
        });
        PlatformService.openURL(deepLink);
        return;
      }
      const provider = yield WalletConnectProvider.awaitAndGetProvider();
      logger.debug("[WalletConnect] getAddress - connecting to WalletConnect", {
        provider
      });
      const addresses = yield WalletConnectProvider.connect({
        connectionOpts: opts,
        deepLinkPreference: this.deepLinkPreference,
        deepLinks: this.metadata.deepLinks
      });
      logger.debug("[WalletConnect] getAddress - connection result", addresses);
      const address = addresses === null || addresses === void 0 ? void 0 : addresses[0];
      return address;
    });
  }
  getWalletClient(chainId) {
    logger.logVerboseTroubleshootingMessage("[WalletConnect] getWalletClient was called - chainId", chainId);
    const provider = WalletConnectProvider.getProvider();
    if (!provider) {
      logger.debug("[WalletConnect] getWalletClient - provider is not initialized");
      throw new DynamicError("WalletConnectProvider is not initialized");
    }
    const walletClient = createWalletClient({
      account: this.getActiveAccount(),
      chain: chainsMap[chainId !== null && chainId !== void 0 ? chainId : String(this.currentChainId)],
      transport: custom({
        request: (args) => {
          this.deepLinkIfApplicable(args.method);
          return provider.request(args).catch(normalizeRpcError);
        }
      }, this.providersConfig.httpTransportConfig)
    });
    return walletClient;
  }
  deepLinkIfApplicable(method) {
    const methodsThatRequireDeepLink = [
      "personal_sign",
      "eth_sendTransaction",
      "eth_signTypedData_v4"
    ];
    const deepLink = this.getDeepLink();
    if (isMobile() && deepLink && methodsThatRequireDeepLink.includes(method)) {
      PlatformService.openURL(deepLink);
    }
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] signMessage", messageToSign);
      const activeAccount = this.getActiveAccount();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] signMessage - activeAccount", activeAccount);
      if (!activeAccount) {
        return;
      }
      const walletClient = yield this.getWalletClient();
      return walletClient.signMessage({
        account: activeAccount,
        message: messageToSign
      });
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const activeAccount = this.getActiveAccount();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] getConnectedAccounts - activeAccount", activeAccount);
      return activeAccount ? [activeAccount.address] : [];
    });
  }
  getActiveAccount() {
    var _a4;
    const provider = WalletConnectProvider.getProvider();
    const connectedAccount = (_a4 = provider === null || provider === void 0 ? void 0 : provider.accounts) === null || _a4 === void 0 ? void 0 : _a4[0];
    logger.logVerboseTroubleshootingMessage("[WalletConnect] getActiveAccount - connectedAccount", connectedAccount);
    if (!connectedAccount) {
      return void 0;
    }
    return toAccount(connectedAccount);
  }
  get currentChainId() {
    const lsCurrentChain = StorageService.getItem(WC_CURRENT_CHAIN_KEY);
    try {
      return lsCurrentChain ? parseIntSafe(lsCurrentChain) : void 0;
    } catch (e9) {
      logger.debug("[WalletConnect] getCurrentChainId - error", e9);
      return void 0;
    }
  }
  set currentChainId(value2) {
    if (value2) {
      StorageService.setItem(WC_CURRENT_CHAIN_KEY, value2.toString());
    } else {
      StorageService.removeItem(WC_CURRENT_CHAIN_KEY);
    }
  }
  getActiveChain() {
    if (!this.currentChainId) {
      return void 0;
    }
    return chainsMap[this.currentChainId];
  }
  getNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] getNetwork");
      const provider = yield WalletConnectProvider.awaitAndGetProvider();
      if (provider === null || provider === void 0 ? void 0 : provider.chainId) {
        const network = provider.chainId;
        this.currentChainId = network;
        logger.logVerboseTroubleshootingMessage("[WalletConnect] getNetwork - provider network", network);
        return network;
      }
      logger.logVerboseTroubleshootingMessage("[WalletConnect] getNetwork - no provider found, returning current chain id", {
        currentChainId: this.currentChainId
      });
      return this.currentChainId;
    });
  }
  providerSwitchNetwork(_a4) {
    const _super = Object.create(null, {
      providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
    });
    return __awaiter(this, arguments, void 0, function* ({ network }) {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - network", {
        network,
        switchNetworkOnlyFromWallet: this.switchNetworkOnlyFromWallet
      });
      const currentNetworkId = yield this.getNetwork();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - currentNetworkId", currentNetworkId);
      if (currentNetworkId && currentNetworkId === network.chainId) {
        return;
      }
      if (this.switchNetworkOnlyFromWallet) {
        throw new DynamicError("Network switching is only supported through the wallet");
      }
      const walletClient = yield this.getWalletClient();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - will switch network");
      yield _super.providerSwitchNetwork.call(this, { network, provider: walletClient });
      this.currentChainId = network.chainId;
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - switched network", network.chainId);
      this.emit("chainChange", { chain: String(network.chainId) });
    });
  }
  supportsNetworkSwitching() {
    return true;
  }
  getSupportedNetworks() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a4;
      const provider = yield WalletConnectProvider.awaitAndGetProvider();
      if (!(provider === null || provider === void 0 ? void 0 : provider.session)) {
        return [];
      }
      const chains = [];
      Object.keys(provider === null || provider === void 0 ? void 0 : provider.session.namespaces).forEach((key) => {
        if (key.startsWith("eip155:")) {
          chains.push(key.split(":")[1]);
        }
      });
      (_a4 = provider === null || provider === void 0 ? void 0 : provider.session.namespaces.eip155) === null || _a4 === void 0 ? void 0 : _a4.accounts.forEach((account) => chains.push(account.split(":")[1]));
      return chains.length ? chains : this.evmNetworks.map((network) => network.chainId.toString());
    });
  }
  getDeepLink() {
    var _a4;
    const provider = WalletConnectProvider.getProvider();
    logger.debug("[WalletConnect] getDeepLink", {
      hasSession: Boolean(provider === null || provider === void 0 ? void 0 : provider.session),
      topic: (_a4 = provider === null || provider === void 0 ? void 0 : provider.session) === null || _a4 === void 0 ? void 0 : _a4.topic,
      uri: provider === null || provider === void 0 ? void 0 : provider.signer.uri
    });
    if (!(provider === null || provider === void 0 ? void 0 : provider.session)) {
      return;
    }
    const deepLink = getDeepLink({
      deepLinks: this.metadata.deepLinks,
      mode: "regular",
      preference: this.deepLinkPreference,
      uri: provider.signer.uri
    });
    logger.logVerboseTroubleshootingMessage("[WalletConnect] getDeepLink - deepLink", deepLink);
    if (!deepLink) {
      return;
    }
    return `${deepLink}?sessionTopic=${provider.session.topic}`;
  }
  getConnectionUri() {
    return WalletConnectProvider.getConnectionUri();
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/InjectedWalletBase.js
var InjectedWalletBase = class extends EthereumWalletConnector {
  constructor() {
    super(...arguments);
    this.walletConnectorFallback = false;
  }
  get ethProviderHelper() {
    if (!this._ethProviderHelper) {
      this._ethProviderHelper = new EthProviderHelper(this);
    }
    return this._ethProviderHelper;
  }
  getMobileOrInstalledWallet() {
    const canUseWalletConnect = this.walletConnectorFallback && this.constructorProps.projectId;
    logger3.logVerboseTroubleshootingMessage("[InjectedWalletBase] getMobileOrInstalledWallet", {
      canUseWalletConnect,
      isInstalledOnBrowser: this.isInstalledOnBrowser(),
      projectId: this.constructorProps.projectId,
      walletConnectorFallback: this.walletConnectorFallback
    });
    if (this.isInstalledOnBrowser() || !canUseWalletConnect) {
      return this;
    }
    return new WalletConnectConnector(Object.assign(Object.assign({}, this.constructorProps), { walletName: this.name }));
  }
  findProvider() {
    var _a4;
    return (_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.getInstalledProvider();
  }
  setupEventListeners() {
    const provider = this.getWalletClient();
    if (!provider)
      return;
    if (!this.ethProviderHelper)
      return;
    const { tearDownEventListeners } = this.ethProviderHelper._setupEventListeners(this);
    this.teardownEventListeners = tearDownEventListeners;
  }
  getWalletClient(chainId) {
    var _a4;
    return (_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.findWalletClient(chainId);
  }
  isInstalledOnBrowser() {
    var _a4;
    return ((_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.findProvider()) !== void 0;
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a4, _b;
      if (this.isInstalledOnBrowser()) {
        return (_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.getAddress();
      }
      if (isMobile() && ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.inAppBrowserUrl) && this.mobileExperience === "in-app-browser") {
        const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
        const { href } = PlatformService.getUrl();
        const deepLink = inAppBrowserCompiledTemplate({
          encodedDappURI: encodeURIComponent(href)
        });
        PlatformService.openURL(deepLink);
      }
      return void 0;
    });
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getAddress();
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a4;
      return (_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.signMessage(messageToSign);
    });
  }
  proveOwnership(address, messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(address);
      return this.signMessage(messageToSign);
    });
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a4;
      const provider = (_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.findProvider();
      if (!provider)
        return;
      void provider.request({
        method: "wallet_revokePermissions",
        params: [
          {
            eth_accounts: {}
          }
        ]
      }).catch((err) => {
        logger3.error("[InjectedWalletBase] endSession - Error revoking permissions", err);
      });
    });
  }
  providerSwitchNetwork(_a4) {
    const _super = Object.create(null, {
      providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
    });
    return __awaiter(this, arguments, void 0, function* ({ network, provider }) {
      return _super.providerSwitchNetwork.call(this, { network, provider });
    });
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/PhantomEvm.js
var PhantomEvm = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "Phantom";
    this.overrideKey = "phantomevm";
  }
  getAddress() {
    const _super = Object.create(null, {
      getAddress: { get: () => super.getAddress }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (this.isInstalledOnBrowser()) {
        return _super.getAddress.call(this);
      }
      if (isMobile()) {
        handleMobileWalletRedirect({
          nativeLink: "phantom://browse",
          universalLink: "https://phantom.app/ul/browse"
        });
      }
      return void 0;
    });
  }
  canGetChainAddress() {
    var _a4, _b;
    return Boolean((_b = (_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.findProvider()) === null || _b === void 0 ? void 0 : _b.selectedAddress);
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/ExodusEvm.js
var ExodusEvm = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "ExodusEvm";
    this.overrideKey = "exodusevm";
    this.walletConnectorFallback = true;
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/FallbackEvmConnector.js
var FallbackEvmConnector = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "Fallback Connector";
    this.overrideKey = "fallbackconnector";
    this.isAvailable = false;
  }
  isInstalledOnBrowser() {
    return false;
  }
};

// node_modules/@dynamic-labs/ethereum/src/utils/getConnectorConstructorForEip6963Wallet/getConnectorConstructorForEip6963Wallet.js
var getConnectorConstructorForEip6963Wallet = (walletDetail) => {
  const { info, provider } = walletDetail;
  const sanitizedName = sanitizeName(info.name);
  return class extends InjectedWalletBase {
    constructor(props) {
      super(Object.assign(Object.assign({}, props), { metadata: {
        groupKey: sanitizedName,
        icon: info.icon,
        id: info.uuid,
        name: info.name,
        rdns: info.rdns
      } }));
      this.name = info.name;
      this.overrideKey = `${sanitizedName}evm`;
    }
    findProvider() {
      return provider;
    }
  };
};

// node_modules/@dynamic-labs/ethereum/src/utils/getConnectorConstructorInjectedWallet/getConnectorConstructorInjectedWallet.js
var getConnectorConstructorInjectedWallet = (key, wallet) => {
  const { shortName } = wallet;
  const name = shortName || wallet.name;
  const walletConnectorFallback = Boolean(wallet.walletConnect);
  return class extends InjectedWalletBase {
    constructor() {
      super(...arguments);
      this.name = name;
      this.walletConnectorFallback = walletConnectorFallback;
      this.overrideKey = key;
    }
  };
};

// node_modules/@dynamic-labs/ethereum/src/injected/fetchInjectedWalletConnectors.js
var injectedWalletOverrides = [
  PhantomEvm,
  ExodusEvm
];
var removeEip6963EventsListener;
var shouldAddEip6963Connector = (eip6963ProviderInfo, walletBook, walletsWithCustomConnectors) => {
  var _a4;
  const { rdns, name } = eip6963ProviderInfo;
  const chain = "evm";
  const connectorKey = `${sanitizeName(name)}${chain}`;
  logger.logVerboseTroubleshootingMessage("[ETH shouldAddEip6963Connector]", rdns, name, chain, connectorKey);
  const existingWallet = Object.entries((_a4 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a4 !== void 0 ? _a4 : {}).find(([key, wallet]) => {
    var _a5, _b;
    return ((_a5 = wallet.eip6963Config) === null || _a5 === void 0 ? void 0 : _a5.rdns) === rdns || key === connectorKey || walletsWithCustomConnectors.includes(connectorKey) || wallet.name === name && ((_b = wallet.injectedConfig) === null || _b === void 0 ? void 0 : _b[0].chain) === chain;
  });
  logger.logVerboseTroubleshootingMessage("[ETH shouldAddEip6963Connector]", existingWallet);
  return !existingWallet;
};
var addEip6963Listener = (walletBook, walletsWithCustomConnectors) => {
  removeEip6963EventsListener === null || removeEip6963EventsListener === void 0 ? void 0 : removeEip6963EventsListener();
  removeEip6963EventsListener = listenToEip6963Events((event) => {
    if (!shouldAddEip6963Connector(event.detail.info, walletBook, walletsWithCustomConnectors)) {
      return;
    }
    logger.logVerboseTroubleshootingMessage("[ETH fetchInjectedWalletConnectors] listenToEip6963Events", event.detail);
    walletConnectorEvents.emit("providerInjected", {
      injectedConnectorConstructor: getConnectorConstructorForEip6963Wallet(event.detail)
    });
  });
};
var fetchInjectedWalletConnector = ({ walletBook, walletsWithCustomConnectors }) => {
  var _a4;
  addEip6963Listener(walletBook, walletsWithCustomConnectors);
  const walletBookConnectors = Object.entries((_a4 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a4 !== void 0 ? _a4 : {}).filter(([key, wallet]) => {
    var _a5;
    return ((_a5 = wallet.injectedConfig) === null || _a5 === void 0 ? void 0 : _a5.find((config) => config.chain === "evm")) && !walletsWithCustomConnectors.includes(key);
  }).map(([key, wallet]) => getConnectorConstructorInjectedWallet(key, wallet));
  const { providers } = Eip6963ProviderSingleton.get();
  const eip6963Connectors = providers.filter((provider) => shouldAddEip6963Connector(provider.info, walletBook, walletsWithCustomConnectors)).map((provider) => getConnectorConstructorForEip6963Wallet(provider));
  logger.logVerboseTroubleshootingMessage("[ETH fetchInjectedWalletConnectors] eip6963Connectors", eip6963Connectors);
  return [...walletBookConnectors, ...eip6963Connectors];
};

// node_modules/@dynamic-labs/ethereum/src/constants.js
var INFURA_ID = "87939db78f824920ada5c872db3e56b8";

// node_modules/@dynamic-labs/ethereum/src/utils/createInjectedConnector/createInjectedConnector.js
var createInjectedConnector = (customConnectorFn) => (props) => {
  const delegate = customConnectorFn(props);
  return [
    class extends InjectedWalletBase {
      constructor(props2) {
        super(Object.assign(Object.assign({}, props2), { metadata: delegate.metadata }));
        this.name = delegate.metadata.name;
      }
      init() {
        return __awaiter(this, void 0, void 0, function* () {
          return delegate.init();
        });
      }
      findProvider() {
        return delegate.findProvider();
      }
      signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
          return delegate.signMessage(messageToSign);
        });
      }
      connect() {
        const _super = Object.create(null, {
          connect: { get: () => super.connect }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (delegate.connect) {
            return delegate.connect();
          }
          return _super.connect.call(this);
        });
      }
      endSession() {
        const _super = Object.create(null, {
          endSession: { get: () => super.endSession }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (delegate.disconnect) {
            yield delegate.disconnect();
          }
          return _super.endSession.call(this);
        });
      }
      getAddress() {
        const _super = Object.create(null, {
          getAddress: { get: () => super.getAddress }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (delegate.getAddress) {
            return delegate.getAddress();
          }
          return _super.getAddress.call(this);
        });
      }
      getConnectedAccounts() {
        const _super = Object.create(null, {
          getConnectedAccounts: { get: () => super.getConnectedAccounts }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (delegate.getConnectedAccounts) {
            return delegate.getConnectedAccounts();
          }
          return _super.getConnectedAccounts.call(this);
        });
      }
      filter() {
        if (delegate.filter) {
          return delegate.filter();
        }
        return super.filter();
      }
      supportsNetworkSwitching() {
        if (delegate.supportsNetworkSwitching) {
          return delegate.supportsNetworkSwitching();
        }
        return super.supportsNetworkSwitching();
      }
    }
  ];
};

// node_modules/@dynamic-labs/embedded-wallet-evm/package.js
var version2 = "4.26.0";

// node_modules/@dynamic-labs/embedded-wallet-evm/_virtual/_tslib.js
function __awaiter2(thisArg, _arguments, P6, generator) {
  function adopt(value2) {
    return value2 instanceof P6 ? value2 : new P6(function(resolve) {
      resolve(value2);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e9) {
        reject(e9);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e9) {
        reject(e9);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@turnkey/viem/dist/index.mjs
var TurnkeyConsensusNeededError = class extends BaseError {
  constructor({ message = "Turnkey activity requires consensus.", activityId, activityStatus }) {
    super(message);
    this.name = "TurnkeyConsensusNeededError";
    this.activityId = activityId;
    this.activityStatus = activityStatus;
  }
};
var TurnkeyActivityError2 = class extends BaseError {
  constructor({ message = "Received unexpected Turnkey activity status.", activityId, activityStatus }) {
    super(message);
    this.name = "TurnkeyActivityError";
    this.activityId = activityId;
    this.activityStatus = activityStatus;
  }
};
function createAccountWithAddress(input) {
  const { client, organizationId, signWith } = input;
  let { ethereumAddress } = input;
  if (!signWith) {
    throw new TurnkeyActivityError({
      message: `Missing signWith parameter`
    });
  }
  if (isAddress(signWith)) {
    ethereumAddress = signWith;
  } else if (!ethereumAddress) {
    throw new TurnkeyActivityError2({
      message: `Missing ethereumAddress parameter`
    });
  }
  return toAccount({
    address: ethereumAddress,
    signMessage: function({ message }) {
      return signMessage4(client, message, organizationId, signWith);
    },
    signTransaction: function(transaction, args) {
      const serializer = !args?.serializer ? serializeTransaction : args.serializer;
      return signTransaction4(client, transaction, serializer, organizationId, signWith);
    },
    signTypedData: function(typedData) {
      return signTypedData4(client, typedData, organizationId, signWith);
    }
  });
}
async function createAccount(input) {
  const { client, organizationId, signWith } = input;
  let { ethereumAddress } = input;
  if (!signWith) {
    throw new TurnkeyActivityError2({
      message: `Missing signWith parameter`
    });
  }
  if (isAddress(signWith)) {
    ethereumAddress = signWith;
  } else if (!ethereumAddress) {
    const data = await client.getPrivateKey({
      privateKeyId: signWith,
      organizationId
    });
    ethereumAddress = data.privateKey.addresses.find((item) => item.format === "ADDRESS_FORMAT_ETHEREUM")?.address;
    if (typeof ethereumAddress !== "string" || !ethereumAddress) {
      throw new TurnkeyActivityError2({
        message: `Unable to find Ethereum address for key ${signWith} under organization ${organizationId}`
      });
    }
  }
  return createAccountWithAddress({
    client,
    organizationId,
    signWith,
    ethereumAddress
  });
}
async function signMessage4(client, message, organizationId, signWith) {
  const hashedMessage = hashMessage(message);
  const signedMessage = await signMessageWithErrorWrapping(client, hashedMessage, organizationId, signWith);
  return `${signedMessage}`;
}
async function signTransaction4(client, transaction, serializer, organizationId, signWith) {
  const serializedTx = serializer(transaction);
  const nonHexPrefixedSerializedTx = serializedTx.replace(/^0x/, "");
  return await signTransactionWithErrorWrapping(client, nonHexPrefixedSerializedTx, organizationId, signWith);
}
async function signTypedData4(client, data, organizationId, signWith) {
  const hashToSign = hashTypedData(data);
  return await signMessageWithErrorWrapping(client, hashToSign, organizationId, signWith);
}
async function signTransactionWithErrorWrapping(client, unsignedTransaction, organizationId, signWith) {
  let signedTx;
  try {
    signedTx = await signTransactionImpl(client, unsignedTransaction, organizationId, signWith);
  } catch (error) {
    if (error instanceof TurnkeyActivityError) {
      throw new TurnkeyActivityError2({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    if (error instanceof TurnkeyActivityConsensusNeededError) {
      throw new TurnkeyConsensusNeededError({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    throw new TurnkeyActivityError2({
      message: `Failed to sign: ${error.message}`
    });
  }
  return `0x${signedTx}`;
}
async function signTransactionImpl(client, unsignedTransaction, organizationId, signWith) {
  if (client instanceof TurnkeyClient) {
    const { activity } = await client.signTransaction({
      type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
      organizationId,
      parameters: {
        signWith,
        type: "TRANSACTION_TYPE_ETHEREUM",
        unsignedTransaction
      },
      timestampMs: String(Date.now())
      // millisecond timestamp
    });
    assertActivityCompleted(activity);
    return assertNonNull(activity?.result?.signTransactionResult?.signedTransaction);
  } else {
    const { activity, signedTransaction } = await client.signTransaction({
      signWith,
      type: "TRANSACTION_TYPE_ETHEREUM",
      unsignedTransaction
    });
    assertActivityCompleted(activity);
    return assertNonNull(signedTransaction);
  }
}
async function signMessageWithErrorWrapping(client, message, organizationId, signWith) {
  let signedMessage;
  try {
    signedMessage = await signMessageImpl(client, message, organizationId, signWith);
  } catch (error) {
    if (error instanceof TurnkeyActivityError) {
      throw new TurnkeyActivityError2({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    if (error instanceof TurnkeyActivityConsensusNeededError) {
      throw new TurnkeyConsensusNeededError({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    throw new TurnkeyActivityError2({
      message: `Failed to sign: ${error.message}`
    });
  }
  return signedMessage;
}
async function signMessageImpl(client, message, organizationId, signWith) {
  let result;
  if (client instanceof TurnkeyClient) {
    const { activity } = await client.signRawPayload({
      type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
      organizationId,
      parameters: {
        signWith,
        payload: message,
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NO_OP"
      },
      timestampMs: String(Date.now())
      // millisecond timestamp
    });
    assertActivityCompleted(activity);
    result = assertNonNull(activity?.result?.signRawPayloadResult);
  } else {
    const { activity, r: r6, s: s3, v: v7 } = await client.signRawPayload({
      signWith,
      payload: message,
      encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
      hashFunction: "HASH_FUNCTION_NO_OP"
    });
    assertActivityCompleted(activity);
    result = {
      r: r6,
      s: s3,
      v: v7
    };
  }
  return assertNonNull(serializeSignature5(result));
}
function serializeSignature5(sig) {
  return serializeSignature({
    r: `0x${sig.r}`,
    s: `0x${sig.s}`,
    v: sig.v === "00" ? 27n : 28n
  });
}

// node_modules/@dynamic-labs/embedded-wallet-evm/src/lib/TurnkeyEVMWalletConnector/TurnkeyEVMWalletConnector.js
var TurnkeyEVMWalletConnector = class _TurnkeyEVMWalletConnector extends TurnkeyWalletConnectorBase {
  constructor(nameAndKey, props) {
    var _a4, _b, _c5;
    super(nameAndKey, props);
    this.walletFallback = {
      brand: {
        alt: "Turnkey Wallet",
        spriteId: "turnkey"
      },
      name: "Turnkey HD"
    };
    this.ChainWallet = EthereumWallet;
    this.connectedChain = "EVM";
    this.supportedChains = ["ETH", "EVM"];
    this.verifiedCredentialChain = "eip155";
    this.evmNetworks = parseEvmNetworks(props.evmNetworks);
    this.walletUiUtils = props.walletUiUtils;
    this._turnkeyAccount = void 0;
    this._selectedChainId = this.getLastUsedChainId();
    this.providersConfig = (_a4 = props.providersConfig) !== null && _a4 !== void 0 ? _a4 : {};
    this.chainRpcProviders = props.chainRpcProviders;
    (_b = this.chainRpcProviders) === null || _b === void 0 ? void 0 : _b.registerEvmProviders((_c5 = this.providersConfig) !== null && _c5 !== void 0 ? _c5 : {});
    this.getTurnkeyClient().then((client) => {
      this.__turnkeyClient = client;
    }).catch((error) => logger2.error("Error getting turnkey client", error));
  }
  getLastUsedChainId() {
    var _a4;
    logger2.logVerboseTroubleshootingMessage("[TurnkeyEVMWalletConnector] getLastUsedChainId", {
      evmNetworks: this.evmNetworks,
      lastUsedChainId: this.lastUsedChainId
    });
    if (this.lastUsedChainId) {
      return this.lastUsedChainId;
    }
    if (!((_a4 = this.evmNetworks) === null || _a4 === void 0 ? void 0 : _a4.length)) {
      return void 0;
    }
    return this.evmNetworks[0].chainId;
  }
  // Public methods
  getNetwork() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a4;
      return (_a4 = yield this.getSigner()) === null || _a4 === void 0 ? void 0 : _a4.getChainId();
    });
  }
  supportsNetworkSwitching() {
    return true;
  }
  switchNetwork(_a4) {
    return __awaiter2(this, arguments, void 0, function* ({ networkChainId }) {
      if (!networkChainId) {
        return;
      }
      if (typeof networkChainId === "string") {
        networkChainId = parseInt(networkChainId);
      }
      this.lastUsedChainId = networkChainId;
      this._selectedChainId = networkChainId;
      yield this.refreshTurnkeyAccount();
      this.emit("chainChange", {
        chain: networkChainId.toString()
      });
    });
  }
  setVerifiedCredentials(verifiedCredentials) {
    const turnkeyVerifiedCredentials = findTurnkeyVerifiedCredentialsWithSmartWalletRef(verifiedCredentials, "eip155");
    const [turnkeyVerifiedCredential] = turnkeyVerifiedCredentials;
    const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !== JSON.stringify(turnkeyVerifiedCredentials);
    if (!didTurnkeyVerifiedCredentialsChanged) {
      return;
    }
    this.verifiedCredential = turnkeyVerifiedCredential;
    this.verifiedCredentials = turnkeyVerifiedCredentials;
    this.refreshTurnkeyAccount();
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a4, _b;
      const activeAddress = ((_a4 = this.verifiedCredential) === null || _a4 === void 0 ? void 0 : _a4.address) || "";
      const isWalletActive = isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (!isWalletActive) {
        const targetActiveAccount = (_b = this.verifiedCredentials) === null || _b === void 0 ? void 0 : _b.find((vc5) => (vc5 === null || vc5 === void 0 ? void 0 : vc5.address) === expectedAddress);
        if (!targetActiveAccount) {
          throw new DynamicError("Account not found");
        }
        this.verifiedCredential = targetActiveAccount;
        this.refreshTurnkeyAccount();
      }
    });
  }
  signAuthorization(parameters) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a4;
      const { address: contractAddress, nonce, chainId } = parameters;
      yield this.createOrRestoreSession();
      if (!contractAddress) {
        throw new Error("Contract address not found");
      }
      const [signer, publicClient] = yield Promise.all([
        this.getSigner(),
        this.getPublicClient()
      ]);
      if (!signer || !publicClient) {
        throw new Error("Required clients not found");
      }
      const { turnkeySubOrganizationId } = (_a4 = this.walletProperties) !== null && _a4 !== void 0 ? _a4 : {};
      if (!turnkeySubOrganizationId) {
        throw new Error("Turnkey sub organization id not found");
      }
      const { address } = signer.account;
      const signature = yield this.internalSign({
        address,
        hash: hashAuthorization({
          address: contractAddress,
          chainId,
          nonce
        }),
        turnkeySubOrganizationId
      });
      return {
        address: contractAddress,
        chainId,
        nonce,
        r: signature.r,
        s: signature.s,
        v: BigInt(signature.v),
        yParity: signature.yParity
      };
    });
  }
  getBalance(address) {
    return __awaiter2(this, void 0, void 0, function* () {
      const client = yield this.getPublicClient();
      if (!client) {
        return void 0;
      }
      const balance = yield client.getBalance({
        address
      });
      return formatEther(balance);
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      const signer = yield this.getSigner();
      if (!signer) {
        throw new Error("Signer not found");
      }
      return signer.signMessage({
        message: messageToSign
      });
    });
  }
  getPublicClient() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a4, _b;
      if (this.evmNetworks.length === 0) {
        return void 0;
      }
      const networkId = (_a4 = yield this.getNetwork()) !== null && _a4 !== void 0 ? _a4 : 1;
      const configurations = {
        cosmos: [],
        evm: this.evmNetworks,
        solana: [],
        starknet: void 0
      };
      if (!this.chainRpcProviders)
        return void 0;
      const providers = this.chainRpcProviders.getProviders(configurations);
      return (_b = this.chainRpcProviders.getEvmProviderByChainId(providers, networkId)) === null || _b === void 0 ? void 0 : _b.provider;
    });
  }
  getSigner() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getTurnkeyAccount();
      return this.getWalletClient();
    });
  }
  // decides in runtime which stamper to use and creates the corresponding account
  getAccount() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a4, _b, _c5;
      if (this.isSessionKeyCompatible() && ((_a4 = this.__turnkeyClient) === null || _a4 === void 0 ? void 0 : _a4.stamper) instanceof ApiKeyStamper) {
        return this._turnkeyAccount;
      }
      if (this.getAuthenticatorHandler().recoveryType === "passkey" && ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof IframeStamper || this.getAuthenticatorHandler().recoveryType === "email" && ((_c5 = this.__turnkeyClient) === null || _c5 === void 0 ? void 0 : _c5.stamper) instanceof WebauthnStamper || this.__turnkeyClient !== this.getAuthenticatorHandler().client) {
        yield this.refreshTurnkeyAccount();
      }
      return this._turnkeyAccount;
    });
  }
  getWalletClient() {
    const rpcUrl = this.networkRpcUrl;
    const account = this._turnkeyAccount;
    const evmNetwork = this.currentEvmNetwork;
    if (!account || !rpcUrl || !evmNetwork) {
      return void 0;
    }
    return createWalletClientWithUiConfirmation({
      account: this.getAccount.bind(this),
      address: this.turnkeyAddress,
      chain: getOrMapViemChain(evmNetwork),
      transport: http(rpcUrl, this.providersConfig.httpTransportConfig),
      // TODO: remove this. We should not be passing references to wallet connectors
      walletConnector: this,
      walletUiUtils: this.walletUiUtils
    });
  }
  // Private methods
  get currentChainId() {
    var _a4, _b, _c5;
    return (_a4 = this._selectedChainId) !== null && _a4 !== void 0 ? _a4 : (_c5 = (_b = this.evmNetworks) === null || _b === void 0 ? void 0 : _b[0]) === null || _c5 === void 0 ? void 0 : _c5.chainId;
  }
  get lastUsedChainId() {
    const lastUsedChainIdLS = localStorage.getItem(_TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
    if (!lastUsedChainIdLS)
      return void 0;
    try {
      const chainId = parseInt(lastUsedChainIdLS);
      if (isNaN(chainId)) {
        return void 0;
      }
      const isChainCurrentlyEnabled = this.evmNetworks.some((network) => network.chainId === chainId);
      if (!isChainCurrentlyEnabled) {
        const lastUsedChainId = this.evmNetworks[0].chainId;
        this.lastUsedChainId = lastUsedChainId;
        return this.lastUsedChainId;
      }
      return chainId;
    } catch (err) {
      logger2.error(err);
      return void 0;
    }
  }
  set lastUsedChainId(chainId) {
    if (chainId === void 0) {
      localStorage.removeItem(_TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
    } else {
      localStorage.setItem(_TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey, chainId.toString());
    }
  }
  get networkRpcUrl() {
    const chainId = this.currentChainId;
    const evmNetwork = this.evmNetworks.find((network) => network.chainId === chainId);
    if (!evmNetwork) {
      return void 0;
    }
    const rpcUrl = getRpcUrlForChain({
      chainId,
      networks: this.evmNetworks
    });
    return rpcUrl;
  }
  get currentEvmNetwork() {
    const chainId = this.currentChainId;
    logger2.logVerboseTroubleshootingMessage("[TurnkeyEVMWalletConnector] currentEvmNetwork", {
      chainId,
      evmNetworks: this.evmNetworks
    });
    return this.evmNetworks.find((network) => network.chainId === chainId);
  }
  internalSign(_a4) {
    return __awaiter2(this, arguments, void 0, function* ({ hash, address, turnkeySubOrganizationId }) {
      var _b;
      const client = yield this.getTurnkeyClient();
      const { activity } = yield client.signRawPayload({
        organizationId: turnkeySubOrganizationId,
        parameters: {
          encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
          hashFunction: "HASH_FUNCTION_NO_OP",
          payload: hash,
          signWith: address
        },
        timestampMs: Date.now().toString(),
        type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
      });
      const result = (_b = activity === null || activity === void 0 ? void 0 : activity.result) === null || _b === void 0 ? void 0 : _b.signRawPayloadResult;
      if (!result) {
        throw new Error("Sign raw payload result not found");
      }
      return {
        r: `0x${result.r}`,
        s: `0x${result.s}`,
        v: result.v,
        yParity: Number(result.v) % 2
      };
    });
  }
  internalSignTransaction(_a4) {
    return __awaiter2(this, arguments, void 0, function* ({ transaction, args, address, turnkeySubOrganizationId }) {
      return this.doRetryableTurnkeyAction({
        action: (turnkeyAccount) => turnkeyAccount.signTransaction(transaction, args),
        activityType: "SignTransaction",
        address,
        turnkeySubOrganizationId
      });
    });
  }
  internalSignTypedData(_a4) {
    return __awaiter2(this, arguments, void 0, function* ({ typedData, address, turnkeySubOrganizationId }) {
      return this.doRetryableTurnkeyAction({
        action: (turnkeyAccount) => turnkeyAccount.signTypedData(typedData),
        activityType: "SignTypedData",
        address,
        turnkeySubOrganizationId
      });
    });
  }
  internalSignMessage(_a4) {
    return __awaiter2(this, arguments, void 0, function* ({ message, address, turnkeySubOrganizationId }) {
      return this.doRetryableTurnkeyAction({
        action: (turnkeyAccount) => turnkeyAccount.signMessage({ message }),
        activityType: "SignMessage",
        address,
        turnkeySubOrganizationId
      });
    });
  }
  doRetryableTurnkeyAction(_a4) {
    return __awaiter2(this, arguments, void 0, function* ({ action, activityType, address, turnkeySubOrganizationId }) {
      yield this.createOrRestoreSession();
      let newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
        address,
        turnkeySubOrganizationId
      });
      try {
        return yield action(newTurnkeyAccountRaw);
      } catch (err) {
        if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message.toLowerCase().includes(errorMsg.toLowerCase()))) {
          yield this.removeSessionKeys();
          yield this.createOrRestoreSession({
            ignoreRestore: true
          });
          newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
            address,
            turnkeySubOrganizationId
          });
          logger2.error(`[TK - removeSessionKeys] failed to perform ${activityType} activity`, {
            activityType,
            address,
            err,
            turnkeySubOrganizationId
          });
          return action(newTurnkeyAccountRaw);
        }
        throw err;
      }
    });
  }
  createTurnkeyAccount(_a4) {
    return __awaiter2(this, arguments, void 0, function* ({ address, turnkeySubOrganizationId }) {
      return createAccount({
        client: yield this.getTurnkeyClient(),
        ethereumAddress: address,
        organizationId: turnkeySubOrganizationId,
        signWith: address
      });
    });
  }
  refreshTurnkeyAccount() {
    return __awaiter2(this, void 0, void 0, function* () {
      this._turnkeyAccount = void 0;
      return this.getTurnkeyAccount();
    });
  }
  getTurnkeyAccount() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a4, _b;
      if (this._turnkeyAccount) {
        return this._turnkeyAccount;
      }
      const { turnkeySubOrganizationId } = (_a4 = this.walletProperties) !== null && _a4 !== void 0 ? _a4 : {};
      const { address } = (_b = this.verifiedCredential) !== null && _b !== void 0 ? _b : {};
      if (!turnkeySubOrganizationId || !address) {
        return;
      }
      this._turnkeyAccount = toAccount({
        address,
        signAuthorization: (...args) => __awaiter2(this, void 0, void 0, function* () {
          return this.signAuthorization(...args);
        }),
        signMessage: (_c5) => __awaiter2(this, [_c5], void 0, function* ({ message }) {
          return this.internalSignMessage({
            address,
            message,
            turnkeySubOrganizationId
          });
        }),
        signTransaction: (transaction, args) => __awaiter2(this, void 0, void 0, function* () {
          return this.internalSignTransaction({
            address,
            args,
            transaction,
            turnkeySubOrganizationId
          });
        }),
        signTypedData: (typedData) => __awaiter2(this, void 0, void 0, function* () {
          return this.internalSignTypedData({
            address,
            turnkeySubOrganizationId,
            typedData
          });
        })
      });
      this.setLoggerMetadata();
      return this._turnkeyAccount;
    });
  }
  createUiTransaction(from16) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from16);
      const walletClient = this.getWalletClient();
      const publicClient = yield this.getPublicClient();
      if (!publicClient || !walletClient) {
        throw new DynamicError("No public client available");
      }
      return createViemUiTransaction({ from: from16, publicClient, walletClient });
    });
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a4, _b;
      const currentNetwork = yield this.getNetwork();
      return (_b = (_a4 = this.evmNetworks.find((network) => network.chainId.toString() === (currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.toString()))) === null || _a4 === void 0 ? void 0 : _a4.blockExplorerUrls) !== null && _b !== void 0 ? _b : [];
    });
  }
  getEnabledNetworks() {
    return this.evmNetworks;
  }
  isSignAuthorizationSupported() {
    return true;
  }
};
TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey = "turnkey-last-used-chain-id";

// node_modules/@dynamic-labs/embedded-wallet-evm/src/TurnkeyEVMWalletConnectors.js
var TurnkeyEVMWalletConnectors = (props) => {
  var _a4;
  if ((_a4 = props.apiProviders) === null || _a4 === void 0 ? void 0 : _a4.turnkey) {
    return [
      class extends TurnkeyEVMWalletConnector {
        constructor(innerProps) {
          super(TurnkeyWalletConnectorInfo.TurnkeyHD, Object.assign(Object.assign({}, props), innerProps));
        }
      },
      class extends TurnkeyEVMWalletConnector {
        constructor(innerProps) {
          super(TurnkeyWalletConnectorInfo.Turnkey, Object.assign(Object.assign({}, props), innerProps));
        }
      }
    ];
  }
  return [];
};

// node_modules/@dynamic-labs/embedded-wallet-evm/src/index.js
assertPackageVersion("@dynamic-labs/embedded-wallet-evm", version2);

// node_modules/@dynamic-labs/waas-evm/package.js
var version3 = "4.26.0";

// node_modules/@dynamic-labs/waas-evm/_virtual/_tslib.js
function __awaiter3(thisArg, _arguments, P6, generator) {
  function adopt(value2) {
    return value2 instanceof P6 ? value2 : new P6(function(resolve) {
      resolve(value2);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e9) {
        reject(e9);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e9) {
        reject(e9);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/waas-evm/src/DynamicWaasEVMConnector.js
var logger4 = new Logger("DynamicWaasConnector");
var DynamicWaasEVMConnector = class _DynamicWaasEVMConnector extends withDynamicWaas(EthereumWalletConnector) {
  constructor(props) {
    super(props);
    this.name = "Dynamic Waas";
    this.overrideKey = "dynamicwaas";
    this.isEmbeddedWallet = true;
    this._selectedChainId = this.getLastUsedChainId();
    this.__exportHandler = new WaasExportHandler();
  }
  getLastUsedChainId() {
    var _a4;
    logger4.logVerboseTroubleshootingMessage("[DynamicWaasEVMConnector] getLastUsedChainId", {
      evmNetworks: this.evmNetworks,
      lastUsedChainId: this.lastUsedChainId
    });
    if (this.lastUsedChainId) {
      return this.lastUsedChainId;
    }
    if (!((_a4 = this.evmNetworks) === null || _a4 === void 0 ? void 0 : _a4.length)) {
      return void 0;
    }
    return this.evmNetworks[0].chainId;
  }
  set verifiedCredentials(verifiedCredentials) {
    this._verifiedCredentials = verifiedCredentials;
  }
  get verifiedCredentials() {
    return this._verifiedCredentials;
  }
  set verifiedCredential(verifiedCredential) {
    this._verifiedCredential = verifiedCredential;
  }
  get verifiedCredential() {
    return this._verifiedCredential;
  }
  setVerifiedCredentials(verifiedCredentials) {
    const dynamicWaasVerifiedCredentials = verifiedCredentials === null || verifiedCredentials === void 0 ? void 0 : verifiedCredentials.reduce((acc, vc5) => {
      if (vc5.walletName === "dynamicwaas" && vc5.chain === "eip155") {
        const smartWallet = verifiedCredentials.find((v7) => v7.signerRefId === vc5.id);
        const smartWalletRefId = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.id;
        const smartWalletRefAddress = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.address;
        acc.push(Object.assign(Object.assign({}, vc5), { smartWalletRefAddress, smartWalletRefId }));
      }
      return acc;
    }, []);
    const [dynamicWaasVerifiedCredential] = dynamicWaasVerifiedCredentials;
    const didDynamicWaasVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !== JSON.stringify(dynamicWaasVerifiedCredentials);
    if (!didDynamicWaasVerifiedCredentialsChanged) {
      return;
    }
    this.verifiedCredential = dynamicWaasVerifiedCredential;
    this.verifiedCredentials = dynamicWaasVerifiedCredentials;
  }
  set lastUsedChainId(chainId) {
    if (chainId === void 0) {
      localStorage.removeItem(_DynamicWaasEVMConnector.lastUsedChainIdStorageKey);
    } else {
      localStorage.setItem(_DynamicWaasEVMConnector.lastUsedChainIdStorageKey, chainId.toString());
    }
    this._selectedChainId = chainId;
  }
  get lastUsedChainId() {
    const lastUsedChainIdLS = localStorage.getItem(_DynamicWaasEVMConnector.lastUsedChainIdStorageKey);
    if (!lastUsedChainIdLS)
      return void 0;
    try {
      const chainId = parseInt(lastUsedChainIdLS);
      if (isNaN(chainId)) {
        return void 0;
      }
      const isChainCurrentlyEnabled = this.evmNetworks.some((network) => network.chainId === chainId);
      if (!isChainCurrentlyEnabled) {
        const lastUsedChainId = this.evmNetworks[0].chainId;
        this.lastUsedChainId = lastUsedChainId;
        return lastUsedChainId;
      }
      return chainId;
    } catch (err) {
      logger4.error(err);
      return void 0;
    }
  }
  get currentChainId() {
    var _a4, _b, _c5;
    return (_a4 = this._selectedChainId) !== null && _a4 !== void 0 ? _a4 : (_c5 = (_b = this.evmNetworks) === null || _b === void 0 ? void 0 : _b[0]) === null || _c5 === void 0 ? void 0 : _c5.chainId;
  }
  getNetwork() {
    return __awaiter3(this, void 0, void 0, function* () {
      return this.currentChainId;
    });
  }
  getEvmNetworkByChainId(chainId) {
    return this.evmNetworks.find((network) => network.chainId === chainId);
  }
  currentEvmNetwork() {
    const chainId = this.currentChainId;
    if (!chainId) {
      return void 0;
    }
    return this.getEvmNetworkByChainId(chainId);
  }
  switchNetwork(_a4) {
    return __awaiter3(this, arguments, void 0, function* ({ networkChainId }) {
      if (!networkChainId) {
        return;
      }
      let networkChainIdInt = networkChainId;
      if (typeof networkChainId === "string") {
        networkChainIdInt = parseInt(networkChainId);
      }
      this.lastUsedChainId = networkChainIdInt;
      this._selectedChainId = networkChainIdInt;
      this.emit("chainChange", {
        chain: networkChainIdInt.toString()
      });
    });
  }
  getRpcUrl() {
    var _a4;
    const evmNetwork = this.currentEvmNetwork();
    if (!evmNetwork) {
      throw new Error("EVM network not found");
    }
    return ((_a4 = evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.privateCustomerRpcUrls) === null || _a4 === void 0 ? void 0 : _a4[0]) || (evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.rpcUrls[0]);
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter3(this, void 0, void 0, function* () {
      var _a4, _b, _c5;
      const walletClient = yield this.getWaasWalletClient();
      const signedSessionId = yield (_a4 = this.getSignedSessionId) === null || _a4 === void 0 ? void 0 : _a4.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      const targetWallet = yield walletClient.getWallet({
        accountAddress: expectedAddress,
        authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
        signedSessionId
      });
      if (!targetWallet) {
        throw new DynamicError("Account not found");
      }
      const isWalletActive = isSameAddress(targetWallet.accountAddress, ((_c5 = this.getActiveAccount()) === null || _c5 === void 0 ? void 0 : _c5.address) || "", this.connectedChain);
      if (!isWalletActive) {
        this.setActiveAccount(targetWallet.accountAddress);
      }
    });
  }
  getActiveAccountAddress() {
    return __awaiter3(this, void 0, void 0, function* () {
      var _a4;
      return (_a4 = this.getActiveAccount()) === null || _a4 === void 0 ? void 0 : _a4.address;
    });
  }
  getViemAccount(_a4) {
    return __awaiter3(this, arguments, void 0, function* ({ accountAddress }) {
      var _b;
      const client = yield this.getWaasWalletClient();
      const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      return toAccount({
        address: accountAddress,
        signAuthorization: (parameters) => __awaiter3(this, void 0, void 0, function* () {
          return this.signAuthorization(parameters);
        }),
        signMessage: (_c5) => __awaiter3(this, [_c5], void 0, function* ({ message }) {
          var _d2, _e8;
          const mfaToken = yield (_d2 = this.getMfaToken) === null || _d2 === void 0 ? void 0 : _d2.call(this, {
            mfaAction: MFAAction.WalletWaasSign
          });
          return client.signMessage({
            accountAddress,
            authToken: (_e8 = this.getAuthToken) === null || _e8 === void 0 ? void 0 : _e8.call(this),
            message,
            mfaToken,
            signedSessionId
          });
        }),
        signTransaction: (transaction) => __awaiter3(this, void 0, void 0, function* () {
          var _f5, _g;
          const mfaToken = yield (_f5 = this.getMfaToken) === null || _f5 === void 0 ? void 0 : _f5.call(this, {
            mfaAction: MFAAction.WalletWaasSign
          });
          return client.signTransaction({
            authToken: (_g = this.getAuthToken) === null || _g === void 0 ? void 0 : _g.call(this),
            mfaToken,
            senderAddress: accountAddress,
            signedSessionId,
            transaction: serializeTransaction(transaction)
          }).then((tx) => tx);
        }),
        signTypedData: (typedData) => __awaiter3(this, void 0, void 0, function* () {
          var _h2, _j;
          const mfaToken = yield (_h2 = this.getMfaToken) === null || _h2 === void 0 ? void 0 : _h2.call(this, {
            mfaAction: MFAAction.WalletWaasSign
          });
          return client.signTypedData({
            accountAddress,
            authToken: (_j = this.getAuthToken) === null || _j === void 0 ? void 0 : _j.call(this),
            mfaToken,
            signedSessionId,
            typedData
          });
        })
      });
    });
  }
  getWalletClient(chainId) {
    var _a4;
    const targetAccountAddress = (_a4 = this.getActiveAccount()) === null || _a4 === void 0 ? void 0 : _a4.address;
    if (!targetAccountAddress) {
      return this.getPublicClient();
    }
    const rpcUrl = this.getRpcUrl();
    const evmNetwork = chainId ? this.getEvmNetworkByChainId(parseInt(chainId)) : this.currentEvmNetwork();
    if (!evmNetwork) {
      throw new Error("EVM network not found");
    }
    return createWalletClientWithUiConfirmation({
      account: () => __awaiter3(this, void 0, void 0, function* () {
        return this.getViemAccount({
          accountAddress: targetAccountAddress
        });
      }),
      address: targetAccountAddress,
      chain: getOrMapViemChain(evmNetwork),
      transport: http(rpcUrl, this.providersConfig.httpTransportConfig),
      // TODO: remove this. We should not be passing references to wallet connectors
      walletConnector: this,
      walletUiUtils: this.walletUiUtils
    });
  }
  signMessage(message) {
    var _a4;
    return (_a4 = this.getWalletClient()) === null || _a4 === void 0 ? void 0 : _a4.signMessage({ message });
  }
  signMessageWithContext(_a4) {
    return __awaiter3(this, arguments, void 0, function* ({ message, context }) {
      var _b, _c5, _d2;
      const walletClient = yield this.getWaasWalletClient();
      const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      return walletClient.signMessage({
        accountAddress: (_c5 = this.getActiveAccount()) === null || _c5 === void 0 ? void 0 : _c5.address,
        authToken: (_d2 = this.getAuthToken) === null || _d2 === void 0 ? void 0 : _d2.call(this),
        context,
        message,
        signedSessionId
      });
    });
  }
  getSigner() {
    return __awaiter3(this, void 0, void 0, function* () {
      return this.getWalletClient();
    });
  }
  getWalletClientByAddress({ accountAddress }) {
    this.setActiveAccount(accountAddress);
    return this.getWalletClient();
  }
  // Chain-specific override for exportClientKeyshares - EVM needs to set active account first
  exportClientKeyshares(_a4) {
    const _super = Object.create(null, {
      exportClientKeyshares: { get: () => super.exportClientKeyshares }
    });
    return __awaiter3(this, arguments, void 0, function* ({ accountAddress, password }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.exportClientKeyshares.call(this, { accountAddress, password });
    });
  }
  // Chain-specific override for backupKeySharesToGoogleDrive - EVM needs to set active account first
  backupKeySharesToGoogleDrive(_a4) {
    const _super = Object.create(null, {
      backupKeySharesToGoogleDrive: { get: () => super.backupKeySharesToGoogleDrive }
    });
    return __awaiter3(this, arguments, void 0, function* ({ accountAddress, password }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.backupKeySharesToGoogleDrive.call(this, { accountAddress, password });
    });
  }
  // Chain-specific override for refreshWalletAccountShares - EVM needs to set active account first
  refreshWalletAccountShares(_a4) {
    const _super = Object.create(null, {
      refreshWalletAccountShares: { get: () => super.refreshWalletAccountShares }
    });
    return __awaiter3(this, arguments, void 0, function* ({ accountAddress, password }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.refreshWalletAccountShares.call(this, { accountAddress, password });
    });
  }
  // Chain-specific override for updatePassword - EVM needs to set active account first
  updatePassword(_a4) {
    const _super = Object.create(null, {
      updatePassword: { get: () => super.updatePassword }
    });
    return __awaiter3(this, arguments, void 0, function* ({ accountAddress, existingPassword, newPassword }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.updatePassword.call(this, {
        accountAddress,
        existingPassword,
        newPassword
      });
    });
  }
  createUiTransaction(from16) {
    return __awaiter3(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from16);
      const walletClient = this.getWalletClient();
      const publicClient = yield this.getPublicClient();
      if (!publicClient || !walletClient) {
        throw new DynamicError("No public client available");
      }
      return new ViemUiTransaction({
        account: from16,
        onSubmit: (transaction) => __awaiter3(this, void 0, void 0, function* () {
          if (transaction.nonNativeAddress) {
            return walletClient.writeContract({
              abi: erc20Abi,
              account: walletClient.account,
              address: transaction.nonNativeAddress,
              args: [transaction.to, transaction.nonNativeValue],
              functionName: "transfer",
              maxFeePerGas: transaction.maxFeePerGas,
              maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
            });
          }
          return walletClient.sendTransaction({
            account: walletClient.account,
            data: "0x",
            maxFeePerGas: transaction.maxFeePerGas,
            maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
            to: transaction.to,
            value: transaction.value
          });
        }),
        publicClient,
        transaction: {}
      });
    });
  }
  getConnectedAccounts() {
    return __awaiter3(this, void 0, void 0, function* () {
      var _a4;
      const verifiedCredentials = this.verifiedCredentials || [];
      const addresses = verifiedCredentials.map((vc5) => vc5 === null || vc5 === void 0 ? void 0 : vc5.address).filter((a4) => typeof a4 === "string");
      if (addresses.length > 0 && ((_a4 = this.verifiedCredential) === null || _a4 === void 0 ? void 0 : _a4.address)) {
        this.setActiveAccount(this.verifiedCredential.address);
      }
      return addresses;
    });
  }
  getAddress() {
    return __awaiter3(this, void 0, void 0, function* () {
      var _a4;
      const activeAccount = this.getActiveAccount();
      if (!activeAccount || !activeAccount.address) {
        if ((_a4 = this.verifiedCredential) === null || _a4 === void 0 ? void 0 : _a4.address) {
          const { address } = this.verifiedCredential;
          this.setActiveAccount(address);
          return address;
        }
        throw new DynamicError("No active wallet address found");
      }
      return activeAccount.address;
    });
  }
  signAuthorization(parameters, password) {
    return __awaiter3(this, void 0, void 0, function* () {
      var _a4, _b, _c5;
      const { address: contractAddress, nonce, chainId } = parameters;
      if (!contractAddress) {
        throw new Error("Contract address not found");
      }
      const [signer, publicClient] = yield Promise.all([
        this.getSigner(),
        this.getPublicClient()
      ]);
      if (!signer || !publicClient) {
        throw new Error("Required clients not found");
      }
      const { address } = signer.account;
      const walletClient = yield this.getWaasWalletClient();
      const signedSessionId = yield (_a4 = this.getSignedSessionId) === null || _a4 === void 0 ? void 0 : _a4.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      const mfaToken = yield (_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
        mfaAction: MFAAction.WalletWaasSign
      });
      const authorization = {
        address: contractAddress,
        chainId,
        nonce
      };
      const signature = yield walletClient.signRawMessage({
        accountAddress: address,
        authToken: (_c5 = this.getAuthToken) === null || _c5 === void 0 ? void 0 : _c5.call(this),
        context: { eip7702Auth: authorization },
        message: hashAuthorization(authorization).slice(2),
        mfaToken,
        password,
        signedSessionId
      });
      const parsedSignature = parseSignature(signature);
      return {
        address: contractAddress,
        chainId,
        nonce,
        r: parsedSignature.r,
        s: parsedSignature.s,
        v: parsedSignature.v,
        yParity: parsedSignature.yParity
      };
    });
  }
  isAtomicSupported(chainId) {
    return __awaiter3(this, void 0, void 0, function* () {
      logger4.debug("[DynamicWaasEVMConnector] isAtomicSupported - not supported", {
        chainId
      });
      return false;
    });
  }
  isPaymasterServiceSupported(chainId) {
    return __awaiter3(this, void 0, void 0, function* () {
      logger4.debug("[DynamicWaasEVMConnector] isPaymasterServiceSupported - not supported", {
        chainId
      });
      return false;
    });
  }
  isSignAuthorizationSupported() {
    return true;
  }
  endSession() {
    const _super = Object.create(null, {
      endSession: { get: () => super.endSession }
    });
    return __awaiter3(this, void 0, void 0, function* () {
      yield _super.endSession.call(this);
    });
  }
};
DynamicWaasEVMConnector.lastUsedChainIdStorageKey = "dynamic-waas-evm-last-used-chain-id";

// node_modules/@dynamic-labs/waas-evm/src/DynamicWaasEVMConnectors.js
var DynamicWaasEVMConnectors = () => [DynamicWaasEVMConnector];

// node_modules/@dynamic-labs/waas-evm/src/index.js
assertPackageVersion("@dynamic-labs/waas-evm", version3);

// node_modules/@dynamic-labs/ethereum/src/walletConnect/utils/fetchWalletConnectWallets.js
var fetchWalletConnectWallets = ({ walletBook }) => {
  var _a4;
  return Object.entries((_a4 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a4 !== void 0 ? _a4 : {}).filter(([, wallet]) => wallet.walletConnect && !wallet.filterFromWalletConnect).map(([key, wallet]) => {
    const { shortName } = wallet;
    const name = shortName || wallet.name;
    return class extends WalletConnectConnector {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { walletName: name }));
        this.overrideKey = key;
      }
    };
  });
};

// node_modules/@dynamic-labs/ethereum/src/walletConnect/utils/getWalletConnectConnector.js
var getWalletConnectConnector = () => class extends WalletConnectConnector {
  constructor(props) {
    super(Object.assign(Object.assign({}, props), { walletName: "WalletConnect" }));
  }
};

// node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js
var walletLogo = (type, width) => {
  let height;
  switch (type) {
    case "standard":
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    case "circle":
      height = width;
      return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
    case "text":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogo":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    case "textLight":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogoLight":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    default:
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/storage/ScopedLocalStorage.js
var ScopedLocalStorage = class _ScopedLocalStorage {
  constructor(scope, module) {
    this.scope = scope;
    this.module = module;
  }
  storeObject(key, item) {
    this.setItem(key, JSON.stringify(item));
  }
  loadObject(key) {
    const item = this.getItem(key);
    return item ? JSON.parse(item) : void 0;
  }
  setItem(key, value2) {
    localStorage.setItem(this.scopedKey(key), value2);
  }
  getItem(key) {
    return localStorage.getItem(this.scopedKey(key));
  }
  removeItem(key) {
    localStorage.removeItem(this.scopedKey(key));
  }
  clear() {
    const prefix = this.scopedKey("");
    const keysToRemove = [];
    for (let i6 = 0; i6 < localStorage.length; i6++) {
      const key = localStorage.key(i6);
      if (typeof key === "string" && key.startsWith(prefix)) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((key) => localStorage.removeItem(key));
  }
  scopedKey(key) {
    return `-${this.scope}${this.module ? `:${this.module}` : ""}:${key}`;
  }
  static clearAll() {
    new _ScopedLocalStorage("CBWSDK").clear();
    new _ScopedLocalStorage("walletlink").clear();
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/constants.js
var standardErrorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
};
var errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  "4902": {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/utils.js
var FALLBACK_MESSAGE = "Unspecified error message.";
var JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
  if (code && Number.isInteger(code)) {
    const codeString = code.toString();
    if (hasKey(errorValues, codeString)) {
      return errorValues[codeString].message;
    }
    if (isJsonRpcServerError(code)) {
      return JSON_RPC_SERVER_ERROR_MESSAGE;
    }
  }
  return fallbackMessage;
}
function isValidCode(code) {
  if (!Number.isInteger(code)) {
    return false;
  }
  const codeString = code.toString();
  if (errorValues[codeString]) {
    return true;
  }
  if (isJsonRpcServerError(code)) {
    return true;
  }
  return false;
}
function serialize(error, { shouldIncludeStack = false } = {}) {
  const serialized = {};
  if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
    const _error = error;
    serialized.code = _error.code;
    if (_error.message && typeof _error.message === "string") {
      serialized.message = _error.message;
      if (hasKey(_error, "data")) {
        serialized.data = _error.data;
      }
    } else {
      serialized.message = getMessageFromCode(serialized.code);
      serialized.data = { originalError: assignOriginalError(error) };
    }
  } else {
    serialized.code = standardErrorCodes.rpc.internal;
    serialized.message = hasStringProperty(error, "message") ? error.message : FALLBACK_MESSAGE;
    serialized.data = { originalError: assignOriginalError(error) };
  }
  if (shouldIncludeStack) {
    serialized.stack = hasStringProperty(error, "stack") ? error.stack : void 0;
  }
  return serialized;
}
function isJsonRpcServerError(code) {
  return code >= -32099 && code <= -32e3;
}
function assignOriginalError(error) {
  if (error && typeof error === "object" && !Array.isArray(error)) {
    return Object.assign({}, error);
  }
  return error;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function hasStringProperty(obj, prop) {
  return typeof obj === "object" && obj !== null && prop in obj && typeof obj[prop] === "string";
}

// node_modules/@coinbase/wallet-sdk/dist/core/error/errors.js
var standardErrors = {
  rpc: {
    parse: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.parse, arg),
    invalidRequest: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidRequest, arg),
    invalidParams: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidParams, arg),
    methodNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotFound, arg),
    internal: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.internal, arg),
    server: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const { code } = opts;
      if (!Number.isInteger(code) || code > -32005 || code < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError(code, opts);
    },
    invalidInput: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidInput, arg),
    resourceNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceNotFound, arg),
    resourceUnavailable: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceUnavailable, arg),
    transactionRejected: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.transactionRejected, arg),
    methodNotSupported: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotSupported, arg),
    limitExceeded: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.limitExceeded, arg)
  },
  provider: {
    userRejectedRequest: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.userRejectedRequest, arg);
    },
    unauthorized: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unauthorized, arg);
    },
    unsupportedMethod: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unsupportedMethod, arg);
    },
    disconnected: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.disconnected, arg);
    },
    chainDisconnected: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.chainDisconnected, arg);
    },
    unsupportedChain: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unsupportedChain, arg);
    },
    custom: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const { code, message, data } = opts;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new EthereumProviderError(code, message, data);
    }
  }
};
function getEthJsonRpcError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new EthereumRpcError(code, message || getMessageFromCode(code), data);
}
function getEthProviderError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new EthereumProviderError(code, message || getMessageFromCode(code), data);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data];
    }
  }
  return [];
}
var EthereumRpcError = class extends Error {
  constructor(code, message, data) {
    if (!Number.isInteger(code)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code;
    if (data !== void 0) {
      this.data = data;
    }
  }
};
var EthereumProviderError = class extends EthereumRpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(code, message, data) {
    if (!isValidEthProviderCode(code)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code, message, data);
  }
};
function isValidEthProviderCode(code) {
  return Number.isInteger(code) && code >= 1e3 && code <= 4999;
}

// node_modules/@coinbase/wallet-sdk/dist/core/type/index.js
function OpaqueType() {
  return (value2) => value2;
}
var HexString = OpaqueType();
var AddressString = OpaqueType();
var BigIntString = OpaqueType();
function IntNumber(num) {
  return Math.floor(num);
}
var RegExpString = OpaqueType();

// node_modules/@coinbase/wallet-sdk/dist/core/type/util.js
var INT_STRING_REGEX = /^[0-9]*$/;
var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
function randomBytesHex(length) {
  return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
}
function uint8ArrayToHex(value2) {
  return [...value2].map((b5) => b5.toString(16).padStart(2, "0")).join("");
}
function hexStringToUint8Array(hexString) {
  return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => Number.parseInt(byte, 16)));
}
function hexStringFromBuffer(buf, includePrefix = false) {
  const hex = buf.toString("hex");
  return HexString(includePrefix ? `0x${hex}` : hex);
}
function encodeToHexString(str) {
  return hexStringFromBuffer(ensureBuffer(str), true);
}
function bigIntStringFromBigInt(bi6) {
  return BigIntString(bi6.toString(10));
}
function hexStringFromNumber(num) {
  return HexString(`0x${BigInt(num).toString(16)}`);
}
function has0xPrefix(str) {
  return str.startsWith("0x") || str.startsWith("0X");
}
function strip0x(hex) {
  if (has0xPrefix(hex)) {
    return hex.slice(2);
  }
  return hex;
}
function prepend0x(hex) {
  if (has0xPrefix(hex)) {
    return `0x${hex.slice(2)}`;
  }
  return `0x${hex}`;
}
function isHexString(hex) {
  if (typeof hex !== "string") {
    return false;
  }
  const s3 = strip0x(hex).toLowerCase();
  return HEXADECIMAL_STRING_REGEX.test(s3);
}
function ensureHexString(hex, includePrefix = false) {
  if (typeof hex === "string") {
    const s3 = strip0x(hex).toLowerCase();
    if (HEXADECIMAL_STRING_REGEX.test(s3)) {
      return HexString(includePrefix ? `0x${s3}` : s3);
    }
  }
  throw standardErrors.rpc.invalidParams(`"${String(hex)}" is not a hexadecimal string`);
}
function ensureEvenLengthHexString(hex, includePrefix = false) {
  let h7 = ensureHexString(hex, false);
  if (h7.length % 2 === 1) {
    h7 = HexString(`0${h7}`);
  }
  return includePrefix ? HexString(`0x${h7}`) : h7;
}
function ensureAddressString(str) {
  if (typeof str === "string") {
    const s3 = strip0x(str).toLowerCase();
    if (isHexString(s3) && s3.length === 40) {
      return AddressString(prepend0x(s3));
    }
  }
  throw standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);
}
function ensureBuffer(str) {
  if (Buffer.isBuffer(str)) {
    return str;
  }
  if (typeof str === "string") {
    if (isHexString(str)) {
      const s3 = ensureEvenLengthHexString(str, false);
      return Buffer.from(s3, "hex");
    }
    return Buffer.from(str, "utf8");
  }
  throw standardErrors.rpc.invalidParams(`Not binary data: ${String(str)}`);
}
function ensureIntNumber(num) {
  if (typeof num === "number" && Number.isInteger(num)) {
    return IntNumber(num);
  }
  if (typeof num === "string") {
    if (INT_STRING_REGEX.test(num)) {
      return IntNumber(Number(num));
    }
    if (isHexString(num)) {
      return IntNumber(Number(BigInt(ensureEvenLengthHexString(num, true))));
    }
  }
  throw standardErrors.rpc.invalidParams(`Not an integer: ${String(num)}`);
}
function ensureBigInt(val) {
  if (val !== null && (typeof val === "bigint" || isBigNumber(val))) {
    return BigInt(val.toString(10));
  }
  if (typeof val === "number") {
    return BigInt(ensureIntNumber(val));
  }
  if (typeof val === "string") {
    if (INT_STRING_REGEX.test(val)) {
      return BigInt(val);
    }
    if (isHexString(val)) {
      return BigInt(ensureEvenLengthHexString(val, true));
    }
  }
  throw standardErrors.rpc.invalidParams(`Not an integer: ${String(val)}`);
}
function ensureParsedJSONObject(val) {
  if (typeof val === "string") {
    return JSON.parse(val);
  }
  if (typeof val === "object") {
    return val;
  }
  throw standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);
}
function isBigNumber(val) {
  if (val == null || typeof val.constructor !== "function") {
    return false;
  }
  const { constructor } = val;
  return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
}
function getFavicon() {
  const el2 = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
  const { protocol: protocol4, host } = document.location;
  const href = el2 ? el2.getAttribute("href") : null;
  if (!href || href.startsWith("javascript:") || href.startsWith("vbscript:")) {
    return `${protocol4}//${host}/favicon.ico`;
  }
  if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
    return href;
  }
  if (href.startsWith("//")) {
    return protocol4 + href;
  }
  return `${protocol4}//${host}${href}`;
}

// node_modules/@coinbase/wallet-sdk/dist/util/cipher.js
async function generateKeyPair() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, true, ["deriveKey"]);
}
async function deriveSharedSecret(ownPrivateKey, peerPublicKey) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: peerPublicKey
  }, ownPrivateKey, {
    name: "AES-GCM",
    length: 256
  }, false, ["encrypt", "decrypt"]);
}
async function encrypt(sharedSecret, plainText) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const cipherText = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, new TextEncoder().encode(plainText));
  return { iv, cipherText };
}
async function decrypt(sharedSecret, { iv, cipherText }) {
  const plainText = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, cipherText);
  return new TextDecoder().decode(plainText);
}
function getFormat(keyType) {
  switch (keyType) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function exportKeyToHexString(type, key) {
  const format = getFormat(type);
  const exported = await crypto.subtle.exportKey(format, key);
  return uint8ArrayToHex(new Uint8Array(exported));
}
async function importKeyFromHexString(type, hexString) {
  const format = getFormat(type);
  const arrayBuffer = hexStringToUint8Array(hexString).buffer;
  return await crypto.subtle.importKey(format, new Uint8Array(arrayBuffer), {
    name: "ECDH",
    namedCurve: "P-256"
  }, true, type === "private" ? ["deriveKey"] : []);
}
async function encryptContent(content, sharedSecret) {
  const serialized = JSON.stringify(content, (_4, value2) => {
    if (!(value2 instanceof Error))
      return value2;
    const error = value2;
    return Object.assign(Object.assign({}, error.code ? { code: error.code } : {}), { message: error.message });
  });
  return encrypt(sharedSecret, serialized);
}
async function decryptContent(encryptedData, sharedSecret) {
  return JSON.parse(await decrypt(sharedSecret, encryptedData));
}

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWKeyManager.js
var OWN_PRIVATE_KEY = {
  storageKey: "ownPrivateKey",
  keyType: "private"
};
var OWN_PUBLIC_KEY = {
  storageKey: "ownPublicKey",
  keyType: "public"
};
var PEER_PUBLIC_KEY = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
var SCWKeyManager = class {
  constructor() {
    this.storage = new ScopedLocalStorage("CBWSDK", "SCWKeyManager");
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    await this.loadKeysIfNeeded();
    return this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    await this.loadKeysIfNeeded();
    return this.sharedSecret;
  }
  async setPeerPublicKey(key) {
    this.sharedSecret = null;
    this.peerPublicKey = key;
    await this.storeKey(PEER_PUBLIC_KEY, key);
    await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
    this.storage.removeItem(OWN_PUBLIC_KEY.storageKey);
    this.storage.removeItem(OWN_PRIVATE_KEY.storageKey);
    this.storage.removeItem(PEER_PUBLIC_KEY.storageKey);
  }
  async generateKeyPair() {
    const newKeyPair = await generateKeyPair();
    this.ownPrivateKey = newKeyPair.privateKey;
    this.ownPublicKey = newKeyPair.publicKey;
    await this.storeKey(OWN_PRIVATE_KEY, newKeyPair.privateKey);
    await this.storeKey(OWN_PUBLIC_KEY, newKeyPair.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null) {
      this.ownPrivateKey = await this.loadKey(OWN_PRIVATE_KEY);
    }
    if (this.ownPublicKey === null) {
      this.ownPublicKey = await this.loadKey(OWN_PUBLIC_KEY);
    }
    if (this.ownPrivateKey === null || this.ownPublicKey === null) {
      await this.generateKeyPair();
    }
    if (this.peerPublicKey === null) {
      this.peerPublicKey = await this.loadKey(PEER_PUBLIC_KEY);
    }
    if (this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await deriveSharedSecret(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(item) {
    const key = this.storage.getItem(item.storageKey);
    if (!key)
      return null;
    return importKeyFromHexString(item.keyType, key);
  }
  async storeKey(item, key) {
    const hexString = await exportKeyToHexString(item.keyType, key);
    this.storage.setItem(item.storageKey, hexString);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/utils.js
function assertGetCapabilitiesParams(params) {
  if (!params || !Array.isArray(params) || params.length !== 1 && params.length !== 2) {
    throw standardErrors.rpc.invalidParams();
  }
  if (typeof params[0] !== "string" || !isAddress(params[0])) {
    throw standardErrors.rpc.invalidParams();
  }
  if (params.length === 2) {
    if (!Array.isArray(params[1])) {
      throw standardErrors.rpc.invalidParams();
    }
    for (const param of params[1]) {
      if (typeof param !== "string" || !param.startsWith("0x")) {
        throw standardErrors.rpc.invalidParams();
      }
    }
  }
}

// node_modules/@coinbase/wallet-sdk/dist/sdk-info.js
var VERSION = "4.3.7";
var NAME = "@coinbase/wallet-sdk";

// node_modules/@coinbase/wallet-sdk/dist/util/provider.js
async function fetchRPCRequest(request, rpcUrl) {
  const requestBody = Object.assign(Object.assign({}, request), { jsonrpc: "2.0", id: crypto.randomUUID() });
  const res = await window.fetch(rpcUrl, {
    method: "POST",
    body: JSON.stringify(requestBody),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": VERSION,
      "X-Cbw-Sdk-Platform": NAME
    }
  });
  const { result, error } = await res.json();
  if (error)
    throw error;
  return result;
}
function getCoinbaseInjectedLegacyProvider() {
  const window2 = globalThis;
  return window2.coinbaseWalletExtension;
}
function getInjectedEthereum() {
  var _a4, _b;
  try {
    const window2 = globalThis;
    return (_b = (_a4 = window2.top) === null || _a4 === void 0 ? void 0 : _a4.ethereum) !== null && _b !== void 0 ? _b : window2.ethereum;
  } catch (_c5) {
    return void 0;
  }
}
function getCoinbaseInjectedProvider({ metadata, preference }) {
  var _a4, _b;
  const { appName, appLogoUrl, appChainIds } = metadata;
  if (preference.options !== "smartWalletOnly") {
    const extension = getCoinbaseInjectedLegacyProvider();
    if (extension) {
      (_a4 = extension.setAppInfo) === null || _a4 === void 0 ? void 0 : _a4.call(extension, appName, appLogoUrl, appChainIds, preference);
      return extension;
    }
  }
  const ethereum = getInjectedEthereum();
  if (ethereum === null || ethereum === void 0 ? void 0 : ethereum.isCoinbaseBrowser) {
    (_b = ethereum.setAppInfo) === null || _b === void 0 ? void 0 : _b.call(ethereum, appName, appLogoUrl, appChainIds, preference);
    return ethereum;
  }
  return void 0;
}
function checkErrorForInvalidRequestArgs(args) {
  if (!args || typeof args !== "object" || Array.isArray(args)) {
    throw standardErrors.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: args
    });
  }
  const { method, params } = args;
  if (typeof method !== "string" || method.length === 0) {
    throw standardErrors.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: args
    });
  }
  if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
    throw standardErrors.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: args
    });
  }
  switch (method) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw standardErrors.provider.unsupportedMethod();
  }
}

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWSigner.js
var ACCOUNTS_KEY = "accounts";
var ACTIVE_CHAIN_STORAGE_KEY = "activeChain";
var AVAILABLE_CHAINS_STORAGE_KEY = "availableChains";
var WALLET_CAPABILITIES_STORAGE_KEY = "walletCapabilities";
var SCWSigner = class {
  constructor(params) {
    var _a4, _b, _c5;
    this.metadata = params.metadata;
    this.communicator = params.communicator;
    this.callback = params.callback;
    this.keyManager = new SCWKeyManager();
    this.storage = new ScopedLocalStorage("CBWSDK", "SCWStateManager");
    this.accounts = (_a4 = this.storage.loadObject(ACCOUNTS_KEY)) !== null && _a4 !== void 0 ? _a4 : [];
    this.chain = this.storage.loadObject(ACTIVE_CHAIN_STORAGE_KEY) || {
      id: (_c5 = (_b = params.metadata.appChainIds) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c5 !== void 0 ? _c5 : 1
    };
    this.handshake = this.handshake.bind(this);
    this.request = this.request.bind(this);
    this.createRequestMessage = this.createRequestMessage.bind(this);
    this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
  }
  async handshake(args) {
    var _a4, _b, _c5, _d2;
    await ((_b = (_a4 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a4));
    const handshakeMessage = await this.createRequestMessage({
      handshake: {
        method: args.method,
        params: Object.assign({}, this.metadata, (_c5 = args.params) !== null && _c5 !== void 0 ? _c5 : {})
      }
    });
    const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);
    if ("failure" in response.content)
      throw response.content.failure;
    const peerPublicKey = await importKeyFromHexString("public", response.sender);
    await this.keyManager.setPeerPublicKey(peerPublicKey);
    const decrypted = await this.decryptResponseMessage(response);
    const result = decrypted.result;
    if ("error" in result)
      throw result.error;
    switch (args.method) {
      case "eth_requestAccounts": {
        const accounts = result.value;
        this.accounts = accounts;
        this.storage.storeObject(ACCOUNTS_KEY, accounts);
        (_d2 = this.callback) === null || _d2 === void 0 ? void 0 : _d2.call(this, "accountsChanged", accounts);
        break;
      }
    }
  }
  async request(request) {
    var _a4;
    if (this.accounts.length === 0) {
      switch (request.method) {
        case "wallet_sendCalls":
          return this.sendRequestToPopup(request);
        default:
          throw standardErrors.provider.unauthorized();
      }
    }
    switch (request.method) {
      case "eth_requestAccounts":
        (_a4 = this.callback) === null || _a4 === void 0 ? void 0 : _a4.call(this, "connect", { chainId: hexStringFromNumber(this.chain.id) });
        return this.accounts;
      case "eth_accounts":
        return this.accounts;
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return hexStringFromNumber(this.chain.id);
      case "wallet_getCapabilities":
        return this.handleGetCapabilitiesRequest(request);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(request);
      case "eth_ecRecover":
      case "personal_sign":
      case "wallet_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(request);
      default:
        if (!this.chain.rpcUrl)
          throw standardErrors.rpc.internal("No RPC URL set for chain");
        return fetchRPCRequest(request, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(request) {
    var _a4, _b;
    await ((_b = (_a4 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a4));
    const response = await this.sendEncryptedRequest(request);
    const decrypted = await this.decryptResponseMessage(response);
    const result = decrypted.result;
    if ("error" in result)
      throw result.error;
    return result.value;
  }
  async cleanup() {
    var _a4, _b;
    this.storage.clear();
    await this.keyManager.clear();
    this.accounts = [];
    this.chain = {
      id: (_b = (_a4 = this.metadata.appChainIds) === null || _a4 === void 0 ? void 0 : _a4[0]) !== null && _b !== void 0 ? _b : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(request) {
    var _a4;
    const params = request.params;
    if (!params || !((_a4 = params[0]) === null || _a4 === void 0 ? void 0 : _a4.chainId)) {
      throw standardErrors.rpc.invalidParams();
    }
    const chainId = ensureIntNumber(params[0].chainId);
    const localResult = this.updateChain(chainId);
    if (localResult)
      return null;
    const popupResult = await this.sendRequestToPopup(request);
    if (popupResult === null) {
      this.updateChain(chainId);
    }
    return popupResult;
  }
  async handleGetCapabilitiesRequest(request) {
    assertGetCapabilitiesParams(request.params);
    const requestedAccount = request.params[0];
    const filterChainIds = request.params[1];
    if (!this.accounts.some((account) => isAddressEqual(account, requestedAccount))) {
      throw standardErrors.provider.unauthorized("no active account found");
    }
    const capabilities = this.storage.loadObject(WALLET_CAPABILITIES_STORAGE_KEY);
    if (!capabilities) {
      return {};
    }
    if (!filterChainIds || filterChainIds.length === 0) {
      return capabilities;
    }
    const filterChainNumbers = new Set(filterChainIds.map((chainId) => hexToNumber(chainId)));
    const filteredCapabilities = Object.fromEntries(Object.entries(capabilities).filter(([capabilityKey]) => {
      try {
        const capabilityChainNumber = hexToNumber(capabilityKey);
        return filterChainNumbers.has(capabilityChainNumber);
      } catch (_a4) {
        return false;
      }
    }));
    return filteredCapabilities;
  }
  async sendEncryptedRequest(request) {
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors.provider.unauthorized("No valid session found, try requestAccounts before other methods");
    }
    const encrypted = await encryptContent({
      action: request,
      chainId: this.chain.id
    }, sharedSecret);
    const message = await this.createRequestMessage({ encrypted });
    return this.communicator.postRequestAndWaitForResponse(message);
  }
  async createRequestMessage(content) {
    const publicKey = await exportKeyToHexString("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      sender: publicKey,
      content,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(message) {
    var _a4, _b;
    const content = message.content;
    if ("failure" in content) {
      throw content.failure;
    }
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors.provider.unauthorized("Invalid session");
    }
    const response = await decryptContent(content.encrypted, sharedSecret);
    const availableChains = (_a4 = response.data) === null || _a4 === void 0 ? void 0 : _a4.chains;
    if (availableChains) {
      const chains = Object.entries(availableChains).map(([id2, rpcUrl]) => ({
        id: Number(id2),
        rpcUrl
      }));
      this.storage.storeObject(AVAILABLE_CHAINS_STORAGE_KEY, chains);
      this.updateChain(this.chain.id, chains);
    }
    const walletCapabilities = (_b = response.data) === null || _b === void 0 ? void 0 : _b.capabilities;
    if (walletCapabilities) {
      this.storage.storeObject(WALLET_CAPABILITIES_STORAGE_KEY, walletCapabilities);
    }
    return response;
  }
  updateChain(chainId, newAvailableChains) {
    var _a4;
    const chains = newAvailableChains !== null && newAvailableChains !== void 0 ? newAvailableChains : this.storage.loadObject(AVAILABLE_CHAINS_STORAGE_KEY);
    const chain = chains === null || chains === void 0 ? void 0 : chains.find((chain2) => chain2.id === chainId);
    if (!chain)
      return false;
    if (chain !== this.chain) {
      this.chain = chain;
      this.storage.storeObject(ACTIVE_CHAIN_STORAGE_KEY, chain);
      (_a4 = this.callback) === null || _a4 === void 0 ? void 0 : _a4.call(this, "chainChanged", hexStringFromNumber(chain.id));
    }
    return true;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/WalletLinkSigner.js
var import_eth_eip712_util = __toESM(require_eth_eip712_util(), 1);

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/constants.js
var WALLET_USER_NAME_KEY = "walletUsername";
var LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
var APP_VERSION_KEY = "AppVersion";

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/Web3Response.js
function isErrorResponse(response) {
  return response.errorMessage !== void 0;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkCipher.js
var WalletLinkCipher = class {
  // @param secret hex representation of 32-byte secret
  constructor(secret) {
    this.secret = secret;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(plainText) {
    const secret = this.secret;
    if (secret.length !== 64)
      throw Error(`secret must be 256 bits`);
    const ivBytes = crypto.getRandomValues(new Uint8Array(12));
    const secretKey = await crypto.subtle.importKey("raw", hexStringToUint8Array(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
    const enc = new TextEncoder();
    const encryptedResult = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: ivBytes
    }, secretKey, enc.encode(plainText));
    const tagLength = 16;
    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
    const authTagBytes = new Uint8Array(authTag);
    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
    const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
    return uint8ArrayToHex(concatted);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(cipherText) {
    const secret = this.secret;
    if (secret.length !== 64)
      throw Error(`secret must be 256 bits`);
    return new Promise((resolve, reject) => {
      void (async function() {
        const secretKey = await crypto.subtle.importKey("raw", hexStringToUint8Array(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
        const encrypted = hexStringToUint8Array(cipherText);
        const ivBytes = encrypted.slice(0, 12);
        const authTagBytes = encrypted.slice(12, 28);
        const encryptedPlaintextBytes = encrypted.slice(28);
        const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
        const algo = {
          name: "AES-GCM",
          iv: new Uint8Array(ivBytes)
        };
        try {
          const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
          const decoder = new TextDecoder();
          resolve(decoder.decode(decrypted));
        } catch (err) {
          reject(err);
        }
      })();
    });
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkHTTP.js
var WalletLinkHTTP = class {
  constructor(linkAPIUrl, sessionId, sessionKey) {
    this.linkAPIUrl = linkAPIUrl;
    this.sessionId = sessionId;
    const credentials = `${sessionId}:${sessionKey}`;
    this.auth = `Basic ${btoa(credentials)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(events) {
    return Promise.all(events.map((e9) => fetch(`${this.linkAPIUrl}/events/${e9.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((error) => console.error("Unabled to mark event as failed:", error));
  }
  async fetchUnseenEvents() {
    var _a4;
    const response = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (response.ok) {
      const { events, error } = await response.json();
      if (error) {
        throw new Error(`Check unseen events failed: ${error}`);
      }
      const responseEvents = (_a4 = events === null || events === void 0 ? void 0 : events.filter((e9) => e9.event === "Web3Response").map((e9) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: e9.id,
        event: e9.event,
        data: e9.data
      }))) !== null && _a4 !== void 0 ? _a4 : [];
      this.markUnseenEventsAsSeen(responseEvents);
      return responseEvents;
    }
    throw new Error(`Check unseen events failed: ${response.status}`);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkWebSocket.js
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
  ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
  ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
})(ConnectionState || (ConnectionState = {}));
var WalletLinkWebSocket = class _WalletLinkWebSocket {
  setConnectionStateListener(listener) {
    this.connectionStateListener = listener;
  }
  setIncomingDataListener(listener) {
    this.incomingDataListener = listener;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(url2, WebSocketClass = WebSocket) {
    this.WebSocketClass = WebSocketClass;
    this.webSocket = null;
    this.isDisconnecting = false;
    this.url = url2.replace(/^http/, "ws");
    this.instanceId = _WalletLinkWebSocket.instanceCounter++;
    _WalletLinkWebSocket.activeInstances.add(this.instanceId);
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket) {
      throw new Error("webSocket object is not null");
    }
    if (this.isDisconnecting) {
      throw new Error("WebSocket is disconnecting, cannot reconnect on same instance");
    }
    return new Promise((resolve, reject) => {
      var _a4;
      let webSocket4;
      try {
        this.webSocket = webSocket4 = new this.WebSocketClass(this.url);
      } catch (err) {
        reject(err);
        return;
      }
      (_a4 = this.connectionStateListener) === null || _a4 === void 0 ? void 0 : _a4.call(this, ConnectionState.CONNECTING);
      webSocket4.onclose = (evt) => {
        var _a5;
        this.clearWebSocket();
        if (webSocket4.readyState !== WebSocket.OPEN) {
          reject(new Error(`websocket error ${evt.code}: ${evt.reason}`));
        }
        (_a5 = this.connectionStateListener) === null || _a5 === void 0 ? void 0 : _a5.call(this, ConnectionState.DISCONNECTED);
      };
      webSocket4.onopen = (_4) => {
        var _a5;
        resolve();
        (_a5 = this.connectionStateListener) === null || _a5 === void 0 ? void 0 : _a5.call(this, ConnectionState.CONNECTED);
        if (_WalletLinkWebSocket.pendingData.length > 0) {
          const pending = [..._WalletLinkWebSocket.pendingData];
          pending.forEach((data) => this.sendData(data));
          _WalletLinkWebSocket.pendingData = [];
        }
      };
      webSocket4.onmessage = (evt) => {
        var _a5, _b;
        if (evt.data === "h") {
          (_a5 = this.incomingDataListener) === null || _a5 === void 0 ? void 0 : _a5.call(this, {
            type: "Heartbeat"
          });
        } else {
          try {
            const message = JSON.parse(evt.data);
            (_b = this.incomingDataListener) === null || _b === void 0 ? void 0 : _b.call(this, message);
          } catch (_c5) {
          }
        }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var _a4;
    const { webSocket: webSocket4 } = this;
    if (!webSocket4) {
      return;
    }
    this.isDisconnecting = true;
    this.clearWebSocket();
    (_a4 = this.connectionStateListener) === null || _a4 === void 0 ? void 0 : _a4.call(this, ConnectionState.DISCONNECTED);
    this.connectionStateListener = void 0;
    this.incomingDataListener = void 0;
    try {
      webSocket4.close();
    } catch (_b) {
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(data) {
    const { webSocket: webSocket4 } = this;
    if (!webSocket4) {
      _WalletLinkWebSocket.pendingData.push(data);
      if (!this.isDisconnecting) {
        this.connect();
      }
      return;
    }
    if (webSocket4.readyState !== WebSocket.OPEN) {
      _WalletLinkWebSocket.pendingData.push(data);
      return;
    }
    webSocket4.send(data);
  }
  clearWebSocket() {
    const { webSocket: webSocket4 } = this;
    if (!webSocket4) {
      return;
    }
    this.webSocket = null;
    webSocket4.onclose = null;
    webSocket4.onerror = null;
    webSocket4.onmessage = null;
    webSocket4.onopen = null;
  }
  /**
   * remove ws from active instances
   */
  cleanup() {
    _WalletLinkWebSocket.activeInstances.delete(this.instanceId);
  }
};
WalletLinkWebSocket.instanceCounter = 0;
WalletLinkWebSocket.activeInstances = /* @__PURE__ */ new Set();
WalletLinkWebSocket.pendingData = [];

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkConnection.js
var HEARTBEAT_INTERVAL = 1e4;
var REQUEST_TIMEOUT = 6e4;
var WalletLinkConnection = class {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session, linkAPIUrl, listener }) {
    this.destroyed = false;
    this.lastHeartbeatResponse = 0;
    this.nextReqId = IntNumber(1);
    this.reconnectAttempts = 0;
    this.isReconnecting = false;
    this._connected = false;
    this._linked = false;
    this.requestResolutions = /* @__PURE__ */ new Map();
    this.handleSessionMetadataUpdated = (metadata) => {
      if (!metadata)
        return;
      const handlers = /* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          // ChainId and JsonRpcUrl are always updated together
          (v7) => metadata.JsonRpcUrl && this.handleChainUpdated(v7, metadata.JsonRpcUrl)
        ]
      ]);
      handlers.forEach((handler, key) => {
        const value2 = metadata[key];
        if (value2 === void 0)
          return;
        handler(value2);
      });
    };
    this.handleDestroyed = (__destroyed) => {
      var _a4;
      if (__destroyed !== "1")
        return;
      (_a4 = this.listener) === null || _a4 === void 0 ? void 0 : _a4.resetAndReload();
    };
    this.handleAccountUpdated = async (encryptedEthereumAddress) => {
      var _a4;
      try {
        const address = await this.cipher.decrypt(encryptedEthereumAddress);
        (_a4 = this.listener) === null || _a4 === void 0 ? void 0 : _a4.accountUpdated(address);
      } catch (_b) {
      }
    };
    this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {
      var _a4;
      try {
        const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);
        (_a4 = this.listener) === null || _a4 === void 0 ? void 0 : _a4.metadataUpdated(key, decryptedValue);
      } catch (_b) {
      }
    };
    this.handleWalletUsernameUpdated = async (walletUsername) => {
      this.handleMetadataUpdated(WALLET_USER_NAME_KEY, walletUsername);
    };
    this.handleAppVersionUpdated = async (appVersion) => {
      this.handleMetadataUpdated(APP_VERSION_KEY, appVersion);
    };
    this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {
      var _a4;
      try {
        const chainId = await this.cipher.decrypt(encryptedChainId);
        const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);
        (_a4 = this.listener) === null || _a4 === void 0 ? void 0 : _a4.chainUpdated(chainId, jsonRpcUrl);
      } catch (_b) {
      }
    };
    this.session = session;
    this.cipher = new WalletLinkCipher(session.secret);
    this.listener = listener;
    this.linkAPIUrl = linkAPIUrl;
    this.WebSocketClass = WebSocket;
    const ws6 = this.createWebSocket();
    this.ws = ws6;
    this.http = new WalletLinkHTTP(linkAPIUrl, session.id, session.key);
    this.setupVisibilityChangeHandler();
  }
  createWebSocket() {
    const ws6 = new WalletLinkWebSocket(`${this.linkAPIUrl}/rpc`, this.WebSocketClass);
    this.activeWsInstance = ws6;
    ws6.setConnectionStateListener(async (state) => {
      if (ws6 !== this.activeWsInstance) {
        return;
      }
      let connected = false;
      switch (state) {
        case ConnectionState.DISCONNECTED:
          if (this.heartbeatIntervalId) {
            clearInterval(this.heartbeatIntervalId);
            this.heartbeatIntervalId = void 0;
          }
          this.lastHeartbeatResponse = 0;
          connected = false;
          if (!this.destroyed) {
            const reconnect = async () => {
              if (this.isReconnecting) {
                return;
              }
              this.isReconnecting = true;
              const delay = this.reconnectAttempts === 0 ? 0 : 3e3;
              await new Promise((resolve) => setTimeout(resolve, delay));
              if (!this.destroyed && ws6 === this.activeWsInstance) {
                this.reconnectAttempts++;
                if ("cleanup" in this.ws && typeof this.ws.cleanup === "function") {
                  this.ws.cleanup();
                }
                this.ws = this.createWebSocket();
                this.ws.connect().catch(() => {
                }).finally(() => {
                  this.isReconnecting = false;
                });
              } else {
                this.isReconnecting = false;
              }
            };
            reconnect();
          }
          break;
        case ConnectionState.CONNECTED:
          this.reconnectAttempts = 0;
          try {
            connected = await this.handleConnected();
            this.fetchUnseenEventsAPI().catch(() => {
            });
          } catch (_error) {
            break;
          }
          this.connected = connected;
          this.updateLastHeartbeat();
          if (this.heartbeatIntervalId) {
            clearInterval(this.heartbeatIntervalId);
          }
          this.heartbeatIntervalId = window.setInterval(() => {
            this.heartbeat();
          }, HEARTBEAT_INTERVAL);
          setTimeout(() => {
            this.heartbeat();
          }, 100);
          break;
        case ConnectionState.CONNECTING:
          break;
      }
      if (state !== ConnectionState.CONNECTED) {
        this.connected = connected;
      }
    });
    ws6.setIncomingDataListener((m5) => {
      var _a4;
      switch (m5.type) {
        // handle server's heartbeat responses
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        // handle link status updates
        case "IsLinkedOK":
        case "Linked": {
          const linked = m5.type === "IsLinkedOK" ? m5.linked : void 0;
          this.linked = linked || m5.onlineGuests > 0;
          break;
        }
        // handle session config updates
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          this.handleSessionMetadataUpdated(m5.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(m5);
          break;
        }
      }
      if (m5.id !== void 0) {
        (_a4 = this.requestResolutions.get(m5.id)) === null || _a4 === void 0 ? void 0 : _a4(m5);
      }
    });
    return ws6;
  }
  setupVisibilityChangeHandler() {
    this.visibilityChangeHandler = () => {
      if (!document.hidden && !this.destroyed) {
        if (!this.connected) {
          this.reconnectWithFreshWebSocket();
        } else {
          this.heartbeat();
        }
      }
    };
    this.focusHandler = () => {
      if (!this.destroyed && !this.connected) {
        this.reconnectWithFreshWebSocket();
      }
    };
    document.addEventListener("visibilitychange", this.visibilityChangeHandler);
    window.addEventListener("focus", this.focusHandler);
    window.addEventListener("pageshow", (event) => {
      if (event.persisted) {
        if (this.focusHandler) {
          this.focusHandler();
        }
      }
    });
  }
  reconnectWithFreshWebSocket() {
    if (this.destroyed)
      return;
    const oldWs = this.ws;
    this.activeWsInstance = void 0;
    oldWs.disconnect();
    if ("cleanup" in oldWs && typeof oldWs.cleanup === "function") {
      oldWs.cleanup();
    }
    this.ws = this.createWebSocket();
    this.ws.connect().catch(() => {
    });
  }
  /**
   * Make a connection to the server
   */
  connect() {
    if (this.destroyed) {
      throw new Error("instance is destroyed");
    }
    this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  async destroy() {
    if (this.destroyed)
      return;
    await this.makeRequest({
      type: "SetSessionConfig",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { __destroyed: "1" }
    }, { timeout: 1e3 });
    this.destroyed = true;
    this.activeWsInstance = void 0;
    if (this.heartbeatIntervalId) {
      clearInterval(this.heartbeatIntervalId);
      this.heartbeatIntervalId = void 0;
    }
    if (this.visibilityChangeHandler) {
      document.removeEventListener("visibilitychange", this.visibilityChangeHandler);
    }
    if (this.focusHandler) {
      window.removeEventListener("focus", this.focusHandler);
    }
    this.ws.disconnect();
    if ("cleanup" in this.ws && typeof this.ws.cleanup === "function") {
      this.ws.cleanup();
    }
    this.listener = void 0;
  }
  get connected() {
    return this._connected;
  }
  set connected(connected) {
    this._connected = connected;
  }
  get linked() {
    return this._linked;
  }
  set linked(linked) {
    var _a4, _b;
    this._linked = linked;
    if (linked)
      (_a4 = this.onceLinked) === null || _a4 === void 0 ? void 0 : _a4.call(this);
    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);
  }
  setOnceLinked(callback) {
    return new Promise((resolve) => {
      if (this.linked) {
        callback().then(resolve);
      } else {
        this.onceLinked = () => {
          callback().then(resolve);
          this.onceLinked = void 0;
        };
      }
    });
  }
  async handleIncomingEvent(m5) {
    var _a4;
    if (m5.type !== "Event" || m5.event !== "Web3Response") {
      return;
    }
    try {
      const decryptedData = await this.cipher.decrypt(m5.data);
      const message = JSON.parse(decryptedData);
      if (message.type !== "WEB3_RESPONSE")
        return;
      (_a4 = this.listener) === null || _a4 === void 0 ? void 0 : _a4.handleWeb3ResponseMessage(message.id, message.response);
    } catch (_error) {
    }
  }
  async checkUnseenEvents() {
    await new Promise((resolve) => setTimeout(resolve, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e9) {
      console.error("Unable to check for unseen events", e9);
    }
  }
  async fetchUnseenEventsAPI() {
    try {
      const responseEvents = await this.http.fetchUnseenEvents();
      responseEvents.forEach((e9) => {
        this.handleIncomingEvent(e9);
      });
    } catch (_error) {
    }
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(event, unencryptedData, callWebhook = false) {
    const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), { origin: location.origin, location: location.href, relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk" })));
    const message = {
      type: "PublishEvent",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id,
      event,
      data,
      callWebhook
    };
    return this.setOnceLinked(async () => {
      const res = await this.makeRequest(message);
      if (res.type === "Fail") {
        throw new Error(res.error || "failed to publish event");
      }
      return res.eventId;
    });
  }
  sendData(message) {
    this.ws.sendData(JSON.stringify(message));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
      this.ws.disconnect();
      return;
    }
    if (!this.connected) {
      return;
    }
    try {
      this.ws.sendData("h");
    } catch (_error) {
    }
  }
  async makeRequest(message, options = { timeout: REQUEST_TIMEOUT }) {
    const reqId = message.id;
    this.sendData(message);
    let timeoutId;
    return Promise.race([
      new Promise((_4, reject) => {
        timeoutId = window.setTimeout(() => {
          reject(new Error(`request ${reqId} timed out`));
        }, options.timeout);
      }),
      new Promise((resolve) => {
        this.requestResolutions.set(reqId, (m5) => {
          clearTimeout(timeoutId);
          resolve(m5);
          this.requestResolutions.delete(reqId);
        });
      })
    ]);
  }
  async handleConnected() {
    const res = await this.makeRequest({
      type: "HostSession",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    });
    if (res.type === "Fail") {
      return false;
    }
    this.sendData({
      type: "IsLinked",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id
    });
    this.sendData({
      type: "GetSessionConfig",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id
    });
    return true;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/RelayEventManager.js
var RelayEventManager = class {
  constructor() {
    this._nextRequestId = 0;
    this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const id2 = this._nextRequestId;
    const idStr = prepend0x(id2.toString(16));
    const callback = this.callbacks.get(idStr);
    if (callback) {
      this.callbacks.delete(idStr);
    }
    return id2;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/WalletLinkSession.js
var STORAGE_KEY_SESSION_ID = "session:id";
var STORAGE_KEY_SESSION_SECRET = "session:secret";
var STORAGE_KEY_SESSION_LINKED = "session:linked";
var WalletLinkSession = class _WalletLinkSession {
  constructor(storage2, id2, secret, linked = false) {
    this.storage = storage2;
    this.id = id2;
    this.secret = secret;
    this.key = bytesToHex(sha256(`${id2}, ${secret} WalletLink`));
    this._linked = !!linked;
  }
  static create(storage2) {
    const id2 = randomBytesHex(16);
    const secret = randomBytesHex(32);
    return new _WalletLinkSession(storage2, id2, secret).save();
  }
  static load(storage2) {
    const id2 = storage2.getItem(STORAGE_KEY_SESSION_ID);
    const linked = storage2.getItem(STORAGE_KEY_SESSION_LINKED);
    const secret = storage2.getItem(STORAGE_KEY_SESSION_SECRET);
    if (id2 && secret) {
      return new _WalletLinkSession(storage2, id2, secret, linked === "1");
    }
    return null;
  }
  get linked() {
    return this._linked;
  }
  set linked(val) {
    this._linked = val;
    this.persistLinked();
  }
  save() {
    this.storage.setItem(STORAGE_KEY_SESSION_ID, this.id);
    this.storage.setItem(STORAGE_KEY_SESSION_SECRET, this.secret);
    this.persistLinked();
    return this;
  }
  persistLinked() {
    this.storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/util.js
function isInIFrame() {
  try {
    return window.frameElement !== null;
  } catch (e9) {
    return false;
  }
}
function getLocation() {
  try {
    if (isInIFrame() && window.top) {
      return window.top.location;
    }
    return window.location;
  } catch (e9) {
    return window.location;
  }
}
function isMobileWeb() {
  var _a4;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((_a4 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a4 === void 0 ? void 0 : _a4.userAgent);
}
function isDarkMode() {
  var _a4, _b;
  return (_b = (_a4 = window === null || window === void 0 ? void 0 : window.matchMedia) === null || _a4 === void 0 ? void 0 : _a4.call(window, "(prefers-color-scheme: dark)").matches) !== null && _b !== void 0 ? _b : false;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset-css.js
var cssReset_css_default = /* @__PURE__ */ (() => `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset.js
function injectCssReset() {
  const styleEl = document.createElement("style");
  styleEl.type = "text/css";
  styleEl.appendChild(document.createTextNode(cssReset_css_default));
  document.documentElement.appendChild(styleEl);
}

// node_modules/clsx/dist/clsx.m.js
function r2(e9) {
  var t4, f12, n4 = "";
  if ("string" == typeof e9 || "number" == typeof e9) n4 += e9;
  else if ("object" == typeof e9) if (Array.isArray(e9)) for (t4 = 0; t4 < e9.length; t4++) e9[t4] && (f12 = r2(e9[t4])) && (n4 && (n4 += " "), n4 += f12);
  else for (t4 in e9) e9[t4] && (n4 && (n4 += " "), n4 += t4);
  return n4;
}
function clsx() {
  for (var e9, t4, f12 = 0, n4 = ""; f12 < arguments.length; ) (e9 = arguments[f12++]) && (t4 = r2(e9)) && (n4 && (n4 += " "), n4 += t4);
  return n4;
}

// node_modules/preact/dist/preact.module.js
var n2;
var l3;
var u3;
var t;
var i3;
var r3;
var o2;
var e;
var f8;
var c3;
var s;
var a2;
var h4;
var p4 = {};
var v4 = [];
var y5 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var w3 = Array.isArray;
function d2(n4, l6) {
  for (var u6 in l6) n4[u6] = l6[u6];
  return n4;
}
function g(n4) {
  n4 && n4.parentNode && n4.parentNode.removeChild(n4);
}
function _2(l6, u6, t4) {
  var i6, r6, o4, e9 = {};
  for (o4 in u6) "key" == o4 ? i6 = u6[o4] : "ref" == o4 ? r6 = u6[o4] : e9[o4] = u6[o4];
  if (arguments.length > 2 && (e9.children = arguments.length > 3 ? n2.call(arguments, 2) : t4), "function" == typeof l6 && null != l6.defaultProps) for (o4 in l6.defaultProps) void 0 === e9[o4] && (e9[o4] = l6.defaultProps[o4]);
  return m2(l6, e9, i6, r6, null);
}
function m2(n4, t4, i6, r6, o4) {
  var e9 = { type: n4, props: t4, key: i6, ref: r6, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o4 ? ++u3 : o4, __i: -1, __u: 0 };
  return null == o4 && null != l3.vnode && l3.vnode(e9), e9;
}
function k5(n4) {
  return n4.children;
}
function x3(n4, l6) {
  this.props = n4, this.context = l6;
}
function S5(n4, l6) {
  if (null == l6) return n4.__ ? S5(n4.__, n4.__i + 1) : null;
  for (var u6; l6 < n4.__k.length; l6++) if (null != (u6 = n4.__k[l6]) && null != u6.__e) return u6.__e;
  return "function" == typeof n4.type ? S5(n4) : null;
}
function C5(n4) {
  var l6, u6;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l6 = 0; l6 < n4.__k.length; l6++) if (null != (u6 = n4.__k[l6]) && null != u6.__e) {
      n4.__e = n4.__c.base = u6.__e;
      break;
    }
    return C5(n4);
  }
}
function M5(n4) {
  (!n4.__d && (n4.__d = true) && i3.push(n4) && !$5.__r++ || r3 != l3.debounceRendering) && ((r3 = l3.debounceRendering) || o2)($5);
}
function $5() {
  for (var n4, u6, t4, r6, o4, f12, c6, s3 = 1; i3.length; ) i3.length > s3 && i3.sort(e), n4 = i3.shift(), s3 = i3.length, n4.__d && (t4 = void 0, o4 = (r6 = (u6 = n4).__v).__e, f12 = [], c6 = [], u6.__P && ((t4 = d2({}, r6)).__v = r6.__v + 1, l3.vnode && l3.vnode(t4), O4(u6.__P, t4, r6, u6.__n, u6.__P.namespaceURI, 32 & r6.__u ? [o4] : null, f12, null == o4 ? S5(r6) : o4, !!(32 & r6.__u), c6), t4.__v = r6.__v, t4.__.__k[t4.__i] = t4, N6(f12, t4, c6), t4.__e != o4 && C5(t4)));
  $5.__r = 0;
}
function I5(n4, l6, u6, t4, i6, r6, o4, e9, f12, c6, s3) {
  var a4, h7, y8, w6, d5, g3, _4 = t4 && t4.__k || v4, m5 = l6.length;
  for (f12 = P4(u6, l6, _4, f12, m5), a4 = 0; a4 < m5; a4++) null != (y8 = u6.__k[a4]) && (h7 = -1 == y8.__i ? p4 : _4[y8.__i] || p4, y8.__i = a4, g3 = O4(n4, y8, h7, i6, r6, o4, e9, f12, c6, s3), w6 = y8.__e, y8.ref && h7.ref != y8.ref && (h7.ref && B4(h7.ref, null, y8), s3.push(y8.ref, y8.__c || w6, y8)), null == d5 && null != w6 && (d5 = w6), 4 & y8.__u || h7.__k === y8.__k ? f12 = A6(y8, f12, n4) : "function" == typeof y8.type && void 0 !== g3 ? f12 = g3 : w6 && (f12 = w6.nextSibling), y8.__u &= -7);
  return u6.__e = d5, f12;
}
function P4(n4, l6, u6, t4, i6) {
  var r6, o4, e9, f12, c6, s3 = u6.length, a4 = s3, h7 = 0;
  for (n4.__k = new Array(i6), r6 = 0; r6 < i6; r6++) null != (o4 = l6[r6]) && "boolean" != typeof o4 && "function" != typeof o4 ? (f12 = r6 + h7, (o4 = n4.__k[r6] = "string" == typeof o4 || "number" == typeof o4 || "bigint" == typeof o4 || o4.constructor == String ? m2(null, o4, null, null, null) : w3(o4) ? m2(k5, { children: o4 }, null, null, null) : null == o4.constructor && o4.__b > 0 ? m2(o4.type, o4.props, o4.key, o4.ref ? o4.ref : null, o4.__v) : o4).__ = n4, o4.__b = n4.__b + 1, e9 = null, -1 != (c6 = o4.__i = L4(o4, u6, f12, a4)) && (a4--, (e9 = u6[c6]) && (e9.__u |= 2)), null == e9 || null == e9.__v ? (-1 == c6 && (i6 > s3 ? h7-- : i6 < s3 && h7++), "function" != typeof o4.type && (o4.__u |= 4)) : c6 != f12 && (c6 == f12 - 1 ? h7-- : c6 == f12 + 1 ? h7++ : (c6 > f12 ? h7-- : h7++, o4.__u |= 4))) : n4.__k[r6] = null;
  if (a4) for (r6 = 0; r6 < s3; r6++) null != (e9 = u6[r6]) && 0 == (2 & e9.__u) && (e9.__e == t4 && (t4 = S5(e9)), D6(e9, e9));
  return t4;
}
function A6(n4, l6, u6) {
  var t4, i6;
  if ("function" == typeof n4.type) {
    for (t4 = n4.__k, i6 = 0; t4 && i6 < t4.length; i6++) t4[i6] && (t4[i6].__ = n4, l6 = A6(t4[i6], l6, u6));
    return l6;
  }
  n4.__e != l6 && (l6 && n4.type && !u6.contains(l6) && (l6 = S5(n4)), u6.insertBefore(n4.__e, l6 || null), l6 = n4.__e);
  do {
    l6 = l6 && l6.nextSibling;
  } while (null != l6 && 8 == l6.nodeType);
  return l6;
}
function L4(n4, l6, u6, t4) {
  var i6, r6, o4, e9 = n4.key, f12 = n4.type, c6 = l6[u6], s3 = null != c6 && 0 == (2 & c6.__u);
  if (null === c6 && null == n4.key || s3 && e9 == c6.key && f12 == c6.type) return u6;
  if (t4 > (s3 ? 1 : 0)) {
    for (i6 = u6 - 1, r6 = u6 + 1; i6 >= 0 || r6 < l6.length; ) if (null != (c6 = l6[o4 = i6 >= 0 ? i6-- : r6++]) && 0 == (2 & c6.__u) && e9 == c6.key && f12 == c6.type) return o4;
  }
  return -1;
}
function T4(n4, l6, u6) {
  "-" == l6[0] ? n4.setProperty(l6, null == u6 ? "" : u6) : n4[l6] = null == u6 ? "" : "number" != typeof u6 || y5.test(l6) ? u6 : u6 + "px";
}
function j3(n4, l6, u6, t4, i6) {
  var r6, o4;
  n: if ("style" == l6) if ("string" == typeof u6) n4.style.cssText = u6;
  else {
    if ("string" == typeof t4 && (n4.style.cssText = t4 = ""), t4) for (l6 in t4) u6 && l6 in u6 || T4(n4.style, l6, "");
    if (u6) for (l6 in u6) t4 && u6[l6] == t4[l6] || T4(n4.style, l6, u6[l6]);
  }
  else if ("o" == l6[0] && "n" == l6[1]) r6 = l6 != (l6 = l6.replace(f8, "$1")), o4 = l6.toLowerCase(), l6 = o4 in n4 || "onFocusOut" == l6 || "onFocusIn" == l6 ? o4.slice(2) : l6.slice(2), n4.l || (n4.l = {}), n4.l[l6 + r6] = u6, u6 ? t4 ? u6.u = t4.u : (u6.u = c3, n4.addEventListener(l6, r6 ? a2 : s, r6)) : n4.removeEventListener(l6, r6 ? a2 : s, r6);
  else {
    if ("http://www.w3.org/2000/svg" == i6) l6 = l6.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l6 && "height" != l6 && "href" != l6 && "list" != l6 && "form" != l6 && "tabIndex" != l6 && "download" != l6 && "rowSpan" != l6 && "colSpan" != l6 && "role" != l6 && "popover" != l6 && l6 in n4) try {
      n4[l6] = null == u6 ? "" : u6;
      break n;
    } catch (n5) {
    }
    "function" == typeof u6 || (null == u6 || false === u6 && "-" != l6[4] ? n4.removeAttribute(l6) : n4.setAttribute(l6, "popover" == l6 && 1 == u6 ? "" : u6));
  }
}
function F6(n4) {
  return function(u6) {
    if (this.l) {
      var t4 = this.l[u6.type + n4];
      if (null == u6.t) u6.t = c3++;
      else if (u6.t < t4.u) return;
      return t4(l3.event ? l3.event(u6) : u6);
    }
  };
}
function O4(n4, u6, t4, i6, r6, o4, e9, f12, c6, s3) {
  var a4, h7, p7, v7, y8, _4, m5, b5, S7, C8, M7, $7, P6, A8, H4, L6, T6, j6 = u6.type;
  if (null != u6.constructor) return null;
  128 & t4.__u && (c6 = !!(32 & t4.__u), o4 = [f12 = u6.__e = t4.__e]), (a4 = l3.__b) && a4(u6);
  n: if ("function" == typeof j6) try {
    if (b5 = u6.props, S7 = "prototype" in j6 && j6.prototype.render, C8 = (a4 = j6.contextType) && i6[a4.__c], M7 = a4 ? C8 ? C8.props.value : a4.__ : i6, t4.__c ? m5 = (h7 = u6.__c = t4.__c).__ = h7.__E : (S7 ? u6.__c = h7 = new j6(b5, M7) : (u6.__c = h7 = new x3(b5, M7), h7.constructor = j6, h7.render = E5), C8 && C8.sub(h7), h7.props = b5, h7.state || (h7.state = {}), h7.context = M7, h7.__n = i6, p7 = h7.__d = true, h7.__h = [], h7._sb = []), S7 && null == h7.__s && (h7.__s = h7.state), S7 && null != j6.getDerivedStateFromProps && (h7.__s == h7.state && (h7.__s = d2({}, h7.__s)), d2(h7.__s, j6.getDerivedStateFromProps(b5, h7.__s))), v7 = h7.props, y8 = h7.state, h7.__v = u6, p7) S7 && null == j6.getDerivedStateFromProps && null != h7.componentWillMount && h7.componentWillMount(), S7 && null != h7.componentDidMount && h7.__h.push(h7.componentDidMount);
    else {
      if (S7 && null == j6.getDerivedStateFromProps && b5 !== v7 && null != h7.componentWillReceiveProps && h7.componentWillReceiveProps(b5, M7), !h7.__e && null != h7.shouldComponentUpdate && false === h7.shouldComponentUpdate(b5, h7.__s, M7) || u6.__v == t4.__v) {
        for (u6.__v != t4.__v && (h7.props = b5, h7.state = h7.__s, h7.__d = false), u6.__e = t4.__e, u6.__k = t4.__k, u6.__k.some(function(n5) {
          n5 && (n5.__ = u6);
        }), $7 = 0; $7 < h7._sb.length; $7++) h7.__h.push(h7._sb[$7]);
        h7._sb = [], h7.__h.length && e9.push(h7);
        break n;
      }
      null != h7.componentWillUpdate && h7.componentWillUpdate(b5, h7.__s, M7), S7 && null != h7.componentDidUpdate && h7.__h.push(function() {
        h7.componentDidUpdate(v7, y8, _4);
      });
    }
    if (h7.context = M7, h7.props = b5, h7.__P = n4, h7.__e = false, P6 = l3.__r, A8 = 0, S7) {
      for (h7.state = h7.__s, h7.__d = false, P6 && P6(u6), a4 = h7.render(h7.props, h7.state, h7.context), H4 = 0; H4 < h7._sb.length; H4++) h7.__h.push(h7._sb[H4]);
      h7._sb = [];
    } else do {
      h7.__d = false, P6 && P6(u6), a4 = h7.render(h7.props, h7.state, h7.context), h7.state = h7.__s;
    } while (h7.__d && ++A8 < 25);
    h7.state = h7.__s, null != h7.getChildContext && (i6 = d2(d2({}, i6), h7.getChildContext())), S7 && !p7 && null != h7.getSnapshotBeforeUpdate && (_4 = h7.getSnapshotBeforeUpdate(v7, y8)), L6 = a4, null != a4 && a4.type === k5 && null == a4.key && (L6 = V5(a4.props.children)), f12 = I5(n4, w3(L6) ? L6 : [L6], u6, t4, i6, r6, o4, e9, f12, c6, s3), h7.base = u6.__e, u6.__u &= -161, h7.__h.length && e9.push(h7), m5 && (h7.__E = h7.__ = null);
  } catch (n5) {
    if (u6.__v = null, c6 || null != o4) if (n5.then) {
      for (u6.__u |= c6 ? 160 : 128; f12 && 8 == f12.nodeType && f12.nextSibling; ) f12 = f12.nextSibling;
      o4[o4.indexOf(f12)] = null, u6.__e = f12;
    } else {
      for (T6 = o4.length; T6--; ) g(o4[T6]);
      z3(u6);
    }
    else u6.__e = t4.__e, u6.__k = t4.__k, n5.then || z3(u6);
    l3.__e(n5, u6, t4);
  }
  else null == o4 && u6.__v == t4.__v ? (u6.__k = t4.__k, u6.__e = t4.__e) : f12 = u6.__e = q3(t4.__e, u6, t4, i6, r6, o4, e9, c6, s3);
  return (a4 = l3.diffed) && a4(u6), 128 & u6.__u ? void 0 : f12;
}
function z3(n4) {
  n4 && n4.__c && (n4.__c.__e = true), n4 && n4.__k && n4.__k.forEach(z3);
}
function N6(n4, u6, t4) {
  for (var i6 = 0; i6 < t4.length; i6++) B4(t4[i6], t4[++i6], t4[++i6]);
  l3.__c && l3.__c(u6, n4), n4.some(function(u7) {
    try {
      n4 = u7.__h, u7.__h = [], n4.some(function(n5) {
        n5.call(u7);
      });
    } catch (n5) {
      l3.__e(n5, u7.__v);
    }
  });
}
function V5(n4) {
  return "object" != typeof n4 || null == n4 || n4.__b && n4.__b > 0 ? n4 : w3(n4) ? n4.map(V5) : d2({}, n4);
}
function q3(u6, t4, i6, r6, o4, e9, f12, c6, s3) {
  var a4, h7, v7, y8, d5, _4, m5, b5 = i6.props, k8 = t4.props, x5 = t4.type;
  if ("svg" == x5 ? o4 = "http://www.w3.org/2000/svg" : "math" == x5 ? o4 = "http://www.w3.org/1998/Math/MathML" : o4 || (o4 = "http://www.w3.org/1999/xhtml"), null != e9) {
    for (a4 = 0; a4 < e9.length; a4++) if ((d5 = e9[a4]) && "setAttribute" in d5 == !!x5 && (x5 ? d5.localName == x5 : 3 == d5.nodeType)) {
      u6 = d5, e9[a4] = null;
      break;
    }
  }
  if (null == u6) {
    if (null == x5) return document.createTextNode(k8);
    u6 = document.createElementNS(o4, x5, k8.is && k8), c6 && (l3.__m && l3.__m(t4, e9), c6 = false), e9 = null;
  }
  if (null == x5) b5 === k8 || c6 && u6.data == k8 || (u6.data = k8);
  else {
    if (e9 = e9 && n2.call(u6.childNodes), b5 = i6.props || p4, !c6 && null != e9) for (b5 = {}, a4 = 0; a4 < u6.attributes.length; a4++) b5[(d5 = u6.attributes[a4]).name] = d5.value;
    for (a4 in b5) if (d5 = b5[a4], "children" == a4) ;
    else if ("dangerouslySetInnerHTML" == a4) v7 = d5;
    else if (!(a4 in k8)) {
      if ("value" == a4 && "defaultValue" in k8 || "checked" == a4 && "defaultChecked" in k8) continue;
      j3(u6, a4, null, d5, o4);
    }
    for (a4 in k8) d5 = k8[a4], "children" == a4 ? y8 = d5 : "dangerouslySetInnerHTML" == a4 ? h7 = d5 : "value" == a4 ? _4 = d5 : "checked" == a4 ? m5 = d5 : c6 && "function" != typeof d5 || b5[a4] === d5 || j3(u6, a4, d5, b5[a4], o4);
    if (h7) c6 || v7 && (h7.__html == v7.__html || h7.__html == u6.innerHTML) || (u6.innerHTML = h7.__html), t4.__k = [];
    else if (v7 && (u6.innerHTML = ""), I5("template" == t4.type ? u6.content : u6, w3(y8) ? y8 : [y8], t4, i6, r6, "foreignObject" == x5 ? "http://www.w3.org/1999/xhtml" : o4, e9, f12, e9 ? e9[0] : i6.__k && S5(i6, 0), c6, s3), null != e9) for (a4 = e9.length; a4--; ) g(e9[a4]);
    c6 || (a4 = "value", "progress" == x5 && null == _4 ? u6.removeAttribute("value") : null != _4 && (_4 !== u6[a4] || "progress" == x5 && !_4 || "option" == x5 && _4 != b5[a4]) && j3(u6, a4, _4, b5[a4], o4), a4 = "checked", null != m5 && m5 != u6[a4] && j3(u6, a4, m5, b5[a4], o4));
  }
  return u6;
}
function B4(n4, u6, t4) {
  try {
    if ("function" == typeof n4) {
      var i6 = "function" == typeof n4.__u;
      i6 && n4.__u(), i6 && null == u6 || (n4.__u = n4(u6));
    } else n4.current = u6;
  } catch (n5) {
    l3.__e(n5, t4);
  }
}
function D6(n4, u6, t4) {
  var i6, r6;
  if (l3.unmount && l3.unmount(n4), (i6 = n4.ref) && (i6.current && i6.current != n4.__e || B4(i6, null, u6)), null != (i6 = n4.__c)) {
    if (i6.componentWillUnmount) try {
      i6.componentWillUnmount();
    } catch (n5) {
      l3.__e(n5, u6);
    }
    i6.base = i6.__P = null;
  }
  if (i6 = n4.__k) for (r6 = 0; r6 < i6.length; r6++) i6[r6] && D6(i6[r6], u6, t4 || "function" != typeof n4.type);
  t4 || g(n4.__e), n4.__c = n4.__ = n4.__e = void 0;
}
function E5(n4, l6, u6) {
  return this.constructor(n4, u6);
}
function G7(u6, t4, i6) {
  var r6, o4, e9, f12;
  t4 == document && (t4 = document.documentElement), l3.__ && l3.__(u6, t4), o4 = (r6 = "function" == typeof i6) ? null : i6 && i6.__k || t4.__k, e9 = [], f12 = [], O4(t4, u6 = (!r6 && i6 || t4).__k = _2(k5, null, [u6]), o4 || p4, p4, t4.namespaceURI, !r6 && i6 ? [i6] : o4 ? null : t4.firstChild ? n2.call(t4.childNodes) : null, e9, !r6 && i6 ? i6 : o4 ? o4.__e : t4.firstChild, r6, f12), N6(e9, u6, f12);
}
n2 = v4.slice, l3 = { __e: function(n4, l6, u6, t4) {
  for (var i6, r6, o4; l6 = l6.__; ) if ((i6 = l6.__c) && !i6.__) try {
    if ((r6 = i6.constructor) && null != r6.getDerivedStateFromError && (i6.setState(r6.getDerivedStateFromError(n4)), o4 = i6.__d), null != i6.componentDidCatch && (i6.componentDidCatch(n4, t4 || {}), o4 = i6.__d), o4) return i6.__E = i6;
  } catch (l7) {
    n4 = l7;
  }
  throw n4;
} }, u3 = 0, t = function(n4) {
  return null != n4 && null == n4.constructor;
}, x3.prototype.setState = function(n4, l6) {
  var u6;
  u6 = null != this.__s && this.__s != this.state ? this.__s : this.__s = d2({}, this.state), "function" == typeof n4 && (n4 = n4(d2({}, u6), this.props)), n4 && d2(u6, n4), null != n4 && this.__v && (l6 && this._sb.push(l6), M5(this));
}, x3.prototype.forceUpdate = function(n4) {
  this.__v && (this.__e = true, n4 && this.__h.push(n4), M5(this));
}, x3.prototype.render = k5, i3 = [], o2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n4, l6) {
  return n4.__v.__b - l6.__v.__b;
}, $5.__r = 0, f8 = /(PointerCapture)$|Capture$/i, c3 = 0, s = F6(false), a2 = F6(true), h4 = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r4;
var u4;
var i4;
var o3 = 0;
var f9 = [];
var c4 = l3;
var e2 = c4.__b;
var a3 = c4.__r;
var v5 = c4.diffed;
var l4 = c4.__c;
var m3 = c4.unmount;
var s2 = c4.__;
function p5(n4, t4) {
  c4.__h && c4.__h(r4, n4, o3 || t4), o3 = 0;
  var u6 = r4.__H || (r4.__H = { __: [], __h: [] });
  return n4 >= u6.__.length && u6.__.push({}), u6.__[n4];
}
function d3(n4) {
  return o3 = 1, h5(D7, n4);
}
function h5(n4, u6, i6) {
  var o4 = p5(t2++, 2);
  if (o4.t = n4, !o4.__c && (o4.__ = [i6 ? i6(u6) : D7(void 0, u6), function(n5) {
    var t4 = o4.__N ? o4.__N[0] : o4.__[0], r6 = o4.t(t4, n5);
    t4 !== r6 && (o4.__N = [r6, o4.__[1]], o4.__c.setState({}));
  }], o4.__c = r4, !r4.__f)) {
    var f12 = function(n5, t4, r6) {
      if (!o4.__c.__H) return true;
      var u7 = o4.__c.__H.__.filter(function(n6) {
        return !!n6.__c;
      });
      if (u7.every(function(n6) {
        return !n6.__N;
      })) return !c6 || c6.call(this, n5, t4, r6);
      var i7 = o4.__c.props !== n5;
      return u7.forEach(function(n6) {
        if (n6.__N) {
          var t5 = n6.__[0];
          n6.__ = n6.__N, n6.__N = void 0, t5 !== n6.__[0] && (i7 = true);
        }
      }), c6 && c6.call(this, n5, t4, r6) || i7;
    };
    r4.__f = true;
    var c6 = r4.shouldComponentUpdate, e9 = r4.componentWillUpdate;
    r4.componentWillUpdate = function(n5, t4, r6) {
      if (this.__e) {
        var u7 = c6;
        c6 = void 0, f12(n5, t4, r6), c6 = u7;
      }
      e9 && e9.call(this, n5, t4, r6);
    }, r4.shouldComponentUpdate = f12;
  }
  return o4.__N || o4.__;
}
function y6(n4, u6) {
  var i6 = p5(t2++, 3);
  !c4.__s && C6(i6.__H, u6) && (i6.__ = n4, i6.u = u6, r4.__H.__h.push(i6));
}
function j4() {
  for (var n4; n4 = f9.shift(); ) if (n4.__P && n4.__H) try {
    n4.__H.__h.forEach(z4), n4.__H.__h.forEach(B5), n4.__H.__h = [];
  } catch (t4) {
    n4.__H.__h = [], c4.__e(t4, n4.__v);
  }
}
c4.__b = function(n4) {
  r4 = null, e2 && e2(n4);
}, c4.__ = function(n4, t4) {
  n4 && t4.__k && t4.__k.__m && (n4.__m = t4.__k.__m), s2 && s2(n4, t4);
}, c4.__r = function(n4) {
  a3 && a3(n4), t2 = 0;
  var i6 = (r4 = n4.__c).__H;
  i6 && (u4 === r4 ? (i6.__h = [], r4.__h = [], i6.__.forEach(function(n5) {
    n5.__N && (n5.__ = n5.__N), n5.u = n5.__N = void 0;
  })) : (i6.__h.forEach(z4), i6.__h.forEach(B5), i6.__h = [], t2 = 0)), u4 = r4;
}, c4.diffed = function(n4) {
  v5 && v5(n4);
  var t4 = n4.__c;
  t4 && t4.__H && (t4.__H.__h.length && (1 !== f9.push(t4) && i4 === c4.requestAnimationFrame || ((i4 = c4.requestAnimationFrame) || w4)(j4)), t4.__H.__.forEach(function(n5) {
    n5.u && (n5.__H = n5.u), n5.u = void 0;
  })), u4 = r4 = null;
}, c4.__c = function(n4, t4) {
  t4.some(function(n5) {
    try {
      n5.__h.forEach(z4), n5.__h = n5.__h.filter(function(n6) {
        return !n6.__ || B5(n6);
      });
    } catch (r6) {
      t4.some(function(n6) {
        n6.__h && (n6.__h = []);
      }), t4 = [], c4.__e(r6, n5.__v);
    }
  }), l4 && l4(n4, t4);
}, c4.unmount = function(n4) {
  m3 && m3(n4);
  var t4, r6 = n4.__c;
  r6 && r6.__H && (r6.__H.__.forEach(function(n5) {
    try {
      z4(n5);
    } catch (n6) {
      t4 = n6;
    }
  }), r6.__H = void 0, t4 && c4.__e(t4, r6.__v));
};
var k6 = "function" == typeof requestAnimationFrame;
function w4(n4) {
  var t4, r6 = function() {
    clearTimeout(u6), k6 && cancelAnimationFrame(t4), setTimeout(n4);
  }, u6 = setTimeout(r6, 35);
  k6 && (t4 = requestAnimationFrame(r6));
}
function z4(n4) {
  var t4 = r4, u6 = n4.__c;
  "function" == typeof u6 && (n4.__c = void 0, u6()), r4 = t4;
}
function B5(n4) {
  var t4 = r4;
  n4.__c = n4.__(), r4 = t4;
}
function C6(n4, t4) {
  return !n4 || n4.length !== t4.length || t4.some(function(t5, r6) {
    return t5 !== n4[r6];
  });
}
function D7(n4, t4) {
  return "function" == typeof t4 ? t4(n4) : t4;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar-css.js
var Snackbar_css_default = /* @__PURE__ */ (() => `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar.js
var cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
var Snackbar = class {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this.nextItemKey = 0;
    this.root = null;
    this.darkMode = isDarkMode();
  }
  attach(el2) {
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-snackbar-root";
    el2.appendChild(this.root);
    this.render();
  }
  presentItem(itemProps) {
    const key = this.nextItemKey++;
    this.items.set(key, itemProps);
    this.render();
    return () => {
      this.items.delete(key);
      this.render();
    };
  }
  clear() {
    this.items.clear();
    this.render();
  }
  render() {
    if (!this.root) {
      return;
    }
    G7(_2(
      "div",
      null,
      _2(SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => _2(SnackbarInstance, Object.assign({}, itemProps, { key }))))
    ), this.root);
  }
};
var SnackbarContainer = (props) => _2(
  "div",
  { class: clsx("-cbwsdk-snackbar-container") },
  _2("style", null, Snackbar_css_default),
  _2("div", { class: "-cbwsdk-snackbar" }, props.children)
);
var SnackbarInstance = ({ autoExpand, message, menuItems }) => {
  const [hidden, setHidden] = d3(true);
  const [expanded, setExpanded] = d3(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
  y6(() => {
    const timers = [
      window.setTimeout(() => {
        setHidden(false);
      }, 1),
      window.setTimeout(() => {
        setExpanded(true);
      }, 1e4)
    ];
    return () => {
      timers.forEach(window.clearTimeout);
    };
  });
  const toggleExpanded = () => {
    setExpanded(!expanded);
  };
  return _2(
    "div",
    { class: clsx("-cbwsdk-snackbar-instance", hidden && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
    _2(
      "div",
      { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
      _2("img", { src: cblogo, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
      " ",
      _2("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
      _2(
        "div",
        { class: "-gear-container" },
        !expanded && _2(
          "svg",
          { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          _2("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
        ),
        _2("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
      )
    ),
    menuItems && menuItems.length > 0 && _2("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i6) => _2(
      "div",
      { class: clsx("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i6 },
      _2(
        "svg",
        { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        _2("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
      ),
      _2("span", { class: clsx("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
    )))
  );
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WalletLinkRelayUI.js
var RETRY_SVG_PATH = "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z";
var WalletLinkRelayUI = class {
  constructor() {
    this.attached = false;
    this.snackbar = new Snackbar();
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    const el2 = document.documentElement;
    const container = document.createElement("div");
    container.className = "-cbwsdk-css-reset";
    el2.appendChild(container);
    this.snackbar.attach(container);
    this.attached = true;
    injectCssReset();
  }
  showConnecting(options) {
    let snackbarProps;
    if (options.isUnlinkedErrorState) {
      snackbarProps = {
        autoExpand: true,
        message: "Connection lost",
        menuItems: [
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    } else {
      snackbarProps = {
        message: "Confirm on phone",
        menuItems: [
          {
            isRed: true,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: options.onCancel
          },
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: RETRY_SVG_PATH,
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    }
    return this.snackbar.presentItem(snackbarProps);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog-css.js
var RedirectDialog_css_default = /* @__PURE__ */ (() => `.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog.js
var RedirectDialog = class {
  constructor() {
    this.root = null;
    this.darkMode = isDarkMode();
  }
  attach() {
    const el2 = document.documentElement;
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-css-reset";
    el2.appendChild(this.root);
    injectCssReset();
  }
  present(props) {
    this.render(props);
  }
  clear() {
    this.render(null);
  }
  render(props) {
    if (!this.root)
      return;
    G7(null, this.root);
    if (!props)
      return;
    G7(_2(RedirectDialogContent, Object.assign({}, props, { onDismiss: () => {
      this.clear();
    }, darkMode: this.darkMode })), this.root);
  }
};
var RedirectDialogContent = ({ title, buttonText, darkMode, onButtonClick, onDismiss }) => {
  const theme = darkMode ? "dark" : "light";
  return _2(
    SnackbarContainer,
    { darkMode },
    _2(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      _2("style", null, RedirectDialog_css_default),
      _2("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: onDismiss }),
      _2(
        "div",
        { class: clsx("-cbwsdk-redirect-dialog-box", theme) },
        _2("p", null, title),
        _2("button", { onClick: onButtonClick }, buttonText)
      )
    )
  );
};

// node_modules/@coinbase/wallet-sdk/dist/core/constants.js
var CB_KEYS_URL = "https://keys.coinbase.com/connect";
var CB_WALLET_RPC_URL = "https://rpc.wallet.coinbase.com";
var WALLETLINK_URL = "https://www.walletlink.org";
var CBW_MOBILE_DEEPLINK_URL = "https://go.cb-w.com/walletlink";

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WLMobileRelayUI.js
var WLMobileRelayUI = class {
  constructor() {
    this.attached = false;
    this.redirectDialog = new RedirectDialog();
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    this.redirectDialog.attach();
    this.attached = true;
  }
  redirectToCoinbaseWallet(walletLinkUrl) {
    const url2 = new URL(CBW_MOBILE_DEEPLINK_URL);
    url2.searchParams.append("redirect_url", getLocation().href);
    if (walletLinkUrl) {
      url2.searchParams.append("wl_url", walletLinkUrl);
    }
    const anchorTag = document.createElement("a");
    anchorTag.target = "cbw-opener";
    anchorTag.href = url2.href;
    anchorTag.rel = "noreferrer noopener";
    anchorTag.click();
  }
  openCoinbaseWalletDeeplink(walletLinkUrl) {
    this.redirectToCoinbaseWallet(walletLinkUrl);
    setTimeout(() => {
      this.redirectDialog.present({
        title: "Redirecting to Coinbase Wallet...",
        buttonText: "Open",
        onButtonClick: () => {
          this.redirectToCoinbaseWallet(walletLinkUrl);
        }
      });
    }, 99);
  }
  showConnecting(_options) {
    return () => {
      this.redirectDialog.clear();
    };
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/WalletLinkRelay.js
var WalletLinkRelay = class _WalletLinkRelay {
  constructor(options) {
    this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" };
    this.isMobileWeb = isMobileWeb();
    this.linkedUpdated = (linked) => {
      this.isLinked = linked;
      const cachedAddresses = this.storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);
      if (linked) {
        this._session.linked = linked;
      }
      this.isUnlinkedErrorState = false;
      if (cachedAddresses) {
        const addresses = cachedAddresses.split(" ");
        const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
        if (addresses[0] !== "" && !linked && this._session.linked && !wasConnectedViaStandalone) {
          this.isUnlinkedErrorState = true;
        }
      }
    };
    this.metadataUpdated = (key, value2) => {
      this.storage.setItem(key, value2);
    };
    this.chainUpdated = (chainId, jsonRpcUrl) => {
      if (this.chainCallbackParams.chainId === chainId && this.chainCallbackParams.jsonRpcUrl === jsonRpcUrl) {
        return;
      }
      this.chainCallbackParams = {
        chainId,
        jsonRpcUrl
      };
      if (this.chainCallback) {
        this.chainCallback(jsonRpcUrl, Number.parseInt(chainId, 10));
      }
    };
    this.accountUpdated = (selectedAddress) => {
      if (this.accountsCallback) {
        this.accountsCallback([selectedAddress]);
      }
      if (_WalletLinkRelay.accountRequestCallbackIds.size > 0) {
        Array.from(_WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id2) => {
          this.invokeCallback(id2, {
            method: "requestEthereumAccounts",
            result: [selectedAddress]
          });
        });
        _WalletLinkRelay.accountRequestCallbackIds.clear();
      }
    };
    this.resetAndReload = this.resetAndReload.bind(this);
    this.linkAPIUrl = options.linkAPIUrl;
    this.storage = options.storage;
    this.metadata = options.metadata;
    this.accountsCallback = options.accountsCallback;
    this.chainCallback = options.chainCallback;
    const { session, ui: ui5, connection } = this.subscribe();
    this._session = session;
    this.connection = connection;
    this.relayEventManager = new RelayEventManager();
    this.ui = ui5;
    this.ui.attach();
  }
  subscribe() {
    const session = WalletLinkSession.load(this.storage) || WalletLinkSession.create(this.storage);
    const { linkAPIUrl } = this;
    const connection = new WalletLinkConnection({
      session,
      linkAPIUrl,
      listener: this
    });
    const ui5 = this.isMobileWeb ? new WLMobileRelayUI() : new WalletLinkRelayUI();
    connection.connect();
    return { session, ui: ui5, connection };
  }
  resetAndReload() {
    this.connection.destroy().then(() => {
      const storedSession = WalletLinkSession.load(this.storage);
      if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
        ScopedLocalStorage.clearAll();
      }
      document.location.reload();
    }).catch((_4) => {
    });
  }
  signEthereumTransaction(params) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: bigIntStringFromBigInt(params.weiValue),
        data: hexStringFromBuffer(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxPriorityFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: false
      }
    });
  }
  signAndSubmitEthereumTransaction(params) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: bigIntStringFromBigInt(params.weiValue),
        data: hexStringFromBuffer(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxFeePerGas: params.maxFeePerGas ? bigIntStringFromBigInt(params.maxFeePerGas) : null,
        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? bigIntStringFromBigInt(params.maxPriorityFeePerGas) : null,
        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: true
      }
    });
  }
  submitEthereumTransaction(signedTransaction, chainId) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: hexStringFromBuffer(signedTransaction, true),
        chainId
      }
    });
  }
  getWalletLinkSession() {
    return this._session;
  }
  sendRequest(request) {
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    return new Promise((resolve, reject) => {
      {
        hideSnackbarItem = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: cancel,
          onResetConnection: this.resetAndReload
          // eslint-disable-line @typescript-eslint/unbound-method
        });
      }
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request);
    });
  }
  publishWeb3RequestEvent(id2, request) {
    const message = { type: "WEB3_REQUEST", id: id2, request };
    this.publishEvent("Web3Request", message, true).then((_4) => {
    }).catch((err) => {
      this.handleWeb3ResponseMessage(message.id, {
        method: request.method,
        errorMessage: err.message
      });
    });
    if (this.isMobileWeb) {
      this.openCoinbaseWalletDeeplink(request.method);
    }
  }
  // copied from MobileRelay
  openCoinbaseWalletDeeplink(method) {
    if (!(this.ui instanceof WLMobileRelayUI))
      return;
    switch (method) {
      case "requestEthereumAccounts":
      // requestEthereumAccounts is handled via popup
      case "switchEthereumChain":
        return;
      default:
        window.addEventListener("blur", () => {
          window.addEventListener("focus", () => {
            this.connection.checkUnseenEvents();
          }, { once: true });
        }, { once: true });
        this.ui.openCoinbaseWalletDeeplink();
        break;
    }
  }
  publishWeb3RequestCanceledEvent(id2) {
    const message = {
      type: "WEB3_REQUEST_CANCELED",
      id: id2
    };
    this.publishEvent("Web3RequestCanceled", message, false).then();
  }
  publishEvent(event, message, callWebhook) {
    return this.connection.publishEvent(event, message, callWebhook);
  }
  handleWeb3ResponseMessage(id2, response) {
    if (response.method === "requestEthereumAccounts") {
      _WalletLinkRelay.accountRequestCallbackIds.forEach((id3) => this.invokeCallback(id3, response));
      _WalletLinkRelay.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(id2, response);
  }
  handleErrorResponse(id2, method, error) {
    var _a4;
    const errorMessage = (_a4 = error === null || error === void 0 ? void 0 : error.message) !== null && _a4 !== void 0 ? _a4 : "Unspecified error message.";
    this.handleWeb3ResponseMessage(id2, {
      method,
      errorMessage
    });
  }
  invokeCallback(id2, response) {
    const callback = this.relayEventManager.callbacks.get(id2);
    if (callback) {
      callback(response);
      this.relayEventManager.callbacks.delete(id2);
    }
  }
  requestEthereumAccounts() {
    const { appName, appLogoUrl } = this.metadata;
    const request = {
      method: "requestEthereumAccounts",
      params: {
        appName,
        appLogoUrl
      }
    };
    const hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      _WalletLinkRelay.accountRequestCallbackIds.add(id2);
      this.publishWeb3RequestEvent(id2, request);
    });
  }
  watchAsset(type, address, symbol, decimals, image, chainId) {
    const request = {
      method: "watchAsset",
      params: {
        type,
        options: {
          address,
          symbol,
          decimals,
          image
        },
        chainId
      }
    };
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request);
    });
  }
  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
    const request = {
      method: "addEthereumChain",
      params: {
        chainId,
        rpcUrls,
        blockExplorerUrls,
        chainName,
        iconUrls,
        nativeCurrency
      }
    };
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request);
    });
  }
  switchEthereumChain(chainId, address) {
    const request = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId }, { address })
    };
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response) && response.errorCode) {
          return reject(standardErrors.provider.custom({
            code: response.errorCode,
            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
          }));
        } else if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request);
    });
  }
};
WalletLinkRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/WalletLinkSigner.js
var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
var WalletLinkSigner = class {
  constructor(options) {
    this._relay = null;
    this._addresses = [];
    this.metadata = options.metadata;
    this._storage = new ScopedLocalStorage("walletlink", WALLETLINK_URL);
    this.callback = options.callback || null;
    const cachedAddresses = this._storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);
    if (cachedAddresses) {
      const addresses = cachedAddresses.split(" ");
      if (addresses[0] !== "") {
        this._addresses = addresses.map((address) => ensureAddressString(address));
      }
    }
    this.initializeRelay();
  }
  getSession() {
    const relay = this.initializeRelay();
    const { id: id2, secret } = relay.getWalletLinkSession();
    return { id: id2, secret };
  }
  async handshake() {
    await this._eth_requestAccounts();
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get jsonRpcUrl() {
    var _a4;
    return (_a4 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a4 !== void 0 ? _a4 : void 0;
  }
  set jsonRpcUrl(value2) {
    this._storage.setItem(DEFAULT_JSON_RPC_URL, value2);
  }
  updateProviderInfo(jsonRpcUrl, chainId) {
    var _a4;
    this.jsonRpcUrl = jsonRpcUrl;
    const originalChainId = this.getChainId();
    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
    const chainChanged = ensureIntNumber(chainId) !== originalChainId;
    if (chainChanged) {
      (_a4 = this.callback) === null || _a4 === void 0 ? void 0 : _a4.call(this, "chainChanged", hexStringFromNumber(chainId));
    }
  }
  async watchAsset(params) {
    const request = Array.isArray(params) ? params[0] : params;
    if (!request.type) {
      throw standardErrors.rpc.invalidParams("Type is required");
    }
    if ((request === null || request === void 0 ? void 0 : request.type) !== "ERC20") {
      throw standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);
    }
    if (!(request === null || request === void 0 ? void 0 : request.options)) {
      throw standardErrors.rpc.invalidParams("Options are required");
    }
    if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
      throw standardErrors.rpc.invalidParams("Address is required");
    }
    const chainId = this.getChainId();
    const { address, symbol, image, decimals } = request.options;
    const relay = this.initializeRelay();
    const result = await relay.watchAsset(request.type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString());
    if (isErrorResponse(result))
      return false;
    return !!result.result;
  }
  async addEthereumChain(params) {
    var _a4, _b;
    const request = params[0];
    if (((_a4 = request.rpcUrls) === null || _a4 === void 0 ? void 0 : _a4.length) === 0) {
      throw standardErrors.rpc.invalidParams("please pass in at least 1 rpcUrl");
    }
    if (!request.chainName || request.chainName.trim() === "") {
      throw standardErrors.rpc.invalidParams("chainName is a required field");
    }
    if (!request.nativeCurrency) {
      throw standardErrors.rpc.invalidParams("nativeCurrency is a required field");
    }
    const chainIdNumber = Number.parseInt(request.chainId, 16);
    if (chainIdNumber === this.getChainId()) {
      return false;
    }
    const relay = this.initializeRelay();
    const { rpcUrls = [], blockExplorerUrls = [], chainName, iconUrls = [], nativeCurrency } = request;
    const res = await relay.addEthereumChain(chainIdNumber.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency);
    if (isErrorResponse(res))
      return false;
    if (((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true) {
      this.updateProviderInfo(rpcUrls[0], chainIdNumber);
      return null;
    }
    throw standardErrors.rpc.internal("unable to add ethereum chain");
  }
  async switchEthereumChain(params) {
    const request = params[0];
    const chainId = Number.parseInt(request.chainId, 16);
    const relay = this.initializeRelay();
    const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0);
    if (isErrorResponse(res))
      throw res;
    const switchResponse = res.result;
    if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
      this.updateProviderInfo(switchResponse.rpcUrl, chainId);
    }
    return null;
  }
  async cleanup() {
    this.callback = null;
    if (this._relay) {
      this._relay.resetAndReload();
    }
    this._storage.clear();
  }
  _setAddresses(addresses, _4) {
    var _a4;
    if (!Array.isArray(addresses)) {
      throw new Error("addresses is not an array");
    }
    const newAddresses = addresses.map((address) => ensureAddressString(address));
    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
      return;
    }
    this._addresses = newAddresses;
    (_a4 = this.callback) === null || _a4 === void 0 ? void 0 : _a4.call(this, "accountsChanged", newAddresses);
    this._storage.setItem(LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
  }
  async request(request) {
    const params = request.params || [];
    switch (request.method) {
      case "eth_accounts":
        return [...this._addresses];
      case "eth_coinbase":
        return this.selectedAddress || null;
      case "net_version":
        return this.getChainId().toString(10);
      case "eth_chainId":
        return hexStringFromNumber(this.getChainId());
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_ecRecover":
      case "personal_ecRecover":
        return this.ecRecover(request);
      case "personal_sign":
        return this.personalSign(request);
      case "eth_signTransaction":
        return this._eth_signTransaction(params);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(params);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(params);
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this.signTypedData(request);
      case "wallet_addEthereumChain":
        return this.addEthereumChain(params);
      case "wallet_switchEthereumChain":
        return this.switchEthereumChain(params);
      case "wallet_watchAsset":
        return this.watchAsset(params);
      default:
        if (!this.jsonRpcUrl)
          throw standardErrors.rpc.internal("No RPC URL set for chain");
        return fetchRPCRequest(request, this.jsonRpcUrl);
    }
  }
  _ensureKnownAddress(addressString) {
    const addressStr = ensureAddressString(addressString);
    const lowercaseAddresses = this._addresses.map((address) => ensureAddressString(address));
    if (!lowercaseAddresses.includes(addressStr)) {
      throw new Error("Unknown Ethereum address");
    }
  }
  _prepareTransactionParams(tx) {
    const fromAddress = tx.from ? ensureAddressString(tx.from) : this.selectedAddress;
    if (!fromAddress) {
      throw new Error("Ethereum address is unavailable");
    }
    this._ensureKnownAddress(fromAddress);
    const toAddress = tx.to ? ensureAddressString(tx.to) : null;
    const weiValue = tx.value != null ? ensureBigInt(tx.value) : BigInt(0);
    const data = tx.data ? ensureBuffer(tx.data) : Buffer.alloc(0);
    const nonce = tx.nonce != null ? ensureIntNumber(tx.nonce) : null;
    const gasPriceInWei = tx.gasPrice != null ? ensureBigInt(tx.gasPrice) : null;
    const maxFeePerGas = tx.maxFeePerGas != null ? ensureBigInt(tx.maxFeePerGas) : null;
    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? ensureBigInt(tx.maxPriorityFeePerGas) : null;
    const gasLimit = tx.gas != null ? ensureBigInt(tx.gas) : null;
    const chainId = tx.chainId ? ensureIntNumber(tx.chainId) : this.getChainId();
    return {
      fromAddress,
      toAddress,
      weiValue,
      data,
      nonce,
      gasPriceInWei,
      maxFeePerGas,
      maxPriorityFeePerGas,
      gasLimit,
      chainId
    };
  }
  async ecRecover(request) {
    const { method, params } = request;
    if (!Array.isArray(params))
      throw standardErrors.rpc.invalidParams();
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: encodeToHexString(params[0]),
        signature: encodeToHexString(params[1]),
        addPrefix: method === "personal_ecRecover"
      }
    });
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  getChainId() {
    var _a4;
    return Number.parseInt((_a4 = this._storage.getItem(DEFAULT_CHAIN_ID_KEY)) !== null && _a4 !== void 0 ? _a4 : "1", 10);
  }
  async _eth_requestAccounts() {
    var _a4, _b;
    if (this._addresses.length > 0) {
      (_a4 = this.callback) === null || _a4 === void 0 ? void 0 : _a4.call(this, "connect", { chainId: hexStringFromNumber(this.getChainId()) });
      return this._addresses;
    }
    const relay = this.initializeRelay();
    const res = await relay.requestEthereumAccounts();
    if (isErrorResponse(res))
      throw res;
    if (!res.result) {
      throw new Error("accounts received is empty");
    }
    this._setAddresses(res.result);
    (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, "connect", { chainId: hexStringFromNumber(this.getChainId()) });
    return this._addresses;
  }
  async personalSign({ params }) {
    if (!Array.isArray(params))
      throw standardErrors.rpc.invalidParams();
    const address = params[1];
    const rawData = params[0];
    this._ensureKnownAddress(address);
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ensureAddressString(address),
        message: encodeToHexString(rawData),
        addPrefix: true,
        typedDataJson: null
      }
    });
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async _eth_signTransaction(params) {
    const tx = this._prepareTransactionParams(params[0] || {});
    const relay = this.initializeRelay();
    const res = await relay.signEthereumTransaction(tx);
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async _eth_sendRawTransaction(params) {
    const signedTransaction = ensureBuffer(params[0]);
    const relay = this.initializeRelay();
    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId());
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async _eth_sendTransaction(params) {
    const tx = this._prepareTransactionParams(params[0] || {});
    const relay = this.initializeRelay();
    const res = await relay.signAndSubmitEthereumTransaction(tx);
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async signTypedData(request) {
    const { method, params } = request;
    if (!Array.isArray(params))
      throw standardErrors.rpc.invalidParams();
    const encode12 = (input) => {
      const hashFuncMap = {
        eth_signTypedData_v1: import_eth_eip712_util.default.hashForSignTypedDataLegacy,
        eth_signTypedData_v3: import_eth_eip712_util.default.hashForSignTypedData_v3,
        eth_signTypedData_v4: import_eth_eip712_util.default.hashForSignTypedData_v4,
        eth_signTypedData: import_eth_eip712_util.default.hashForSignTypedData_v4
      };
      return hexStringFromBuffer(hashFuncMap[method]({
        data: ensureParsedJSONObject(input)
      }), true);
    };
    const address = params[method === "eth_signTypedData_v1" ? 1 : 0];
    const rawData = params[method === "eth_signTypedData_v1" ? 0 : 1];
    this._ensureKnownAddress(address);
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ensureAddressString(address),
        message: encode12(rawData),
        typedDataJson: JSON.stringify(rawData, null, 2),
        addPrefix: false
      }
    });
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  initializeRelay() {
    if (!this._relay) {
      this._relay = new WalletLinkRelay({
        linkAPIUrl: WALLETLINK_URL,
        storage: this._storage,
        metadata: this.metadata,
        accountsCallback: this._setAddresses.bind(this),
        chainCallback: this.updateProviderInfo.bind(this)
      });
    }
    return this._relay;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/util.js
var SIGNER_TYPE_KEY = "SignerType";
var storage = new ScopedLocalStorage("CBWSDK", "SignerConfigurator");
function loadSignerType() {
  return storage.getItem(SIGNER_TYPE_KEY);
}
function storeSignerType(signerType) {
  storage.setItem(SIGNER_TYPE_KEY, signerType);
}
async function fetchSignerType(params) {
  const { communicator, metadata, handshakeRequest, callback } = params;
  listenForWalletLinkSessionRequest(communicator, metadata, callback).catch(() => {
  });
  const request = {
    id: crypto.randomUUID(),
    event: "selectSignerType",
    data: Object.assign(Object.assign({}, params.preference), { handshakeRequest })
  };
  const { data } = await communicator.postRequestAndWaitForResponse(request);
  return data;
}
function createSigner(params) {
  const { signerType, metadata, communicator, callback } = params;
  switch (signerType) {
    case "scw": {
      return new SCWSigner({
        metadata,
        callback,
        communicator
      });
    }
    case "walletlink": {
      return new WalletLinkSigner({
        metadata,
        callback
      });
    }
  }
}
async function listenForWalletLinkSessionRequest(communicator, metadata, callback) {
  await communicator.onMessage(({ event }) => event === "WalletLinkSessionRequest");
  const walletlink = new WalletLinkSigner({
    metadata,
    callback
  });
  communicator.postMessage({
    event: "WalletLinkUpdate",
    data: { session: walletlink.getSession() }
  });
  await walletlink.handshake();
  communicator.postMessage({
    event: "WalletLinkUpdate",
    data: { connected: true }
  });
}

// node_modules/@coinbase/wallet-sdk/dist/util/checkCrossOriginOpenerPolicy.js
var COOP_ERROR_MESSAGE = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`;
var createCoopChecker = () => {
  let crossOriginOpenerPolicy;
  return {
    getCrossOriginOpenerPolicy: () => {
      if (crossOriginOpenerPolicy === void 0) {
        return "undefined";
      }
      return crossOriginOpenerPolicy;
    },
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window === "undefined") {
        crossOriginOpenerPolicy = "non-browser-env";
        return;
      }
      try {
        const url2 = `${window.location.origin}${window.location.pathname}`;
        const response = await fetch(url2, {
          method: "HEAD"
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = response.headers.get("Cross-Origin-Opener-Policy");
        crossOriginOpenerPolicy = result !== null && result !== void 0 ? result : "null";
        if (crossOriginOpenerPolicy === "same-origin") {
          console.error(COOP_ERROR_MESSAGE);
        }
      } catch (error) {
        console.error("Error checking Cross-Origin-Opener-Policy:", error.message);
        crossOriginOpenerPolicy = "error";
      }
    }
  };
};
var { checkCrossOriginOpenerPolicy, getCrossOriginOpenerPolicy } = createCoopChecker();

// node_modules/@coinbase/wallet-sdk/dist/util/web.js
var POPUP_WIDTH = 420;
var POPUP_HEIGHT = 540;
var RETRY_BUTTON = {
  isRed: false,
  info: "Retry",
  svgWidth: "10",
  svgHeight: "11",
  path: RETRY_SVG_PATH,
  defaultFillRule: "evenodd",
  defaultClipRule: "evenodd"
};
var POPUP_BLOCKED_MESSAGE = "Popup was blocked. Try again.";
var snackbar = null;
function openPopup(url2) {
  const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;
  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;
  appendAppInfoQueryParams(url2);
  function tryOpenPopup() {
    const popupId = `wallet_${crypto.randomUUID()}`;
    const popup2 = window.open(url2, popupId, `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`);
    popup2 === null || popup2 === void 0 ? void 0 : popup2.focus();
    if (!popup2) {
      return null;
    }
    return popup2;
  }
  let popup = tryOpenPopup();
  if (!popup) {
    const sb = initSnackbar();
    return new Promise((resolve, reject) => {
      sb.presentItem({
        autoExpand: true,
        message: POPUP_BLOCKED_MESSAGE,
        menuItems: [
          Object.assign(Object.assign({}, RETRY_BUTTON), { onClick: () => {
            popup = tryOpenPopup();
            if (popup) {
              resolve(popup);
            } else {
              reject(standardErrors.rpc.internal("Popup window was blocked"));
            }
            sb.clear();
          } })
        ]
      });
    });
  }
  return Promise.resolve(popup);
}
function closePopup(popup) {
  if (popup && !popup.closed) {
    popup.close();
  }
}
function appendAppInfoQueryParams(url2) {
  const params = {
    sdkName: NAME,
    sdkVersion: VERSION,
    origin: window.location.origin,
    coop: getCrossOriginOpenerPolicy()
  };
  for (const [key, value2] of Object.entries(params)) {
    url2.searchParams.append(key, value2.toString());
  }
}
function initSnackbar() {
  if (!snackbar) {
    const root = document.createElement("div");
    root.className = "-cbwsdk-css-reset";
    document.body.appendChild(root);
    snackbar = new Snackbar();
    snackbar.attach(root);
  }
  return snackbar;
}

// node_modules/@coinbase/wallet-sdk/dist/core/communicator/Communicator.js
var Communicator = class {
  constructor({ url: url2 = CB_KEYS_URL, metadata, preference }) {
    this.popup = null;
    this.listeners = /* @__PURE__ */ new Map();
    this.postMessage = async (message) => {
      const popup = await this.waitForPopupLoaded();
      popup.postMessage(message, this.url.origin);
    };
    this.postRequestAndWaitForResponse = async (request) => {
      const responsePromise = this.onMessage(({ requestId }) => requestId === request.id);
      this.postMessage(request);
      return await responsePromise;
    };
    this.onMessage = async (predicate) => {
      return new Promise((resolve, reject) => {
        const listener = (event) => {
          if (event.origin !== this.url.origin)
            return;
          const message = event.data;
          if (predicate(message)) {
            resolve(message);
            window.removeEventListener("message", listener);
            this.listeners.delete(listener);
          }
        };
        window.addEventListener("message", listener);
        this.listeners.set(listener, { reject });
      });
    };
    this.disconnect = () => {
      closePopup(this.popup);
      this.popup = null;
      this.listeners.forEach(({ reject }, listener) => {
        reject(standardErrors.provider.userRejectedRequest("Request rejected"));
        window.removeEventListener("message", listener);
      });
      this.listeners.clear();
    };
    this.waitForPopupLoaded = async () => {
      if (this.popup && !this.popup.closed) {
        this.popup.focus();
        return this.popup;
      }
      this.popup = await openPopup(this.url);
      this.onMessage(({ event }) => event === "PopupUnload").then(this.disconnect).catch(() => {
      });
      return this.onMessage(({ event }) => event === "PopupLoaded").then((message) => {
        this.postMessage({
          requestId: message.id,
          data: {
            version: VERSION,
            metadata: this.metadata,
            preference: this.preference,
            location: window.location.toString()
          }
        });
      }).then(() => {
        if (!this.popup)
          throw standardErrors.rpc.internal();
        return this.popup;
      });
    };
    this.url = new URL(url2);
    this.metadata = metadata;
    this.preference = preference;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/serialize.js
function serializeError(error) {
  const serialized = serialize(getErrorObject(error), {
    shouldIncludeStack: true
  });
  const docUrl = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  docUrl.searchParams.set("version", VERSION);
  docUrl.searchParams.set("code", serialized.code.toString());
  docUrl.searchParams.set("message", serialized.message);
  return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });
}
function getErrorObject(error) {
  var _a4;
  if (typeof error === "string") {
    return {
      message: error,
      code: standardErrorCodes.rpc.internal
    };
  } else if (isErrorResponse(error)) {
    const message = error.errorMessage;
    const code = (_a4 = error.errorCode) !== null && _a4 !== void 0 ? _a4 : message.match(/(denied|rejected)/i) ? standardErrorCodes.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, error), {
      message,
      code,
      data: { method: error.method }
    });
  }
  return error;
}

// node_modules/@coinbase/wallet-sdk/dist/core/provider/interface.js
var ProviderEventEmitter = class extends import_index.default {
};

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletProvider.js
var __rest2 = function(s3, e9) {
  var t4 = {};
  for (var p7 in s3) if (Object.prototype.hasOwnProperty.call(s3, p7) && e9.indexOf(p7) < 0)
    t4[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p7 = Object.getOwnPropertySymbols(s3); i6 < p7.length; i6++) {
      if (e9.indexOf(p7[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i6]))
        t4[p7[i6]] = s3[p7[i6]];
    }
  return t4;
};
var CoinbaseWalletProvider = class extends ProviderEventEmitter {
  constructor(_a4) {
    var { metadata } = _a4, _b = _a4.preference, { keysUrl } = _b, preference = __rest2(_b, ["keysUrl"]);
    super();
    this.signer = null;
    this.isCoinbaseWallet = true;
    this.metadata = metadata;
    this.preference = preference;
    this.communicator = new Communicator({
      url: keysUrl,
      metadata,
      preference
    });
    const signerType = loadSignerType();
    if (signerType) {
      this.signer = this.initSigner(signerType);
    }
  }
  async request(args) {
    try {
      checkErrorForInvalidRequestArgs(args);
      if (!this.signer) {
        switch (args.method) {
          case "eth_requestAccounts": {
            const signerType = await this.requestSignerSelection(args);
            const signer = this.initSigner(signerType);
            await signer.handshake(args);
            this.signer = signer;
            storeSignerType(signerType);
            break;
          }
          case "wallet_sendCalls": {
            const ephemeralSigner = this.initSigner("scw");
            await ephemeralSigner.handshake({ method: "handshake" });
            const result = await ephemeralSigner.request(args);
            await ephemeralSigner.cleanup();
            return result;
          }
          case "wallet_getCallsStatus":
            return fetchRPCRequest(args, CB_WALLET_RPC_URL);
          case "net_version":
            return 1;
          // default value
          case "eth_chainId":
            return hexStringFromNumber(1);
          // default value
          default: {
            throw standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
          }
        }
      }
      return await this.signer.request(args);
    } catch (error) {
      const { code } = error;
      if (code === standardErrorCodes.provider.unauthorized)
        this.disconnect();
      return Promise.reject(serializeError(error));
    }
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    console.warn(`.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.`);
    return await this.request({
      method: "eth_requestAccounts"
    });
  }
  async disconnect() {
    var _a4;
    await ((_a4 = this.signer) === null || _a4 === void 0 ? void 0 : _a4.cleanup());
    this.signer = null;
    ScopedLocalStorage.clearAll();
    this.emit("disconnect", standardErrors.provider.disconnected("User initiated disconnection"));
  }
  requestSignerSelection(handshakeRequest) {
    return fetchSignerType({
      communicator: this.communicator,
      preference: this.preference,
      metadata: this.metadata,
      handshakeRequest,
      callback: this.emit.bind(this)
    });
  }
  initSigner(signerType) {
    return createSigner({
      signerType,
      metadata: this.metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
};

// node_modules/@coinbase/wallet-sdk/dist/util/validatePreferences.js
function validatePreferences(preference) {
  if (!preference) {
    return;
  }
  if (!["all", "smartWalletOnly", "eoaOnly"].includes(preference.options)) {
    throw new Error(`Invalid options: ${preference.options}`);
  }
  if (preference.attribution) {
    if (preference.attribution.auto !== void 0 && preference.attribution.dataSuffix !== void 0) {
      throw new Error(`Attribution cannot contain both auto and dataSuffix properties`);
    }
  }
}

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
var CoinbaseWalletSDK = class {
  constructor(metadata) {
    this.metadata = {
      appName: metadata.appName || "Dapp",
      appLogoUrl: metadata.appLogoUrl || getFavicon(),
      appChainIds: metadata.appChainIds || []
    };
    this.storeLatestVersion();
    void checkCrossOriginOpenerPolicy();
  }
  makeWeb3Provider(preference = { options: "all" }) {
    var _a4;
    validatePreferences(preference);
    const params = { metadata: this.metadata, preference };
    return (_a4 = getCoinbaseInjectedProvider(params)) !== null && _a4 !== void 0 ? _a4 : new CoinbaseWalletProvider(params);
  }
  /**
   * Official Coinbase Wallet logo for developers to use on their frontend
   * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
   * @param width Width of the logo (Optional)
   * @returns SVG Data URI
   */
  getCoinbaseWalletLogo(type, width = 240) {
    return walletLogo(type, width);
  }
  storeLatestVersion() {
    const versionStorage = new ScopedLocalStorage("CBWSDK");
    versionStorage.setItem("VERSION", VERSION);
  }
};

// node_modules/@dynamic-labs/ethereum/src/coinbase/helpers.js
var coinbaseProvider;
var baseSepolia = 84532;
var baseMainnet = 8453;
var getCoinbaseProvider = ({ appLogoUrl, appName, evmNetworks, walletPreference } = {}) => {
  const appChainIds = evmNetworks === null || evmNetworks === void 0 ? void 0 : evmNetworks.map((network) => Number(network.chainId));
  const hasBaseSepolia = evmNetworks === null || evmNetworks === void 0 ? void 0 : evmNetworks.some((network) => network.chainId === baseSepolia);
  if (hasBaseSepolia) {
    appChainIds === null || appChainIds === void 0 ? void 0 : appChainIds.sort((a4, b5) => a4 === baseSepolia ? -1 : b5 === baseSepolia ? 1 : 0);
  }
  const hasBaseMainnet = evmNetworks === null || evmNetworks === void 0 ? void 0 : evmNetworks.some((network) => network.chainId === baseMainnet);
  if (hasBaseMainnet) {
    appChainIds === null || appChainIds === void 0 ? void 0 : appChainIds.sort((a4, b5) => a4 === baseMainnet ? -1 : b5 === baseMainnet ? 1 : 0);
  }
  if (!coinbaseProvider) {
    const coinbaseSdk = new CoinbaseWalletSDK({
      appChainIds,
      appLogoUrl,
      appName
    });
    coinbaseProvider = coinbaseSdk.makeWeb3Provider({
      options: walletPreference !== null && walletPreference !== void 0 ? walletPreference : "all"
    });
  }
  return coinbaseProvider;
};

// node_modules/@dynamic-labs/ethereum/src/coinbase/coinbase.js
var Coinbase = class extends EthereumWalletConnector {
  constructor(_a4) {
    var { appName, appLogoUrl, evmNetworks, coinbaseWalletPreference } = _a4, props = __rest(_a4, ["appName", "appLogoUrl", "evmNetworks", "coinbaseWalletPreference"]);
    super(Object.assign({ evmNetworks }, props));
    this.name = "Coinbase";
    this.overrideKey = "coinbase";
    this.canConnectViaQrCode = false;
    this.canConnectViaCustodialService = !this.isInstalledOnBrowser();
    this.coinbaseProviderOpts = {
      appLogoUrl,
      appName,
      evmNetworks,
      walletPreference: coinbaseWalletPreference
    };
  }
  get coinbaseProvider() {
    return getCoinbaseProvider(this.coinbaseProviderOpts);
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const accounts = yield this.coinbaseProvider.request({
          method: "eth_accounts"
        });
        if (accounts[0]) {
          this.setActiveAccount(this.parseAddress(accounts[0]));
        }
        return accounts.map(this.parseAddress);
      } catch (error) {
        logger3.error("Error getting connected accounts", error);
        return [];
      }
    });
  }
  isInstalledOnBrowser() {
    var _a4, _b;
    return Boolean((_a4 = window === null || window === void 0 ? void 0 : window.coinbaseWalletExtension) === null || _a4 === void 0 ? void 0 : _a4.isCoinbaseWallet) || Boolean((_b = window === null || window === void 0 ? void 0 : window.ethereum) === null || _b === void 0 ? void 0 : _b.isCoinbaseWallet);
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a4;
      if (isMobile() && !this.isInstalledOnBrowser() && ((_a4 = this.metadata) === null || _a4 === void 0 ? void 0 : _a4.inAppBrowserUrl) && this.mobileExperience === "in-app-browser") {
        const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
        const { href } = PlatformService.getUrl();
        const deepLink = inAppBrowserCompiledTemplate({
          encodedDappURI: encodeURIComponent(href)
        });
        PlatformService.openURL(deepLink);
        return;
      }
      const [address] = yield this.coinbaseProvider.request({
        method: "eth_requestAccounts"
      });
      const parsedAddress = this.parseAddress(address);
      this.setActiveAccount(parsedAddress);
      return parsedAddress;
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      const [address] = yield this.coinbaseProvider.request({
        method: "eth_requestAccounts"
      });
      const parsedAddress = this.parseAddress(address);
      try {
        return yield this.coinbaseProvider.request({
          method: "personal_sign",
          params: [toHex(toBytes(messageToSign)), parsedAddress]
        });
      } catch (err) {
        logger3.error("Error signing message", err);
        return void 0;
      }
    });
  }
  setupEventListeners() {
    const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
    this.coinbaseProvider.on("accountsChanged", handleAccountChange);
    this.coinbaseProvider.on("chainChanged", handleChainChange);
    this.coinbaseProvider.on("disconnect", handleDisconnect);
    this.teardownEventListeners = () => {
      this.coinbaseProvider.removeListener("accountsChanged", handleAccountChange);
      this.coinbaseProvider.removeListener("chainChanged", handleChainChange);
      this.coinbaseProvider.removeListener("disconnect", handleDisconnect);
    };
  }
  getWalletClient(chainId) {
    return createWalletClient({
      account: this.getActiveAccount(),
      chain: chainId ? chainsMap[chainId] : this.getActiveChain(),
      transport: custom(this.coinbaseProvider, this.providersConfig.httpTransportConfig)
    });
  }
};

// node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_debug = __toESM(require_browser());
var import_sdk_analytics = __toESM(require_dist());
var import_eventemitter2 = __toESM(require_eventemitter2());

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/validate.js
function validate10(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate10;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i6 = 0; i6 < 256; ++i6) {
  byteToHex.push((i6 + 256).toString(16).substr(1));
}
var i6;
function stringify7(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify7;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v7;
  var arr = new Uint8Array(16);
  arr[0] = (v7 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v7 >>> 16 & 255;
  arr[2] = v7 >>> 8 & 255;
  arr[3] = v7 & 255;
  arr[4] = (v7 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v7 & 255;
  arr[6] = (v7 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v7 & 255;
  arr[8] = (v7 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v7 & 255;
  arr[10] = (v7 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v7 / 4294967296 & 255;
  arr[12] = v7 >>> 24 & 255;
  arr[13] = v7 >>> 16 & 255;
  arr[14] = v7 >>> 8 & 255;
  arr[15] = v7 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes4(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i6 = 0; i6 < str.length; ++i6) {
    bytes.push(str.charCodeAt(i6));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version4, hashfunc) {
  function generateUUID(value2, namespace, buf, offset) {
    if (typeof value2 === "string") {
      value2 = stringToBytes4(value2);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value2.length);
    bytes.set(namespace);
    bytes.set(value2, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version4;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i6 = 0; i6 < 16; ++i6) {
        buf[offset + i6] = bytes[i6];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i6 = 0; i6 < msg.length; ++i6) {
      bytes[i6] = msg.charCodeAt(i6);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i6 = 0; i6 < length32; i6 += 8) {
    var x5 = input[i6 >> 5] >>> i6 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x5 >>> 4 & 15) + hexTab.charAt(x5 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x5, len) {
  x5[len >> 5] |= 128 << len % 32;
  x5[getOutputLength(len) - 1] = len;
  var a4 = 1732584193;
  var b5 = -271733879;
  var c6 = -1732584194;
  var d5 = 271733878;
  for (var i6 = 0; i6 < x5.length; i6 += 16) {
    var olda = a4;
    var oldb = b5;
    var oldc = c6;
    var oldd = d5;
    a4 = md5ff(a4, b5, c6, d5, x5[i6], 7, -680876936);
    d5 = md5ff(d5, a4, b5, c6, x5[i6 + 1], 12, -389564586);
    c6 = md5ff(c6, d5, a4, b5, x5[i6 + 2], 17, 606105819);
    b5 = md5ff(b5, c6, d5, a4, x5[i6 + 3], 22, -1044525330);
    a4 = md5ff(a4, b5, c6, d5, x5[i6 + 4], 7, -176418897);
    d5 = md5ff(d5, a4, b5, c6, x5[i6 + 5], 12, 1200080426);
    c6 = md5ff(c6, d5, a4, b5, x5[i6 + 6], 17, -1473231341);
    b5 = md5ff(b5, c6, d5, a4, x5[i6 + 7], 22, -45705983);
    a4 = md5ff(a4, b5, c6, d5, x5[i6 + 8], 7, 1770035416);
    d5 = md5ff(d5, a4, b5, c6, x5[i6 + 9], 12, -1958414417);
    c6 = md5ff(c6, d5, a4, b5, x5[i6 + 10], 17, -42063);
    b5 = md5ff(b5, c6, d5, a4, x5[i6 + 11], 22, -1990404162);
    a4 = md5ff(a4, b5, c6, d5, x5[i6 + 12], 7, 1804603682);
    d5 = md5ff(d5, a4, b5, c6, x5[i6 + 13], 12, -40341101);
    c6 = md5ff(c6, d5, a4, b5, x5[i6 + 14], 17, -1502002290);
    b5 = md5ff(b5, c6, d5, a4, x5[i6 + 15], 22, 1236535329);
    a4 = md5gg(a4, b5, c6, d5, x5[i6 + 1], 5, -165796510);
    d5 = md5gg(d5, a4, b5, c6, x5[i6 + 6], 9, -1069501632);
    c6 = md5gg(c6, d5, a4, b5, x5[i6 + 11], 14, 643717713);
    b5 = md5gg(b5, c6, d5, a4, x5[i6], 20, -373897302);
    a4 = md5gg(a4, b5, c6, d5, x5[i6 + 5], 5, -701558691);
    d5 = md5gg(d5, a4, b5, c6, x5[i6 + 10], 9, 38016083);
    c6 = md5gg(c6, d5, a4, b5, x5[i6 + 15], 14, -660478335);
    b5 = md5gg(b5, c6, d5, a4, x5[i6 + 4], 20, -405537848);
    a4 = md5gg(a4, b5, c6, d5, x5[i6 + 9], 5, 568446438);
    d5 = md5gg(d5, a4, b5, c6, x5[i6 + 14], 9, -1019803690);
    c6 = md5gg(c6, d5, a4, b5, x5[i6 + 3], 14, -187363961);
    b5 = md5gg(b5, c6, d5, a4, x5[i6 + 8], 20, 1163531501);
    a4 = md5gg(a4, b5, c6, d5, x5[i6 + 13], 5, -1444681467);
    d5 = md5gg(d5, a4, b5, c6, x5[i6 + 2], 9, -51403784);
    c6 = md5gg(c6, d5, a4, b5, x5[i6 + 7], 14, 1735328473);
    b5 = md5gg(b5, c6, d5, a4, x5[i6 + 12], 20, -1926607734);
    a4 = md5hh(a4, b5, c6, d5, x5[i6 + 5], 4, -378558);
    d5 = md5hh(d5, a4, b5, c6, x5[i6 + 8], 11, -2022574463);
    c6 = md5hh(c6, d5, a4, b5, x5[i6 + 11], 16, 1839030562);
    b5 = md5hh(b5, c6, d5, a4, x5[i6 + 14], 23, -35309556);
    a4 = md5hh(a4, b5, c6, d5, x5[i6 + 1], 4, -1530992060);
    d5 = md5hh(d5, a4, b5, c6, x5[i6 + 4], 11, 1272893353);
    c6 = md5hh(c6, d5, a4, b5, x5[i6 + 7], 16, -155497632);
    b5 = md5hh(b5, c6, d5, a4, x5[i6 + 10], 23, -1094730640);
    a4 = md5hh(a4, b5, c6, d5, x5[i6 + 13], 4, 681279174);
    d5 = md5hh(d5, a4, b5, c6, x5[i6], 11, -358537222);
    c6 = md5hh(c6, d5, a4, b5, x5[i6 + 3], 16, -722521979);
    b5 = md5hh(b5, c6, d5, a4, x5[i6 + 6], 23, 76029189);
    a4 = md5hh(a4, b5, c6, d5, x5[i6 + 9], 4, -640364487);
    d5 = md5hh(d5, a4, b5, c6, x5[i6 + 12], 11, -421815835);
    c6 = md5hh(c6, d5, a4, b5, x5[i6 + 15], 16, 530742520);
    b5 = md5hh(b5, c6, d5, a4, x5[i6 + 2], 23, -995338651);
    a4 = md5ii(a4, b5, c6, d5, x5[i6], 6, -198630844);
    d5 = md5ii(d5, a4, b5, c6, x5[i6 + 7], 10, 1126891415);
    c6 = md5ii(c6, d5, a4, b5, x5[i6 + 14], 15, -1416354905);
    b5 = md5ii(b5, c6, d5, a4, x5[i6 + 5], 21, -57434055);
    a4 = md5ii(a4, b5, c6, d5, x5[i6 + 12], 6, 1700485571);
    d5 = md5ii(d5, a4, b5, c6, x5[i6 + 3], 10, -1894986606);
    c6 = md5ii(c6, d5, a4, b5, x5[i6 + 10], 15, -1051523);
    b5 = md5ii(b5, c6, d5, a4, x5[i6 + 1], 21, -2054922799);
    a4 = md5ii(a4, b5, c6, d5, x5[i6 + 8], 6, 1873313359);
    d5 = md5ii(d5, a4, b5, c6, x5[i6 + 15], 10, -30611744);
    c6 = md5ii(c6, d5, a4, b5, x5[i6 + 6], 15, -1560198380);
    b5 = md5ii(b5, c6, d5, a4, x5[i6 + 13], 21, 1309151649);
    a4 = md5ii(a4, b5, c6, d5, x5[i6 + 4], 6, -145523070);
    d5 = md5ii(d5, a4, b5, c6, x5[i6 + 11], 10, -1120210379);
    c6 = md5ii(c6, d5, a4, b5, x5[i6 + 2], 15, 718787259);
    b5 = md5ii(b5, c6, d5, a4, x5[i6 + 9], 21, -343485551);
    a4 = safeAdd(a4, olda);
    b5 = safeAdd(b5, oldb);
    c6 = safeAdd(c6, oldc);
    d5 = safeAdd(d5, oldd);
  }
  return [a4, b5, c6, d5];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i6 = 0; i6 < length8; i6 += 8) {
    output[i6 >> 5] |= (input[i6 / 8] & 255) << i6 % 32;
  }
  return output;
}
function safeAdd(x5, y8) {
  var lsw = (x5 & 65535) + (y8 & 65535);
  var msw = (x5 >> 16) + (y8 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q5, a4, b5, x5, s3, t4) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a4, q5), safeAdd(x5, t4)), s3), b5);
}
function md5ff(a4, b5, c6, d5, x5, s3, t4) {
  return md5cmn(b5 & c6 | ~b5 & d5, a4, b5, x5, s3, t4);
}
function md5gg(a4, b5, c6, d5, x5, s3, t4) {
  return md5cmn(b5 & d5 | c6 & ~d5, a4, b5, x5, s3, t4);
}
function md5hh(a4, b5, c6, d5, x5, s3, t4) {
  return md5cmn(b5 ^ c6 ^ d5, a4, b5, x5, s3, t4);
}
function md5ii(a4, b5, c6, d5, x5, s3, t4) {
  return md5cmn(c6 ^ (b5 | ~d5), a4, b5, x5, s3, t4);
}
var md5_default = md5;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v3.js
var v32 = v35_default("v3", 48, md5_default);

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v4.js
function v42(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i6 = 0; i6 < 16; ++i6) {
      buf[offset + i6] = rnds[i6];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v42;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/sha1.js
function f10(s3, x5, y8, z6) {
  switch (s3) {
    case 0:
      return x5 & y8 ^ ~x5 & z6;
    case 1:
      return x5 ^ y8 ^ z6;
    case 2:
      return x5 & y8 ^ x5 & z6 ^ y8 & z6;
    case 3:
      return x5 ^ y8 ^ z6;
  }
}
function ROTL(x5, n4) {
  return x5 << n4 | x5 >>> 32 - n4;
}
function sha1(bytes) {
  var K4 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i6 = 0; i6 < msg.length; ++i6) {
      bytes.push(msg.charCodeAt(i6));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l6 = bytes.length / 4 + 2;
  var N8 = Math.ceil(l6 / 16);
  var M7 = new Array(N8);
  for (var _i6 = 0; _i6 < N8; ++_i6) {
    var arr = new Uint32Array(16);
    for (var j6 = 0; j6 < 16; ++j6) {
      arr[j6] = bytes[_i6 * 64 + j6 * 4] << 24 | bytes[_i6 * 64 + j6 * 4 + 1] << 16 | bytes[_i6 * 64 + j6 * 4 + 2] << 8 | bytes[_i6 * 64 + j6 * 4 + 3];
    }
    M7[_i6] = arr;
  }
  M7[N8 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M7[N8 - 1][14] = Math.floor(M7[N8 - 1][14]);
  M7[N8 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i22 = 0; _i22 < N8; ++_i22) {
    var W8 = new Uint32Array(80);
    for (var t4 = 0; t4 < 16; ++t4) {
      W8[t4] = M7[_i22][t4];
    }
    for (var _t6 = 16; _t6 < 80; ++_t6) {
      W8[_t6] = ROTL(W8[_t6 - 3] ^ W8[_t6 - 8] ^ W8[_t6 - 14] ^ W8[_t6 - 16], 1);
    }
    var a4 = H4[0];
    var b5 = H4[1];
    var c6 = H4[2];
    var d5 = H4[3];
    var e9 = H4[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s3 = Math.floor(_t22 / 20);
      var T6 = ROTL(a4, 5) + f10(s3, b5, c6, d5) + e9 + K4[s3] + W8[_t22] >>> 0;
      e9 = d5;
      d5 = c6;
      c6 = ROTL(b5, 30) >>> 0;
      b5 = a4;
      a4 = T6;
    }
    H4[0] = H4[0] + a4 >>> 0;
    H4[1] = H4[1] + b5 >>> 0;
    H4[2] = H4[2] + c6 >>> 0;
    H4[3] = H4[3] + d5 >>> 0;
    H4[4] = H4[4] + e9 >>> 0;
  }
  return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
}
var sha1_default = sha1;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v5.js
var v52 = v35_default("v5", 80, sha1_default);

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i6 = 0; i6 < chars.length; i6++) {
  lookup[chars.charCodeAt(i6)] = i6;
}
var decode5 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i6, p7 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i6 = 0; i6 < len; i6 += 4) {
    encoded1 = lookup[base64.charCodeAt(i6)];
    encoded2 = lookup[base64.charCodeAt(i6 + 1)];
    encoded3 = lookup[base64.charCodeAt(i6 + 2)];
    encoded4 = lookup[base64.charCodeAt(i6 + 3)];
    bytes[p7++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p7++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p7++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode5(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i6) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i6] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i6 = 0; i6 < encodedPackets.length; i6++) {
    const decodedPacket = decodePacket(encodedPackets[i6], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size10) {
  if (chunks[0].length === size10) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size10);
  let j6 = 0;
  for (let i6 = 0; i6 < size10; i6++) {
    buffer[i6] = chunks[0][j6++];
    if (j6 === chunks[0].length) {
      chunks.shift();
      j6 = 0;
    }
  }
  if (chunks.length && j6 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j6);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n4 = view.getUint32(0);
          if (n4 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n4 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var protocol = 4;

// node_modules/@socket.io/component-emitter/lib/esm/index.js
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn6) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn6);
  return this;
};
Emitter.prototype.once = function(event, fn6) {
  function on7() {
    this.off(event, on7);
    fn6.apply(this, arguments);
  }
  on7.fn = fn6;
  this.on(event, on7);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn6) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i6 = 0; i6 < callbacks.length; i6++) {
    cb = callbacks[i6];
    if (cb === fn6 || cb.fn === fn6) {
      callbacks.splice(i6, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i6 = 1; i6 < arguments.length; i6++) {
    args[i6 - 1] = arguments[i6];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i6 = 0, len = callbacks.length; i6 < len; ++i6) {
      callbacks[i6].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globals.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
var defaultBinaryType = "arraybuffer";
function createCookieJar() {
}

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k8) => {
    if (obj.hasOwnProperty(k8)) {
      acc[k8] = obj[k8];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c6 = 0, length = 0;
  for (let i6 = 0, l6 = str.length; i6 < l6; i6++) {
    c6 = str.charCodeAt(i6);
    if (c6 < 128) {
      length += 1;
    } else if (c6 < 2048) {
      length += 2;
    } else if (c6 < 55296 || c6 >= 57344) {
      length += 3;
    } else {
      i6++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode11(obj) {
  let str = "";
  for (let i6 in obj) {
    if (obj.hasOwnProperty(i6)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i6) + "=" + encodeURIComponent(obj[i6]);
    }
  }
  return str;
}
function decode6(qs3) {
  let qry = {};
  let pairs = qs3.split("&");
  for (let i6 = 0, l6 = pairs.length; i6 < l6; i6++) {
    let pair = pairs[i6].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode11(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
};

// node_modules/engine.io-client/build/esm/transports/polling.js
var Polling = class extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      } else {
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
var hasCORS = value;

// node_modules/engine.io-client/build/esm/transports/polling-xhr.js
function empty() {
}
var BaseXHR = class extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn6) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn6);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request2 = class _Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a4;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i6 in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i6)) {
              xhr.setRequestHeader(i6, this._opts.extraHeaders[i6]);
            }
          }
        }
      } catch (e9) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e9) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e9) {
      }
      (_a4 = this._opts.cookieJar) === null || _a4 === void 0 ? void 0 : _a4.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a5;
        if (xhr.readyState === 3) {
          (_a5 = this._opts.cookieJar) === null || _a5 === void 0 ? void 0 : _a5.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e9) {
      this.setTimeoutFn(() => {
        this._onError(e9);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = _Request.requestsCount++;
      _Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e9) {
      }
    }
    if (typeof document !== "undefined") {
      delete _Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Request2.requestsCount = 0;
Request2.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i6 in Request2.requests) {
    if (Request2.requests.hasOwnProperty(i6)) {
      Request2.requests[i6].abort();
    }
  }
}
var hasXHR2 = (function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
})();
var XHR = class extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request2(newRequest, this.uri(), opts);
  }
};
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e9) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e9) {
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var BaseWS = class extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e9) => this.onError("websocket error", e9);
  }
  write(packets) {
    this.writable = false;
    for (let i6 = 0; i6 < packets.length; i6++) {
      const packet = packets[i6];
      const lastPacket = i6 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e9) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};
var WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var WS = class extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
};

// node_modules/engine.io-client/build/esm/transports/webtransport.js
var WT = class extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i6 = 0; i6 < packets.length; i6++) {
      const packet = packets[i6];
      const lastPacket = i6 === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a4;
    (_a4 = this._transport) === null || _a4 === void 0 ? void 0 : _a4.close();
  }
};

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re3 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse2(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b5 = str.indexOf("["), e9 = str.indexOf("]");
  if (b5 != -1 && e9 != -1) {
    str = str.substring(0, b5) + str.substring(b5, e9).replace(/:/g, ";") + str.substring(e9, str.length);
  }
  let m5 = re3.exec(str || ""), uri = {}, i6 = 14;
  while (i6--) {
    uri[parts[i6]] = m5[i6] || "";
  }
  if (b5 != -1 && e9 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $22) {
    if ($1) {
      data[$1] = $22;
    }
  });
  return data;
}

// node_modules/engine.io-client/build/esm/socket.js
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
var SocketWithoutUpgrade = class _SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse2(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse2(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t4) => {
      const transportName = t4.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t4;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode6(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && _SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    _SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i6 = 0; i6 < this.writeBuffer.length; i6++) {
      const data = this.writeBuffer[i6].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i6 > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i6);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn6) {
    this._sendPacket("message", msg, options, fn6);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn6) {
    this._sendPacket("message", msg, options, fn6);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type, data, options, fn6) {
    if ("function" === typeof data) {
      fn6 = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn6 = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn6)
      this.once("flush", fn6);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    _SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i6 = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i6 !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i6, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
};
SocketWithoutUpgrade.protocol = protocol;
var SocketWithUpgrade = class extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i6 = 0; i6 < this._upgrades.length; i6++) {
        this._probe(this._upgrades[i6]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to6) {
      if (transport && to6.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i6 = 0; i6 < upgrades.length; i6++) {
      if (~this.transports.indexOf(upgrades[i6]))
        filteredUpgrades.push(upgrades[i6]);
    }
    return filteredUpgrades;
  }
};
var Socket = class extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o4 = typeof uri === "object" ? uri : opts;
    if (!o4.transports || o4.transports && typeof o4.transports[0] === "string") {
      o4.transports = (o4.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t4) => !!t4);
    }
    super(uri, o4);
  }
};

// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse2(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Decoder: () => Decoder2,
  Encoder: () => Encoder2,
  PacketType: () => PacketType,
  protocol: () => protocol3
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString7 = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString7.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString7.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i6 = 0, l6 = obj.length; i6 < l6; i6++) {
      if (hasBinary(obj[i6])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i6 = 0; i6 < data.length; i6++) {
      newData[i6] = _deconstructPacket(data[i6], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i6 = 0; i6 < data.length; i6++) {
      data[i6] = _reconstructPacket(data[i6], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

// node_modules/socket.io-parser/build/esm/index.js
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder2 = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
};
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
var Decoder2 = class _Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i6 = 0;
    const p7 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p7.type] === void 0) {
      throw new Error("unknown packet type " + p7.type);
    }
    if (p7.type === PacketType.BINARY_EVENT || p7.type === PacketType.BINARY_ACK) {
      const start = i6 + 1;
      while (str.charAt(++i6) !== "-" && i6 != str.length) {
      }
      const buf = str.substring(start, i6);
      if (buf != Number(buf) || str.charAt(i6) !== "-") {
        throw new Error("Illegal attachments");
      }
      p7.attachments = Number(buf);
    }
    if ("/" === str.charAt(i6 + 1)) {
      const start = i6 + 1;
      while (++i6) {
        const c6 = str.charAt(i6);
        if ("," === c6)
          break;
        if (i6 === str.length)
          break;
      }
      p7.nsp = str.substring(start, i6);
    } else {
      p7.nsp = "/";
    }
    const next = str.charAt(i6 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i6 + 1;
      while (++i6) {
        const c6 = str.charAt(i6);
        if (null == c6 || Number(c6) != c6) {
          --i6;
          break;
        }
        if (i6 === str.length)
          break;
      }
      p7.id = Number(str.substring(start, i6 + 1));
    }
    if (str.charAt(++i6)) {
      const payload = this.tryParse(str.substr(i6));
      if (_Decoder.isPayloadValid(p7.type, payload)) {
        p7.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p7;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e9) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// node_modules/socket.io-client/build/esm/on.js
function on5(obj, ev, fn6) {
  obj.on(ev, fn6);
  return function subDestroy() {
    obj.off(ev, fn6);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io6, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io6;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io6 = this.io;
    this.subs = [
      on5(io6, "open", this.onopen.bind(this)),
      on5(io6, "packet", this.onpacket.bind(this)),
      on5(io6, "error", this.onerror.bind(this)),
      on5(io6, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a4, _b, _c5;
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id2 = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id2, ack);
      packet.id = id2;
    }
    const isTransportWritable = (_b = (_a4 = this.io.engine) === null || _a4 === void 0 ? void 0 : _a4.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c5 = this.io.engine) === null || _c5 === void 0 ? void 0 : _c5._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) {
    } else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id2, ack) {
    var _a4;
    const timeout = (_a4 = this.flags.timeout) !== null && _a4 !== void 0 ? _a4 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id2] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id2];
      for (let i6 = 0; i6 < this.sendBuffer.length; i6++) {
        if (this.sendBuffer[i6].id === id2) {
          this.sendBuffer.splice(i6, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn6 = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn6.withError = true;
    this.acks[id2] = fn6;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn6 = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn6.withError = true;
      args.push(fn6);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id2) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id2);
      if (!isBuffered) {
        const ack = this.acks[id2];
        delete this.acks[id2];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id2) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id: id2,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id2, pid) {
    this.id = id2;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i6 = 0; i6 < listeners.length; i6++) {
        if (listener === listeners[i6]) {
          listeners.splice(i6, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i6 = 0; i6 < listeners.length; i6++) {
        if (listener === listeners[i6]) {
          listeners.splice(i6, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms3 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms3);
    ms3 = (Math.floor(rand * 10) & 1) == 0 ? ms3 - deviation : ms3 + deviation;
  }
  return Math.min(ms3, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a4;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a4 = opts.randomizationFactor) !== null && _a4 !== void 0 ? _a4 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v7) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v7;
    if (!v7) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v7) {
    if (v7 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v7;
    return this;
  }
  reconnectionDelay(v7) {
    var _a4;
    if (v7 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v7;
    (_a4 = this.backoff) === null || _a4 === void 0 ? void 0 : _a4.setMin(v7);
    return this;
  }
  randomizationFactor(v7) {
    var _a4;
    if (v7 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v7;
    (_a4 = this.backoff) === null || _a4 === void 0 ? void 0 : _a4.setJitter(v7);
    return this;
  }
  reconnectionDelayMax(v7) {
    var _a4;
    if (v7 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v7;
    (_a4 = this.backoff) === null || _a4 === void 0 ? void 0 : _a4.setMax(v7);
    return this;
  }
  timeout(v7) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v7;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn6) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on5(socket, "open", function() {
      self2.onopen();
      fn6 && fn6();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn6) {
        fn6(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on5(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn6) {
    return this.open(fn6);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on5(socket, "ping", this.onping.bind(this)),
      on5(socket, "data", this.ondata.bind(this)),
      on5(socket, "error", this.onerror.bind(this)),
      on5(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on5(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e9) {
      this.onclose("parse error", e9);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i6 = 0; i6 < encodedPackets.length; i6++) {
      this.engine.write(encodedPackets[i6], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a4;
    this.cleanup();
    (_a4 = this.engine) === null || _a4 === void 0 ? void 0 : _a4.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id2 = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id2] && path in cache[id2]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io6;
  if (newConnection) {
    io6 = new Manager(source, opts);
  } else {
    if (!cache[id2]) {
      cache[id2] = new Manager(source, opts);
    }
    io6 = cache[id2];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io6.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// import("./**/*.entry.js") in node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var globImport_entry_js = __glob({});

// node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
function c5(e9, t4, n4, r6) {
  return new (n4 || (n4 = Promise))((function(i6, o4) {
    function s3(e10) {
      try {
        c6(r6.next(e10));
      } catch (e11) {
        o4(e11);
      }
    }
    function a4(e10) {
      try {
        c6(r6.throw(e10));
      } catch (e11) {
        o4(e11);
      }
    }
    function c6(e10) {
      var t5;
      e10.done ? i6(e10.value) : (t5 = e10.value, t5 instanceof n4 ? t5 : new n4((function(e11) {
        e11(t5);
      }))).then(s3, a4);
    }
    c6((r6 = r6.apply(e9, t4 || [])).next());
  }));
}
var l5 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
var d4 = [];
var u5 = [];
var h6 = "undefined" != typeof Uint8Array ? Uint8Array : Array;
var f11 = false;
function p6() {
  f11 = true;
  for (var e9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t4 = 0; t4 < 64; ++t4) d4[t4] = e9[t4], u5[e9.charCodeAt(t4)] = t4;
  u5["-".charCodeAt(0)] = 62, u5["_".charCodeAt(0)] = 63;
}
function g2(e9, t4, n4) {
  for (var r6, i6, o4 = [], s3 = t4; s3 < n4; s3 += 3) r6 = (e9[s3] << 16) + (e9[s3 + 1] << 8) + e9[s3 + 2], o4.push(d4[(i6 = r6) >> 18 & 63] + d4[i6 >> 12 & 63] + d4[i6 >> 6 & 63] + d4[63 & i6]);
  return o4.join("");
}
function m4(e9) {
  var t4;
  f11 || p6();
  for (var n4 = e9.length, r6 = n4 % 3, i6 = "", o4 = [], s3 = 16383, a4 = 0, c6 = n4 - r6; a4 < c6; a4 += s3) o4.push(g2(e9, a4, a4 + s3 > c6 ? c6 : a4 + s3));
  return 1 === r6 ? (t4 = e9[n4 - 1], i6 += d4[t4 >> 2], i6 += d4[t4 << 4 & 63], i6 += "==") : 2 === r6 && (t4 = (e9[n4 - 2] << 8) + e9[n4 - 1], i6 += d4[t4 >> 10], i6 += d4[t4 >> 4 & 63], i6 += d4[t4 << 2 & 63], i6 += "="), o4.push(i6), o4.join("");
}
function y7(e9, t4, n4, r6, i6) {
  var o4, s3, a4 = 8 * i6 - r6 - 1, c6 = (1 << a4) - 1, l6 = c6 >> 1, d5 = -7, u6 = n4 ? i6 - 1 : 0, h7 = n4 ? -1 : 1, f12 = e9[t4 + u6];
  for (u6 += h7, o4 = f12 & (1 << -d5) - 1, f12 >>= -d5, d5 += a4; d5 > 0; o4 = 256 * o4 + e9[t4 + u6], u6 += h7, d5 -= 8) ;
  for (s3 = o4 & (1 << -d5) - 1, o4 >>= -d5, d5 += r6; d5 > 0; s3 = 256 * s3 + e9[t4 + u6], u6 += h7, d5 -= 8) ;
  if (0 === o4) o4 = 1 - l6;
  else {
    if (o4 === c6) return s3 ? NaN : 1 / 0 * (f12 ? -1 : 1);
    s3 += Math.pow(2, r6), o4 -= l6;
  }
  return (f12 ? -1 : 1) * s3 * Math.pow(2, o4 - r6);
}
function v6(e9, t4, n4, r6, i6, o4) {
  var s3, a4, c6, l6 = 8 * o4 - i6 - 1, d5 = (1 << l6) - 1, u6 = d5 >> 1, h7 = 23 === i6 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f12 = r6 ? 0 : o4 - 1, p7 = r6 ? 1 : -1, g3 = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
  for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (a4 = isNaN(t4) ? 1 : 0, s3 = d5) : (s3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (c6 = Math.pow(2, -s3)) < 1 && (s3--, c6 *= 2), (t4 += s3 + u6 >= 1 ? h7 / c6 : h7 * Math.pow(2, 1 - u6)) * c6 >= 2 && (s3++, c6 /= 2), s3 + u6 >= d5 ? (a4 = 0, s3 = d5) : s3 + u6 >= 1 ? (a4 = (t4 * c6 - 1) * Math.pow(2, i6), s3 += u6) : (a4 = t4 * Math.pow(2, u6 - 1) * Math.pow(2, i6), s3 = 0)); i6 >= 8; e9[n4 + f12] = 255 & a4, f12 += p7, a4 /= 256, i6 -= 8) ;
  for (s3 = s3 << i6 | a4, l6 += i6; l6 > 0; e9[n4 + f12] = 255 & s3, f12 += p7, s3 /= 256, l6 -= 8) ;
  e9[n4 + f12 - p7] |= 128 * g3;
}
var b4 = {}.toString;
var w5 = Array.isArray || function(e9) {
  return "[object Array]" == b4.call(e9);
};
C7.TYPED_ARRAY_SUPPORT = void 0 === l5.TYPED_ARRAY_SUPPORT || l5.TYPED_ARRAY_SUPPORT;
var E6 = S6();
function S6() {
  return C7.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function _3(e9, t4) {
  if (S6() < t4) throw new RangeError("Invalid typed array length");
  return C7.TYPED_ARRAY_SUPPORT ? (e9 = new Uint8Array(t4)).__proto__ = C7.prototype : (null === e9 && (e9 = new C7(t4)), e9.length = t4), e9;
}
function C7(e9, t4, n4) {
  if (!(C7.TYPED_ARRAY_SUPPORT || this instanceof C7)) return new C7(e9, t4, n4);
  if ("number" == typeof e9) {
    if ("string" == typeof t4) throw new Error("If encoding is specified then the first argument must be a string");
    return x4(this, e9);
  }
  return k7(this, e9, t4, n4);
}
function k7(e9, t4, n4, r6) {
  if ("number" == typeof t4) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t4 instanceof ArrayBuffer ? (function(e10, t5, n5, r7) {
    if (t5.byteLength, n5 < 0 || t5.byteLength < n5) throw new RangeError("'offset' is out of bounds");
    if (t5.byteLength < n5 + (r7 || 0)) throw new RangeError("'length' is out of bounds");
    t5 = void 0 === n5 && void 0 === r7 ? new Uint8Array(t5) : void 0 === r7 ? new Uint8Array(t5, n5) : new Uint8Array(t5, n5, r7);
    C7.TYPED_ARRAY_SUPPORT ? (e10 = t5).__proto__ = C7.prototype : e10 = M6(e10, t5);
    return e10;
  })(e9, t4, n4, r6) : "string" == typeof t4 ? (function(e10, t5, n5) {
    "string" == typeof n5 && "" !== n5 || (n5 = "utf8");
    if (!C7.isEncoding(n5)) throw new TypeError('"encoding" must be a valid string encoding');
    var r7 = 0 | R5(t5, n5);
    e10 = _3(e10, r7);
    var i6 = e10.write(t5, n5);
    i6 !== r7 && (e10 = e10.slice(0, i6));
    return e10;
  })(e9, t4, n4) : (function(e10, t5) {
    if (T5(t5)) {
      var n5 = 0 | I6(t5.length);
      return 0 === (e10 = _3(e10, n5)).length || t5.copy(e10, 0, 0, n5), e10;
    }
    if (t5) {
      if ("undefined" != typeof ArrayBuffer && t5.buffer instanceof ArrayBuffer || "length" in t5) return "number" != typeof t5.length || (r7 = t5.length) != r7 ? _3(e10, 0) : M6(e10, t5);
      if ("Buffer" === t5.type && w5(t5.data)) return M6(e10, t5.data);
    }
    var r7;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  })(e9, t4);
}
function A7(e9) {
  if ("number" != typeof e9) throw new TypeError('"size" argument must be a number');
  if (e9 < 0) throw new RangeError('"size" argument must not be negative');
}
function x4(e9, t4) {
  if (A7(t4), e9 = _3(e9, t4 < 0 ? 0 : 0 | I6(t4)), !C7.TYPED_ARRAY_SUPPORT) for (var n4 = 0; n4 < t4; ++n4) e9[n4] = 0;
  return e9;
}
function M6(e9, t4) {
  var n4 = t4.length < 0 ? 0 : 0 | I6(t4.length);
  e9 = _3(e9, n4);
  for (var r6 = 0; r6 < n4; r6 += 1) e9[r6] = 255 & t4[r6];
  return e9;
}
function I6(e9) {
  if (e9 >= S6()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S6().toString(16) + " bytes");
  return 0 | e9;
}
function T5(e9) {
  return !(null == e9 || !e9._isBuffer);
}
function R5(e9, t4) {
  if (T5(e9)) return e9.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e9) || e9 instanceof ArrayBuffer)) return e9.byteLength;
  "string" != typeof e9 && (e9 = "" + e9);
  var n4 = e9.length;
  if (0 === n4) return 0;
  for (var r6 = false; ; ) switch (t4) {
    case "ascii":
    case "latin1":
    case "binary":
      return n4;
    case "utf8":
    case "utf-8":
    case void 0:
      return ie6(e9).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * n4;
    case "hex":
      return n4 >>> 1;
    case "base64":
      return oe2(e9).length;
    default:
      if (r6) return ie6(e9).length;
      t4 = ("" + t4).toLowerCase(), r6 = true;
  }
}
function P5(e9, t4, n4) {
  var r6 = false;
  if ((void 0 === t4 || t4 < 0) && (t4 = 0), t4 > this.length) return "";
  if ((void 0 === n4 || n4 > this.length) && (n4 = this.length), n4 <= 0) return "";
  if ((n4 >>>= 0) <= (t4 >>>= 0)) return "";
  for (e9 || (e9 = "utf8"); ; ) switch (e9) {
    case "hex":
      return V6(this, t4, n4);
    case "utf8":
    case "utf-8":
      return F7(this, t4, n4);
    case "ascii":
      return q4(this, t4, n4);
    case "latin1":
    case "binary":
      return W7(this, t4, n4);
    case "base64":
      return H3(this, t4, n4);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return G8(this, t4, n4);
    default:
      if (r6) throw new TypeError("Unknown encoding: " + e9);
      e9 = (e9 + "").toLowerCase(), r6 = true;
  }
}
function O5(e9, t4, n4) {
  var r6 = e9[t4];
  e9[t4] = e9[n4], e9[n4] = r6;
}
function N7(e9, t4, n4, r6, i6) {
  if (0 === e9.length) return -1;
  if ("string" == typeof n4 ? (r6 = n4, n4 = 0) : n4 > 2147483647 ? n4 = 2147483647 : n4 < -2147483648 && (n4 = -2147483648), n4 = +n4, isNaN(n4) && (n4 = i6 ? 0 : e9.length - 1), n4 < 0 && (n4 = e9.length + n4), n4 >= e9.length) {
    if (i6) return -1;
    n4 = e9.length - 1;
  } else if (n4 < 0) {
    if (!i6) return -1;
    n4 = 0;
  }
  if ("string" == typeof t4 && (t4 = C7.from(t4, r6)), T5(t4)) return 0 === t4.length ? -1 : L5(e9, t4, n4, r6, i6);
  if ("number" == typeof t4) return t4 &= 255, C7.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i6 ? Uint8Array.prototype.indexOf.call(e9, t4, n4) : Uint8Array.prototype.lastIndexOf.call(e9, t4, n4) : L5(e9, [t4], n4, r6, i6);
  throw new TypeError("val must be string, number or Buffer");
}
function L5(e9, t4, n4, r6, i6) {
  var o4, s3 = 1, a4 = e9.length, c6 = t4.length;
  if (void 0 !== r6 && ("ucs2" === (r6 = String(r6).toLowerCase()) || "ucs-2" === r6 || "utf16le" === r6 || "utf-16le" === r6)) {
    if (e9.length < 2 || t4.length < 2) return -1;
    s3 = 2, a4 /= 2, c6 /= 2, n4 /= 2;
  }
  function l6(e10, t5) {
    return 1 === s3 ? e10[t5] : e10.readUInt16BE(t5 * s3);
  }
  if (i6) {
    var d5 = -1;
    for (o4 = n4; o4 < a4; o4++) if (l6(e9, o4) === l6(t4, -1 === d5 ? 0 : o4 - d5)) {
      if (-1 === d5 && (d5 = o4), o4 - d5 + 1 === c6) return d5 * s3;
    } else -1 !== d5 && (o4 -= o4 - d5), d5 = -1;
  } else for (n4 + c6 > a4 && (n4 = a4 - c6), o4 = n4; o4 >= 0; o4--) {
    for (var u6 = true, h7 = 0; h7 < c6; h7++) if (l6(e9, o4 + h7) !== l6(t4, h7)) {
      u6 = false;
      break;
    }
    if (u6) return o4;
  }
  return -1;
}
function D8(e9, t4, n4, r6) {
  n4 = Number(n4) || 0;
  var i6 = e9.length - n4;
  r6 ? (r6 = Number(r6)) > i6 && (r6 = i6) : r6 = i6;
  var o4 = t4.length;
  if (o4 % 2 != 0) throw new TypeError("Invalid hex string");
  r6 > o4 / 2 && (r6 = o4 / 2);
  for (var s3 = 0; s3 < r6; ++s3) {
    var a4 = parseInt(t4.substr(2 * s3, 2), 16);
    if (isNaN(a4)) return s3;
    e9[n4 + s3] = a4;
  }
  return s3;
}
function $6(e9, t4, n4, r6) {
  return se6(ie6(t4, e9.length - n4), e9, n4, r6);
}
function B6(e9, t4, n4, r6) {
  return se6((function(e10) {
    for (var t5 = [], n5 = 0; n5 < e10.length; ++n5) t5.push(255 & e10.charCodeAt(n5));
    return t5;
  })(t4), e9, n4, r6);
}
function K3(e9, t4, n4, r6) {
  return B6(e9, t4, n4, r6);
}
function j5(e9, t4, n4, r6) {
  return se6(oe2(t4), e9, n4, r6);
}
function U5(e9, t4, n4, r6) {
  return se6((function(e10, t5) {
    for (var n5, r7, i6, o4 = [], s3 = 0; s3 < e10.length && !((t5 -= 2) < 0); ++s3) r7 = (n5 = e10.charCodeAt(s3)) >> 8, i6 = n5 % 256, o4.push(i6), o4.push(r7);
    return o4;
  })(t4, e9.length - n4), e9, n4, r6);
}
function H3(e9, t4, n4) {
  return 0 === t4 && n4 === e9.length ? m4(e9) : m4(e9.slice(t4, n4));
}
function F7(e9, t4, n4) {
  n4 = Math.min(e9.length, n4);
  for (var r6 = [], i6 = t4; i6 < n4; ) {
    var o4, s3, a4, c6, l6 = e9[i6], d5 = null, u6 = l6 > 239 ? 4 : l6 > 223 ? 3 : l6 > 191 ? 2 : 1;
    if (i6 + u6 <= n4) switch (u6) {
      case 1:
        l6 < 128 && (d5 = l6);
        break;
      case 2:
        128 == (192 & (o4 = e9[i6 + 1])) && (c6 = (31 & l6) << 6 | 63 & o4) > 127 && (d5 = c6);
        break;
      case 3:
        o4 = e9[i6 + 1], s3 = e9[i6 + 2], 128 == (192 & o4) && 128 == (192 & s3) && (c6 = (15 & l6) << 12 | (63 & o4) << 6 | 63 & s3) > 2047 && (c6 < 55296 || c6 > 57343) && (d5 = c6);
        break;
      case 4:
        o4 = e9[i6 + 1], s3 = e9[i6 + 2], a4 = e9[i6 + 3], 128 == (192 & o4) && 128 == (192 & s3) && 128 == (192 & a4) && (c6 = (15 & l6) << 18 | (63 & o4) << 12 | (63 & s3) << 6 | 63 & a4) > 65535 && c6 < 1114112 && (d5 = c6);
    }
    null === d5 ? (d5 = 65533, u6 = 1) : d5 > 65535 && (d5 -= 65536, r6.push(d5 >>> 10 & 1023 | 55296), d5 = 56320 | 1023 & d5), r6.push(d5), i6 += u6;
  }
  return (function(e10) {
    var t5 = e10.length;
    if (t5 <= z5) return String.fromCharCode.apply(String, e10);
    var n5 = "", r7 = 0;
    for (; r7 < t5; ) n5 += String.fromCharCode.apply(String, e10.slice(r7, r7 += z5));
    return n5;
  })(r6);
}
C7.poolSize = 8192, C7._augment = function(e9) {
  return e9.__proto__ = C7.prototype, e9;
}, C7.from = function(e9, t4, n4) {
  return k7(null, e9, t4, n4);
}, C7.TYPED_ARRAY_SUPPORT && (C7.prototype.__proto__ = Uint8Array.prototype, C7.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && C7[Symbol.species]), C7.alloc = function(e9, t4, n4) {
  return (function(e10, t5, n5, r6) {
    return A7(t5), t5 <= 0 ? _3(e10, t5) : void 0 !== n5 ? "string" == typeof r6 ? _3(e10, t5).fill(n5, r6) : _3(e10, t5).fill(n5) : _3(e10, t5);
  })(null, e9, t4, n4);
}, C7.allocUnsafe = function(e9) {
  return x4(null, e9);
}, C7.allocUnsafeSlow = function(e9) {
  return x4(null, e9);
}, C7.isBuffer = ae6, C7.compare = function(e9, t4) {
  if (!T5(e9) || !T5(t4)) throw new TypeError("Arguments must be Buffers");
  if (e9 === t4) return 0;
  for (var n4 = e9.length, r6 = t4.length, i6 = 0, o4 = Math.min(n4, r6); i6 < o4; ++i6) if (e9[i6] !== t4[i6]) {
    n4 = e9[i6], r6 = t4[i6];
    break;
  }
  return n4 < r6 ? -1 : r6 < n4 ? 1 : 0;
}, C7.isEncoding = function(e9) {
  switch (String(e9).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, C7.concat = function(e9, t4) {
  if (!w5(e9)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === e9.length) return C7.alloc(0);
  var n4;
  if (void 0 === t4) for (t4 = 0, n4 = 0; n4 < e9.length; ++n4) t4 += e9[n4].length;
  var r6 = C7.allocUnsafe(t4), i6 = 0;
  for (n4 = 0; n4 < e9.length; ++n4) {
    var o4 = e9[n4];
    if (!T5(o4)) throw new TypeError('"list" argument must be an Array of Buffers');
    o4.copy(r6, i6), i6 += o4.length;
  }
  return r6;
}, C7.byteLength = R5, C7.prototype._isBuffer = true, C7.prototype.swap16 = function() {
  var e9 = this.length;
  if (e9 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t4 = 0; t4 < e9; t4 += 2) O5(this, t4, t4 + 1);
  return this;
}, C7.prototype.swap32 = function() {
  var e9 = this.length;
  if (e9 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t4 = 0; t4 < e9; t4 += 4) O5(this, t4, t4 + 3), O5(this, t4 + 1, t4 + 2);
  return this;
}, C7.prototype.swap64 = function() {
  var e9 = this.length;
  if (e9 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t4 = 0; t4 < e9; t4 += 8) O5(this, t4, t4 + 7), O5(this, t4 + 1, t4 + 6), O5(this, t4 + 2, t4 + 5), O5(this, t4 + 3, t4 + 4);
  return this;
}, C7.prototype.toString = function() {
  var e9 = 0 | this.length;
  return 0 === e9 ? "" : 0 === arguments.length ? F7(this, 0, e9) : P5.apply(this, arguments);
}, C7.prototype.equals = function(e9) {
  if (!T5(e9)) throw new TypeError("Argument must be a Buffer");
  return this === e9 || 0 === C7.compare(this, e9);
}, C7.prototype.inspect = function() {
  var e9 = "";
  return this.length > 0 && (e9 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e9 += " ... ")), "<Buffer " + e9 + ">";
}, C7.prototype.compare = function(e9, t4, n4, r6, i6) {
  if (!T5(e9)) throw new TypeError("Argument must be a Buffer");
  if (void 0 === t4 && (t4 = 0), void 0 === n4 && (n4 = e9 ? e9.length : 0), void 0 === r6 && (r6 = 0), void 0 === i6 && (i6 = this.length), t4 < 0 || n4 > e9.length || r6 < 0 || i6 > this.length) throw new RangeError("out of range index");
  if (r6 >= i6 && t4 >= n4) return 0;
  if (r6 >= i6) return -1;
  if (t4 >= n4) return 1;
  if (this === e9) return 0;
  for (var o4 = (i6 >>>= 0) - (r6 >>>= 0), s3 = (n4 >>>= 0) - (t4 >>>= 0), a4 = Math.min(o4, s3), c6 = this.slice(r6, i6), l6 = e9.slice(t4, n4), d5 = 0; d5 < a4; ++d5) if (c6[d5] !== l6[d5]) {
    o4 = c6[d5], s3 = l6[d5];
    break;
  }
  return o4 < s3 ? -1 : s3 < o4 ? 1 : 0;
}, C7.prototype.includes = function(e9, t4, n4) {
  return -1 !== this.indexOf(e9, t4, n4);
}, C7.prototype.indexOf = function(e9, t4, n4) {
  return N7(this, e9, t4, n4, true);
}, C7.prototype.lastIndexOf = function(e9, t4, n4) {
  return N7(this, e9, t4, n4, false);
}, C7.prototype.write = function(e9, t4, n4, r6) {
  if (void 0 === t4) r6 = "utf8", n4 = this.length, t4 = 0;
  else if (void 0 === n4 && "string" == typeof t4) r6 = t4, n4 = this.length, t4 = 0;
  else {
    if (!isFinite(t4)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t4 |= 0, isFinite(n4) ? (n4 |= 0, void 0 === r6 && (r6 = "utf8")) : (r6 = n4, n4 = void 0);
  }
  var i6 = this.length - t4;
  if ((void 0 === n4 || n4 > i6) && (n4 = i6), e9.length > 0 && (n4 < 0 || t4 < 0) || t4 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  r6 || (r6 = "utf8");
  for (var o4 = false; ; ) switch (r6) {
    case "hex":
      return D8(this, e9, t4, n4);
    case "utf8":
    case "utf-8":
      return $6(this, e9, t4, n4);
    case "ascii":
      return B6(this, e9, t4, n4);
    case "latin1":
    case "binary":
      return K3(this, e9, t4, n4);
    case "base64":
      return j5(this, e9, t4, n4);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return U5(this, e9, t4, n4);
    default:
      if (o4) throw new TypeError("Unknown encoding: " + r6);
      r6 = ("" + r6).toLowerCase(), o4 = true;
  }
}, C7.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var z5 = 4096;
function q4(e9, t4, n4) {
  var r6 = "";
  n4 = Math.min(e9.length, n4);
  for (var i6 = t4; i6 < n4; ++i6) r6 += String.fromCharCode(127 & e9[i6]);
  return r6;
}
function W7(e9, t4, n4) {
  var r6 = "";
  n4 = Math.min(e9.length, n4);
  for (var i6 = t4; i6 < n4; ++i6) r6 += String.fromCharCode(e9[i6]);
  return r6;
}
function V6(e9, t4, n4) {
  var r6 = e9.length;
  (!t4 || t4 < 0) && (t4 = 0), (!n4 || n4 < 0 || n4 > r6) && (n4 = r6);
  for (var i6 = "", o4 = t4; o4 < n4; ++o4) i6 += re4(e9[o4]);
  return i6;
}
function G8(e9, t4, n4) {
  for (var r6 = e9.slice(t4, n4), i6 = "", o4 = 0; o4 < r6.length; o4 += 2) i6 += String.fromCharCode(r6[o4] + 256 * r6[o4 + 1]);
  return i6;
}
function Y6(e9, t4, n4) {
  if (e9 % 1 != 0 || e9 < 0) throw new RangeError("offset is not uint");
  if (e9 + t4 > n4) throw new RangeError("Trying to access beyond buffer length");
}
function Z4(e9, t4, n4, r6, i6, o4) {
  if (!T5(e9)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t4 > i6 || t4 < o4) throw new RangeError('"value" argument is out of bounds');
  if (n4 + r6 > e9.length) throw new RangeError("Index out of range");
}
function J4(e9, t4, n4, r6) {
  t4 < 0 && (t4 = 65535 + t4 + 1);
  for (var i6 = 0, o4 = Math.min(e9.length - n4, 2); i6 < o4; ++i6) e9[n4 + i6] = (t4 & 255 << 8 * (r6 ? i6 : 1 - i6)) >>> 8 * (r6 ? i6 : 1 - i6);
}
function Q7(e9, t4, n4, r6) {
  t4 < 0 && (t4 = 4294967295 + t4 + 1);
  for (var i6 = 0, o4 = Math.min(e9.length - n4, 4); i6 < o4; ++i6) e9[n4 + i6] = t4 >>> 8 * (r6 ? i6 : 3 - i6) & 255;
}
function X7(e9, t4, n4, r6, i6, o4) {
  if (n4 + r6 > e9.length) throw new RangeError("Index out of range");
  if (n4 < 0) throw new RangeError("Index out of range");
}
function ee4(e9, t4, n4, r6, i6) {
  return i6 || X7(e9, 0, n4, 4), v6(e9, t4, n4, r6, 23, 4), n4 + 4;
}
function te3(e9, t4, n4, r6, i6) {
  return i6 || X7(e9, 0, n4, 8), v6(e9, t4, n4, r6, 52, 8), n4 + 8;
}
C7.prototype.slice = function(e9, t4) {
  var n4, r6 = this.length;
  if ((e9 = ~~e9) < 0 ? (e9 += r6) < 0 && (e9 = 0) : e9 > r6 && (e9 = r6), (t4 = void 0 === t4 ? r6 : ~~t4) < 0 ? (t4 += r6) < 0 && (t4 = 0) : t4 > r6 && (t4 = r6), t4 < e9 && (t4 = e9), C7.TYPED_ARRAY_SUPPORT) (n4 = this.subarray(e9, t4)).__proto__ = C7.prototype;
  else {
    var i6 = t4 - e9;
    n4 = new C7(i6, void 0);
    for (var o4 = 0; o4 < i6; ++o4) n4[o4] = this[o4 + e9];
  }
  return n4;
}, C7.prototype.readUIntLE = function(e9, t4, n4) {
  e9 |= 0, t4 |= 0, n4 || Y6(e9, t4, this.length);
  for (var r6 = this[e9], i6 = 1, o4 = 0; ++o4 < t4 && (i6 *= 256); ) r6 += this[e9 + o4] * i6;
  return r6;
}, C7.prototype.readUIntBE = function(e9, t4, n4) {
  e9 |= 0, t4 |= 0, n4 || Y6(e9, t4, this.length);
  for (var r6 = this[e9 + --t4], i6 = 1; t4 > 0 && (i6 *= 256); ) r6 += this[e9 + --t4] * i6;
  return r6;
}, C7.prototype.readUInt8 = function(e9, t4) {
  return t4 || Y6(e9, 1, this.length), this[e9];
}, C7.prototype.readUInt16LE = function(e9, t4) {
  return t4 || Y6(e9, 2, this.length), this[e9] | this[e9 + 1] << 8;
}, C7.prototype.readUInt16BE = function(e9, t4) {
  return t4 || Y6(e9, 2, this.length), this[e9] << 8 | this[e9 + 1];
}, C7.prototype.readUInt32LE = function(e9, t4) {
  return t4 || Y6(e9, 4, this.length), (this[e9] | this[e9 + 1] << 8 | this[e9 + 2] << 16) + 16777216 * this[e9 + 3];
}, C7.prototype.readUInt32BE = function(e9, t4) {
  return t4 || Y6(e9, 4, this.length), 16777216 * this[e9] + (this[e9 + 1] << 16 | this[e9 + 2] << 8 | this[e9 + 3]);
}, C7.prototype.readIntLE = function(e9, t4, n4) {
  e9 |= 0, t4 |= 0, n4 || Y6(e9, t4, this.length);
  for (var r6 = this[e9], i6 = 1, o4 = 0; ++o4 < t4 && (i6 *= 256); ) r6 += this[e9 + o4] * i6;
  return r6 >= (i6 *= 128) && (r6 -= Math.pow(2, 8 * t4)), r6;
}, C7.prototype.readIntBE = function(e9, t4, n4) {
  e9 |= 0, t4 |= 0, n4 || Y6(e9, t4, this.length);
  for (var r6 = t4, i6 = 1, o4 = this[e9 + --r6]; r6 > 0 && (i6 *= 256); ) o4 += this[e9 + --r6] * i6;
  return o4 >= (i6 *= 128) && (o4 -= Math.pow(2, 8 * t4)), o4;
}, C7.prototype.readInt8 = function(e9, t4) {
  return t4 || Y6(e9, 1, this.length), 128 & this[e9] ? -1 * (255 - this[e9] + 1) : this[e9];
}, C7.prototype.readInt16LE = function(e9, t4) {
  t4 || Y6(e9, 2, this.length);
  var n4 = this[e9] | this[e9 + 1] << 8;
  return 32768 & n4 ? 4294901760 | n4 : n4;
}, C7.prototype.readInt16BE = function(e9, t4) {
  t4 || Y6(e9, 2, this.length);
  var n4 = this[e9 + 1] | this[e9] << 8;
  return 32768 & n4 ? 4294901760 | n4 : n4;
}, C7.prototype.readInt32LE = function(e9, t4) {
  return t4 || Y6(e9, 4, this.length), this[e9] | this[e9 + 1] << 8 | this[e9 + 2] << 16 | this[e9 + 3] << 24;
}, C7.prototype.readInt32BE = function(e9, t4) {
  return t4 || Y6(e9, 4, this.length), this[e9] << 24 | this[e9 + 1] << 16 | this[e9 + 2] << 8 | this[e9 + 3];
}, C7.prototype.readFloatLE = function(e9, t4) {
  return t4 || Y6(e9, 4, this.length), y7(this, e9, true, 23, 4);
}, C7.prototype.readFloatBE = function(e9, t4) {
  return t4 || Y6(e9, 4, this.length), y7(this, e9, false, 23, 4);
}, C7.prototype.readDoubleLE = function(e9, t4) {
  return t4 || Y6(e9, 8, this.length), y7(this, e9, true, 52, 8);
}, C7.prototype.readDoubleBE = function(e9, t4) {
  return t4 || Y6(e9, 8, this.length), y7(this, e9, false, 52, 8);
}, C7.prototype.writeUIntLE = function(e9, t4, n4, r6) {
  (e9 = +e9, t4 |= 0, n4 |= 0, r6) || Z4(this, e9, t4, n4, Math.pow(2, 8 * n4) - 1, 0);
  var i6 = 1, o4 = 0;
  for (this[t4] = 255 & e9; ++o4 < n4 && (i6 *= 256); ) this[t4 + o4] = e9 / i6 & 255;
  return t4 + n4;
}, C7.prototype.writeUIntBE = function(e9, t4, n4, r6) {
  (e9 = +e9, t4 |= 0, n4 |= 0, r6) || Z4(this, e9, t4, n4, Math.pow(2, 8 * n4) - 1, 0);
  var i6 = n4 - 1, o4 = 1;
  for (this[t4 + i6] = 255 & e9; --i6 >= 0 && (o4 *= 256); ) this[t4 + i6] = e9 / o4 & 255;
  return t4 + n4;
}, C7.prototype.writeUInt8 = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 1, 255, 0), C7.TYPED_ARRAY_SUPPORT || (e9 = Math.floor(e9)), this[t4] = 255 & e9, t4 + 1;
}, C7.prototype.writeUInt16LE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 2, 65535, 0), C7.TYPED_ARRAY_SUPPORT ? (this[t4] = 255 & e9, this[t4 + 1] = e9 >>> 8) : J4(this, e9, t4, true), t4 + 2;
}, C7.prototype.writeUInt16BE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 2, 65535, 0), C7.TYPED_ARRAY_SUPPORT ? (this[t4] = e9 >>> 8, this[t4 + 1] = 255 & e9) : J4(this, e9, t4, false), t4 + 2;
}, C7.prototype.writeUInt32LE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 4, 4294967295, 0), C7.TYPED_ARRAY_SUPPORT ? (this[t4 + 3] = e9 >>> 24, this[t4 + 2] = e9 >>> 16, this[t4 + 1] = e9 >>> 8, this[t4] = 255 & e9) : Q7(this, e9, t4, true), t4 + 4;
}, C7.prototype.writeUInt32BE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 4, 4294967295, 0), C7.TYPED_ARRAY_SUPPORT ? (this[t4] = e9 >>> 24, this[t4 + 1] = e9 >>> 16, this[t4 + 2] = e9 >>> 8, this[t4 + 3] = 255 & e9) : Q7(this, e9, t4, false), t4 + 4;
}, C7.prototype.writeIntLE = function(e9, t4, n4, r6) {
  if (e9 = +e9, t4 |= 0, !r6) {
    var i6 = Math.pow(2, 8 * n4 - 1);
    Z4(this, e9, t4, n4, i6 - 1, -i6);
  }
  var o4 = 0, s3 = 1, a4 = 0;
  for (this[t4] = 255 & e9; ++o4 < n4 && (s3 *= 256); ) e9 < 0 && 0 === a4 && 0 !== this[t4 + o4 - 1] && (a4 = 1), this[t4 + o4] = (e9 / s3 >> 0) - a4 & 255;
  return t4 + n4;
}, C7.prototype.writeIntBE = function(e9, t4, n4, r6) {
  if (e9 = +e9, t4 |= 0, !r6) {
    var i6 = Math.pow(2, 8 * n4 - 1);
    Z4(this, e9, t4, n4, i6 - 1, -i6);
  }
  var o4 = n4 - 1, s3 = 1, a4 = 0;
  for (this[t4 + o4] = 255 & e9; --o4 >= 0 && (s3 *= 256); ) e9 < 0 && 0 === a4 && 0 !== this[t4 + o4 + 1] && (a4 = 1), this[t4 + o4] = (e9 / s3 >> 0) - a4 & 255;
  return t4 + n4;
}, C7.prototype.writeInt8 = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 1, 127, -128), C7.TYPED_ARRAY_SUPPORT || (e9 = Math.floor(e9)), e9 < 0 && (e9 = 255 + e9 + 1), this[t4] = 255 & e9, t4 + 1;
}, C7.prototype.writeInt16LE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 2, 32767, -32768), C7.TYPED_ARRAY_SUPPORT ? (this[t4] = 255 & e9, this[t4 + 1] = e9 >>> 8) : J4(this, e9, t4, true), t4 + 2;
}, C7.prototype.writeInt16BE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 2, 32767, -32768), C7.TYPED_ARRAY_SUPPORT ? (this[t4] = e9 >>> 8, this[t4 + 1] = 255 & e9) : J4(this, e9, t4, false), t4 + 2;
}, C7.prototype.writeInt32LE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 4, 2147483647, -2147483648), C7.TYPED_ARRAY_SUPPORT ? (this[t4] = 255 & e9, this[t4 + 1] = e9 >>> 8, this[t4 + 2] = e9 >>> 16, this[t4 + 3] = e9 >>> 24) : Q7(this, e9, t4, true), t4 + 4;
}, C7.prototype.writeInt32BE = function(e9, t4, n4) {
  return e9 = +e9, t4 |= 0, n4 || Z4(this, e9, t4, 4, 2147483647, -2147483648), e9 < 0 && (e9 = 4294967295 + e9 + 1), C7.TYPED_ARRAY_SUPPORT ? (this[t4] = e9 >>> 24, this[t4 + 1] = e9 >>> 16, this[t4 + 2] = e9 >>> 8, this[t4 + 3] = 255 & e9) : Q7(this, e9, t4, false), t4 + 4;
}, C7.prototype.writeFloatLE = function(e9, t4, n4) {
  return ee4(this, e9, t4, true, n4);
}, C7.prototype.writeFloatBE = function(e9, t4, n4) {
  return ee4(this, e9, t4, false, n4);
}, C7.prototype.writeDoubleLE = function(e9, t4, n4) {
  return te3(this, e9, t4, true, n4);
}, C7.prototype.writeDoubleBE = function(e9, t4, n4) {
  return te3(this, e9, t4, false, n4);
}, C7.prototype.copy = function(e9, t4, n4, r6) {
  if (n4 || (n4 = 0), r6 || 0 === r6 || (r6 = this.length), t4 >= e9.length && (t4 = e9.length), t4 || (t4 = 0), r6 > 0 && r6 < n4 && (r6 = n4), r6 === n4) return 0;
  if (0 === e9.length || 0 === this.length) return 0;
  if (t4 < 0) throw new RangeError("targetStart out of bounds");
  if (n4 < 0 || n4 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (r6 < 0) throw new RangeError("sourceEnd out of bounds");
  r6 > this.length && (r6 = this.length), e9.length - t4 < r6 - n4 && (r6 = e9.length - t4 + n4);
  var i6, o4 = r6 - n4;
  if (this === e9 && n4 < t4 && t4 < r6) for (i6 = o4 - 1; i6 >= 0; --i6) e9[i6 + t4] = this[i6 + n4];
  else if (o4 < 1e3 || !C7.TYPED_ARRAY_SUPPORT) for (i6 = 0; i6 < o4; ++i6) e9[i6 + t4] = this[i6 + n4];
  else Uint8Array.prototype.set.call(e9, this.subarray(n4, n4 + o4), t4);
  return o4;
}, C7.prototype.fill = function(e9, t4, n4, r6) {
  if ("string" == typeof e9) {
    if ("string" == typeof t4 ? (r6 = t4, t4 = 0, n4 = this.length) : "string" == typeof n4 && (r6 = n4, n4 = this.length), 1 === e9.length) {
      var i6 = e9.charCodeAt(0);
      i6 < 256 && (e9 = i6);
    }
    if (void 0 !== r6 && "string" != typeof r6) throw new TypeError("encoding must be a string");
    if ("string" == typeof r6 && !C7.isEncoding(r6)) throw new TypeError("Unknown encoding: " + r6);
  } else "number" == typeof e9 && (e9 &= 255);
  if (t4 < 0 || this.length < t4 || this.length < n4) throw new RangeError("Out of range index");
  if (n4 <= t4) return this;
  var o4;
  if (t4 >>>= 0, n4 = void 0 === n4 ? this.length : n4 >>> 0, e9 || (e9 = 0), "number" == typeof e9) for (o4 = t4; o4 < n4; ++o4) this[o4] = e9;
  else {
    var s3 = T5(e9) ? e9 : ie6(new C7(e9, r6).toString()), a4 = s3.length;
    for (o4 = 0; o4 < n4 - t4; ++o4) this[o4 + t4] = s3[o4 % a4];
  }
  return this;
};
var ne6 = /[^+\/0-9A-Za-z-_]/g;
function re4(e9) {
  return e9 < 16 ? "0" + e9.toString(16) : e9.toString(16);
}
function ie6(e9, t4) {
  var n4;
  t4 = t4 || 1 / 0;
  for (var r6 = e9.length, i6 = null, o4 = [], s3 = 0; s3 < r6; ++s3) {
    if ((n4 = e9.charCodeAt(s3)) > 55295 && n4 < 57344) {
      if (!i6) {
        if (n4 > 56319) {
          (t4 -= 3) > -1 && o4.push(239, 191, 189);
          continue;
        }
        if (s3 + 1 === r6) {
          (t4 -= 3) > -1 && o4.push(239, 191, 189);
          continue;
        }
        i6 = n4;
        continue;
      }
      if (n4 < 56320) {
        (t4 -= 3) > -1 && o4.push(239, 191, 189), i6 = n4;
        continue;
      }
      n4 = 65536 + (i6 - 55296 << 10 | n4 - 56320);
    } else i6 && (t4 -= 3) > -1 && o4.push(239, 191, 189);
    if (i6 = null, n4 < 128) {
      if ((t4 -= 1) < 0) break;
      o4.push(n4);
    } else if (n4 < 2048) {
      if ((t4 -= 2) < 0) break;
      o4.push(n4 >> 6 | 192, 63 & n4 | 128);
    } else if (n4 < 65536) {
      if ((t4 -= 3) < 0) break;
      o4.push(n4 >> 12 | 224, n4 >> 6 & 63 | 128, 63 & n4 | 128);
    } else {
      if (!(n4 < 1114112)) throw new Error("Invalid code point");
      if ((t4 -= 4) < 0) break;
      o4.push(n4 >> 18 | 240, n4 >> 12 & 63 | 128, n4 >> 6 & 63 | 128, 63 & n4 | 128);
    }
  }
  return o4;
}
function oe2(e9) {
  return (function(e10) {
    var t4, n4, r6, i6, o4, s3;
    f11 || p6();
    var a4 = e10.length;
    if (a4 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    o4 = "=" === e10[a4 - 2] ? 2 : "=" === e10[a4 - 1] ? 1 : 0, s3 = new h6(3 * a4 / 4 - o4), r6 = o4 > 0 ? a4 - 4 : a4;
    var c6 = 0;
    for (t4 = 0, n4 = 0; t4 < r6; t4 += 4, n4 += 3) i6 = u5[e10.charCodeAt(t4)] << 18 | u5[e10.charCodeAt(t4 + 1)] << 12 | u5[e10.charCodeAt(t4 + 2)] << 6 | u5[e10.charCodeAt(t4 + 3)], s3[c6++] = i6 >> 16 & 255, s3[c6++] = i6 >> 8 & 255, s3[c6++] = 255 & i6;
    return 2 === o4 ? (i6 = u5[e10.charCodeAt(t4)] << 2 | u5[e10.charCodeAt(t4 + 1)] >> 4, s3[c6++] = 255 & i6) : 1 === o4 && (i6 = u5[e10.charCodeAt(t4)] << 10 | u5[e10.charCodeAt(t4 + 1)] << 4 | u5[e10.charCodeAt(t4 + 2)] >> 2, s3[c6++] = i6 >> 8 & 255, s3[c6++] = 255 & i6), s3;
  })((function(e10) {
    if ((e10 = (function(e11) {
      return e11.trim ? e11.trim() : e11.replace(/^\s+|\s+$/g, "");
    })(e10).replace(ne6, "")).length < 2) return "";
    for (; e10.length % 4 != 0; ) e10 += "=";
    return e10;
  })(e9));
}
function se6(e9, t4, n4, r6) {
  for (var i6 = 0; i6 < r6 && !(i6 + n4 >= t4.length || i6 >= e9.length); ++i6) t4[i6 + n4] = e9[i6];
  return i6;
}
function ae6(e9) {
  return null != e9 && (!!e9._isBuffer || ce6(e9) || (function(e10) {
    return "function" == typeof e10.readFloatLE && "function" == typeof e10.slice && ce6(e10.slice(0, 0));
  })(e9));
}
function ce6(e9) {
  return !!e9.constructor && "function" == typeof e9.constructor.isBuffer && e9.constructor.isBuffer(e9);
}
var le6 = Object.freeze({ __proto__: null, Buffer: C7, INSPECT_MAX_BYTES: 50, SlowBuffer: function(e9) {
  return +e9 != e9 && (e9 = 0), C7.alloc(+e9);
}, isBuffer: ae6, kMaxLength: E6 });
var de6 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function ue6(e9) {
  return e9 && e9.__esModule && Object.prototype.hasOwnProperty.call(e9, "default") ? e9.default : e9;
}
function he6(e9) {
  if (e9.__esModule) return e9;
  var t4 = e9.default;
  if ("function" == typeof t4) {
    var n4 = function e10() {
      return this instanceof e10 ? Reflect.construct(t4, arguments, this.constructor) : t4.apply(this, arguments);
    };
    n4.prototype = t4.prototype;
  } else n4 = {};
  return Object.defineProperty(n4, "__esModule", { value: true }), Object.keys(e9).forEach((function(t5) {
    var r6 = Object.getOwnPropertyDescriptor(e9, t5);
    Object.defineProperty(n4, t5, r6.get ? r6 : { enumerable: true, get: function() {
      return e9[t5];
    } });
  })), n4;
}
var fe6 = {};
var pe6 = {};
var ge4 = {};
function me6(e9) {
  if (!Number.isSafeInteger(e9) || e9 < 0) throw new Error(`positive integer expected, not ${e9}`);
}
function ye4(e9) {
  if ("boolean" != typeof e9) throw new Error(`boolean expected, not ${e9}`);
}
function ve3(e9) {
  return e9 instanceof Uint8Array || null != e9 && "object" == typeof e9 && "Uint8Array" === e9.constructor.name;
}
function be4(e9, ...t4) {
  if (!ve3(e9)) throw new Error("Uint8Array expected");
  if (t4.length > 0 && !t4.includes(e9.length)) throw new Error(`Uint8Array expected of length ${t4}, not of length=${e9.length}`);
}
function we4(e9) {
  if ("function" != typeof e9 || "function" != typeof e9.create) throw new Error("hash must be wrapped by utils.wrapConstructor");
  me6(e9.outputLen), me6(e9.blockLen);
}
function Ee4(e9, t4 = true) {
  if (e9.destroyed) throw new Error("Hash instance has been destroyed");
  if (t4 && e9.finished) throw new Error("Hash#digest() has already been called");
}
function Se4(e9, t4) {
  be4(e9);
  const n4 = t4.outputLen;
  if (e9.length < n4) throw new Error(`digestInto() expects output buffer of length at least ${n4}`);
}
Object.defineProperty(ge4, "__esModule", { value: true }), ge4.isBytes = ve3, ge4.number = me6, ge4.bool = ye4, ge4.bytes = be4, ge4.hash = we4, ge4.exists = Ee4, ge4.output = Se4;
var _e7 = { number: me6, bool: ye4, bytes: be4, hash: we4, exists: Ee4, output: Se4 };
ge4.default = _e7, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.wrapCipher = e9.Hash = e9.nextTick = e9.isLE = e9.createView = e9.u32 = e9.u16 = e9.u8 = void 0, e9.bytesToHex = r6, e9.hexToBytes = s3, e9.hexToNumber = a4, e9.bytesToNumberBE = function(e10) {
    return a4(r6(e10));
  }, e9.numberToBytesBE = function(e10, t5) {
    return s3(e10.toString(16).padStart(2 * t5, "0"));
  }, e9.asyncLoop = async function(t5, n5, r7) {
    let i7 = Date.now();
    for (let o5 = 0; o5 < t5; o5++) {
      r7(o5);
      const t6 = Date.now() - i7;
      t6 >= 0 && t6 < n5 || (await (0, e9.nextTick)(), i7 += t6);
    }
  }, e9.utf8ToBytes = c6, e9.bytesToUtf8 = function(e10) {
    return new TextDecoder().decode(e10);
  }, e9.toBytes = function(e10) {
    if ("string" == typeof e10) e10 = c6(e10);
    else {
      if (!(0, t4.isBytes)(e10)) throw new Error("Uint8Array expected, got " + typeof e10);
      e10 = d5(e10);
    }
    return e10;
  }, e9.concatBytes = function(...e10) {
    let n5 = 0;
    for (let r8 = 0; r8 < e10.length; r8++) {
      const i7 = e10[r8];
      (0, t4.bytes)(i7), n5 += i7.length;
    }
    const r7 = new Uint8Array(n5);
    for (let t5 = 0, n6 = 0; t5 < e10.length; t5++) {
      const i7 = e10[t5];
      r7.set(i7, n6), n6 += i7.length;
    }
    return r7;
  }, e9.checkOpts = function(e10, t5) {
    if (null == t5 || "object" != typeof t5) throw new Error("options must be defined");
    return Object.assign(e10, t5);
  }, e9.equalBytes = function(e10, t5) {
    if (e10.length !== t5.length) return false;
    let n5 = 0;
    for (let r7 = 0; r7 < e10.length; r7++) n5 |= e10[r7] ^ t5[r7];
    return 0 === n5;
  }, e9.setBigUint64 = l6, e9.u64Lengths = function(t5, n5) {
    const r7 = new Uint8Array(16), i7 = (0, e9.createView)(r7);
    return l6(i7, 0, BigInt(n5 ? n5.length : 0), true), l6(i7, 8, BigInt(t5.length), true), r7;
  }, e9.isAligned32 = function(e10) {
    return e10.byteOffset % 4 == 0;
  }, e9.copyBytes = d5, e9.clean = function(...e10) {
    for (let t5 = 0; t5 < e10.length; t5++) e10[t5].fill(0);
  };
  const t4 = ge4;
  e9.u8 = (e10) => new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength);
  e9.u16 = (e10) => new Uint16Array(e10.buffer, e10.byteOffset, Math.floor(e10.byteLength / 2));
  e9.u32 = (e10) => new Uint32Array(e10.buffer, e10.byteOffset, Math.floor(e10.byteLength / 4));
  if (e9.createView = (e10) => new DataView(e10.buffer, e10.byteOffset, e10.byteLength), e9.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !e9.isLE) throw new Error("Non little-endian hardware is not supported");
  const n4 = Array.from({ length: 256 }, ((e10, t5) => t5.toString(16).padStart(2, "0")));
  function r6(e10) {
    (0, t4.bytes)(e10);
    let r7 = "";
    for (let t5 = 0; t5 < e10.length; t5++) r7 += n4[e10[t5]];
    return r7;
  }
  const i6 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o4(e10) {
    return e10 >= i6._0 && e10 <= i6._9 ? e10 - i6._0 : e10 >= i6._A && e10 <= i6._F ? e10 - (i6._A - 10) : e10 >= i6._a && e10 <= i6._f ? e10 - (i6._a - 10) : void 0;
  }
  function s3(e10) {
    if ("string" != typeof e10) throw new Error("hex string expected, got " + typeof e10);
    const t5 = e10.length, n5 = t5 / 2;
    if (t5 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t5);
    const r7 = new Uint8Array(n5);
    for (let t6 = 0, i7 = 0; t6 < n5; t6++, i7 += 2) {
      const n6 = o4(e10.charCodeAt(i7)), s4 = o4(e10.charCodeAt(i7 + 1));
      if (void 0 === n6 || void 0 === s4) {
        const t7 = e10[i7] + e10[i7 + 1];
        throw new Error('hex string expected, got non-hex character "' + t7 + '" at index ' + i7);
      }
      r7[t6] = 16 * n6 + s4;
    }
    return r7;
  }
  function a4(e10) {
    if ("string" != typeof e10) throw new Error("hex string expected, got " + typeof e10);
    return BigInt("" === e10 ? "0" : `0x${e10}`);
  }
  function c6(e10) {
    if ("string" != typeof e10) throw new Error("string expected, got " + typeof e10);
    return new Uint8Array(new TextEncoder().encode(e10));
  }
  e9.nextTick = async () => {
  };
  e9.Hash = class {
  };
  function l6(e10, t5, n5, r7) {
    if ("function" == typeof e10.setBigUint64) return e10.setBigUint64(t5, n5, r7);
    const i7 = BigInt(32), o5 = BigInt(4294967295), s4 = Number(n5 >> i7 & o5), a5 = Number(n5 & o5), c7 = r7 ? 4 : 0, l7 = r7 ? 0 : 4;
    e10.setUint32(t5 + c7, s4, r7), e10.setUint32(t5 + l7, a5, r7);
  }
  function d5(e10) {
    return Uint8Array.from(e10);
  }
  e9.wrapCipher = (e10, t5) => (Object.assign(t5, e10), t5);
})(pe6);
var Ce7 = {};
var ke7 = {};
Object.defineProperty(ke7, "__esModule", { value: true }), ke7.AEAD_TAG_LENGTH = ke7.XCHACHA20_NONCE_LENGTH = ke7.CURVE25519_PUBLIC_KEY_SIZE = ke7.ETH_PUBLIC_KEY_SIZE = ke7.UNCOMPRESSED_PUBLIC_KEY_SIZE = ke7.COMPRESSED_PUBLIC_KEY_SIZE = ke7.SECRET_KEY_LENGTH = void 0, ke7.SECRET_KEY_LENGTH = 32, ke7.COMPRESSED_PUBLIC_KEY_SIZE = 33, ke7.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65, ke7.ETH_PUBLIC_KEY_SIZE = 64, ke7.CURVE25519_PUBLIC_KEY_SIZE = 32, ke7.XCHACHA20_NONCE_LENGTH = 24, ke7.AEAD_TAG_LENGTH = 16, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.ephemeralKeySize = e9.symmetricNonceLength = e9.symmetricAlgorithm = e9.isHkdfKeyCompressed = e9.isEphemeralKeyCompressed = e9.ellipticCurve = e9.ECIES_CONFIG = void 0;
  var t4 = ke7, n4 = function() {
    this.ellipticCurve = "secp256k1", this.isEphemeralKeyCompressed = false, this.isHkdfKeyCompressed = false, this.symmetricAlgorithm = "aes-256-gcm", this.symmetricNonceLength = 16;
  };
  e9.ECIES_CONFIG = new n4();
  e9.ellipticCurve = function() {
    return e9.ECIES_CONFIG.ellipticCurve;
  };
  e9.isEphemeralKeyCompressed = function() {
    return e9.ECIES_CONFIG.isEphemeralKeyCompressed;
  };
  e9.isHkdfKeyCompressed = function() {
    return e9.ECIES_CONFIG.isHkdfKeyCompressed;
  };
  e9.symmetricAlgorithm = function() {
    return e9.ECIES_CONFIG.symmetricAlgorithm;
  };
  e9.symmetricNonceLength = function() {
    return e9.ECIES_CONFIG.symmetricNonceLength;
  };
  e9.ephemeralKeySize = function() {
    var n5 = { secp256k1: e9.ECIES_CONFIG.isEphemeralKeyCompressed ? t4.COMPRESSED_PUBLIC_KEY_SIZE : t4.UNCOMPRESSED_PUBLIC_KEY_SIZE, x25519: t4.CURVE25519_PUBLIC_KEY_SIZE, ed25519: t4.CURVE25519_PUBLIC_KEY_SIZE };
    if (e9.ECIES_CONFIG.ellipticCurve in n5) return n5[e9.ECIES_CONFIG.ellipticCurve];
    throw new Error("Not implemented");
  };
})(Ce7);
var Ae5 = {};
var xe4 = {};
var Me5 = {};
var Ie6 = {};
var Te4 = {};
var Re5 = {};
Object.defineProperty(Re5, "__esModule", { value: true }), Re5.crypto = void 0, Re5.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.gcm = e9.ctr = e9.cbc = e9.utils = void 0, e9.randomBytes = i6, e9.getWebcryptoSubtle = o4, e9.managedNonce = function(e10) {
    return (0, n4.number)(e10.nonceLength), (t5, ...n5) => ({ encrypt(o5, ...s4) {
      const { nonceLength: a5 } = e10, c6 = i6(a5), l6 = e10(t5, c6, ...n5).encrypt(o5, ...s4), d5 = (0, r6.concatBytes)(c6, l6);
      return l6.fill(0), d5;
    }, decrypt(r7, ...i7) {
      const { nonceLength: o5 } = e10, s4 = r7.subarray(0, o5), a5 = r7.subarray(o5);
      return e10(t5, s4, ...n5).decrypt(a5, ...i7);
    } });
  };
  const t4 = Re5, n4 = ge4, r6 = pe6;
  function i6(e10 = 32) {
    if (t4.crypto && "function" == typeof t4.crypto.getRandomValues) return t4.crypto.getRandomValues(new Uint8Array(e10));
    if (t4.crypto && "function" == typeof t4.crypto.randomBytes) return t4.crypto.randomBytes(e10);
    throw new Error("crypto.getRandomValues must be defined");
  }
  function o4() {
    if (t4.crypto && "object" == typeof t4.crypto.subtle && null != t4.crypto.subtle) return t4.crypto.subtle;
    throw new Error("crypto.subtle must be defined");
  }
  e9.utils = { async encrypt(e10, t5, n5, r7) {
    const i7 = o4(), s4 = await i7.importKey("raw", e10, t5, true, ["encrypt"]), a5 = await i7.encrypt(n5, s4, r7);
    return new Uint8Array(a5);
  }, async decrypt(e10, t5, n5, r7) {
    const i7 = o4(), s4 = await i7.importKey("raw", e10, t5, true, ["decrypt"]), a5 = await i7.decrypt(n5, s4, r7);
    return new Uint8Array(a5);
  } };
  const s3 = { CBC: "AES-CBC", CTR: "AES-CTR", GCM: "AES-GCM" };
  function a4(t5) {
    return (r7, i7, o5) => {
      (0, n4.bytes)(r7), (0, n4.bytes)(i7);
      const a5 = { name: t5, length: 8 * r7.length }, c6 = (function(e10, t6, n5) {
        if (e10 === s3.CBC) return { name: s3.CBC, iv: t6 };
        if (e10 === s3.CTR) return { name: s3.CTR, counter: t6, length: 64 };
        if (e10 === s3.GCM) return n5 ? { name: s3.GCM, iv: t6, additionalData: n5 } : { name: s3.GCM, iv: t6 };
        throw new Error("unknown aes block mode");
      })(t5, i7, o5);
      return { encrypt: (t6) => ((0, n4.bytes)(t6), e9.utils.encrypt(r7, a5, c6, t6)), decrypt: (t6) => ((0, n4.bytes)(t6), e9.utils.decrypt(r7, a5, c6, t6)) };
    };
  }
  e9.cbc = a4(s3.CBC), e9.ctr = a4(s3.CTR), e9.gcm = a4(s3.GCM);
})(Te4);
var Pe6 = {};
var Oe3 = {};
var Ne3 = {};
var Le7 = {};
function De4(e9) {
  if (!Number.isSafeInteger(e9) || e9 < 0) throw new Error(`positive integer expected, not ${e9}`);
}
function $e6(e9) {
  if ("boolean" != typeof e9) throw new Error(`boolean expected, not ${e9}`);
}
function Be6(e9) {
  return e9 instanceof Uint8Array || null != e9 && "object" == typeof e9 && "Uint8Array" === e9.constructor.name;
}
function Ke7(e9, ...t4) {
  if (!Be6(e9)) throw new Error("Uint8Array expected");
  if (t4.length > 0 && !t4.includes(e9.length)) throw new Error(`Uint8Array expected of length ${t4}, not of length=${e9.length}`);
}
function je6(e9) {
  if ("function" != typeof e9 || "function" != typeof e9.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
  De4(e9.outputLen), De4(e9.blockLen);
}
function Ue6(e9, t4 = true) {
  if (e9.destroyed) throw new Error("Hash instance has been destroyed");
  if (t4 && e9.finished) throw new Error("Hash#digest() has already been called");
}
function He6(e9, t4) {
  Ke7(e9);
  const n4 = t4.outputLen;
  if (e9.length < n4) throw new Error(`digestInto() expects output buffer of length at least ${n4}`);
}
Object.defineProperty(Le7, "__esModule", { value: true }), Le7.isBytes = Be6, Le7.number = De4, Le7.bool = $e6, Le7.bytes = Ke7, Le7.hash = je6, Le7.exists = Ue6, Le7.output = He6;
var Fe5 = { number: De4, bool: $e6, bytes: Ke7, hash: je6, exists: Ue6, output: He6 };
Le7.default = Fe5;
var ze3 = {};
var qe4 = {};
Object.defineProperty(qe4, "__esModule", { value: true }), qe4.crypto = void 0, qe4.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.Hash = e9.nextTick = e9.byteSwapIfBE = e9.byteSwap = e9.isLE = e9.rotl = e9.rotr = e9.createView = e9.u32 = e9.u8 = void 0, e9.isBytes = function(e10) {
    return e10 instanceof Uint8Array || null != e10 && "object" == typeof e10 && "Uint8Array" === e10.constructor.name;
  }, e9.byteSwap32 = function(t5) {
    for (let n5 = 0; n5 < t5.length; n5++) t5[n5] = (0, e9.byteSwap)(t5[n5]);
  }, e9.bytesToHex = function(e10) {
    (0, n4.bytes)(e10);
    let t5 = "";
    for (let n5 = 0; n5 < e10.length; n5++) t5 += r6[e10[n5]];
    return t5;
  }, e9.hexToBytes = function(e10) {
    if ("string" != typeof e10) throw new Error("hex string expected, got " + typeof e10);
    const t5 = e10.length, n5 = t5 / 2;
    if (t5 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t5);
    const r7 = new Uint8Array(n5);
    for (let t6 = 0, i7 = 0; t6 < n5; t6++, i7 += 2) {
      const n6 = o4(e10.charCodeAt(i7)), s4 = o4(e10.charCodeAt(i7 + 1));
      if (void 0 === n6 || void 0 === s4) {
        const t7 = e10[i7] + e10[i7 + 1];
        throw new Error('hex string expected, got non-hex character "' + t7 + '" at index ' + i7);
      }
      r7[t6] = 16 * n6 + s4;
    }
    return r7;
  }, e9.asyncLoop = async function(t5, n5, r7) {
    let i7 = Date.now();
    for (let o5 = 0; o5 < t5; o5++) {
      r7(o5);
      const t6 = Date.now() - i7;
      t6 >= 0 && t6 < n5 || (await (0, e9.nextTick)(), i7 += t6);
    }
  }, e9.utf8ToBytes = s3, e9.toBytes = a4, e9.concatBytes = function(...e10) {
    let t5 = 0;
    for (let r8 = 0; r8 < e10.length; r8++) {
      const i7 = e10[r8];
      (0, n4.bytes)(i7), t5 += i7.length;
    }
    const r7 = new Uint8Array(t5);
    for (let t6 = 0, n5 = 0; t6 < e10.length; t6++) {
      const i7 = e10[t6];
      r7.set(i7, n5), n5 += i7.length;
    }
    return r7;
  }, e9.checkOpts = function(e10, t5) {
    if (void 0 !== t5 && "[object Object]" !== c6.call(t5)) throw new Error("Options should be object or undefined");
    return Object.assign(e10, t5);
  }, e9.wrapConstructor = function(e10) {
    const t5 = (t6) => e10().update(a4(t6)).digest(), n5 = e10();
    return t5.outputLen = n5.outputLen, t5.blockLen = n5.blockLen, t5.create = () => e10(), t5;
  }, e9.wrapConstructorWithOpts = function(e10) {
    const t5 = (t6, n6) => e10(n6).update(a4(t6)).digest(), n5 = e10({});
    return t5.outputLen = n5.outputLen, t5.blockLen = n5.blockLen, t5.create = (t6) => e10(t6), t5;
  }, e9.wrapXOFConstructorWithOpts = function(e10) {
    const t5 = (t6, n6) => e10(n6).update(a4(t6)).digest(), n5 = e10({});
    return t5.outputLen = n5.outputLen, t5.blockLen = n5.blockLen, t5.create = (t6) => e10(t6), t5;
  }, e9.randomBytes = function(e10 = 32) {
    if (t4.crypto && "function" == typeof t4.crypto.getRandomValues) return t4.crypto.getRandomValues(new Uint8Array(e10));
    if (t4.crypto && "function" == typeof t4.crypto.randomBytes) return t4.crypto.randomBytes(e10);
    throw new Error("crypto.getRandomValues must be defined");
  };
  const t4 = qe4, n4 = Le7;
  e9.u8 = (e10) => new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength);
  e9.u32 = (e10) => new Uint32Array(e10.buffer, e10.byteOffset, Math.floor(e10.byteLength / 4));
  e9.createView = (e10) => new DataView(e10.buffer, e10.byteOffset, e10.byteLength);
  e9.rotr = (e10, t5) => e10 << 32 - t5 | e10 >>> t5;
  e9.rotl = (e10, t5) => e10 << t5 | e10 >>> 32 - t5 >>> 0, e9.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
  e9.byteSwap = (e10) => e10 << 24 & 4278190080 | e10 << 8 & 16711680 | e10 >>> 8 & 65280 | e10 >>> 24 & 255, e9.byteSwapIfBE = e9.isLE ? (e10) => e10 : (t5) => (0, e9.byteSwap)(t5);
  const r6 = Array.from({ length: 256 }, ((e10, t5) => t5.toString(16).padStart(2, "0")));
  const i6 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o4(e10) {
    return e10 >= i6._0 && e10 <= i6._9 ? e10 - i6._0 : e10 >= i6._A && e10 <= i6._F ? e10 - (i6._A - 10) : e10 >= i6._a && e10 <= i6._f ? e10 - (i6._a - 10) : void 0;
  }
  function s3(e10) {
    if ("string" != typeof e10) throw new Error("utf8ToBytes expected string, got " + typeof e10);
    return new Uint8Array(new TextEncoder().encode(e10));
  }
  function a4(e10) {
    return "string" == typeof e10 && (e10 = s3(e10)), (0, n4.bytes)(e10), e10;
  }
  e9.nextTick = async () => {
  };
  e9.Hash = class {
    clone() {
      return this._cloneInto();
    }
  };
  const c6 = {}.toString;
})(ze3), Object.defineProperty(Ne3, "__esModule", { value: true }), Ne3.HashMD = Ne3.Maj = Ne3.Chi = void 0;
var We3 = Le7;
var Ve5 = ze3;
Ne3.Chi = (e9, t4, n4) => e9 & t4 ^ ~e9 & n4;
Ne3.Maj = (e9, t4, n4) => e9 & t4 ^ e9 & n4 ^ t4 & n4;
Ne3.HashMD = class extends Ve5.Hash {
  constructor(e9, t4, n4, r6) {
    super(), this.blockLen = e9, this.outputLen = t4, this.padOffset = n4, this.isLE = r6, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e9), this.view = (0, Ve5.createView)(this.buffer);
  }
  update(e9) {
    (0, We3.exists)(this);
    const { view: t4, buffer: n4, blockLen: r6 } = this, i6 = (e9 = (0, Ve5.toBytes)(e9)).length;
    for (let o4 = 0; o4 < i6; ) {
      const s3 = Math.min(r6 - this.pos, i6 - o4);
      if (s3 !== r6) n4.set(e9.subarray(o4, o4 + s3), this.pos), this.pos += s3, o4 += s3, this.pos === r6 && (this.process(t4, 0), this.pos = 0);
      else {
        const t5 = (0, Ve5.createView)(e9);
        for (; r6 <= i6 - o4; o4 += r6) this.process(t5, o4);
      }
    }
    return this.length += e9.length, this.roundClean(), this;
  }
  digestInto(e9) {
    (0, We3.exists)(this), (0, We3.output)(e9, this), this.finished = true;
    const { buffer: t4, view: n4, blockLen: r6, isLE: i6 } = this;
    let { pos: o4 } = this;
    t4[o4++] = 128, this.buffer.subarray(o4).fill(0), this.padOffset > r6 - o4 && (this.process(n4, 0), o4 = 0);
    for (let e10 = o4; e10 < r6; e10++) t4[e10] = 0;
    !(function(e10, t5, n5, r7) {
      if ("function" == typeof e10.setBigUint64) return e10.setBigUint64(t5, n5, r7);
      const i7 = BigInt(32), o5 = BigInt(4294967295), s4 = Number(n5 >> i7 & o5), a5 = Number(n5 & o5), c7 = r7 ? 4 : 0, l7 = r7 ? 0 : 4;
      e10.setUint32(t5 + c7, s4, r7), e10.setUint32(t5 + l7, a5, r7);
    })(n4, r6 - 8, BigInt(8 * this.length), i6), this.process(n4, 0);
    const s3 = (0, Ve5.createView)(e9), a4 = this.outputLen;
    if (a4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c6 = a4 / 4, l6 = this.get();
    if (c6 > l6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let e10 = 0; e10 < c6; e10++) s3.setUint32(4 * e10, l6[e10], i6);
  }
  digest() {
    const { buffer: e9, outputLen: t4 } = this;
    this.digestInto(e9);
    const n4 = e9.slice(0, t4);
    return this.destroy(), n4;
  }
  _cloneInto(e9) {
    e9 || (e9 = new this.constructor()), e9.set(...this.get());
    const { blockLen: t4, buffer: n4, length: r6, finished: i6, destroyed: o4, pos: s3 } = this;
    return e9.length = r6, e9.pos = s3, e9.finished = i6, e9.destroyed = o4, r6 % t4 && e9.buffer.set(n4), e9;
  }
};
var Ge3 = {};
Object.defineProperty(Ge3, "__esModule", { value: true }), Ge3.add5L = Ge3.add5H = Ge3.add4H = Ge3.add4L = Ge3.add3H = Ge3.add3L = Ge3.rotlBL = Ge3.rotlBH = Ge3.rotlSL = Ge3.rotlSH = Ge3.rotr32L = Ge3.rotr32H = Ge3.rotrBL = Ge3.rotrBH = Ge3.rotrSL = Ge3.rotrSH = Ge3.shrSL = Ge3.shrSH = Ge3.toBig = void 0, Ge3.fromBig = Je3, Ge3.split = Qe5, Ge3.add = ht6;
var Ye4 = BigInt(2 ** 32 - 1);
var Ze4 = BigInt(32);
function Je3(e9, t4 = false) {
  return t4 ? { h: Number(e9 & Ye4), l: Number(e9 >> Ze4 & Ye4) } : { h: 0 | Number(e9 >> Ze4 & Ye4), l: 0 | Number(e9 & Ye4) };
}
function Qe5(e9, t4 = false) {
  let n4 = new Uint32Array(e9.length), r6 = new Uint32Array(e9.length);
  for (let i6 = 0; i6 < e9.length; i6++) {
    const { h: o4, l: s3 } = Je3(e9[i6], t4);
    [n4[i6], r6[i6]] = [o4, s3];
  }
  return [n4, r6];
}
var Xe4 = (e9, t4) => BigInt(e9 >>> 0) << Ze4 | BigInt(t4 >>> 0);
Ge3.toBig = Xe4;
var et2 = (e9, t4, n4) => e9 >>> n4;
Ge3.shrSH = et2;
var tt4 = (e9, t4, n4) => e9 << 32 - n4 | t4 >>> n4;
Ge3.shrSL = tt4;
var nt6 = (e9, t4, n4) => e9 >>> n4 | t4 << 32 - n4;
Ge3.rotrSH = nt6;
var rt5 = (e9, t4, n4) => e9 << 32 - n4 | t4 >>> n4;
Ge3.rotrSL = rt5;
var it3 = (e9, t4, n4) => e9 << 64 - n4 | t4 >>> n4 - 32;
Ge3.rotrBH = it3;
var ot5 = (e9, t4, n4) => e9 >>> n4 - 32 | t4 << 64 - n4;
Ge3.rotrBL = ot5;
var st2 = (e9, t4) => t4;
Ge3.rotr32H = st2;
var at5 = (e9, t4) => e9;
Ge3.rotr32L = at5;
var ct5 = (e9, t4, n4) => e9 << n4 | t4 >>> 32 - n4;
Ge3.rotlSH = ct5;
var lt6 = (e9, t4, n4) => t4 << n4 | e9 >>> 32 - n4;
Ge3.rotlSL = lt6;
var dt6 = (e9, t4, n4) => t4 << n4 - 32 | e9 >>> 64 - n4;
Ge3.rotlBH = dt6;
var ut6 = (e9, t4, n4) => e9 << n4 - 32 | t4 >>> 64 - n4;
function ht6(e9, t4, n4, r6) {
  const i6 = (t4 >>> 0) + (r6 >>> 0);
  return { h: e9 + n4 + (i6 / 2 ** 32 | 0) | 0, l: 0 | i6 };
}
Ge3.rotlBL = ut6;
var ft3 = (e9, t4, n4) => (e9 >>> 0) + (t4 >>> 0) + (n4 >>> 0);
Ge3.add3L = ft3;
var pt6 = (e9, t4, n4, r6) => t4 + n4 + r6 + (e9 / 2 ** 32 | 0) | 0;
Ge3.add3H = pt6;
var gt6 = (e9, t4, n4, r6) => (e9 >>> 0) + (t4 >>> 0) + (n4 >>> 0) + (r6 >>> 0);
Ge3.add4L = gt6;
var mt6 = (e9, t4, n4, r6, i6) => t4 + n4 + r6 + i6 + (e9 / 2 ** 32 | 0) | 0;
Ge3.add4H = mt6;
var yt3 = (e9, t4, n4, r6, i6) => (e9 >>> 0) + (t4 >>> 0) + (n4 >>> 0) + (r6 >>> 0) + (i6 >>> 0);
Ge3.add5L = yt3;
var vt6 = (e9, t4, n4, r6, i6, o4) => t4 + n4 + r6 + i6 + o4 + (e9 / 2 ** 32 | 0) | 0;
Ge3.add5H = vt6;
var bt3 = { fromBig: Je3, split: Qe5, toBig: Xe4, shrSH: et2, shrSL: tt4, rotrSH: nt6, rotrSL: rt5, rotrBH: it3, rotrBL: ot5, rotr32H: st2, rotr32L: at5, rotlSH: ct5, rotlSL: lt6, rotlBH: dt6, rotlBL: ut6, add: ht6, add3L: ft3, add3H: pt6, add4L: gt6, add4H: mt6, add5H: vt6, add5L: yt3 };
Ge3.default = bt3, Object.defineProperty(Oe3, "__esModule", { value: true }), Oe3.sha384 = Oe3.sha512_256 = Oe3.sha512_224 = Oe3.sha512 = Oe3.SHA384 = Oe3.SHA512_256 = Oe3.SHA512_224 = Oe3.SHA512 = void 0;
var wt6 = Ne3;
var Et5 = Ge3;
var St7 = ze3;
var [_t5, Ct6] = (() => Et5.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(((e9) => BigInt(e9)))))();
var kt4 = new Uint32Array(80);
var At6 = new Uint32Array(80);
var xt6 = class extends wt6.HashMD {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e9, Al: t4, Bh: n4, Bl: r6, Ch: i6, Cl: o4, Dh: s3, Dl: a4, Eh: c6, El: l6, Fh: d5, Fl: u6, Gh: h7, Gl: f12, Hh: p7, Hl: g3 } = this;
    return [e9, t4, n4, r6, i6, o4, s3, a4, c6, l6, d5, u6, h7, f12, p7, g3];
  }
  set(e9, t4, n4, r6, i6, o4, s3, a4, c6, l6, d5, u6, h7, f12, p7, g3) {
    this.Ah = 0 | e9, this.Al = 0 | t4, this.Bh = 0 | n4, this.Bl = 0 | r6, this.Ch = 0 | i6, this.Cl = 0 | o4, this.Dh = 0 | s3, this.Dl = 0 | a4, this.Eh = 0 | c6, this.El = 0 | l6, this.Fh = 0 | d5, this.Fl = 0 | u6, this.Gh = 0 | h7, this.Gl = 0 | f12, this.Hh = 0 | p7, this.Hl = 0 | g3;
  }
  process(e9, t4) {
    for (let n5 = 0; n5 < 16; n5++, t4 += 4) kt4[n5] = e9.getUint32(t4), At6[n5] = e9.getUint32(t4 += 4);
    for (let e10 = 16; e10 < 80; e10++) {
      const t5 = 0 | kt4[e10 - 15], n5 = 0 | At6[e10 - 15], r7 = Et5.default.rotrSH(t5, n5, 1) ^ Et5.default.rotrSH(t5, n5, 8) ^ Et5.default.shrSH(t5, n5, 7), i7 = Et5.default.rotrSL(t5, n5, 1) ^ Et5.default.rotrSL(t5, n5, 8) ^ Et5.default.shrSL(t5, n5, 7), o5 = 0 | kt4[e10 - 2], s4 = 0 | At6[e10 - 2], a5 = Et5.default.rotrSH(o5, s4, 19) ^ Et5.default.rotrBH(o5, s4, 61) ^ Et5.default.shrSH(o5, s4, 6), c7 = Et5.default.rotrSL(o5, s4, 19) ^ Et5.default.rotrBL(o5, s4, 61) ^ Et5.default.shrSL(o5, s4, 6), l7 = Et5.default.add4L(i7, c7, At6[e10 - 7], At6[e10 - 16]), d6 = Et5.default.add4H(l7, r7, a5, kt4[e10 - 7], kt4[e10 - 16]);
      kt4[e10] = 0 | d6, At6[e10] = 0 | l7;
    }
    let { Ah: n4, Al: r6, Bh: i6, Bl: o4, Ch: s3, Cl: a4, Dh: c6, Dl: l6, Eh: d5, El: u6, Fh: h7, Fl: f12, Gh: p7, Gl: g3, Hh: m5, Hl: y8 } = this;
    for (let e10 = 0; e10 < 80; e10++) {
      const t5 = Et5.default.rotrSH(d5, u6, 14) ^ Et5.default.rotrSH(d5, u6, 18) ^ Et5.default.rotrBH(d5, u6, 41), v7 = Et5.default.rotrSL(d5, u6, 14) ^ Et5.default.rotrSL(d5, u6, 18) ^ Et5.default.rotrBL(d5, u6, 41), b5 = d5 & h7 ^ ~d5 & p7, w6 = u6 & f12 ^ ~u6 & g3, E7 = Et5.default.add5L(y8, v7, w6, Ct6[e10], At6[e10]), S7 = Et5.default.add5H(E7, m5, t5, b5, _t5[e10], kt4[e10]), _4 = 0 | E7, C8 = Et5.default.rotrSH(n4, r6, 28) ^ Et5.default.rotrBH(n4, r6, 34) ^ Et5.default.rotrBH(n4, r6, 39), k8 = Et5.default.rotrSL(n4, r6, 28) ^ Et5.default.rotrBL(n4, r6, 34) ^ Et5.default.rotrBL(n4, r6, 39), A8 = n4 & i6 ^ n4 & s3 ^ i6 & s3, x5 = r6 & o4 ^ r6 & a4 ^ o4 & a4;
      m5 = 0 | p7, y8 = 0 | g3, p7 = 0 | h7, g3 = 0 | f12, h7 = 0 | d5, f12 = 0 | u6, { h: d5, l: u6 } = Et5.default.add(0 | c6, 0 | l6, 0 | S7, 0 | _4), c6 = 0 | s3, l6 = 0 | a4, s3 = 0 | i6, a4 = 0 | o4, i6 = 0 | n4, o4 = 0 | r6;
      const M7 = Et5.default.add3L(_4, k8, x5);
      n4 = Et5.default.add3H(M7, S7, C8, A8), r6 = 0 | M7;
    }
    ({ h: n4, l: r6 } = Et5.default.add(0 | this.Ah, 0 | this.Al, 0 | n4, 0 | r6)), { h: i6, l: o4 } = Et5.default.add(0 | this.Bh, 0 | this.Bl, 0 | i6, 0 | o4), { h: s3, l: a4 } = Et5.default.add(0 | this.Ch, 0 | this.Cl, 0 | s3, 0 | a4), { h: c6, l: l6 } = Et5.default.add(0 | this.Dh, 0 | this.Dl, 0 | c6, 0 | l6), { h: d5, l: u6 } = Et5.default.add(0 | this.Eh, 0 | this.El, 0 | d5, 0 | u6), { h: h7, l: f12 } = Et5.default.add(0 | this.Fh, 0 | this.Fl, 0 | h7, 0 | f12), { h: p7, l: g3 } = Et5.default.add(0 | this.Gh, 0 | this.Gl, 0 | p7, 0 | g3), { h: m5, l: y8 } = Et5.default.add(0 | this.Hh, 0 | this.Hl, 0 | m5, 0 | y8), this.set(n4, r6, i6, o4, s3, a4, c6, l6, d5, u6, h7, f12, p7, g3, m5, y8);
  }
  roundClean() {
    kt4.fill(0), At6.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Oe3.SHA512 = xt6;
var Mt6 = class extends xt6 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Oe3.SHA512_224 = Mt6;
var It4 = class extends xt6 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Oe3.SHA512_256 = It4;
var Tt6 = class extends xt6 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Oe3.SHA384 = Tt6, Oe3.sha512 = (0, St7.wrapConstructor)((() => new xt6())), Oe3.sha512_224 = (0, St7.wrapConstructor)((() => new Mt6())), Oe3.sha512_256 = (0, St7.wrapConstructor)((() => new It4())), Oe3.sha384 = (0, St7.wrapConstructor)((() => new Tt6()));
var Rt6 = {};
var Pt4 = {};
var Ot6 = {};
var Nt6 = {};
Object.defineProperty(Nt6, "__esModule", { value: true }), Nt6.notImplemented = Nt6.bitMask = void 0, Nt6.isBytes = Bt4, Nt6.abytes = Kt6, Nt6.abool = function(e9, t4) {
  if ("boolean" != typeof t4) throw new Error(`${e9} must be valid boolean, got "${t4}".`);
}, Nt6.bytesToHex = Ut5, Nt6.numberToHexUnpadded = Ht6, Nt6.hexToNumber = Ft2, Nt6.hexToBytes = Wt6, Nt6.bytesToNumberBE = function(e9) {
  return Ft2(Ut5(e9));
}, Nt6.bytesToNumberLE = function(e9) {
  return Kt6(e9), Ft2(Ut5(Uint8Array.from(e9).reverse()));
}, Nt6.numberToBytesBE = Vt4, Nt6.numberToBytesLE = function(e9, t4) {
  return Vt4(e9, t4).reverse();
}, Nt6.numberToVarBytesBE = function(e9) {
  return Wt6(Ht6(e9));
}, Nt6.ensureBytes = function(e9, t4, n4) {
  let r6;
  if ("string" == typeof t4) try {
    r6 = Wt6(t4);
  } catch (n5) {
    throw new Error(`${e9} must be valid hex string, got "${t4}". Cause: ${n5}`);
  }
  else {
    if (!Bt4(t4)) throw new Error(`${e9} must be hex string or Uint8Array`);
    r6 = Uint8Array.from(t4);
  }
  const i6 = r6.length;
  if ("number" == typeof n4 && i6 !== n4) throw new Error(`${e9} expected ${n4} bytes, got ${i6}`);
  return r6;
}, Nt6.concatBytes = Gt6, Nt6.equalBytes = function(e9, t4) {
  if (e9.length !== t4.length) return false;
  let n4 = 0;
  for (let r6 = 0; r6 < e9.length; r6++) n4 |= e9[r6] ^ t4[r6];
  return 0 === n4;
}, Nt6.utf8ToBytes = function(e9) {
  if ("string" != typeof e9) throw new Error("utf8ToBytes expected string, got " + typeof e9);
  return new Uint8Array(new TextEncoder().encode(e9));
}, Nt6.inRange = Zt6, Nt6.aInRange = function(e9, t4, n4, r6) {
  if (!Zt6(t4, n4, r6)) throw new Error(`expected valid ${e9}: ${n4} <= n < ${r6}, got ${typeof t4} ${t4}`);
}, Nt6.bitLen = function(e9) {
  let t4;
  for (t4 = 0; e9 > Lt4; e9 >>= Dt5, t4 += 1) ;
  return t4;
}, Nt6.bitGet = function(e9, t4) {
  return e9 >> BigInt(t4) & Dt5;
}, Nt6.bitSet = function(e9, t4, n4) {
  return e9 | (n4 ? Dt5 : Lt4) << BigInt(t4);
}, Nt6.createHmacDrbg = function(e9, t4, n4) {
  if ("number" != typeof e9 || e9 < 2) throw new Error("hashLen must be a number");
  if ("number" != typeof t4 || t4 < 2) throw new Error("qByteLen must be a number");
  if ("function" != typeof n4) throw new Error("hmacFn must be a function");
  let r6 = Jt6(e9), i6 = Jt6(e9), o4 = 0;
  const s3 = () => {
    r6.fill(1), i6.fill(0), o4 = 0;
  }, a4 = (...e10) => n4(i6, r6, ...e10), c6 = (e10 = Jt6()) => {
    i6 = a4(Qt4([0]), e10), r6 = a4(), 0 !== e10.length && (i6 = a4(Qt4([1]), e10), r6 = a4());
  }, l6 = () => {
    if (o4++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let e10 = 0;
    const n5 = [];
    for (; e10 < t4; ) {
      r6 = a4();
      const t5 = r6.slice();
      n5.push(t5), e10 += r6.length;
    }
    return Gt6(...n5);
  };
  return (e10, t5) => {
    let n5;
    for (s3(), c6(e10); !(n5 = t5(l6())); ) c6();
    return s3(), n5;
  };
}, Nt6.validateObject = function(e9, t4, n4 = {}) {
  const r6 = (t5, n5, r7) => {
    const i6 = Xt6[n5];
    if ("function" != typeof i6) throw new Error(`Invalid validator "${n5}", expected function`);
    const o4 = e9[t5];
    if (!(r7 && void 0 === o4 || i6(o4, e9))) throw new Error(`Invalid param ${String(t5)}=${o4} (${typeof o4}), expected ${n5}`);
  };
  for (const [e10, n5] of Object.entries(t4)) r6(e10, n5, false);
  for (const [e10, t5] of Object.entries(n4)) r6(e10, t5, true);
  return e9;
}, Nt6.memoized = function(e9) {
  const t4 = /* @__PURE__ */ new WeakMap();
  return (n4, ...r6) => {
    const i6 = t4.get(n4);
    if (void 0 !== i6) return i6;
    const o4 = e9(n4, ...r6);
    return t4.set(n4, o4), o4;
  };
};
var Lt4 = BigInt(0);
var Dt5 = BigInt(1);
var $t6 = BigInt(2);
function Bt4(e9) {
  return e9 instanceof Uint8Array || null != e9 && "object" == typeof e9 && "Uint8Array" === e9.constructor.name;
}
function Kt6(e9) {
  if (!Bt4(e9)) throw new Error("Uint8Array expected");
}
var jt5 = Array.from({ length: 256 }, ((e9, t4) => t4.toString(16).padStart(2, "0")));
function Ut5(e9) {
  Kt6(e9);
  let t4 = "";
  for (let n4 = 0; n4 < e9.length; n4++) t4 += jt5[e9[n4]];
  return t4;
}
function Ht6(e9) {
  const t4 = e9.toString(16);
  return 1 & t4.length ? `0${t4}` : t4;
}
function Ft2(e9) {
  if ("string" != typeof e9) throw new Error("hex string expected, got " + typeof e9);
  return BigInt("" === e9 ? "0" : `0x${e9}`);
}
var zt4 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function qt3(e9) {
  return e9 >= zt4._0 && e9 <= zt4._9 ? e9 - zt4._0 : e9 >= zt4._A && e9 <= zt4._F ? e9 - (zt4._A - 10) : e9 >= zt4._a && e9 <= zt4._f ? e9 - (zt4._a - 10) : void 0;
}
function Wt6(e9) {
  if ("string" != typeof e9) throw new Error("hex string expected, got " + typeof e9);
  const t4 = e9.length, n4 = t4 / 2;
  if (t4 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t4);
  const r6 = new Uint8Array(n4);
  for (let t5 = 0, i6 = 0; t5 < n4; t5++, i6 += 2) {
    const n5 = qt3(e9.charCodeAt(i6)), o4 = qt3(e9.charCodeAt(i6 + 1));
    if (void 0 === n5 || void 0 === o4) {
      const t6 = e9[i6] + e9[i6 + 1];
      throw new Error('hex string expected, got non-hex character "' + t6 + '" at index ' + i6);
    }
    r6[t5] = 16 * n5 + o4;
  }
  return r6;
}
function Vt4(e9, t4) {
  return Wt6(e9.toString(16).padStart(2 * t4, "0"));
}
function Gt6(...e9) {
  let t4 = 0;
  for (let n5 = 0; n5 < e9.length; n5++) {
    const r6 = e9[n5];
    Kt6(r6), t4 += r6.length;
  }
  const n4 = new Uint8Array(t4);
  for (let t5 = 0, r6 = 0; t5 < e9.length; t5++) {
    const i6 = e9[t5];
    n4.set(i6, r6), r6 += i6.length;
  }
  return n4;
}
var Yt6 = (e9) => "bigint" == typeof e9 && Lt4 <= e9;
function Zt6(e9, t4, n4) {
  return Yt6(e9) && Yt6(t4) && Yt6(n4) && t4 <= e9 && e9 < n4;
}
Nt6.bitMask = (e9) => ($t6 << BigInt(e9 - 1)) - Dt5;
var Jt6 = (e9) => new Uint8Array(e9);
var Qt4 = (e9) => Uint8Array.from(e9);
var Xt6 = { bigint: (e9) => "bigint" == typeof e9, function: (e9) => "function" == typeof e9, boolean: (e9) => "boolean" == typeof e9, string: (e9) => "string" == typeof e9, stringOrUint8Array: (e9) => "string" == typeof e9 || Bt4(e9), isSafeInteger: (e9) => Number.isSafeInteger(e9), array: (e9) => Array.isArray(e9), field: (e9, t4) => t4.Fp.isValid(e9), hash: (e9) => "function" == typeof e9 && Number.isSafeInteger(e9.outputLen) };
Nt6.notImplemented = () => {
  throw new Error("not implemented");
}, Object.defineProperty(Ot6, "__esModule", { value: true }), Ot6.isNegativeLE = void 0, Ot6.mod = ln3, Ot6.pow = dn3, Ot6.pow2 = function(e9, t4, n4) {
  let r6 = e9;
  for (; t4-- > tn5; ) r6 *= r6, r6 %= n4;
  return r6;
}, Ot6.invert = un3, Ot6.tonelliShanks = hn3, Ot6.FpSqrt = fn5, Ot6.validateField = function(e9) {
  const t4 = pn3.reduce(((e10, t5) => (e10[t5] = "function", e10)), { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" });
  return (0, en5.validateObject)(e9, t4);
}, Ot6.FpPow = gn3, Ot6.FpInvertBatch = mn5, Ot6.FpDiv = function(e9, t4, n4) {
  return e9.mul(t4, "bigint" == typeof n4 ? un3(n4, e9.ORDER) : e9.inv(n4));
}, Ot6.FpLegendre = yn5, Ot6.FpIsSquare = function(e9) {
  const t4 = yn5(e9.ORDER);
  return (n4) => {
    const r6 = t4(e9, n4);
    return e9.eql(r6, e9.ZERO) || e9.eql(r6, e9.ONE);
  };
}, Ot6.nLength = vn5, Ot6.Field = function(e9, t4, n4 = false, r6 = {}) {
  if (e9 <= tn5) throw new Error(`Expected Field ORDER > 0, got ${e9}`);
  const { nBitLength: i6, nByteLength: o4 } = vn5(e9, t4);
  if (o4 > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const s3 = fn5(e9), a4 = Object.freeze({ ORDER: e9, BITS: i6, BYTES: o4, MASK: (0, en5.bitMask)(i6), ZERO: tn5, ONE: nn5, create: (t5) => ln3(t5, e9), isValid: (t5) => {
    if ("bigint" != typeof t5) throw new Error("Invalid field element: expected bigint, got " + typeof t5);
    return tn5 <= t5 && t5 < e9;
  }, is0: (e10) => e10 === tn5, isOdd: (e10) => (e10 & nn5) === nn5, neg: (t5) => ln3(-t5, e9), eql: (e10, t5) => e10 === t5, sqr: (t5) => ln3(t5 * t5, e9), add: (t5, n5) => ln3(t5 + n5, e9), sub: (t5, n5) => ln3(t5 - n5, e9), mul: (t5, n5) => ln3(t5 * n5, e9), pow: (e10, t5) => gn3(a4, e10, t5), div: (t5, n5) => ln3(t5 * un3(n5, e9), e9), sqrN: (e10) => e10 * e10, addN: (e10, t5) => e10 + t5, subN: (e10, t5) => e10 - t5, mulN: (e10, t5) => e10 * t5, inv: (t5) => un3(t5, e9), sqrt: r6.sqrt || ((e10) => s3(a4, e10)), invertBatch: (e10) => mn5(a4, e10), cmov: (e10, t5, n5) => n5 ? t5 : e10, toBytes: (e10) => n4 ? (0, en5.numberToBytesLE)(e10, o4) : (0, en5.numberToBytesBE)(e10, o4), fromBytes: (e10) => {
    if (e10.length !== o4) throw new Error(`Fp.fromBytes: expected ${o4}, got ${e10.length}`);
    return n4 ? (0, en5.bytesToNumberLE)(e10) : (0, en5.bytesToNumberBE)(e10);
  } });
  return Object.freeze(a4);
}, Ot6.FpSqrtOdd = function(e9, t4) {
  if (!e9.isOdd) throw new Error("Field doesn't have isOdd");
  const n4 = e9.sqrt(t4);
  return e9.isOdd(n4) ? n4 : e9.neg(n4);
}, Ot6.FpSqrtEven = function(e9, t4) {
  if (!e9.isOdd) throw new Error("Field doesn't have isOdd");
  const n4 = e9.sqrt(t4);
  return e9.isOdd(n4) ? e9.neg(n4) : n4;
}, Ot6.hashToPrivateScalar = function(e9, t4, n4 = false) {
  e9 = (0, en5.ensureBytes)("privateHash", e9);
  const r6 = e9.length, i6 = vn5(t4).nByteLength + 8;
  if (i6 < 24 || r6 < i6 || r6 > 1024) throw new Error(`hashToPrivateScalar: expected ${i6}-1024 bytes of input, got ${r6}`);
  const o4 = n4 ? (0, en5.bytesToNumberLE)(e9) : (0, en5.bytesToNumberBE)(e9);
  return ln3(o4, t4 - nn5) + nn5;
}, Ot6.getFieldBytesLength = bn5, Ot6.getMinHashLength = wn5, Ot6.mapHashToField = function(e9, t4, n4 = false) {
  const r6 = e9.length, i6 = bn5(t4), o4 = wn5(t4);
  if (r6 < 16 || r6 < o4 || r6 > 1024) throw new Error(`expected ${o4}-1024 bytes of input, got ${r6}`);
  const s3 = ln3(n4 ? (0, en5.bytesToNumberBE)(e9) : (0, en5.bytesToNumberLE)(e9), t4 - nn5) + nn5;
  return n4 ? (0, en5.numberToBytesLE)(s3, i6) : (0, en5.numberToBytesBE)(s3, i6);
};
var en5 = Nt6;
var tn5 = BigInt(0);
var nn5 = BigInt(1);
var rn5 = BigInt(2);
var on6 = BigInt(3);
var sn6 = BigInt(4);
var an3 = BigInt(5);
var cn5 = BigInt(8);
function ln3(e9, t4) {
  const n4 = e9 % t4;
  return n4 >= tn5 ? n4 : t4 + n4;
}
function dn3(e9, t4, n4) {
  if (n4 <= tn5 || t4 < tn5) throw new Error("Expected power/modulo > 0");
  if (n4 === nn5) return tn5;
  let r6 = nn5;
  for (; t4 > tn5; ) t4 & nn5 && (r6 = r6 * e9 % n4), e9 = e9 * e9 % n4, t4 >>= nn5;
  return r6;
}
function un3(e9, t4) {
  if (e9 === tn5 || t4 <= tn5) throw new Error(`invert: expected positive integers, got n=${e9} mod=${t4}`);
  let n4 = ln3(e9, t4), r6 = t4, i6 = tn5, o4 = nn5;
  for (; n4 !== tn5; ) {
    const e10 = r6 % n4, t5 = i6 - o4 * (r6 / n4);
    r6 = n4, n4 = e10, i6 = o4, o4 = t5;
  }
  if (r6 !== nn5) throw new Error("invert: does not exist");
  return ln3(i6, t4);
}
function hn3(e9) {
  const t4 = (e9 - nn5) / rn5;
  let n4, r6, i6;
  for (n4 = e9 - nn5, r6 = 0; n4 % rn5 === tn5; n4 /= rn5, r6++) ;
  for (i6 = rn5; i6 < e9 && dn3(i6, t4, e9) !== e9 - nn5; i6++) ;
  if (1 === r6) {
    const t5 = (e9 + nn5) / sn6;
    return function(e10, n5) {
      const r7 = e10.pow(n5, t5);
      if (!e10.eql(e10.sqr(r7), n5)) throw new Error("Cannot find square root");
      return r7;
    };
  }
  const o4 = (n4 + nn5) / rn5;
  return function(e10, s3) {
    if (e10.pow(s3, t4) === e10.neg(e10.ONE)) throw new Error("Cannot find square root");
    let a4 = r6, c6 = e10.pow(e10.mul(e10.ONE, i6), n4), l6 = e10.pow(s3, o4), d5 = e10.pow(s3, n4);
    for (; !e10.eql(d5, e10.ONE); ) {
      if (e10.eql(d5, e10.ZERO)) return e10.ZERO;
      let t5 = 1;
      for (let n6 = e10.sqr(d5); t5 < a4 && !e10.eql(n6, e10.ONE); t5++) n6 = e10.sqr(n6);
      const n5 = e10.pow(c6, nn5 << BigInt(a4 - t5 - 1));
      c6 = e10.sqr(n5), l6 = e10.mul(l6, n5), d5 = e10.mul(d5, c6), a4 = t5;
    }
    return l6;
  };
}
function fn5(e9) {
  if (e9 % sn6 === on6) {
    const t4 = (e9 + nn5) / sn6;
    return function(e10, n4) {
      const r6 = e10.pow(n4, t4);
      if (!e10.eql(e10.sqr(r6), n4)) throw new Error("Cannot find square root");
      return r6;
    };
  }
  if (e9 % cn5 === an3) {
    const t4 = (e9 - an3) / cn5;
    return function(e10, n4) {
      const r6 = e10.mul(n4, rn5), i6 = e10.pow(r6, t4), o4 = e10.mul(n4, i6), s3 = e10.mul(e10.mul(o4, rn5), i6), a4 = e10.mul(o4, e10.sub(s3, e10.ONE));
      if (!e10.eql(e10.sqr(a4), n4)) throw new Error("Cannot find square root");
      return a4;
    };
  }
  return hn3(e9);
}
BigInt(9), BigInt(16);
Ot6.isNegativeLE = (e9, t4) => (ln3(e9, t4) & nn5) === nn5;
var pn3 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function gn3(e9, t4, n4) {
  if (n4 < tn5) throw new Error("Expected power > 0");
  if (n4 === tn5) return e9.ONE;
  if (n4 === nn5) return t4;
  let r6 = e9.ONE, i6 = t4;
  for (; n4 > tn5; ) n4 & nn5 && (r6 = e9.mul(r6, i6)), i6 = e9.sqr(i6), n4 >>= nn5;
  return r6;
}
function mn5(e9, t4) {
  const n4 = new Array(t4.length), r6 = t4.reduce(((t5, r7, i7) => e9.is0(r7) ? t5 : (n4[i7] = t5, e9.mul(t5, r7))), e9.ONE), i6 = e9.inv(r6);
  return t4.reduceRight(((t5, r7, i7) => e9.is0(r7) ? t5 : (n4[i7] = e9.mul(t5, n4[i7]), e9.mul(t5, r7))), i6), n4;
}
function yn5(e9) {
  const t4 = (e9 - nn5) / rn5;
  return (e10, n4) => e10.pow(n4, t4);
}
function vn5(e9, t4) {
  const n4 = void 0 !== t4 ? t4 : e9.toString(2).length;
  return { nBitLength: n4, nByteLength: Math.ceil(n4 / 8) };
}
function bn5(e9) {
  if ("bigint" != typeof e9) throw new Error("field order must be bigint");
  const t4 = e9.toString(2).length;
  return Math.ceil(t4 / 8);
}
function wn5(e9) {
  const t4 = bn5(e9);
  return t4 + Math.ceil(t4 / 2);
}
Object.defineProperty(Pt4, "__esModule", { value: true }), Pt4.wNAF = function(e9, t4) {
  const n4 = (e10, t5) => {
    const n5 = t5.negate();
    return e10 ? n5 : t5;
  }, r6 = (e10) => {
    if (!Number.isSafeInteger(e10) || e10 <= 0 || e10 > t4) throw new Error(`Wrong window size=${e10}, should be [1..${t4}]`);
  }, i6 = (e10) => {
    r6(e10);
    return { windows: Math.ceil(t4 / e10) + 1, windowSize: 2 ** (e10 - 1) };
  };
  return { constTimeNegate: n4, unsafeLadder(t5, n5) {
    let r7 = e9.ZERO, i7 = t5;
    for (; n5 > _n5; ) n5 & Cn3 && (r7 = r7.add(i7)), i7 = i7.double(), n5 >>= Cn3;
    return r7;
  }, precomputeWindow(e10, t5) {
    const { windows: n5, windowSize: r7 } = i6(t5), o4 = [];
    let s3 = e10, a4 = s3;
    for (let e11 = 0; e11 < n5; e11++) {
      a4 = s3, o4.push(a4);
      for (let e12 = 1; e12 < r7; e12++) a4 = a4.add(s3), o4.push(a4);
      s3 = a4.double();
    }
    return o4;
  }, wNAF(t5, r7, o4) {
    const { windows: s3, windowSize: a4 } = i6(t5);
    let c6 = e9.ZERO, l6 = e9.BASE;
    const d5 = BigInt(2 ** t5 - 1), u6 = 2 ** t5, h7 = BigInt(t5);
    for (let e10 = 0; e10 < s3; e10++) {
      const t6 = e10 * a4;
      let i7 = Number(o4 & d5);
      o4 >>= h7, i7 > a4 && (i7 -= u6, o4 += Cn3);
      const s4 = t6, f12 = t6 + Math.abs(i7) - 1, p7 = e10 % 2 != 0, g3 = i7 < 0;
      0 === i7 ? l6 = l6.add(n4(p7, r7[s4])) : c6 = c6.add(n4(g3, r7[f12]));
    }
    return { p: c6, f: l6 };
  }, wNAFCached(e10, t5, n5) {
    const r7 = An5.get(e10) || 1;
    let i7 = kn3.get(e10);
    return i7 || (i7 = this.precomputeWindow(e10, r7), 1 !== r7 && kn3.set(e10, n5(i7))), this.wNAF(r7, i7, t5);
  }, setWindowSize(e10, t5) {
    r6(t5), An5.set(e10, t5), kn3.delete(e10);
  } };
}, Pt4.pippenger = function(e9, t4, n4, r6) {
  if (!Array.isArray(n4) || !Array.isArray(r6) || r6.length !== n4.length) throw new Error("arrays of points and scalars must have equal length");
  r6.forEach(((e10, n5) => {
    if (!t4.isValid(e10)) throw new Error(`wrong scalar at index ${n5}`);
  })), n4.forEach(((t5, n5) => {
    if (!(t5 instanceof e9)) throw new Error(`wrong point at index ${n5}`);
  }));
  const i6 = (0, Sn5.bitLen)(BigInt(n4.length)), o4 = i6 > 12 ? i6 - 3 : i6 > 4 ? i6 - 2 : i6 ? 2 : 1, s3 = (1 << o4) - 1, a4 = new Array(s3 + 1).fill(e9.ZERO), c6 = Math.floor((t4.BITS - 1) / o4) * o4;
  let l6 = e9.ZERO;
  for (let t5 = c6; t5 >= 0; t5 -= o4) {
    a4.fill(e9.ZERO);
    for (let e10 = 0; e10 < r6.length; e10++) {
      const i8 = r6[e10], o5 = Number(i8 >> BigInt(t5) & BigInt(s3));
      a4[o5] = a4[o5].add(n4[e10]);
    }
    let i7 = e9.ZERO;
    for (let t6 = a4.length - 1, n5 = e9.ZERO; t6 > 0; t6--) n5 = n5.add(a4[t6]), i7 = i7.add(n5);
    if (l6 = l6.add(i7), 0 !== t5) for (let e10 = 0; e10 < o4; e10++) l6 = l6.double();
  }
  return l6;
}, Pt4.validateBasic = function(e9) {
  return (0, En5.validateField)(e9.Fp), (0, Sn5.validateObject)(e9, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...(0, En5.nLength)(e9.n, e9.nBitLength), ...e9, p: e9.Fp.ORDER });
};
var En5 = Ot6;
var Sn5 = Nt6;
var _n5 = BigInt(0);
var Cn3 = BigInt(1);
var kn3 = /* @__PURE__ */ new WeakMap();
var An5 = /* @__PURE__ */ new WeakMap();
Object.defineProperty(Rt6, "__esModule", { value: true }), Rt6.twistedEdwards = function(e9) {
  const t4 = (function(e10) {
    const t5 = (0, xn5.validateBasic)(e10);
    return In5.validateObject(e10, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...t5 });
  })(e9), { Fp: n4, n: r6, prehash: i6, hash: o4, randomBytes: s3, nByteLength: a4, h: c6 } = t4, l6 = On5 << BigInt(8 * a4) - Pn4, d5 = n4.create, u6 = (0, Mn3.Field)(t4.n, t4.nBitLength), h7 = t4.uvRatio || ((e10, t5) => {
    try {
      return { isValid: true, value: n4.sqrt(e10 * n4.inv(t5)) };
    } catch (e11) {
      return { isValid: false, value: Rn5 };
    }
  }), f12 = t4.adjustScalarBytes || ((e10) => e10), p7 = t4.domain || ((e10, t5, n5) => {
    if ((0, Tn5.abool)("phflag", n5), t5.length || n5) throw new Error("Contexts/pre-hash are not supported");
    return e10;
  });
  function g3(e10, t5) {
    In5.aInRange("coordinate " + e10, t5, Rn5, l6);
  }
  function m5(e10) {
    if (!(e10 instanceof b5)) throw new Error("ExtendedPoint expected");
  }
  const y8 = (0, Tn5.memoized)(((e10, t5) => {
    const { ex: r7, ey: i7, ez: o5 } = e10, s4 = e10.is0();
    null == t5 && (t5 = s4 ? Nn5 : n4.inv(o5));
    const a5 = d5(r7 * t5), c7 = d5(i7 * t5), l7 = d5(o5 * t5);
    if (s4) return { x: Rn5, y: Pn4 };
    if (l7 !== Pn4) throw new Error("invZ was invalid");
    return { x: a5, y: c7 };
  })), v7 = (0, Tn5.memoized)(((e10) => {
    const { a: n5, d: r7 } = t4;
    if (e10.is0()) throw new Error("bad point: ZERO");
    const { ex: i7, ey: o5, ez: s4, et: a5 } = e10, c7 = d5(i7 * i7), l7 = d5(o5 * o5), u7 = d5(s4 * s4), h8 = d5(u7 * u7), f13 = d5(c7 * n5);
    if (d5(u7 * d5(f13 + l7)) !== d5(h8 + d5(r7 * d5(c7 * l7)))) throw new Error("bad point: equation left != right (1)");
    if (d5(i7 * o5) !== d5(s4 * a5)) throw new Error("bad point: equation left != right (2)");
    return true;
  }));
  class b5 {
    constructor(e10, t5, n5, r7) {
      this.ex = e10, this.ey = t5, this.ez = n5, this.et = r7, g3("x", e10), g3("y", t5), g3("z", n5), g3("t", r7), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(e10) {
      if (e10 instanceof b5) throw new Error("extended point not allowed");
      const { x: t5, y: n5 } = e10 || {};
      return g3("x", t5), g3("y", n5), new b5(t5, n5, Pn4, d5(t5 * n5));
    }
    static normalizeZ(e10) {
      const t5 = n4.invertBatch(e10.map(((e11) => e11.ez)));
      return e10.map(((e11, n5) => e11.toAffine(t5[n5]))).map(b5.fromAffine);
    }
    static msm(e10, t5) {
      return (0, xn5.pippenger)(b5, u6, e10, t5);
    }
    _setWindowSize(e10) {
      S7.setWindowSize(this, e10);
    }
    assertValidity() {
      v7(this);
    }
    equals(e10) {
      m5(e10);
      const { ex: t5, ey: n5, ez: r7 } = this, { ex: i7, ey: o5, ez: s4 } = e10, a5 = d5(t5 * s4), c7 = d5(i7 * r7), l7 = d5(n5 * s4), u7 = d5(o5 * r7);
      return a5 === c7 && l7 === u7;
    }
    is0() {
      return this.equals(b5.ZERO);
    }
    negate() {
      return new b5(d5(-this.ex), this.ey, this.ez, d5(-this.et));
    }
    double() {
      const { a: e10 } = t4, { ex: n5, ey: r7, ez: i7 } = this, o5 = d5(n5 * n5), s4 = d5(r7 * r7), a5 = d5(On5 * d5(i7 * i7)), c7 = d5(e10 * o5), l7 = n5 + r7, u7 = d5(d5(l7 * l7) - o5 - s4), h8 = c7 + s4, f13 = h8 - a5, p8 = c7 - s4, g4 = d5(u7 * f13), m6 = d5(h8 * p8), y9 = d5(u7 * p8), v8 = d5(f13 * h8);
      return new b5(g4, m6, v8, y9);
    }
    add(e10) {
      m5(e10);
      const { a: n5, d: r7 } = t4, { ex: i7, ey: o5, ez: s4, et: a5 } = this, { ex: c7, ey: l7, ez: u7, et: h8 } = e10;
      if (n5 === BigInt(-1)) {
        const e11 = d5((o5 - i7) * (l7 + c7)), t5 = d5((o5 + i7) * (l7 - c7)), n6 = d5(t5 - e11);
        if (n6 === Rn5) return this.double();
        const r8 = d5(s4 * On5 * h8), f14 = d5(a5 * On5 * u7), p9 = f14 + r8, g5 = t5 + e11, m6 = f14 - r8, y10 = d5(p9 * n6), v9 = d5(g5 * m6), w8 = d5(p9 * m6), E9 = d5(n6 * g5);
        return new b5(y10, v9, E9, w8);
      }
      const f13 = d5(i7 * c7), p8 = d5(o5 * l7), g4 = d5(a5 * r7 * h8), y9 = d5(s4 * u7), v8 = d5((i7 + o5) * (c7 + l7) - f13 - p8), w7 = y9 - g4, E8 = y9 + g4, S8 = d5(p8 - n5 * f13), _5 = d5(v8 * w7), C9 = d5(E8 * S8), k9 = d5(v8 * S8), A9 = d5(w7 * E8);
      return new b5(_5, C9, A9, k9);
    }
    subtract(e10) {
      return this.add(e10.negate());
    }
    wNAF(e10) {
      return S7.wNAFCached(this, e10, b5.normalizeZ);
    }
    multiply(e10) {
      const t5 = e10;
      In5.aInRange("scalar", t5, Pn4, r6);
      const { p: n5, f: i7 } = this.wNAF(t5);
      return b5.normalizeZ([n5, i7])[0];
    }
    multiplyUnsafe(e10) {
      const t5 = e10;
      return In5.aInRange("scalar", t5, Rn5, r6), t5 === Rn5 ? E7 : this.equals(E7) || t5 === Pn4 ? this : this.equals(w6) ? this.wNAF(t5).p : S7.unsafeLadder(this, t5);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c6).is0();
    }
    isTorsionFree() {
      return S7.unsafeLadder(this, r6).is0();
    }
    toAffine(e10) {
      return y8(this, e10);
    }
    clearCofactor() {
      const { h: e10 } = t4;
      return e10 === Pn4 ? this : this.multiplyUnsafe(e10);
    }
    static fromHex(e10, r7 = false) {
      const { d: i7, a: o5 } = t4, s4 = n4.BYTES;
      e10 = (0, Tn5.ensureBytes)("pointHex", e10, s4), (0, Tn5.abool)("zip215", r7);
      const a5 = e10.slice(), c7 = e10[s4 - 1];
      a5[s4 - 1] = -129 & c7;
      const u7 = In5.bytesToNumberLE(a5), f13 = r7 ? l6 : n4.ORDER;
      In5.aInRange("pointHex.y", u7, Rn5, f13);
      const p8 = d5(u7 * u7), g4 = d5(p8 - Pn4), m6 = d5(i7 * p8 - o5);
      let { isValid: y9, value: v8 } = h7(g4, m6);
      if (!y9) throw new Error("Point.fromHex: invalid y coordinate");
      const w7 = (v8 & Pn4) === Pn4, E8 = 0 != (128 & c7);
      if (!r7 && v8 === Rn5 && E8) throw new Error("Point.fromHex: x=0 and x_0=1");
      return E8 !== w7 && (v8 = d5(-v8)), b5.fromAffine({ x: v8, y: u7 });
    }
    static fromPrivateKey(e10) {
      return k8(e10).point;
    }
    toRawBytes() {
      const { x: e10, y: t5 } = this.toAffine(), r7 = In5.numberToBytesLE(t5, n4.BYTES);
      return r7[r7.length - 1] |= e10 & Pn4 ? 128 : 0, r7;
    }
    toHex() {
      return In5.bytesToHex(this.toRawBytes());
    }
  }
  b5.BASE = new b5(t4.Gx, t4.Gy, Pn4, d5(t4.Gx * t4.Gy)), b5.ZERO = new b5(Rn5, Pn4, Pn4, Rn5);
  const { BASE: w6, ZERO: E7 } = b5, S7 = (0, xn5.wNAF)(b5, 8 * a4);
  function _4(e10) {
    return (0, Mn3.mod)(e10, r6);
  }
  function C8(e10) {
    return _4(In5.bytesToNumberLE(e10));
  }
  function k8(e10) {
    const t5 = a4;
    e10 = (0, Tn5.ensureBytes)("private key", e10, t5);
    const n5 = (0, Tn5.ensureBytes)("hashed private key", o4(e10), 2 * t5), r7 = f12(n5.slice(0, t5)), i7 = n5.slice(t5, 2 * t5), s4 = C8(r7), c7 = w6.multiply(s4), l7 = c7.toRawBytes();
    return { head: r7, prefix: i7, scalar: s4, point: c7, pointBytes: l7 };
  }
  function A8(e10 = new Uint8Array(), ...t5) {
    const n5 = In5.concatBytes(...t5);
    return C8(o4(p7(n5, (0, Tn5.ensureBytes)("context", e10), !!i6)));
  }
  const x5 = Ln3;
  w6._setWindowSize(8);
  const M7 = { getExtendedPublicKey: k8, randomPrivateKey: () => s3(n4.BYTES), precompute: (e10 = 8, t5 = b5.BASE) => (t5._setWindowSize(e10), t5.multiply(BigInt(3)), t5) };
  return { CURVE: t4, getPublicKey: function(e10) {
    return k8(e10).pointBytes;
  }, sign: function(e10, t5, o5 = {}) {
    e10 = (0, Tn5.ensureBytes)("message", e10), i6 && (e10 = i6(e10));
    const { prefix: s4, scalar: c7, pointBytes: l7 } = k8(t5), d6 = A8(o5.context, s4, e10), u7 = w6.multiply(d6).toRawBytes(), h8 = _4(d6 + A8(o5.context, u7, l7, e10) * c7);
    In5.aInRange("signature.s", h8, Rn5, r6);
    const f13 = In5.concatBytes(u7, In5.numberToBytesLE(h8, n4.BYTES));
    return (0, Tn5.ensureBytes)("result", f13, 2 * a4);
  }, verify: function(e10, t5, r7, o5 = x5) {
    const { context: s4, zip215: a5 } = o5, c7 = n4.BYTES;
    e10 = (0, Tn5.ensureBytes)("signature", e10, 2 * c7), t5 = (0, Tn5.ensureBytes)("message", t5), void 0 !== a5 && (0, Tn5.abool)("zip215", a5), i6 && (t5 = i6(t5));
    const l7 = In5.bytesToNumberLE(e10.slice(c7, 2 * c7));
    let d6, u7, h8;
    try {
      d6 = b5.fromHex(r7, a5), u7 = b5.fromHex(e10.slice(0, c7), a5), h8 = w6.multiplyUnsafe(l7);
    } catch (e11) {
      return false;
    }
    if (!a5 && d6.isSmallOrder()) return false;
    const f13 = A8(s4, u7.toRawBytes(), d6.toRawBytes(), t5);
    return u7.add(d6.multiplyUnsafe(f13)).subtract(h8).clearCofactor().equals(b5.ZERO);
  }, ExtendedPoint: b5, utils: M7 };
};
var xn5 = Pt4;
var Mn3 = Ot6;
var In5 = Nt6;
var Tn5 = Nt6;
var Rn5 = BigInt(0);
var Pn4 = BigInt(1);
var On5 = BigInt(2);
var Nn5 = BigInt(8);
var Ln3 = { zip215: true };
var Dn3 = {};
Object.defineProperty(Dn3, "__esModule", { value: true }), Dn3.expand_message_xmd = Fn5, Dn3.expand_message_xof = zn5, Dn3.hash_to_field = qn5, Dn3.isogenyMap = function(e9, t4) {
  const n4 = t4.map(((e10) => Array.from(e10).reverse()));
  return (t5, r6) => {
    const [i6, o4, s3, a4] = n4.map(((n5) => n5.reduce(((n6, r7) => e9.add(e9.mul(n6, t5), r7)))));
    return t5 = e9.div(i6, o4), r6 = e9.mul(r6, e9.div(s3, a4)), { x: t5, y: r6 };
  };
}, Dn3.createHasher = function(e9, t4, n4) {
  if ("function" != typeof t4) throw new Error("mapToCurve() must be defined");
  return { hashToCurve(r6, i6) {
    const o4 = qn5(r6, 2, { ...n4, DST: n4.DST, ...i6 }), s3 = e9.fromAffine(t4(o4[0])), a4 = e9.fromAffine(t4(o4[1])), c6 = s3.add(a4).clearCofactor();
    return c6.assertValidity(), c6;
  }, encodeToCurve(r6, i6) {
    const o4 = qn5(r6, 1, { ...n4, DST: n4.encodeDST, ...i6 }), s3 = e9.fromAffine(t4(o4[0])).clearCofactor();
    return s3.assertValidity(), s3;
  }, mapToCurve(n5) {
    if (!Array.isArray(n5)) throw new Error("mapToCurve: expected array of bigints");
    for (const e10 of n5) if ("bigint" != typeof e10) throw new Error(`mapToCurve: expected array of bigints, got ${e10} in array`);
    const r6 = e9.fromAffine(t4(n5)).clearCofactor();
    return r6.assertValidity(), r6;
  } };
};
var $n3 = Ot6;
var Bn5 = Nt6;
var Kn5 = Bn5.bytesToNumberBE;
function jn3(e9, t4) {
  if (Hn3(e9), Hn3(t4), e9 < 0 || e9 >= 1 << 8 * t4) throw new Error(`bad I2OSP call: value=${e9} length=${t4}`);
  const n4 = Array.from({ length: t4 }).fill(0);
  for (let r6 = t4 - 1; r6 >= 0; r6--) n4[r6] = 255 & e9, e9 >>>= 8;
  return new Uint8Array(n4);
}
function Un5(e9, t4) {
  const n4 = new Uint8Array(e9.length);
  for (let r6 = 0; r6 < e9.length; r6++) n4[r6] = e9[r6] ^ t4[r6];
  return n4;
}
function Hn3(e9) {
  if (!Number.isSafeInteger(e9)) throw new Error("number expected");
}
function Fn5(e9, t4, n4, r6) {
  (0, Bn5.abytes)(e9), (0, Bn5.abytes)(t4), Hn3(n4), t4.length > 255 && (t4 = r6((0, Bn5.concatBytes)((0, Bn5.utf8ToBytes)("H2C-OVERSIZE-DST-"), t4)));
  const { outputLen: i6, blockLen: o4 } = r6, s3 = Math.ceil(n4 / i6);
  if (n4 > 65535 || s3 > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
  const a4 = (0, Bn5.concatBytes)(t4, jn3(t4.length, 1)), c6 = jn3(0, o4), l6 = jn3(n4, 2), d5 = new Array(s3), u6 = r6((0, Bn5.concatBytes)(c6, e9, l6, jn3(0, 1), a4));
  d5[0] = r6((0, Bn5.concatBytes)(u6, jn3(1, 1), a4));
  for (let e10 = 1; e10 <= s3; e10++) {
    const t5 = [Un5(u6, d5[e10 - 1]), jn3(e10 + 1, 1), a4];
    d5[e10] = r6((0, Bn5.concatBytes)(...t5));
  }
  return (0, Bn5.concatBytes)(...d5).slice(0, n4);
}
function zn5(e9, t4, n4, r6, i6) {
  if ((0, Bn5.abytes)(e9), (0, Bn5.abytes)(t4), Hn3(n4), t4.length > 255) {
    const e10 = Math.ceil(2 * r6 / 8);
    t4 = i6.create({ dkLen: e10 }).update((0, Bn5.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t4).digest();
  }
  if (n4 > 65535 || t4.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
  return i6.create({ dkLen: n4 }).update(e9).update(jn3(n4, 2)).update(t4).update(jn3(t4.length, 1)).digest();
}
function qn5(e9, t4, n4) {
  (0, Bn5.validateObject)(n4, { DST: "stringOrUint8Array", p: "bigint", m: "isSafeInteger", k: "isSafeInteger", hash: "hash" });
  const { p: r6, k: i6, m: o4, hash: s3, expand: a4, DST: c6 } = n4;
  (0, Bn5.abytes)(e9), Hn3(t4);
  const l6 = "string" == typeof c6 ? (0, Bn5.utf8ToBytes)(c6) : c6, d5 = r6.toString(2).length, u6 = Math.ceil((d5 + i6) / 8), h7 = t4 * o4 * u6;
  let f12;
  if ("xmd" === a4) f12 = Fn5(e9, l6, h7, s3);
  else if ("xof" === a4) f12 = zn5(e9, l6, h7, i6, s3);
  else {
    if ("_internal_pass" !== a4) throw new Error('expand must be "xmd" or "xof"');
    f12 = e9;
  }
  const p7 = new Array(t4);
  for (let e10 = 0; e10 < t4; e10++) {
    const t5 = new Array(o4);
    for (let n5 = 0; n5 < o4; n5++) {
      const i7 = u6 * (n5 + e10 * o4), s4 = f12.subarray(i7, i7 + u6);
      t5[n5] = (0, $n3.mod)(Kn5(s4), r6);
    }
    p7[e10] = t5;
  }
  return p7;
}
var Wn2 = {};
Object.defineProperty(Wn2, "__esModule", { value: true }), Wn2.montgomery = function(e9) {
  const t4 = (function(e10) {
    return (0, Gn2.validateObject)(e10, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e10 });
  })(e9), { P: n4 } = t4, r6 = (e10) => (0, Vn3.mod)(e10, n4), i6 = t4.montgomeryBits, o4 = Math.ceil(i6 / 8), s3 = t4.nByteLength, a4 = t4.adjustScalarBytes || ((e10) => e10), c6 = t4.powPminus2 || ((e10) => (0, Vn3.pow)(e10, n4 - BigInt(2), n4));
  function l6(e10, t5, n5) {
    const i7 = r6(e10 * (t5 - n5));
    return [t5 = r6(t5 - i7), n5 = r6(n5 + i7)];
  }
  const d5 = (t4.a - BigInt(2)) / BigInt(4);
  function u6(e10) {
    return (0, Gn2.numberToBytesLE)(r6(e10), o4);
  }
  function h7(e10, t5) {
    const h8 = (function(e11) {
      const t6 = (0, Gn2.ensureBytes)("u coordinate", e11, o4);
      return 32 === s3 && (t6[31] &= 127), (0, Gn2.bytesToNumberLE)(t6);
    })(t5), f13 = (function(e11) {
      const t6 = (0, Gn2.ensureBytes)("scalar", e11), n5 = t6.length;
      if (n5 !== o4 && n5 !== s3) throw new Error(`Expected ${o4} or ${s3} bytes, got ${n5}`);
      return (0, Gn2.bytesToNumberLE)(a4(t6));
    })(e10), p8 = (function(e11, t6) {
      (0, Gn2.aInRange)("u", e11, Yn2, n4), (0, Gn2.aInRange)("scalar", t6, Yn2, n4);
      const o5 = t6, s4 = e11;
      let a5, u7 = Zn2, h9 = Yn2, f14 = e11, p9 = Zn2, g3 = Yn2;
      for (let e12 = BigInt(i6 - 1); e12 >= Yn2; e12--) {
        const t7 = o5 >> e12 & Zn2;
        g3 ^= t7, a5 = l6(g3, u7, f14), u7 = a5[0], f14 = a5[1], a5 = l6(g3, h9, p9), h9 = a5[0], p9 = a5[1], g3 = t7;
        const n5 = u7 + h9, i7 = r6(n5 * n5), c7 = u7 - h9, m6 = r6(c7 * c7), y8 = i7 - m6, v7 = f14 + p9, b5 = r6((f14 - p9) * n5), w6 = r6(v7 * c7), E7 = b5 + w6, S7 = b5 - w6;
        f14 = r6(E7 * E7), p9 = r6(s4 * r6(S7 * S7)), u7 = r6(i7 * m6), h9 = r6(y8 * (i7 + r6(d5 * y8)));
      }
      a5 = l6(g3, u7, f14), u7 = a5[0], f14 = a5[1], a5 = l6(g3, h9, p9), h9 = a5[0], p9 = a5[1];
      const m5 = c6(h9);
      return r6(u7 * m5);
    })(h8, f13);
    if (p8 === Yn2) throw new Error("Invalid private or public key received");
    return u6(p8);
  }
  const f12 = u6(t4.Gu);
  function p7(e10) {
    return h7(e10, f12);
  }
  return { scalarMult: h7, scalarMultBase: p7, getSharedSecret: (e10, t5) => h7(e10, t5), getPublicKey: (e10) => p7(e10), utils: { randomPrivateKey: () => t4.randomBytes(t4.nByteLength) }, GuBytes: f12 };
};
var Vn3 = Ot6;
var Gn2 = Nt6;
var Yn2 = BigInt(0);
var Zn2 = BigInt(1);
!(function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.hash_to_ristretto255 = e9.hashToRistretto255 = e9.RistrettoPoint = e9.encodeToCurve = e9.hashToCurve = e9.edwardsToMontgomery = e9.x25519 = e9.ed25519ph = e9.ed25519ctx = e9.ed25519 = e9.ED25519_TORSION_SUBGROUP = void 0, e9.edwardsToMontgomeryPub = S7, e9.edwardsToMontgomeryPriv = function(e10) {
    const t5 = w6.hash(e10.subarray(0, 32));
    return w6.adjustScalarBytes(t5).subarray(0, 32);
  };
  const t4 = Oe3, n4 = ze3, r6 = Rt6, i6 = Dn3, o4 = Ot6, s3 = Wn2, a4 = Nt6, c6 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), l6 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"), d5 = BigInt(0), u6 = BigInt(1), h7 = BigInt(2), f12 = BigInt(3), p7 = BigInt(5), g3 = BigInt(8);
  function m5(e10) {
    const t5 = BigInt(10), n5 = BigInt(20), r7 = BigInt(40), i7 = BigInt(80), s4 = c6, a5 = e10 * e10 % s4 * e10 % s4, l7 = (0, o4.pow2)(a5, h7, s4) * a5 % s4, d6 = (0, o4.pow2)(l7, u6, s4) * e10 % s4, f13 = (0, o4.pow2)(d6, p7, s4) * d6 % s4, g4 = (0, o4.pow2)(f13, t5, s4) * f13 % s4, m6 = (0, o4.pow2)(g4, n5, s4) * g4 % s4, y9 = (0, o4.pow2)(m6, r7, s4) * m6 % s4, v8 = (0, o4.pow2)(y9, i7, s4) * y9 % s4, b6 = (0, o4.pow2)(v8, i7, s4) * y9 % s4, w7 = (0, o4.pow2)(b6, t5, s4) * f13 % s4;
    return { pow_p_5_8: (0, o4.pow2)(w7, h7, s4) * e10 % s4, b2: a5 };
  }
  function y8(e10) {
    return e10[0] &= 248, e10[31] &= 127, e10[31] |= 64, e10;
  }
  function v7(e10, t5) {
    const n5 = c6, r7 = (0, o4.mod)(t5 * t5 * t5, n5), i7 = m5(e10 * (0, o4.mod)(r7 * r7 * t5, n5)).pow_p_5_8;
    let s4 = (0, o4.mod)(e10 * r7 * i7, n5);
    const a5 = (0, o4.mod)(t5 * s4 * s4, n5), d6 = s4, u7 = (0, o4.mod)(s4 * l6, n5), h8 = a5 === e10, f13 = a5 === (0, o4.mod)(-e10, n5), p8 = a5 === (0, o4.mod)(-e10 * l6, n5);
    return h8 && (s4 = d6), (f13 || p8) && (s4 = u7), (0, o4.isNegativeLE)(s4, n5) && (s4 = (0, o4.mod)(-s4, n5)), { isValid: h8 || f13, value: s4 };
  }
  e9.ED25519_TORSION_SUBGROUP = ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];
  const b5 = (() => (0, o4.Field)(c6, void 0, true))(), w6 = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: b5, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: g3, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: t4.sha512, randomBytes: n4.randomBytes, adjustScalarBytes: y8, uvRatio: v7 }))();
  function E7(e10, t5, r7) {
    if (t5.length > 255) throw new Error("Context is too big");
    return (0, n4.concatBytes)((0, n4.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([r7 ? 1 : 0, t5.length]), t5, e10);
  }
  function S7(t5) {
    const { y: n5 } = e9.ed25519.ExtendedPoint.fromHex(t5), r7 = BigInt(1);
    return b5.toBytes(b5.create((r7 + n5) * b5.inv(r7 - n5)));
  }
  e9.ed25519 = (0, r6.twistedEdwards)(w6), e9.ed25519ctx = (0, r6.twistedEdwards)({ ...w6, domain: E7 }), e9.ed25519ph = (0, r6.twistedEdwards)(Object.assign({}, w6, { domain: E7, prehash: t4.sha512 })), e9.x25519 = (0, s3.montgomery)({ P: c6, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e10) => {
    const t5 = c6, { pow_p_5_8: n5, b2: r7 } = m5(e10);
    return (0, o4.mod)((0, o4.pow2)(n5, f12, t5) * r7, t5);
  }, adjustScalarBytes: y8, randomBytes: n4.randomBytes }), e9.edwardsToMontgomery = S7;
  const _4 = (() => (b5.ORDER + f12) / g3)(), C8 = (() => b5.pow(h7, _4))(), k8 = (() => b5.sqrt(b5.neg(b5.ONE)))();
  const A8 = (() => (0, o4.FpSqrtEven)(b5, b5.neg(BigInt(486664))))();
  function x5(e10) {
    const { xMn: t5, xMd: n5, yMn: r7, yMd: i7 } = (function(e11) {
      const t6 = (b5.ORDER - p7) / g3, n6 = BigInt(486662);
      let r8 = b5.sqr(e11);
      r8 = b5.mul(r8, h7);
      let i8 = b5.add(r8, b5.ONE), o6 = b5.neg(n6), s5 = b5.sqr(i8), a6 = b5.mul(s5, i8), c8 = b5.mul(r8, n6);
      c8 = b5.mul(c8, o6), c8 = b5.add(c8, s5), c8 = b5.mul(c8, o6);
      let l8 = b5.sqr(a6);
      s5 = b5.sqr(l8), l8 = b5.mul(l8, a6), l8 = b5.mul(l8, c8), s5 = b5.mul(s5, l8);
      let d7 = b5.pow(s5, t6);
      d7 = b5.mul(d7, l8);
      let f14 = b5.mul(d7, k8);
      s5 = b5.sqr(d7), s5 = b5.mul(s5, a6);
      let m6 = b5.eql(s5, c8), y9 = b5.cmov(f14, d7, m6), v8 = b5.mul(o6, r8), w7 = b5.mul(d7, e11);
      w7 = b5.mul(w7, C8);
      let E8 = b5.mul(w7, k8), S8 = b5.mul(c8, r8);
      s5 = b5.sqr(w7), s5 = b5.mul(s5, a6);
      let _5 = b5.eql(s5, S8), A9 = b5.cmov(E8, w7, _5);
      s5 = b5.sqr(y9), s5 = b5.mul(s5, a6);
      let x6 = b5.eql(s5, c8), M8 = b5.cmov(v8, o6, x6), I8 = b5.cmov(A9, y9, x6), T7 = b5.isOdd(I8);
      return I8 = b5.cmov(I8, b5.neg(I8), x6 !== T7), { xMn: M8, xMd: i8, yMn: I8, yMd: u6 };
    })(e10);
    let o5 = b5.mul(t5, i7);
    o5 = b5.mul(o5, A8);
    let s4 = b5.mul(n5, r7), a5 = b5.sub(t5, n5), c7 = b5.add(t5, n5), l7 = b5.mul(s4, c7), d6 = b5.eql(l7, b5.ZERO);
    o5 = b5.cmov(o5, b5.ZERO, d6), s4 = b5.cmov(s4, b5.ONE, d6), a5 = b5.cmov(a5, b5.ONE, d6), c7 = b5.cmov(c7, b5.ONE, d6);
    const f13 = b5.invertBatch([s4, c7]);
    return { x: b5.mul(o5, f13[0]), y: b5.mul(a5, f13[1]) };
  }
  const M7 = (() => (0, i6.createHasher)(e9.ed25519.ExtendedPoint, ((e10) => x5(e10[0])), { DST: "edwards25519_XMD:SHA-512_ELL2_RO_", encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_", p: b5.ORDER, m: 1, k: 128, expand: "xmd", hash: t4.sha512 }))();
  function I7(e10) {
    if (!(e10 instanceof K4)) throw new Error("RistrettoPoint expected");
  }
  e9.hashToCurve = M7.hashToCurve, e9.encodeToCurve = M7.encodeToCurve;
  const T6 = l6, R6 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), P6 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), O6 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), N8 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), L6 = (e10) => v7(u6, e10), D9 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), $7 = (t5) => e9.ed25519.CURVE.Fp.create((0, a4.bytesToNumberLE)(t5) & D9);
  function B7(t5) {
    const { d: n5 } = e9.ed25519.CURVE, r7 = e9.ed25519.CURVE.Fp.ORDER, i7 = e9.ed25519.CURVE.Fp.create, s4 = i7(T6 * t5 * t5), a5 = i7((s4 + u6) * O6);
    let c7 = BigInt(-1);
    const l7 = i7((c7 - n5 * s4) * i7(s4 + n5));
    let { isValid: d6, value: h8 } = v7(a5, l7), f13 = i7(h8 * t5);
    (0, o4.isNegativeLE)(f13, r7) || (f13 = i7(-f13)), d6 || (h8 = f13), d6 || (c7 = s4);
    const p8 = i7(c7 * (s4 - u6) * N8 - l7), g4 = h8 * h8, m6 = i7((h8 + h8) * l7), y9 = i7(p8 * R6), b6 = i7(u6 - g4), w7 = i7(u6 + g4);
    return new e9.ed25519.ExtendedPoint(i7(m6 * w7), i7(b6 * y9), i7(y9 * w7), i7(m6 * b6));
  }
  class K4 {
    constructor(e10) {
      this.ep = e10;
    }
    static fromAffine(t5) {
      return new K4(e9.ed25519.ExtendedPoint.fromAffine(t5));
    }
    static hashToCurve(e10) {
      e10 = (0, a4.ensureBytes)("ristrettoHash", e10, 64);
      const t5 = B7($7(e10.slice(0, 32))), n5 = B7($7(e10.slice(32, 64)));
      return new K4(t5.add(n5));
    }
    static fromHex(t5) {
      t5 = (0, a4.ensureBytes)("ristrettoHex", t5, 32);
      const { a: n5, d: r7 } = e9.ed25519.CURVE, i7 = e9.ed25519.CURVE.Fp.ORDER, s4 = e9.ed25519.CURVE.Fp.create, c7 = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", l7 = $7(t5);
      if (!(0, a4.equalBytes)((0, a4.numberToBytesLE)(l7, 32), t5) || (0, o4.isNegativeLE)(l7, i7)) throw new Error(c7);
      const h8 = s4(l7 * l7), f13 = s4(u6 + n5 * h8), p8 = s4(u6 - n5 * h8), g4 = s4(f13 * f13), m6 = s4(p8 * p8), y9 = s4(n5 * r7 * g4 - m6), { isValid: v8, value: b6 } = L6(s4(y9 * m6)), w7 = s4(b6 * p8), E8 = s4(b6 * w7 * y9);
      let S8 = s4((l7 + l7) * w7);
      (0, o4.isNegativeLE)(S8, i7) && (S8 = s4(-S8));
      const _5 = s4(f13 * E8), C9 = s4(S8 * _5);
      if (!v8 || (0, o4.isNegativeLE)(C9, i7) || _5 === d5) throw new Error(c7);
      return new K4(new e9.ed25519.ExtendedPoint(S8, _5, u6, C9));
    }
    toRawBytes() {
      let { ex: t5, ey: n5, ez: r7, et: i7 } = this.ep;
      const s4 = e9.ed25519.CURVE.Fp.ORDER, c7 = e9.ed25519.CURVE.Fp.create, l7 = c7(c7(r7 + n5) * c7(r7 - n5)), d6 = c7(t5 * n5), u7 = c7(d6 * d6), { value: h8 } = L6(c7(l7 * u7)), f13 = c7(h8 * l7), p8 = c7(h8 * d6), g4 = c7(f13 * p8 * i7);
      let m6;
      if ((0, o4.isNegativeLE)(i7 * g4, s4)) {
        let e10 = c7(n5 * T6), r8 = c7(t5 * T6);
        t5 = e10, n5 = r8, m6 = c7(f13 * P6);
      } else m6 = p8;
      (0, o4.isNegativeLE)(t5 * g4, s4) && (n5 = c7(-n5));
      let y9 = c7((r7 - n5) * m6);
      return (0, o4.isNegativeLE)(y9, s4) && (y9 = c7(-y9)), (0, a4.numberToBytesLE)(y9, 32);
    }
    toHex() {
      return (0, a4.bytesToHex)(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(t5) {
      I7(t5);
      const { ex: n5, ey: r7 } = this.ep, { ex: i7, ey: o5 } = t5.ep, s4 = e9.ed25519.CURVE.Fp.create, a5 = s4(n5 * o5) === s4(r7 * i7), c7 = s4(r7 * o5) === s4(n5 * i7);
      return a5 || c7;
    }
    add(e10) {
      return I7(e10), new K4(this.ep.add(e10.ep));
    }
    subtract(e10) {
      return I7(e10), new K4(this.ep.subtract(e10.ep));
    }
    multiply(e10) {
      return new K4(this.ep.multiply(e10));
    }
    multiplyUnsafe(e10) {
      return new K4(this.ep.multiplyUnsafe(e10));
    }
    double() {
      return new K4(this.ep.double());
    }
    negate() {
      return new K4(this.ep.negate());
    }
  }
  e9.RistrettoPoint = (K4.BASE || (K4.BASE = new K4(e9.ed25519.ExtendedPoint.BASE)), K4.ZERO || (K4.ZERO = new K4(e9.ed25519.ExtendedPoint.ZERO)), K4);
  e9.hashToRistretto255 = (e10, r7) => {
    const o5 = r7.DST, s4 = "string" == typeof o5 ? (0, n4.utf8ToBytes)(o5) : o5, a5 = (0, i6.expand_message_xmd)(e10, s4, 64, t4.sha512);
    return K4.hashToCurve(a5);
  }, e9.hash_to_ristretto255 = e9.hashToRistretto255;
})(Pe6);
var Jn3 = {};
var Qn3 = {};
Object.defineProperty(Qn3, "__esModule", { value: true }), Qn3.sha224 = Qn3.sha256 = Qn3.SHA256 = void 0;
var Xn2 = Ne3;
var er2 = ze3;
var tr3 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var nr2 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var rr3 = new Uint32Array(64);
var ir3 = class extends Xn2.HashMD {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | nr2[0], this.B = 0 | nr2[1], this.C = 0 | nr2[2], this.D = 0 | nr2[3], this.E = 0 | nr2[4], this.F = 0 | nr2[5], this.G = 0 | nr2[6], this.H = 0 | nr2[7];
  }
  get() {
    const { A: e9, B: t4, C: n4, D: r6, E: i6, F: o4, G: s3, H: a4 } = this;
    return [e9, t4, n4, r6, i6, o4, s3, a4];
  }
  set(e9, t4, n4, r6, i6, o4, s3, a4) {
    this.A = 0 | e9, this.B = 0 | t4, this.C = 0 | n4, this.D = 0 | r6, this.E = 0 | i6, this.F = 0 | o4, this.G = 0 | s3, this.H = 0 | a4;
  }
  process(e9, t4) {
    for (let n5 = 0; n5 < 16; n5++, t4 += 4) rr3[n5] = e9.getUint32(t4, false);
    for (let e10 = 16; e10 < 64; e10++) {
      const t5 = rr3[e10 - 15], n5 = rr3[e10 - 2], r7 = (0, er2.rotr)(t5, 7) ^ (0, er2.rotr)(t5, 18) ^ t5 >>> 3, i7 = (0, er2.rotr)(n5, 17) ^ (0, er2.rotr)(n5, 19) ^ n5 >>> 10;
      rr3[e10] = i7 + rr3[e10 - 7] + r7 + rr3[e10 - 16] | 0;
    }
    let { A: n4, B: r6, C: i6, D: o4, E: s3, F: a4, G: c6, H: l6 } = this;
    for (let e10 = 0; e10 < 64; e10++) {
      const t5 = l6 + ((0, er2.rotr)(s3, 6) ^ (0, er2.rotr)(s3, 11) ^ (0, er2.rotr)(s3, 25)) + (0, Xn2.Chi)(s3, a4, c6) + tr3[e10] + rr3[e10] | 0, d5 = ((0, er2.rotr)(n4, 2) ^ (0, er2.rotr)(n4, 13) ^ (0, er2.rotr)(n4, 22)) + (0, Xn2.Maj)(n4, r6, i6) | 0;
      l6 = c6, c6 = a4, a4 = s3, s3 = o4 + t5 | 0, o4 = i6, i6 = r6, r6 = n4, n4 = t5 + d5 | 0;
    }
    n4 = n4 + this.A | 0, r6 = r6 + this.B | 0, i6 = i6 + this.C | 0, o4 = o4 + this.D | 0, s3 = s3 + this.E | 0, a4 = a4 + this.F | 0, c6 = c6 + this.G | 0, l6 = l6 + this.H | 0, this.set(n4, r6, i6, o4, s3, a4, c6, l6);
  }
  roundClean() {
    rr3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
Qn3.SHA256 = ir3;
var or3 = class extends ir3 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
Qn3.sha256 = (0, er2.wrapConstructor)((() => new ir3())), Qn3.sha224 = (0, er2.wrapConstructor)((() => new or3()));
var sr3 = {};
var ar2 = {};
!(function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.hmac = e9.HMAC = void 0;
  const t4 = Le7, n4 = ze3;
  class r6 extends n4.Hash {
    constructor(e10, r7) {
      super(), this.finished = false, this.destroyed = false, (0, t4.hash)(e10);
      const i6 = (0, n4.toBytes)(r7);
      if (this.iHash = e10.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const o4 = this.blockLen, s3 = new Uint8Array(o4);
      s3.set(i6.length > o4 ? e10.create().update(i6).digest() : i6);
      for (let e11 = 0; e11 < s3.length; e11++) s3[e11] ^= 54;
      this.iHash.update(s3), this.oHash = e10.create();
      for (let e11 = 0; e11 < s3.length; e11++) s3[e11] ^= 106;
      this.oHash.update(s3), s3.fill(0);
    }
    update(e10) {
      return (0, t4.exists)(this), this.iHash.update(e10), this;
    }
    digestInto(e10) {
      (0, t4.exists)(this), (0, t4.bytes)(e10, this.outputLen), this.finished = true, this.iHash.digestInto(e10), this.oHash.update(e10), this.oHash.digestInto(e10), this.destroy();
    }
    digest() {
      const e10 = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(e10), e10;
    }
    _cloneInto(e10) {
      e10 || (e10 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: t5, iHash: n5, finished: r7, destroyed: i6, blockLen: o4, outputLen: s3 } = this;
      return e10.finished = r7, e10.destroyed = i6, e10.blockLen = o4, e10.outputLen = s3, e10.oHash = t5._cloneInto(e10.oHash), e10.iHash = n5._cloneInto(e10.iHash), e10;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e9.HMAC = r6;
  e9.hmac = (e10, t5, n5) => new r6(e10, t5).update(n5).digest(), e9.hmac.create = (e10, t5) => new r6(e10, t5);
})(ar2);
var cr3 = {};
!(function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.DER = void 0, e9.weierstrassPoints = f12, e9.weierstrass = function(s4) {
    const a5 = (function(e10) {
      const n5 = (0, t4.validateBasic)(e10);
      return r6.validateObject(n5, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...n5 });
    })(s4), { Fp: d6, n: u7 } = a5, h8 = d6.BYTES + 1, p8 = 2 * d6.BYTES + 1;
    function g3(e10) {
      return n4.mod(e10, u7);
    }
    function m5(e10) {
      return n4.invert(e10, u7);
    }
    const { ProjectivePoint: y8, normPrivateKeyToScalar: v7, weierstrassEquation: b5, isWithinCurveOrder: w6 } = f12({ ...a5, toBytes(e10, t5, n5) {
      const o5 = t5.toAffine(), s5 = d6.toBytes(o5.x), a6 = r6.concatBytes;
      return (0, i6.abool)("isCompressed", n5), n5 ? a6(Uint8Array.from([t5.hasEvenY() ? 2 : 3]), s5) : a6(Uint8Array.from([4]), s5, d6.toBytes(o5.y));
    }, fromBytes(e10) {
      const t5 = e10.length, n5 = e10[0], i7 = e10.subarray(1);
      if (t5 !== h8 || 2 !== n5 && 3 !== n5) {
        if (t5 === p8 && 4 === n5) {
          return { x: d6.fromBytes(i7.subarray(0, d6.BYTES)), y: d6.fromBytes(i7.subarray(d6.BYTES, 2 * d6.BYTES)) };
        }
        throw new Error(`Point of length ${t5} was invalid. Expected ${h8} compressed bytes or ${p8} uncompressed bytes`);
      }
      {
        const e11 = r6.bytesToNumberBE(i7);
        if (!r6.inRange(e11, l6, d6.ORDER)) throw new Error("Point is not on curve");
        const t6 = b5(e11);
        let o5;
        try {
          o5 = d6.sqrt(t6);
        } catch (e12) {
          const t7 = e12 instanceof Error ? ": " + e12.message : "";
          throw new Error("Point is not on curve" + t7);
        }
        return 1 == (1 & n5) !== ((o5 & l6) === l6) && (o5 = d6.neg(o5)), { x: e11, y: o5 };
      }
    } }), E7 = (e10) => r6.bytesToHex(r6.numberToBytesBE(e10, a5.nByteLength));
    function S7(e10) {
      return e10 > u7 >> l6;
    }
    const _4 = (e10, t5, n5) => r6.bytesToNumberBE(e10.slice(t5, n5));
    class C8 {
      constructor(e10, t5, n5) {
        this.r = e10, this.s = t5, this.recovery = n5, this.assertValidity();
      }
      static fromCompact(e10) {
        const t5 = a5.nByteLength;
        return e10 = (0, i6.ensureBytes)("compactSignature", e10, 2 * t5), new C8(_4(e10, 0, t5), _4(e10, t5, 2 * t5));
      }
      static fromDER(t5) {
        const { r: n5, s: r7 } = e9.DER.toSig((0, i6.ensureBytes)("DER", t5));
        return new C8(n5, r7);
      }
      assertValidity() {
        r6.aInRange("r", this.r, l6, u7), r6.aInRange("s", this.s, l6, u7);
      }
      addRecoveryBit(e10) {
        return new C8(this.r, this.s, e10);
      }
      recoverPublicKey(e10) {
        const { r: t5, s: n5, recovery: r7 } = this, o5 = M7((0, i6.ensureBytes)("msgHash", e10));
        if (null == r7 || ![0, 1, 2, 3].includes(r7)) throw new Error("recovery id invalid");
        const s5 = 2 === r7 || 3 === r7 ? t5 + a5.n : t5;
        if (s5 >= d6.ORDER) throw new Error("recovery id 2 or 3 invalid");
        const c7 = 0 == (1 & r7) ? "02" : "03", l7 = y8.fromHex(c7 + E7(s5)), u8 = m5(s5), h9 = g3(-o5 * u8), f13 = g3(n5 * u8), p9 = y8.BASE.multiplyAndAddUnsafe(l7, h9, f13);
        if (!p9) throw new Error("point at infinify");
        return p9.assertValidity(), p9;
      }
      hasHighS() {
        return S7(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new C8(this.r, g3(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return r6.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e9.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return r6.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return E7(this.r) + E7(this.s);
      }
    }
    const k8 = { isValidPrivateKey(e10) {
      try {
        return v7(e10), true;
      } catch (e11) {
        return false;
      }
    }, normPrivateKeyToScalar: v7, randomPrivateKey: () => {
      const e10 = n4.getMinHashLength(a5.n);
      return n4.mapHashToField(a5.randomBytes(e10), a5.n);
    }, precompute: (e10 = 8, t5 = y8.BASE) => (t5._setWindowSize(e10), t5.multiply(BigInt(3)), t5) };
    function A8(e10) {
      const t5 = r6.isBytes(e10), n5 = "string" == typeof e10, i7 = (t5 || n5) && e10.length;
      return t5 ? i7 === h8 || i7 === p8 : n5 ? i7 === 2 * h8 || i7 === 2 * p8 : e10 instanceof y8;
    }
    const x5 = a5.bits2int || function(e10) {
      const t5 = r6.bytesToNumberBE(e10), n5 = 8 * e10.length - a5.nBitLength;
      return n5 > 0 ? t5 >> BigInt(n5) : t5;
    }, M7 = a5.bits2int_modN || function(e10) {
      return g3(x5(e10));
    }, I7 = r6.bitMask(a5.nBitLength);
    function T6(e10) {
      return r6.aInRange(`num < 2^${a5.nBitLength}`, e10, c6, I7), r6.numberToBytesBE(e10, a5.nByteLength);
    }
    function R6(e10, t5, n5 = P6) {
      if (["recovered", "canonical"].some(((e11) => e11 in n5))) throw new Error("sign() legacy options not supported");
      const { hash: s5, randomBytes: u8 } = a5;
      let { lowS: h9, prehash: f13, extraEntropy: p9 } = n5;
      null == h9 && (h9 = true), e10 = (0, i6.ensureBytes)("msgHash", e10), o4(n5), f13 && (e10 = (0, i6.ensureBytes)("prehashed msgHash", s5(e10)));
      const b6 = M7(e10), E8 = v7(t5), _5 = [T6(E8), T6(b6)];
      if (null != p9 && false !== p9) {
        const e11 = true === p9 ? u8(d6.BYTES) : p9;
        _5.push((0, i6.ensureBytes)("extraEntropy", e11));
      }
      const k9 = r6.concatBytes(..._5), A9 = b6;
      return { seed: k9, k2sig: function(e11) {
        const t6 = x5(e11);
        if (!w6(t6)) return;
        const n6 = m5(t6), r7 = y8.BASE.multiply(t6).toAffine(), i7 = g3(r7.x);
        if (i7 === c6) return;
        const o5 = g3(n6 * g3(A9 + i7 * E8));
        if (o5 === c6) return;
        let s6 = (r7.x === i7 ? 0 : 2) | Number(r7.y & l6), a6 = o5;
        return h9 && S7(o5) && (a6 = (function(e12) {
          return S7(e12) ? g3(-e12) : e12;
        })(o5), s6 ^= 1), new C8(i7, a6, s6);
      } };
    }
    const P6 = { lowS: a5.lowS, prehash: false }, O6 = { lowS: a5.lowS, prehash: false };
    return y8.BASE._setWindowSize(8), { CURVE: a5, getPublicKey: function(e10, t5 = true) {
      return y8.fromPrivateKey(e10).toRawBytes(t5);
    }, getSharedSecret: function(e10, t5, n5 = true) {
      if (A8(e10)) throw new Error("first arg must be private key");
      if (!A8(t5)) throw new Error("second arg must be public key");
      const r7 = y8.fromHex(t5);
      return r7.multiply(v7(e10)).toRawBytes(n5);
    }, sign: function(e10, t5, n5 = P6) {
      const { seed: i7, k2sig: o5 } = R6(e10, t5, n5), s5 = a5, c7 = r6.createHmacDrbg(s5.hash.outputLen, s5.nByteLength, s5.hmac);
      return c7(i7, o5);
    }, verify: function(t5, n5, s5, c7 = O6) {
      const l7 = t5;
      if (n5 = (0, i6.ensureBytes)("msgHash", n5), s5 = (0, i6.ensureBytes)("publicKey", s5), "strict" in c7) throw new Error("options.strict was renamed to lowS");
      o4(c7);
      const { lowS: d7, prehash: u8 } = c7;
      let h9, f13;
      try {
        if ("string" == typeof l7 || r6.isBytes(l7)) try {
          h9 = C8.fromDER(l7);
        } catch (t6) {
          if (!(t6 instanceof e9.DER.Err)) throw t6;
          h9 = C8.fromCompact(l7);
        }
        else {
          if ("object" != typeof l7 || "bigint" != typeof l7.r || "bigint" != typeof l7.s) throw new Error("PARSE");
          {
            const { r: e10, s: t6 } = l7;
            h9 = new C8(e10, t6);
          }
        }
        f13 = y8.fromHex(s5);
      } catch (e10) {
        if ("PARSE" === e10.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return false;
      }
      if (d7 && h9.hasHighS()) return false;
      u8 && (n5 = a5.hash(n5));
      const { r: p9, s: v8 } = h9, b6 = M7(n5), w7 = m5(v8), E8 = g3(b6 * w7), S8 = g3(p9 * w7), _5 = y8.BASE.multiplyAndAddUnsafe(f13, E8, S8)?.toAffine();
      if (!_5) return false;
      const k9 = g3(_5.x);
      return k9 === p9;
    }, ProjectivePoint: y8, Signature: C8, utils: k8 };
  }, e9.SWUFpSqrtRatio = p7, e9.mapToCurveSimpleSWU = function(e10, t5) {
    if (n4.validateField(e10), !e10.isValid(t5.A) || !e10.isValid(t5.B) || !e10.isValid(t5.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const r7 = p7(e10, t5.Z);
    if (!e10.isOdd) throw new Error("Fp.isOdd is not implemented!");
    return (n5) => {
      let i7, o5, s4, a5, c7, l7, d6, u7;
      i7 = e10.sqr(n5), i7 = e10.mul(i7, t5.Z), o5 = e10.sqr(i7), o5 = e10.add(o5, i7), s4 = e10.add(o5, e10.ONE), s4 = e10.mul(s4, t5.B), a5 = e10.cmov(t5.Z, e10.neg(o5), !e10.eql(o5, e10.ZERO)), a5 = e10.mul(a5, t5.A), o5 = e10.sqr(s4), l7 = e10.sqr(a5), c7 = e10.mul(l7, t5.A), o5 = e10.add(o5, c7), o5 = e10.mul(o5, s4), l7 = e10.mul(l7, a5), c7 = e10.mul(l7, t5.B), o5 = e10.add(o5, c7), d6 = e10.mul(i7, s4);
      const { isValid: h8, value: f13 } = r7(o5, l7);
      u7 = e10.mul(i7, n5), u7 = e10.mul(u7, f13), d6 = e10.cmov(d6, s4, h8), u7 = e10.cmov(u7, f13, h8);
      const p8 = e10.isOdd(n5) === e10.isOdd(u7);
      return u7 = e10.cmov(e10.neg(u7), u7, p8), d6 = e10.div(d6, a5), { x: d6, y: u7 };
    };
  };
  const t4 = Pt4, n4 = Ot6, r6 = Nt6, i6 = Nt6;
  function o4(e10) {
    void 0 !== e10.lowS && (0, i6.abool)("lowS", e10.lowS), void 0 !== e10.prehash && (0, i6.abool)("prehash", e10.prehash);
  }
  const { bytesToNumberBE: s3, hexToBytes: a4 } = r6;
  e9.DER = { Err: class extends Error {
    constructor(e10 = "") {
      super(e10);
    }
  }, _tlv: { encode: (t5, n5) => {
    const { Err: i7 } = e9.DER;
    if (t5 < 0 || t5 > 256) throw new i7("tlv.encode: wrong tag");
    if (1 & n5.length) throw new i7("tlv.encode: unpadded data");
    const o5 = n5.length / 2, s4 = r6.numberToHexUnpadded(o5);
    if (s4.length / 2 & 128) throw new i7("tlv.encode: long form length too big");
    const a5 = o5 > 127 ? r6.numberToHexUnpadded(s4.length / 2 | 128) : "";
    return `${r6.numberToHexUnpadded(t5)}${a5}${s4}${n5}`;
  }, decode(t5, n5) {
    const { Err: r7 } = e9.DER;
    let i7 = 0;
    if (t5 < 0 || t5 > 256) throw new r7("tlv.encode: wrong tag");
    if (n5.length < 2 || n5[i7++] !== t5) throw new r7("tlv.decode: wrong tlv");
    const o5 = n5[i7++];
    let s4 = 0;
    if (!!(128 & o5)) {
      const e10 = 127 & o5;
      if (!e10) throw new r7("tlv.decode(long): indefinite length not supported");
      if (e10 > 4) throw new r7("tlv.decode(long): byte length is too big");
      const t6 = n5.subarray(i7, i7 + e10);
      if (t6.length !== e10) throw new r7("tlv.decode: length bytes not complete");
      if (0 === t6[0]) throw new r7("tlv.decode(long): zero leftmost byte");
      for (const e11 of t6) s4 = s4 << 8 | e11;
      if (i7 += e10, s4 < 128) throw new r7("tlv.decode(long): not minimal encoding");
    } else s4 = o5;
    const a5 = n5.subarray(i7, i7 + s4);
    if (a5.length !== s4) throw new r7("tlv.decode: wrong value length");
    return { v: a5, l: n5.subarray(i7 + s4) };
  } }, _int: { encode(t5) {
    const { Err: n5 } = e9.DER;
    if (t5 < c6) throw new n5("integer: negative integers are not allowed");
    let i7 = r6.numberToHexUnpadded(t5);
    if (8 & Number.parseInt(i7[0], 16) && (i7 = "00" + i7), 1 & i7.length) throw new n5("unexpected assertion");
    return i7;
  }, decode(t5) {
    const { Err: n5 } = e9.DER;
    if (128 & t5[0]) throw new n5("Invalid signature integer: negative");
    if (0 === t5[0] && !(128 & t5[1])) throw new n5("Invalid signature integer: unnecessary leading zero");
    return s3(t5);
  } }, toSig(t5) {
    const { Err: n5, _int: i7, _tlv: o5 } = e9.DER, s4 = "string" == typeof t5 ? a4(t5) : t5;
    r6.abytes(s4);
    const { v: c7, l: l7 } = o5.decode(48, s4);
    if (l7.length) throw new n5("Invalid signature: left bytes after parsing");
    const { v: d6, l: u7 } = o5.decode(2, c7), { v: h8, l: f13 } = o5.decode(2, u7);
    if (f13.length) throw new n5("Invalid signature: left bytes after parsing");
    return { r: i7.decode(d6), s: i7.decode(h8) };
  }, hexFromSig(t5) {
    const { _tlv: n5, _int: r7 } = e9.DER, i7 = `${n5.encode(2, r7.encode(t5.r))}${n5.encode(2, r7.encode(t5.s))}`;
    return n5.encode(48, i7);
  } };
  const c6 = BigInt(0), l6 = BigInt(1), d5 = BigInt(2), u6 = BigInt(3), h7 = BigInt(4);
  function f12(e10) {
    const o5 = (function(e11) {
      const n5 = (0, t4.validateBasic)(e11);
      r6.validateObject(n5, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
      const { endo: i7, Fp: o6, a: s5 } = n5;
      if (i7) {
        if (!o6.eql(s5, o6.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if ("object" != typeof i7 || "bigint" != typeof i7.beta || "function" != typeof i7.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
      return Object.freeze({ ...n5 });
    })(e10), { Fp: s4 } = o5, a5 = n4.Field(o5.n, o5.nBitLength), d6 = o5.toBytes || ((e11, t5, n5) => {
      const i7 = t5.toAffine();
      return r6.concatBytes(Uint8Array.from([4]), s4.toBytes(i7.x), s4.toBytes(i7.y));
    }), h8 = o5.fromBytes || ((e11) => {
      const t5 = e11.subarray(1);
      return { x: s4.fromBytes(t5.subarray(0, s4.BYTES)), y: s4.fromBytes(t5.subarray(s4.BYTES, 2 * s4.BYTES)) };
    });
    function f13(e11) {
      const { a: t5, b: n5 } = o5, r7 = s4.sqr(e11), i7 = s4.mul(r7, e11);
      return s4.add(s4.add(i7, s4.mul(e11, t5)), n5);
    }
    if (!s4.eql(s4.sqr(o5.Gy), f13(o5.Gx))) throw new Error("bad generator point: equation left != right");
    function p8(e11) {
      const { allowedPrivateKeyLengths: t5, nByteLength: s5, wrapPrivateKey: a6, n: c7 } = o5;
      if (t5 && "bigint" != typeof e11) {
        if (r6.isBytes(e11) && (e11 = r6.bytesToHex(e11)), "string" != typeof e11 || !t5.includes(e11.length)) throw new Error("Invalid key");
        e11 = e11.padStart(2 * s5, "0");
      }
      let d7;
      try {
        d7 = "bigint" == typeof e11 ? e11 : r6.bytesToNumberBE((0, i6.ensureBytes)("private key", e11, s5));
      } catch (t6) {
        throw new Error(`private key must be ${s5} bytes, hex or bigint, not ${typeof e11}`);
      }
      return a6 && (d7 = n4.mod(d7, c7)), r6.aInRange("private key", d7, l6, c7), d7;
    }
    function g3(e11) {
      if (!(e11 instanceof v7)) throw new Error("ProjectivePoint expected");
    }
    const m5 = (0, i6.memoized)(((e11, t5) => {
      const { px: n5, py: r7, pz: i7 } = e11;
      if (s4.eql(i7, s4.ONE)) return { x: n5, y: r7 };
      const o6 = e11.is0();
      null == t5 && (t5 = o6 ? s4.ONE : s4.inv(i7));
      const a6 = s4.mul(n5, t5), c7 = s4.mul(r7, t5), l7 = s4.mul(i7, t5);
      if (o6) return { x: s4.ZERO, y: s4.ZERO };
      if (!s4.eql(l7, s4.ONE)) throw new Error("invZ was invalid");
      return { x: a6, y: c7 };
    })), y8 = (0, i6.memoized)(((e11) => {
      if (e11.is0()) {
        if (o5.allowInfinityPoint && !s4.is0(e11.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: t5, y: n5 } = e11.toAffine();
      if (!s4.isValid(t5) || !s4.isValid(n5)) throw new Error("bad point: x or y not FE");
      const r7 = s4.sqr(n5), i7 = f13(t5);
      if (!s4.eql(r7, i7)) throw new Error("bad point: equation left != right");
      if (!e11.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
      return true;
    }));
    class v7 {
      constructor(e11, t5, n5) {
        if (this.px = e11, this.py = t5, this.pz = n5, null == e11 || !s4.isValid(e11)) throw new Error("x required");
        if (null == t5 || !s4.isValid(t5)) throw new Error("y required");
        if (null == n5 || !s4.isValid(n5)) throw new Error("z required");
        Object.freeze(this);
      }
      static fromAffine(e11) {
        const { x: t5, y: n5 } = e11 || {};
        if (!e11 || !s4.isValid(t5) || !s4.isValid(n5)) throw new Error("invalid affine point");
        if (e11 instanceof v7) throw new Error("projective point not allowed");
        const r7 = (e12) => s4.eql(e12, s4.ZERO);
        return r7(t5) && r7(n5) ? v7.ZERO : new v7(t5, n5, s4.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(e11) {
        const t5 = s4.invertBatch(e11.map(((e12) => e12.pz)));
        return e11.map(((e12, n5) => e12.toAffine(t5[n5]))).map(v7.fromAffine);
      }
      static fromHex(e11) {
        const t5 = v7.fromAffine(h8((0, i6.ensureBytes)("pointHex", e11)));
        return t5.assertValidity(), t5;
      }
      static fromPrivateKey(e11) {
        return v7.BASE.multiply(p8(e11));
      }
      static msm(e11, n5) {
        return (0, t4.pippenger)(v7, a5, e11, n5);
      }
      _setWindowSize(e11) {
        w6.setWindowSize(this, e11);
      }
      assertValidity() {
        y8(this);
      }
      hasEvenY() {
        const { y: e11 } = this.toAffine();
        if (s4.isOdd) return !s4.isOdd(e11);
        throw new Error("Field doesn't support isOdd");
      }
      equals(e11) {
        g3(e11);
        const { px: t5, py: n5, pz: r7 } = this, { px: i7, py: o6, pz: a6 } = e11, c7 = s4.eql(s4.mul(t5, a6), s4.mul(i7, r7)), l7 = s4.eql(s4.mul(n5, a6), s4.mul(o6, r7));
        return c7 && l7;
      }
      negate() {
        return new v7(this.px, s4.neg(this.py), this.pz);
      }
      double() {
        const { a: e11, b: t5 } = o5, n5 = s4.mul(t5, u6), { px: r7, py: i7, pz: a6 } = this;
        let c7 = s4.ZERO, l7 = s4.ZERO, d7 = s4.ZERO, h9 = s4.mul(r7, r7), f14 = s4.mul(i7, i7), p9 = s4.mul(a6, a6), g4 = s4.mul(r7, i7);
        return g4 = s4.add(g4, g4), d7 = s4.mul(r7, a6), d7 = s4.add(d7, d7), c7 = s4.mul(e11, d7), l7 = s4.mul(n5, p9), l7 = s4.add(c7, l7), c7 = s4.sub(f14, l7), l7 = s4.add(f14, l7), l7 = s4.mul(c7, l7), c7 = s4.mul(g4, c7), d7 = s4.mul(n5, d7), p9 = s4.mul(e11, p9), g4 = s4.sub(h9, p9), g4 = s4.mul(e11, g4), g4 = s4.add(g4, d7), d7 = s4.add(h9, h9), h9 = s4.add(d7, h9), h9 = s4.add(h9, p9), h9 = s4.mul(h9, g4), l7 = s4.add(l7, h9), p9 = s4.mul(i7, a6), p9 = s4.add(p9, p9), h9 = s4.mul(p9, g4), c7 = s4.sub(c7, h9), d7 = s4.mul(p9, f14), d7 = s4.add(d7, d7), d7 = s4.add(d7, d7), new v7(c7, l7, d7);
      }
      add(e11) {
        g3(e11);
        const { px: t5, py: n5, pz: r7 } = this, { px: i7, py: a6, pz: c7 } = e11;
        let l7 = s4.ZERO, d7 = s4.ZERO, h9 = s4.ZERO;
        const f14 = o5.a, p9 = s4.mul(o5.b, u6);
        let m6 = s4.mul(t5, i7), y9 = s4.mul(n5, a6), b6 = s4.mul(r7, c7), w7 = s4.add(t5, n5), E7 = s4.add(i7, a6);
        w7 = s4.mul(w7, E7), E7 = s4.add(m6, y9), w7 = s4.sub(w7, E7), E7 = s4.add(t5, r7);
        let S7 = s4.add(i7, c7);
        return E7 = s4.mul(E7, S7), S7 = s4.add(m6, b6), E7 = s4.sub(E7, S7), S7 = s4.add(n5, r7), l7 = s4.add(a6, c7), S7 = s4.mul(S7, l7), l7 = s4.add(y9, b6), S7 = s4.sub(S7, l7), h9 = s4.mul(f14, E7), l7 = s4.mul(p9, b6), h9 = s4.add(l7, h9), l7 = s4.sub(y9, h9), h9 = s4.add(y9, h9), d7 = s4.mul(l7, h9), y9 = s4.add(m6, m6), y9 = s4.add(y9, m6), b6 = s4.mul(f14, b6), E7 = s4.mul(p9, E7), y9 = s4.add(y9, b6), b6 = s4.sub(m6, b6), b6 = s4.mul(f14, b6), E7 = s4.add(E7, b6), m6 = s4.mul(y9, E7), d7 = s4.add(d7, m6), m6 = s4.mul(S7, E7), l7 = s4.mul(w7, l7), l7 = s4.sub(l7, m6), m6 = s4.mul(w7, y9), h9 = s4.mul(S7, h9), h9 = s4.add(h9, m6), new v7(l7, d7, h9);
      }
      subtract(e11) {
        return this.add(e11.negate());
      }
      is0() {
        return this.equals(v7.ZERO);
      }
      wNAF(e11) {
        return w6.wNAFCached(this, e11, v7.normalizeZ);
      }
      multiplyUnsafe(e11) {
        r6.aInRange("scalar", e11, c6, o5.n);
        const t5 = v7.ZERO;
        if (e11 === c6) return t5;
        if (e11 === l6) return this;
        const { endo: n5 } = o5;
        if (!n5) return w6.unsafeLadder(this, e11);
        let { k1neg: i7, k1: a6, k2neg: d7, k2: u7 } = n5.splitScalar(e11), h9 = t5, f14 = t5, p9 = this;
        for (; a6 > c6 || u7 > c6; ) a6 & l6 && (h9 = h9.add(p9)), u7 & l6 && (f14 = f14.add(p9)), p9 = p9.double(), a6 >>= l6, u7 >>= l6;
        return i7 && (h9 = h9.negate()), d7 && (f14 = f14.negate()), f14 = new v7(s4.mul(f14.px, n5.beta), f14.py, f14.pz), h9.add(f14);
      }
      multiply(e11) {
        const { endo: t5, n: n5 } = o5;
        let i7, a6;
        if (r6.aInRange("scalar", e11, l6, n5), t5) {
          const { k1neg: n6, k1: r7, k2neg: o6, k2: c7 } = t5.splitScalar(e11);
          let { p: l7, f: d7 } = this.wNAF(r7), { p: u7, f: h9 } = this.wNAF(c7);
          l7 = w6.constTimeNegate(n6, l7), u7 = w6.constTimeNegate(o6, u7), u7 = new v7(s4.mul(u7.px, t5.beta), u7.py, u7.pz), i7 = l7.add(u7), a6 = d7.add(h9);
        } else {
          const { p: t6, f: n6 } = this.wNAF(e11);
          i7 = t6, a6 = n6;
        }
        return v7.normalizeZ([i7, a6])[0];
      }
      multiplyAndAddUnsafe(e11, t5, n5) {
        const r7 = v7.BASE, i7 = (e12, t6) => t6 !== c6 && t6 !== l6 && e12.equals(r7) ? e12.multiply(t6) : e12.multiplyUnsafe(t6), o6 = i7(this, t5).add(i7(e11, n5));
        return o6.is0() ? void 0 : o6;
      }
      toAffine(e11) {
        return m5(this, e11);
      }
      isTorsionFree() {
        const { h: e11, isTorsionFree: t5 } = o5;
        if (e11 === l6) return true;
        if (t5) return t5(v7, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: e11, clearCofactor: t5 } = o5;
        return e11 === l6 ? this : t5 ? t5(v7, this) : this.multiplyUnsafe(o5.h);
      }
      toRawBytes(e11 = true) {
        return (0, i6.abool)("isCompressed", e11), this.assertValidity(), d6(v7, this, e11);
      }
      toHex(e11 = true) {
        return (0, i6.abool)("isCompressed", e11), r6.bytesToHex(this.toRawBytes(e11));
      }
    }
    v7.BASE = new v7(o5.Gx, o5.Gy, s4.ONE), v7.ZERO = new v7(s4.ZERO, s4.ONE, s4.ZERO);
    const b5 = o5.nBitLength, w6 = (0, t4.wNAF)(v7, o5.endo ? Math.ceil(b5 / 2) : b5);
    return { CURVE: o5, ProjectivePoint: v7, normPrivateKeyToScalar: p8, weierstrassEquation: f13, isWithinCurveOrder: function(e11) {
      return r6.inRange(e11, l6, o5.n);
    } };
  }
  function p7(e10, t5) {
    const n5 = e10.ORDER;
    let r7 = c6;
    for (let e11 = n5 - l6; e11 % d5 === c6; e11 /= d5) r7 += l6;
    const i7 = r7, o5 = d5 << i7 - l6 - l6, s4 = o5 * d5, a5 = (n5 - l6) / s4, f13 = (a5 - l6) / d5, p8 = s4 - l6, g3 = o5, m5 = e10.pow(t5, a5), y8 = e10.pow(t5, (a5 + l6) / d5);
    let v7 = (t6, n6) => {
      let r8 = m5, o6 = e10.pow(n6, p8), s5 = e10.sqr(o6);
      s5 = e10.mul(s5, n6);
      let a6 = e10.mul(t6, s5);
      a6 = e10.pow(a6, f13), a6 = e10.mul(a6, o6), o6 = e10.mul(a6, n6), s5 = e10.mul(a6, t6);
      let c7 = e10.mul(s5, o6);
      a6 = e10.pow(c7, g3);
      let u7 = e10.eql(a6, e10.ONE);
      o6 = e10.mul(s5, y8), a6 = e10.mul(c7, r8), s5 = e10.cmov(o6, s5, u7), c7 = e10.cmov(a6, c7, u7);
      for (let t7 = i7; t7 > l6; t7--) {
        let n7 = t7 - d5;
        n7 = d5 << n7 - l6;
        let i8 = e10.pow(c7, n7);
        const a7 = e10.eql(i8, e10.ONE);
        o6 = e10.mul(s5, r8), r8 = e10.mul(r8, r8), i8 = e10.mul(c7, r8), s5 = e10.cmov(o6, s5, a7), c7 = e10.cmov(i8, c7, a7);
      }
      return { isValid: u7, value: s5 };
    };
    if (e10.ORDER % h7 === u6) {
      const n6 = (e10.ORDER - u6) / h7, r8 = e10.sqrt(e10.neg(t5));
      v7 = (t6, i8) => {
        let o6 = e10.sqr(i8);
        const s5 = e10.mul(t6, i8);
        o6 = e10.mul(o6, s5);
        let a6 = e10.pow(o6, n6);
        a6 = e10.mul(a6, s5);
        const c7 = e10.mul(a6, r8), l7 = e10.mul(e10.sqr(a6), i8), d6 = e10.eql(l7, t6);
        return { isValid: d6, value: e10.cmov(c7, a6, d6) };
      };
    }
    return v7;
  }
})(cr3), Object.defineProperty(sr3, "__esModule", { value: true }), sr3.getHash = hr3, sr3.createCurve = function(e9, t4) {
  const n4 = (t5) => (0, ur2.weierstrass)({ ...e9, ...hr3(t5) });
  return Object.freeze({ ...n4(t4), create: n4 });
};
var lr2 = ar2;
var dr3 = ze3;
var ur2 = cr3;
function hr3(e9) {
  return { hash: e9, hmac: (t4, ...n4) => (0, lr2.hmac)(e9, t4, (0, dr3.concatBytes)(...n4)), randomBytes: dr3.randomBytes };
}
!(function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.encodeToCurve = e9.hashToCurve = e9.schnorr = e9.secp256k1 = void 0;
  const t4 = Qn3, n4 = ze3, r6 = sr3, i6 = Dn3, o4 = Ot6, s3 = Nt6, a4 = cr3, c6 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), l6 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), d5 = BigInt(1), u6 = BigInt(2), h7 = (e10, t5) => (e10 + t5 / u6) / t5;
  function f12(e10) {
    const t5 = c6, n5 = BigInt(3), r7 = BigInt(6), i7 = BigInt(11), s4 = BigInt(22), a5 = BigInt(23), l7 = BigInt(44), d6 = BigInt(88), h8 = e10 * e10 * e10 % t5, f13 = h8 * h8 * e10 % t5, g4 = (0, o4.pow2)(f13, n5, t5) * f13 % t5, m6 = (0, o4.pow2)(g4, n5, t5) * f13 % t5, y9 = (0, o4.pow2)(m6, u6, t5) * h8 % t5, v8 = (0, o4.pow2)(y9, i7, t5) * y9 % t5, b6 = (0, o4.pow2)(v8, s4, t5) * v8 % t5, w7 = (0, o4.pow2)(b6, l7, t5) * b6 % t5, E8 = (0, o4.pow2)(w7, d6, t5) * w7 % t5, S8 = (0, o4.pow2)(E8, l7, t5) * b6 % t5, _5 = (0, o4.pow2)(S8, n5, t5) * f13 % t5, C9 = (0, o4.pow2)(_5, a5, t5) * v8 % t5, k9 = (0, o4.pow2)(C9, r7, t5) * h8 % t5, A9 = (0, o4.pow2)(k9, u6, t5);
    if (!p7.eql(p7.sqr(A9), e10)) throw new Error("Cannot find square root");
    return A9;
  }
  const p7 = (0, o4.Field)(c6, void 0, void 0, { sqrt: f12 });
  e9.secp256k1 = (0, r6.createCurve)({ a: BigInt(0), b: BigInt(7), Fp: p7, n: l6, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), h: BigInt(1), lowS: true, endo: { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar: (e10) => {
    const t5 = l6, n5 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r7 = -d5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i7 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s4 = n5, a5 = BigInt("0x100000000000000000000000000000000"), c7 = h7(s4 * e10, t5), u7 = h7(-r7 * e10, t5);
    let f13 = (0, o4.mod)(e10 - c7 * n5 - u7 * i7, t5), p8 = (0, o4.mod)(-c7 * r7 - u7 * s4, t5);
    const g4 = f13 > a5, m6 = p8 > a5;
    if (g4 && (f13 = t5 - f13), m6 && (p8 = t5 - p8), f13 > a5 || p8 > a5) throw new Error("splitScalar: Endomorphism failed, k=" + e10);
    return { k1neg: g4, k1: f13, k2neg: m6, k2: p8 };
  } } }, t4.sha256);
  const g3 = BigInt(0), m5 = {};
  function y8(e10, ...n5) {
    let r7 = m5[e10];
    if (void 0 === r7) {
      const n6 = (0, t4.sha256)(Uint8Array.from(e10, ((e11) => e11.charCodeAt(0))));
      r7 = (0, s3.concatBytes)(n6, n6), m5[e10] = r7;
    }
    return (0, t4.sha256)((0, s3.concatBytes)(r7, ...n5));
  }
  const v7 = (e10) => e10.toRawBytes(true).slice(1), b5 = (e10) => (0, s3.numberToBytesBE)(e10, 32), w6 = (e10) => (0, o4.mod)(e10, c6), E7 = (e10) => (0, o4.mod)(e10, l6), S7 = e9.secp256k1.ProjectivePoint, _4 = (e10, t5, n5) => S7.BASE.multiplyAndAddUnsafe(e10, t5, n5);
  function C8(t5) {
    let n5 = e9.secp256k1.utils.normPrivateKeyToScalar(t5), r7 = S7.fromPrivateKey(n5);
    return { scalar: r7.hasEvenY() ? n5 : E7(-n5), bytes: v7(r7) };
  }
  function k8(e10) {
    (0, s3.aInRange)("x", e10, d5, c6);
    const t5 = w6(e10 * e10);
    let n5 = f12(w6(t5 * e10 + BigInt(7)));
    n5 % u6 !== g3 && (n5 = w6(-n5));
    const r7 = new S7(e10, n5, d5);
    return r7.assertValidity(), r7;
  }
  const A8 = s3.bytesToNumberBE;
  function x5(...e10) {
    return E7(A8(y8("BIP0340/challenge", ...e10)));
  }
  function M7(e10) {
    return C8(e10).bytes;
  }
  function I7(e10, t5, r7 = (0, n4.randomBytes)(32)) {
    const i7 = (0, s3.ensureBytes)("message", e10), { bytes: o5, scalar: a5 } = C8(t5), c7 = (0, s3.ensureBytes)("auxRand", r7, 32), l7 = b5(a5 ^ A8(y8("BIP0340/aux", c7))), d6 = y8("BIP0340/nonce", l7, o5, i7), u7 = E7(A8(d6));
    if (u7 === g3) throw new Error("sign failed: k is zero");
    const { bytes: h8, scalar: f13 } = C8(u7), p8 = x5(h8, o5, i7), m6 = new Uint8Array(64);
    if (m6.set(h8, 0), m6.set(b5(E7(f13 + p8 * a5)), 32), !T6(m6, i7, o5)) throw new Error("sign: Invalid signature produced");
    return m6;
  }
  function T6(e10, t5, n5) {
    const r7 = (0, s3.ensureBytes)("signature", e10, 64), i7 = (0, s3.ensureBytes)("message", t5), o5 = (0, s3.ensureBytes)("publicKey", n5, 32);
    try {
      const e11 = k8(A8(o5)), t6 = A8(r7.subarray(0, 32));
      if (!(0, s3.inRange)(t6, d5, c6)) return false;
      const n6 = A8(r7.subarray(32, 64));
      if (!(0, s3.inRange)(n6, d5, l6)) return false;
      const a5 = x5(b5(t6), v7(e11), i7), u7 = _4(e11, n6, E7(-a5));
      return !(!u7 || !u7.hasEvenY() || u7.toAffine().x !== t6);
    } catch (e11) {
      return false;
    }
  }
  e9.schnorr = { getPublicKey: M7, sign: I7, verify: T6, utils: { randomPrivateKey: e9.secp256k1.utils.randomPrivateKey, lift_x: k8, pointToBytes: v7, numberToBytesBE: s3.numberToBytesBE, bytesToNumberBE: s3.bytesToNumberBE, taggedHash: y8, mod: o4.mod } };
  const R6 = (() => (0, i6.isogenyMap)(p7, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map(((e10) => e10.map(((e11) => BigInt(e11)))))))(), P6 = (() => (0, a4.mapToCurveSimpleSWU)(p7, { A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"), B: BigInt("1771"), Z: p7.create(BigInt("-11")) }))(), O6 = (() => (0, i6.createHasher)(e9.secp256k1.ProjectivePoint, ((e10) => {
    const { x: t5, y: n5 } = P6(p7.create(e10[0]));
    return R6(t5, n5);
  }), { DST: "secp256k1_XMD:SHA-256_SSWU_RO_", encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_", p: p7.ORDER, m: 1, k: 128, expand: "xmd", hash: t4.sha256 }))();
  e9.hashToCurve = O6.hashToCurve, e9.encodeToCurve = O6.encodeToCurve;
})(Jn3);
var fr3 = {};
!(function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.decodeHex = e9.remove0x = void 0;
  var t4 = pe6;
  e9.remove0x = function(e10) {
    return e10.startsWith("0x") || e10.startsWith("0X") ? e10.slice(2) : e10;
  };
  e9.decodeHex = function(n4) {
    return (0, t4.hexToBytes)((0, e9.remove0x)(n4));
  };
})(fr3), (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.hexToPublicKey = e9.convertPublicKeyFormat = e9.getSharedPoint = e9.getPublicKey = e9.isValidPrivateKey = e9.getValidSecret = void 0;
  var t4 = Te4, n4 = Pe6, r6 = Jn3, i6 = Ce7, o4 = ke7, s3 = fr3;
  e9.getValidSecret = function() {
    var n5;
    do {
      n5 = (0, t4.randomBytes)(o4.SECRET_KEY_LENGTH);
    } while (!(0, e9.isValidPrivateKey)(n5));
    return n5;
  };
  e9.isValidPrivateKey = function(e10) {
    return a4((0, i6.ellipticCurve)(), (function(t5) {
      return t5.utils.isValidPrivateKey(e10);
    }), (function() {
      return true;
    }), (function() {
      return true;
    }));
  };
  e9.getPublicKey = function(e10) {
    return a4((0, i6.ellipticCurve)(), (function(t5) {
      return t5.getPublicKey(e10);
    }), (function(t5) {
      return t5.getPublicKey(e10);
    }), (function(t5) {
      return t5.getPublicKey(e10);
    }));
  };
  e9.getSharedPoint = function(e10, t5, n5) {
    return a4((0, i6.ellipticCurve)(), (function(r7) {
      return r7.getSharedSecret(e10, t5, n5);
    }), (function(n6) {
      return n6.getSharedSecret(e10, t5);
    }), (function(n6) {
      return l6(n6, e10, t5);
    }));
  };
  e9.convertPublicKeyFormat = function(e10, t5) {
    return a4((0, i6.ellipticCurve)(), (function(n5) {
      return n5.getSharedSecret(BigInt(1), e10, t5);
    }), (function() {
      return e10;
    }), (function() {
      return e10;
    }));
  };
  function a4(e10, t5, i7, o5) {
    if ("secp256k1" === e10) return t5(r6.secp256k1);
    if ("x25519" === e10) return i7(n4.x25519);
    if ("ed25519" === e10) return o5(n4.ed25519);
    throw new Error("Not implemented");
  }
  e9.hexToPublicKey = function(e10) {
    var t5 = (0, s3.decodeHex)(e10);
    return a4((0, i6.ellipticCurve)(), (function() {
      return c6(t5);
    }), (function() {
      return t5;
    }), (function() {
      return t5;
    }));
  };
  var c6 = function(e10) {
    if (e10.length === o4.ETH_PUBLIC_KEY_SIZE) {
      var t5 = new Uint8Array(1 + e10.length);
      return t5.set([4]), t5.set(e10, 1), t5;
    }
    return e10;
  }, l6 = function(e10, t5, n5) {
    var r7 = e10.utils.getExtendedPublicKey(t5).scalar;
    return e10.ExtendedPoint.fromHex(n5).multiply(r7).toRawBytes();
  };
})(Ie6);
var pr3 = {};
var gr3 = {};
Object.defineProperty(gr3, "__esModule", { value: true }), gr3.hkdf = void 0, gr3.extract = br3, gr3.expand = Sr5;
var mr5 = Le7;
var yr5 = ze3;
var vr5 = ar2;
function br3(e9, t4, n4) {
  return (0, mr5.hash)(e9), void 0 === n4 && (n4 = new Uint8Array(e9.outputLen)), (0, vr5.hmac)(e9, (0, yr5.toBytes)(n4), (0, yr5.toBytes)(t4));
}
var wr5 = new Uint8Array([0]);
var Er5 = new Uint8Array();
function Sr5(e9, t4, n4, r6 = 32) {
  if ((0, mr5.hash)(e9), (0, mr5.number)(r6), r6 > 255 * e9.outputLen) throw new Error("Length should be <= 255*HashLen");
  const i6 = Math.ceil(r6 / e9.outputLen);
  void 0 === n4 && (n4 = Er5);
  const o4 = new Uint8Array(i6 * e9.outputLen), s3 = vr5.hmac.create(e9, t4), a4 = s3._cloneInto(), c6 = new Uint8Array(s3.outputLen);
  for (let t5 = 0; t5 < i6; t5++) wr5[0] = t5 + 1, a4.update(0 === t5 ? Er5 : c6).update(n4).update(wr5).digestInto(c6), o4.set(c6, e9.outputLen * t5), s3._cloneInto(a4);
  return s3.destroy(), a4.destroy(), c6.fill(0), wr5.fill(0), o4.slice(0, r6);
}
gr3.hkdf = (e9, t4, n4, r6, i6) => Sr5(e9, br3(e9, t4, n4), r6, i6), (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.getSharedKey = e9.deriveKey = void 0;
  var t4 = pe6, n4 = gr3, r6 = Qn3;
  e9.deriveKey = function(e10, t5, i6) {
    return (0, n4.hkdf)(r6.sha256, e10, t5, i6, 32);
  };
  e9.getSharedKey = function() {
    for (var n5 = [], r7 = 0; r7 < arguments.length; r7++) n5[r7] = arguments[r7];
    return (0, e9.deriveKey)(t4.concatBytes.apply(void 0, n5));
  };
})(pr3);
var _r5 = {};
var Cr3 = {};
var kr3 = {};
var Ar5 = {};
Object.defineProperty(Ar5, "__esModule", { value: true }), Ar5.polyval = Ar5.ghash = void 0, Ar5._toGHASHKey = Or5;
var xr5 = ge4;
var Mr3 = pe6;
var Ir5 = 16;
var Tr5 = new Uint8Array(16);
var Rr5 = (0, Mr3.u32)(Tr5);
var Pr3 = (e9) => (e9 >>> 0 & 255) << 24 | (e9 >>> 8 & 255) << 16 | (e9 >>> 16 & 255) << 8 | e9 >>> 24 & 255 | 0;
function Or5(e9) {
  e9.reverse();
  const t4 = 1 & e9[15];
  let n4 = 0;
  for (let t5 = 0; t5 < e9.length; t5++) {
    const r6 = e9[t5];
    e9[t5] = r6 >>> 1 | n4, n4 = (1 & r6) << 7;
  }
  return e9[0] ^= 225 & -t4, e9;
}
var Nr5 = class {
  constructor(e9, t4) {
    this.blockLen = Ir5, this.outputLen = Ir5, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = false, e9 = (0, Mr3.toBytes)(e9), (0, xr5.bytes)(e9, 16);
    const n4 = (0, Mr3.createView)(e9);
    let r6 = n4.getUint32(0, false), i6 = n4.getUint32(4, false), o4 = n4.getUint32(8, false), s3 = n4.getUint32(12, false);
    const a4 = [];
    for (let e10 = 0; e10 < 128; e10++) a4.push({ s0: Pr3(r6), s1: Pr3(i6), s2: Pr3(o4), s3: Pr3(s3) }), { s0: r6, s1: i6, s2: o4, s3 } = { s3: (d5 = o4) << 31 | (u6 = s3) >>> 1, s2: (l6 = i6) << 31 | d5 >>> 1, s1: (c6 = r6) << 31 | l6 >>> 1, s0: c6 >>> 1 ^ 225 << 24 & -(1 & u6) };
    var c6, l6, d5, u6;
    const h7 = ((e10) => e10 > 65536 ? 8 : e10 > 1024 ? 4 : 2)(t4 || 1024);
    if (![1, 2, 4, 8].includes(h7)) throw new Error(`ghash: wrong window size=${h7}, should be 2, 4 or 8`);
    this.W = h7;
    const f12 = 128 / h7, p7 = this.windowSize = 2 ** h7, g3 = [];
    for (let e10 = 0; e10 < f12; e10++) for (let t5 = 0; t5 < p7; t5++) {
      let n5 = 0, r7 = 0, i7 = 0, o5 = 0;
      for (let s4 = 0; s4 < h7; s4++) {
        if (!(t5 >>> h7 - s4 - 1 & 1)) continue;
        const { s0: c7, s1: l7, s2: d6, s3: u7 } = a4[h7 * e10 + s4];
        n5 ^= c7, r7 ^= l7, i7 ^= d6, o5 ^= u7;
      }
      g3.push({ s0: n5, s1: r7, s2: i7, s3: o5 });
    }
    this.t = g3;
  }
  _updateBlock(e9, t4, n4, r6) {
    e9 ^= this.s0, t4 ^= this.s1, n4 ^= this.s2, r6 ^= this.s3;
    const { W: i6, t: o4, windowSize: s3 } = this;
    let a4 = 0, c6 = 0, l6 = 0, d5 = 0;
    const u6 = (1 << i6) - 1;
    let h7 = 0;
    for (const f12 of [e9, t4, n4, r6]) for (let e10 = 0; e10 < 4; e10++) {
      const t5 = f12 >>> 8 * e10 & 255;
      for (let e11 = 8 / i6 - 1; e11 >= 0; e11--) {
        const n5 = t5 >>> i6 * e11 & u6, { s0: r7, s1: f13, s2: p7, s3: g3 } = o4[h7 * s3 + n5];
        a4 ^= r7, c6 ^= f13, l6 ^= p7, d5 ^= g3, h7 += 1;
      }
    }
    this.s0 = a4, this.s1 = c6, this.s2 = l6, this.s3 = d5;
  }
  update(e9) {
    e9 = (0, Mr3.toBytes)(e9), (0, xr5.exists)(this);
    const t4 = (0, Mr3.u32)(e9), n4 = Math.floor(e9.length / Ir5), r6 = e9.length % Ir5;
    for (let e10 = 0; e10 < n4; e10++) this._updateBlock(t4[4 * e10 + 0], t4[4 * e10 + 1], t4[4 * e10 + 2], t4[4 * e10 + 3]);
    return r6 && (Tr5.set(e9.subarray(n4 * Ir5)), this._updateBlock(Rr5[0], Rr5[1], Rr5[2], Rr5[3]), (0, Mr3.clean)(Rr5)), this;
  }
  destroy() {
    const { t: e9 } = this;
    for (const t4 of e9) t4.s0 = 0, t4.s1 = 0, t4.s2 = 0, t4.s3 = 0;
  }
  digestInto(e9) {
    (0, xr5.exists)(this), (0, xr5.output)(e9, this), this.finished = true;
    const { s0: t4, s1: n4, s2: r6, s3: i6 } = this, o4 = (0, Mr3.u32)(e9);
    return o4[0] = t4, o4[1] = n4, o4[2] = r6, o4[3] = i6, e9;
  }
  digest() {
    const e9 = new Uint8Array(Ir5);
    return this.digestInto(e9), this.destroy(), e9;
  }
};
var Lr3 = class extends Nr5 {
  constructor(e9, t4) {
    e9 = (0, Mr3.toBytes)(e9);
    const n4 = Or5((0, Mr3.copyBytes)(e9));
    super(n4, t4), (0, Mr3.clean)(n4);
  }
  update(e9) {
    e9 = (0, Mr3.toBytes)(e9), (0, xr5.exists)(this);
    const t4 = (0, Mr3.u32)(e9), n4 = e9.length % Ir5, r6 = Math.floor(e9.length / Ir5);
    for (let e10 = 0; e10 < r6; e10++) this._updateBlock(Pr3(t4[4 * e10 + 3]), Pr3(t4[4 * e10 + 2]), Pr3(t4[4 * e10 + 1]), Pr3(t4[4 * e10 + 0]));
    return n4 && (Tr5.set(e9.subarray(r6 * Ir5)), this._updateBlock(Pr3(Rr5[3]), Pr3(Rr5[2]), Pr3(Rr5[1]), Pr3(Rr5[0])), (0, Mr3.clean)(Rr5)), this;
  }
  digestInto(e9) {
    (0, xr5.exists)(this), (0, xr5.output)(e9, this), this.finished = true;
    const { s0: t4, s1: n4, s2: r6, s3: i6 } = this, o4 = (0, Mr3.u32)(e9);
    return o4[0] = t4, o4[1] = n4, o4[2] = r6, o4[3] = i6, e9.reverse();
  }
};
function Dr3(e9) {
  const t4 = (t5, n5) => e9(n5, t5.length).update((0, Mr3.toBytes)(t5)).digest(), n4 = e9(new Uint8Array(16), 0);
  return t4.outputLen = n4.outputLen, t4.blockLen = n4.blockLen, t4.create = (t5, n5) => e9(t5, n5), t4;
}
Ar5.ghash = Dr3(((e9, t4) => new Nr5(e9, t4))), Ar5.polyval = Dr3(((e9, t4) => new Lr3(e9, t4))), Object.defineProperty(kr3, "__esModule", { value: true }), kr3.unsafe = kr3.aeskwp = kr3.aeskw = kr3.siv = kr3.gcm = kr3.cfb = kr3.cbc = kr3.ecb = kr3.ctr = void 0, kr3.expandKeyLE = ei4, kr3.expandKeyDecLE = ti3;
var $r5 = ge4;
var Br5 = Ar5;
var Kr2 = pe6;
var jr3 = 16;
var Ur5 = new Uint8Array(jr3);
var Hr3 = 283;
function Fr2(e9) {
  return e9 << 1 ^ Hr3 & -(e9 >> 7);
}
function zr2(e9, t4) {
  let n4 = 0;
  for (; t4 > 0; t4 >>= 1) n4 ^= e9 & -(1 & t4), e9 = Fr2(e9);
  return n4;
}
var qr3 = (() => {
  const e9 = new Uint8Array(256);
  for (let t5 = 0, n4 = 1; t5 < 256; t5++, n4 ^= Fr2(n4)) e9[t5] = n4;
  const t4 = new Uint8Array(256);
  t4[0] = 99;
  for (let n4 = 0; n4 < 255; n4++) {
    let r6 = e9[255 - n4];
    r6 |= r6 << 8, t4[e9[n4]] = 255 & (r6 ^ r6 >> 4 ^ r6 >> 5 ^ r6 >> 6 ^ r6 >> 7 ^ 99);
  }
  return (0, Kr2.clean)(e9), t4;
})();
var Wr3 = qr3.map(((e9, t4) => qr3.indexOf(t4)));
var Vr3 = (e9) => e9 << 24 | e9 >>> 8;
var Gr3 = (e9) => e9 << 8 | e9 >>> 24;
var Yr2 = (e9) => e9 << 24 & 4278190080 | e9 << 8 & 16711680 | e9 >>> 8 & 65280 | e9 >>> 24 & 255;
function Zr3(e9, t4) {
  if (256 !== e9.length) throw new Error("Wrong sbox length");
  const n4 = new Uint32Array(256).map(((n5, r7) => t4(e9[r7]))), r6 = n4.map(Gr3), i6 = r6.map(Gr3), o4 = i6.map(Gr3), s3 = new Uint32Array(65536), a4 = new Uint32Array(65536), c6 = new Uint16Array(65536);
  for (let t5 = 0; t5 < 256; t5++) for (let l6 = 0; l6 < 256; l6++) {
    const d5 = 256 * t5 + l6;
    s3[d5] = n4[t5] ^ r6[l6], a4[d5] = i6[t5] ^ o4[l6], c6[d5] = e9[t5] << 8 | e9[l6];
  }
  return { sbox: e9, sbox2: c6, T0: n4, T1: r6, T2: i6, T3: o4, T01: s3, T23: a4 };
}
var Jr2 = Zr3(qr3, ((e9) => zr2(e9, 3) << 24 | e9 << 16 | e9 << 8 | zr2(e9, 2)));
var Qr5 = Zr3(Wr3, ((e9) => zr2(e9, 11) << 24 | zr2(e9, 13) << 16 | zr2(e9, 9) << 8 | zr2(e9, 14)));
var Xr3 = (() => {
  const e9 = new Uint8Array(16);
  for (let t4 = 0, n4 = 1; t4 < 16; t4++, n4 = Fr2(n4)) e9[t4] = n4;
  return e9;
})();
function ei4(e9) {
  (0, $r5.bytes)(e9);
  const t4 = e9.length;
  if (![16, 24, 32].includes(t4)) throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t4}`);
  const { sbox2: n4 } = Jr2, r6 = [];
  (0, Kr2.isAligned32)(e9) || r6.push(e9 = (0, Kr2.copyBytes)(e9));
  const i6 = (0, Kr2.u32)(e9), o4 = i6.length, s3 = (e10) => ri4(n4, e10, e10, e10, e10), a4 = new Uint32Array(t4 + 28);
  a4.set(i6);
  for (let e10 = o4; e10 < a4.length; e10++) {
    let t5 = a4[e10 - 1];
    e10 % o4 == 0 ? t5 = s3(Vr3(t5)) ^ Xr3[e10 / o4 - 1] : o4 > 6 && e10 % o4 == 4 && (t5 = s3(t5)), a4[e10] = a4[e10 - o4] ^ t5;
  }
  return (0, Kr2.clean)(...r6), a4;
}
function ti3(e9) {
  const t4 = ei4(e9), n4 = t4.slice(), r6 = t4.length, { sbox2: i6 } = Jr2, { T0: o4, T1: s3, T2: a4, T3: c6 } = Qr5;
  for (let e10 = 0; e10 < r6; e10 += 4) for (let i7 = 0; i7 < 4; i7++) n4[e10 + i7] = t4[r6 - e10 - 4 + i7];
  (0, Kr2.clean)(t4);
  for (let e10 = 4; e10 < r6 - 4; e10++) {
    const t5 = n4[e10], r7 = ri4(i6, t5, t5, t5, t5);
    n4[e10] = o4[255 & r7] ^ s3[r7 >>> 8 & 255] ^ a4[r7 >>> 16 & 255] ^ c6[r7 >>> 24];
  }
  return n4;
}
function ni4(e9, t4, n4, r6, i6, o4) {
  return e9[n4 << 8 & 65280 | r6 >>> 8 & 255] ^ t4[i6 >>> 8 & 65280 | o4 >>> 24 & 255];
}
function ri4(e9, t4, n4, r6, i6) {
  return e9[255 & t4 | 65280 & n4] | e9[r6 >>> 16 & 255 | i6 >>> 16 & 65280] << 16;
}
function ii4(e9, t4, n4, r6, i6) {
  const { sbox2: o4, T01: s3, T23: a4 } = Jr2;
  let c6 = 0;
  t4 ^= e9[c6++], n4 ^= e9[c6++], r6 ^= e9[c6++], i6 ^= e9[c6++];
  const l6 = e9.length / 4 - 2;
  for (let o5 = 0; o5 < l6; o5++) {
    const o6 = e9[c6++] ^ ni4(s3, a4, t4, n4, r6, i6), l7 = e9[c6++] ^ ni4(s3, a4, n4, r6, i6, t4), d5 = e9[c6++] ^ ni4(s3, a4, r6, i6, t4, n4), u6 = e9[c6++] ^ ni4(s3, a4, i6, t4, n4, r6);
    t4 = o6, n4 = l7, r6 = d5, i6 = u6;
  }
  return { s0: e9[c6++] ^ ri4(o4, t4, n4, r6, i6), s1: e9[c6++] ^ ri4(o4, n4, r6, i6, t4), s2: e9[c6++] ^ ri4(o4, r6, i6, t4, n4), s3: e9[c6++] ^ ri4(o4, i6, t4, n4, r6) };
}
function oi4(e9, t4, n4, r6, i6) {
  const { sbox2: o4, T01: s3, T23: a4 } = Qr5;
  let c6 = 0;
  t4 ^= e9[c6++], n4 ^= e9[c6++], r6 ^= e9[c6++], i6 ^= e9[c6++];
  const l6 = e9.length / 4 - 2;
  for (let o5 = 0; o5 < l6; o5++) {
    const o6 = e9[c6++] ^ ni4(s3, a4, t4, i6, r6, n4), l7 = e9[c6++] ^ ni4(s3, a4, n4, t4, i6, r6), d5 = e9[c6++] ^ ni4(s3, a4, r6, n4, t4, i6), u6 = e9[c6++] ^ ni4(s3, a4, i6, r6, n4, t4);
    t4 = o6, n4 = l7, r6 = d5, i6 = u6;
  }
  return { s0: e9[c6++] ^ ri4(o4, t4, i6, r6, n4), s1: e9[c6++] ^ ri4(o4, n4, t4, i6, r6), s2: e9[c6++] ^ ri4(o4, r6, n4, t4, i6), s3: e9[c6++] ^ ri4(o4, i6, r6, n4, t4) };
}
function si4(e9, t4) {
  if (void 0 === t4) return new Uint8Array(e9);
  if ((0, $r5.bytes)(t4), t4.length < e9) throw new Error(`aes: wrong destination length, expected at least ${e9}, got: ${t4.length}`);
  if (!(0, Kr2.isAligned32)(t4)) throw new Error("unaligned dst");
  return t4;
}
function ai4(e9, t4, n4, r6) {
  (0, $r5.bytes)(t4, jr3), (0, $r5.bytes)(n4);
  const i6 = n4.length;
  r6 = si4(i6, r6);
  const o4 = t4, s3 = (0, Kr2.u32)(o4);
  let { s0: a4, s1: c6, s2: l6, s3: d5 } = ii4(e9, s3[0], s3[1], s3[2], s3[3]);
  const u6 = (0, Kr2.u32)(n4), h7 = (0, Kr2.u32)(r6);
  for (let t5 = 0; t5 + 4 <= u6.length; t5 += 4) {
    h7[t5 + 0] = u6[t5 + 0] ^ a4, h7[t5 + 1] = u6[t5 + 1] ^ c6, h7[t5 + 2] = u6[t5 + 2] ^ l6, h7[t5 + 3] = u6[t5 + 3] ^ d5;
    let n5 = 1;
    for (let e10 = o4.length - 1; e10 >= 0; e10--) n5 = n5 + (255 & o4[e10]) | 0, o4[e10] = 255 & n5, n5 >>>= 8;
    ({ s0: a4, s1: c6, s2: l6, s3: d5 } = ii4(e9, s3[0], s3[1], s3[2], s3[3]));
  }
  const f12 = jr3 * Math.floor(u6.length / 4);
  if (f12 < i6) {
    const e10 = new Uint32Array([a4, c6, l6, d5]), t5 = (0, Kr2.u8)(e10);
    for (let e11 = f12, o5 = 0; e11 < i6; e11++, o5++) r6[e11] = n4[e11] ^ t5[o5];
    (0, Kr2.clean)(e10);
  }
  return r6;
}
function ci4(e9, t4, n4, r6, i6) {
  (0, $r5.bytes)(n4, jr3), (0, $r5.bytes)(r6), i6 = si4(r6.length, i6);
  const o4 = n4, s3 = (0, Kr2.u32)(o4), a4 = (0, Kr2.createView)(o4), c6 = (0, Kr2.u32)(r6), l6 = (0, Kr2.u32)(i6), d5 = t4 ? 0 : 12, u6 = r6.length;
  let h7 = a4.getUint32(d5, t4), { s0: f12, s1: p7, s2: g3, s3: m5 } = ii4(e9, s3[0], s3[1], s3[2], s3[3]);
  for (let n5 = 0; n5 + 4 <= c6.length; n5 += 4) l6[n5 + 0] = c6[n5 + 0] ^ f12, l6[n5 + 1] = c6[n5 + 1] ^ p7, l6[n5 + 2] = c6[n5 + 2] ^ g3, l6[n5 + 3] = c6[n5 + 3] ^ m5, h7 = h7 + 1 >>> 0, a4.setUint32(d5, h7, t4), { s0: f12, s1: p7, s2: g3, s3: m5 } = ii4(e9, s3[0], s3[1], s3[2], s3[3]);
  const y8 = jr3 * Math.floor(c6.length / 4);
  if (y8 < u6) {
    const e10 = new Uint32Array([f12, p7, g3, m5]), t5 = (0, Kr2.u8)(e10);
    for (let e11 = y8, n5 = 0; e11 < u6; e11++, n5++) i6[e11] = r6[e11] ^ t5[n5];
    (0, Kr2.clean)(e10);
  }
  return i6;
}
function li4(e9) {
  if ((0, $r5.bytes)(e9), e9.length % jr3 != 0) throw new Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16");
}
function di4(e9, t4, n4) {
  (0, $r5.bytes)(e9);
  let r6 = e9.length;
  const i6 = r6 % jr3;
  if (!t4 && 0 !== i6) throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  (0, Kr2.isAligned32)(e9) || (e9 = (0, Kr2.copyBytes)(e9));
  const o4 = (0, Kr2.u32)(e9);
  if (t4) {
    let e10 = jr3 - i6;
    e10 || (e10 = jr3), r6 += e10;
  }
  const s3 = si4(r6, n4);
  return { b: o4, o: (0, Kr2.u32)(s3), out: s3 };
}
function ui4(e9, t4) {
  if (!t4) return e9;
  const n4 = e9.length;
  if (!n4) throw new Error("aes/pcks5: empty ciphertext not allowed");
  const r6 = e9[n4 - 1];
  if (r6 <= 0 || r6 > 16) throw new Error("aes/pcks5: wrong padding");
  const i6 = e9.subarray(0, -r6);
  for (let t5 = 0; t5 < r6; t5++) if (e9[n4 - t5 - 1] !== r6) throw new Error("aes/pcks5: wrong padding");
  return i6;
}
function hi4(e9) {
  const t4 = new Uint8Array(16), n4 = (0, Kr2.u32)(t4);
  t4.set(e9);
  const r6 = jr3 - e9.length;
  for (let e10 = jr3 - r6; e10 < jr3; e10++) t4[e10] = r6;
  return n4;
}
function fi4(e9, t4, n4, r6, i6) {
  const o4 = null == i6 ? 0 : i6.length, s3 = e9.create(n4, r6.length + o4);
  i6 && s3.update(i6), s3.update(r6);
  const a4 = new Uint8Array(16), c6 = (0, Kr2.createView)(a4);
  i6 && (0, Kr2.setBigUint64)(c6, 0, BigInt(8 * o4), t4), (0, Kr2.setBigUint64)(c6, 8, BigInt(8 * r6.length), t4), s3.update(a4);
  const l6 = s3.digest();
  return (0, Kr2.clean)(a4), l6;
}
kr3.ctr = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 16 }, (function(e9, t4) {
  function n4(n5, r6) {
    if ((0, $r5.bytes)(n5), void 0 !== r6 && ((0, $r5.bytes)(r6), !(0, Kr2.isAligned32)(r6))) throw new Error("unaligned destination");
    const i6 = ei4(e9), o4 = (0, Kr2.copyBytes)(t4), s3 = [i6, o4];
    (0, Kr2.isAligned32)(n5) || s3.push(n5 = (0, Kr2.copyBytes)(n5));
    const a4 = ai4(i6, o4, n5, r6);
    return (0, Kr2.clean)(...s3), a4;
  }
  return (0, $r5.bytes)(e9), (0, $r5.bytes)(t4, jr3), { encrypt: (e10, t5) => n4(e10, t5), decrypt: (e10, t5) => n4(e10, t5) };
})), kr3.ecb = (0, Kr2.wrapCipher)({ blockSize: 16 }, (function(e9, t4 = {}) {
  (0, $r5.bytes)(e9);
  const n4 = !t4.disablePadding;
  return { encrypt(t5, r6) {
    const { b: i6, o: o4, out: s3 } = di4(t5, n4, r6), a4 = ei4(e9);
    let c6 = 0;
    for (; c6 + 4 <= i6.length; ) {
      const { s0: e10, s1: t6, s2: n5, s3: r7 } = ii4(a4, i6[c6 + 0], i6[c6 + 1], i6[c6 + 2], i6[c6 + 3]);
      o4[c6++] = e10, o4[c6++] = t6, o4[c6++] = n5, o4[c6++] = r7;
    }
    if (n4) {
      const e10 = hi4(t5.subarray(4 * c6)), { s0: n5, s1: r7, s2: i7, s3: s4 } = ii4(a4, e10[0], e10[1], e10[2], e10[3]);
      o4[c6++] = n5, o4[c6++] = r7, o4[c6++] = i7, o4[c6++] = s4;
    }
    return (0, Kr2.clean)(a4), s3;
  }, decrypt(t5, r6) {
    li4(t5);
    const i6 = ti3(e9), o4 = si4(t5.length, r6), s3 = [i6];
    (0, Kr2.isAligned32)(t5) || s3.push(t5 = (0, Kr2.copyBytes)(t5));
    const a4 = (0, Kr2.u32)(t5), c6 = (0, Kr2.u32)(o4);
    for (let e10 = 0; e10 + 4 <= a4.length; ) {
      const { s0: t6, s1: n5, s2: r7, s3: o5 } = oi4(i6, a4[e10 + 0], a4[e10 + 1], a4[e10 + 2], a4[e10 + 3]);
      c6[e10++] = t6, c6[e10++] = n5, c6[e10++] = r7, c6[e10++] = o5;
    }
    return (0, Kr2.clean)(...s3), ui4(o4, n4);
  } };
})), kr3.cbc = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 16 }, (function(e9, t4, n4 = {}) {
  (0, $r5.bytes)(e9), (0, $r5.bytes)(t4, 16);
  const r6 = !n4.disablePadding;
  return { encrypt(n5, i6) {
    const o4 = ei4(e9), { b: s3, o: a4, out: c6 } = di4(n5, r6, i6);
    let l6 = t4;
    const d5 = [o4];
    (0, Kr2.isAligned32)(l6) || d5.push(l6 = (0, Kr2.copyBytes)(l6));
    const u6 = (0, Kr2.u32)(l6);
    let h7 = u6[0], f12 = u6[1], p7 = u6[2], g3 = u6[3], m5 = 0;
    for (; m5 + 4 <= s3.length; ) h7 ^= s3[m5 + 0], f12 ^= s3[m5 + 1], p7 ^= s3[m5 + 2], g3 ^= s3[m5 + 3], { s0: h7, s1: f12, s2: p7, s3: g3 } = ii4(o4, h7, f12, p7, g3), a4[m5++] = h7, a4[m5++] = f12, a4[m5++] = p7, a4[m5++] = g3;
    if (r6) {
      const e10 = hi4(n5.subarray(4 * m5));
      h7 ^= e10[0], f12 ^= e10[1], p7 ^= e10[2], g3 ^= e10[3], { s0: h7, s1: f12, s2: p7, s3: g3 } = ii4(o4, h7, f12, p7, g3), a4[m5++] = h7, a4[m5++] = f12, a4[m5++] = p7, a4[m5++] = g3;
    }
    return (0, Kr2.clean)(...d5), c6;
  }, decrypt(n5, i6) {
    li4(n5);
    const o4 = ti3(e9);
    let s3 = t4;
    const a4 = [o4];
    (0, Kr2.isAligned32)(s3) || a4.push(s3 = (0, Kr2.copyBytes)(s3));
    const c6 = (0, Kr2.u32)(s3), l6 = si4(n5.length, i6);
    (0, Kr2.isAligned32)(n5) || a4.push(n5 = (0, Kr2.copyBytes)(n5));
    const d5 = (0, Kr2.u32)(n5), u6 = (0, Kr2.u32)(l6);
    let h7 = c6[0], f12 = c6[1], p7 = c6[2], g3 = c6[3];
    for (let e10 = 0; e10 + 4 <= d5.length; ) {
      const t5 = h7, n6 = f12, r7 = p7, i7 = g3;
      h7 = d5[e10 + 0], f12 = d5[e10 + 1], p7 = d5[e10 + 2], g3 = d5[e10 + 3];
      const { s0: s4, s1: a5, s2: c7, s3: l7 } = oi4(o4, h7, f12, p7, g3);
      u6[e10++] = s4 ^ t5, u6[e10++] = a5 ^ n6, u6[e10++] = c7 ^ r7, u6[e10++] = l7 ^ i7;
    }
    return (0, Kr2.clean)(...a4), ui4(l6, r6);
  } };
})), kr3.cfb = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 16 }, (function(e9, t4) {
  function n4(n5, r6, i6) {
    (0, $r5.bytes)(n5);
    const o4 = n5.length;
    i6 = si4(o4, i6);
    const s3 = ei4(e9);
    let a4 = t4;
    const c6 = [s3];
    (0, Kr2.isAligned32)(a4) || c6.push(a4 = (0, Kr2.copyBytes)(a4)), (0, Kr2.isAligned32)(n5) || c6.push(n5 = (0, Kr2.copyBytes)(n5));
    const l6 = (0, Kr2.u32)(n5), d5 = (0, Kr2.u32)(i6), u6 = r6 ? d5 : l6, h7 = (0, Kr2.u32)(a4);
    let f12 = h7[0], p7 = h7[1], g3 = h7[2], m5 = h7[3];
    for (let e10 = 0; e10 + 4 <= l6.length; ) {
      const { s0: t5, s1: n6, s2: r7, s3: i7 } = ii4(s3, f12, p7, g3, m5);
      d5[e10 + 0] = l6[e10 + 0] ^ t5, d5[e10 + 1] = l6[e10 + 1] ^ n6, d5[e10 + 2] = l6[e10 + 2] ^ r7, d5[e10 + 3] = l6[e10 + 3] ^ i7, f12 = u6[e10++], p7 = u6[e10++], g3 = u6[e10++], m5 = u6[e10++];
    }
    const y8 = jr3 * Math.floor(l6.length / 4);
    if (y8 < o4) {
      ({ s0: f12, s1: p7, s2: g3, s3: m5 } = ii4(s3, f12, p7, g3, m5));
      const e10 = (0, Kr2.u8)(new Uint32Array([f12, p7, g3, m5]));
      for (let t5 = y8, r7 = 0; t5 < o4; t5++, r7++) i6[t5] = n5[t5] ^ e10[r7];
      (0, Kr2.clean)(e10);
    }
    return (0, Kr2.clean)(...c6), i6;
  }
  return (0, $r5.bytes)(e9), (0, $r5.bytes)(t4, 16), { encrypt: (e10, t5) => n4(e10, true, t5), decrypt: (e10, t5) => n4(e10, false, t5) };
})), kr3.gcm = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, (function(e9, t4, n4) {
  if ((0, $r5.bytes)(e9), (0, $r5.bytes)(t4), void 0 !== n4 && (0, $r5.bytes)(n4), t4.length < 8) throw new Error("aes/gcm: invalid nonce length");
  const r6 = 16;
  function i6(e10, t5, r7) {
    const i7 = fi4(Br5.ghash, false, e10, r7, n4);
    for (let e11 = 0; e11 < t5.length; e11++) i7[e11] ^= t5[e11];
    return i7;
  }
  function o4() {
    const n5 = ei4(e9), r7 = Ur5.slice(), i7 = Ur5.slice();
    if (ci4(n5, false, i7, i7, r7), 12 === t4.length) i7.set(t4);
    else {
      const e10 = Ur5.slice(), n6 = (0, Kr2.createView)(e10);
      (0, Kr2.setBigUint64)(n6, 8, BigInt(8 * t4.length), false);
      const o5 = Br5.ghash.create(r7).update(t4).update(e10);
      o5.digestInto(i7), o5.destroy();
    }
    return { xk: n5, authKey: r7, counter: i7, tagMask: ci4(n5, false, i7, Ur5) };
  }
  return { encrypt(e10) {
    (0, $r5.bytes)(e10);
    const { xk: t5, authKey: n5, counter: s3, tagMask: a4 } = o4(), c6 = new Uint8Array(e10.length + r6), l6 = [t5, n5, s3, a4];
    (0, Kr2.isAligned32)(e10) || l6.push(e10 = (0, Kr2.copyBytes)(e10)), ci4(t5, false, s3, e10, c6);
    const d5 = i6(n5, a4, c6.subarray(0, c6.length - r6));
    return l6.push(d5), c6.set(d5, e10.length), (0, Kr2.clean)(...l6), c6;
  }, decrypt(e10) {
    if ((0, $r5.bytes)(e10), e10.length < r6) throw new Error("aes/gcm: ciphertext less than tagLen (16)");
    const { xk: t5, authKey: n5, counter: s3, tagMask: a4 } = o4(), c6 = [t5, n5, a4, s3];
    (0, Kr2.isAligned32)(e10) || c6.push(e10 = (0, Kr2.copyBytes)(e10));
    const l6 = e10.subarray(0, -16), d5 = e10.subarray(-16), u6 = i6(n5, a4, l6);
    if (c6.push(u6), !(0, Kr2.equalBytes)(u6, d5)) throw new Error("aes/gcm: invalid ghash tag");
    const h7 = ci4(t5, false, s3, l6);
    return (0, Kr2.clean)(...c6), h7;
  } };
}));
var pi4 = (e9, t4, n4) => (r6) => {
  if (!Number.isSafeInteger(r6) || t4 > r6 || r6 > n4) throw new Error(`${e9}: invalid value=${r6}, must be [${t4}..${n4}]`);
};
function gi3(e9) {
  return null != e9 && "object" == typeof e9 && (e9 instanceof Uint32Array || "Uint32Array" === e9.constructor.name);
}
function mi6(e9, t4) {
  if ((0, $r5.bytes)(t4, 16), !gi3(e9)) throw new Error("_encryptBlock accepts result of expandKeyLE");
  const n4 = (0, Kr2.u32)(t4);
  let { s0: r6, s1: i6, s2: o4, s3 } = ii4(e9, n4[0], n4[1], n4[2], n4[3]);
  return n4[0] = r6, n4[1] = i6, n4[2] = o4, n4[3] = s3, t4;
}
function yi5(e9, t4) {
  if ((0, $r5.bytes)(t4, 16), !gi3(e9)) throw new Error("_decryptBlock accepts result of expandKeyLE");
  const n4 = (0, Kr2.u32)(t4);
  let { s0: r6, s1: i6, s2: o4, s3 } = oi4(e9, n4[0], n4[1], n4[2], n4[3]);
  return n4[0] = r6, n4[1] = i6, n4[2] = o4, n4[3] = s3, t4;
}
kr3.siv = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, (function(e9, t4, n4) {
  const r6 = pi4("AAD", 0, 2 ** 36), i6 = pi4("plaintext", 0, 2 ** 36), o4 = pi4("nonce", 12, 12), s3 = pi4("ciphertext", 16, 2 ** 36 + 16);
  function a4() {
    const n5 = ei4(e9), r7 = new Uint8Array(e9.length), i7 = new Uint8Array(16), o5 = [n5, r7];
    let s4 = t4;
    (0, Kr2.isAligned32)(s4) || o5.push(s4 = (0, Kr2.copyBytes)(s4));
    const a5 = (0, Kr2.u32)(s4);
    let c7 = 0, l7 = a5[0], d5 = a5[1], u6 = a5[2], h7 = 0;
    for (const e10 of [i7, r7].map(Kr2.u32)) {
      const t5 = (0, Kr2.u32)(e10);
      for (let e11 = 0; e11 < t5.length; e11 += 2) {
        const { s0: r8, s1: i8 } = ii4(n5, c7, l7, d5, u6);
        t5[e11 + 0] = r8, t5[e11 + 1] = i8, c7 = ++h7;
      }
    }
    const f12 = { authKey: i7, encKey: ei4(r7) };
    return (0, Kr2.clean)(...o5), f12;
  }
  function c6(e10, r7, i7) {
    const o5 = fi4(Br5.polyval, true, r7, i7, n4);
    for (let e11 = 0; e11 < 12; e11++) o5[e11] ^= t4[e11];
    o5[15] &= 127;
    const s4 = (0, Kr2.u32)(o5);
    let a5 = s4[0], c7 = s4[1], l7 = s4[2], d5 = s4[3];
    return { s0: a5, s1: c7, s2: l7, s3: d5 } = ii4(e10, a5, c7, l7, d5), s4[0] = a5, s4[1] = c7, s4[2] = l7, s4[3] = d5, o5;
  }
  function l6(e10, t5, n5) {
    let r7 = (0, Kr2.copyBytes)(t5);
    r7[15] |= 128;
    const i7 = ci4(e10, true, r7, n5);
    return (0, Kr2.clean)(r7), i7;
  }
  return (0, $r5.bytes)(e9, 16, 24, 32), (0, $r5.bytes)(t4), o4(t4.length), void 0 !== n4 && ((0, $r5.bytes)(n4), r6(n4.length)), { encrypt(e10) {
    (0, $r5.bytes)(e10), i6(e10.length);
    const { encKey: t5, authKey: n5 } = a4(), r7 = c6(t5, n5, e10), o5 = [t5, n5, r7];
    (0, Kr2.isAligned32)(e10) || o5.push(e10 = (0, Kr2.copyBytes)(e10));
    const s4 = new Uint8Array(e10.length + 16);
    return s4.set(r7, e10.length), s4.set(l6(t5, r7, e10)), (0, Kr2.clean)(...o5), s4;
  }, decrypt(e10) {
    (0, $r5.bytes)(e10), s3(e10.length);
    const t5 = e10.subarray(-16), { encKey: n5, authKey: r7 } = a4(), i7 = [n5, r7];
    (0, Kr2.isAligned32)(e10) || i7.push(e10 = (0, Kr2.copyBytes)(e10));
    const o5 = l6(n5, t5, e10.subarray(0, -16)), d5 = c6(n5, r7, o5);
    if (i7.push(d5), !(0, Kr2.equalBytes)(t5, d5)) throw (0, Kr2.clean)(...i7), new Error("invalid polyval tag");
    return (0, Kr2.clean)(...i7), o5;
  } };
}));
var vi6 = { encrypt(e9, t4) {
  if (t4.length >= 2 ** 32) throw new Error("plaintext should be less than 4gb");
  const n4 = ei4(e9);
  if (16 === t4.length) mi6(n4, t4);
  else {
    const e10 = (0, Kr2.u32)(t4);
    let r6 = e10[0], i6 = e10[1];
    for (let t5 = 0, o4 = 1; t5 < 6; t5++) for (let t6 = 2; t6 < e10.length; t6 += 2, o4++) {
      const { s0: s3, s1: a4, s2: c6, s3: l6 } = ii4(n4, r6, i6, e10[t6], e10[t6 + 1]);
      r6 = s3, i6 = a4 ^ Yr2(o4), e10[t6] = c6, e10[t6 + 1] = l6;
    }
    e10[0] = r6, e10[1] = i6;
  }
  n4.fill(0);
}, decrypt(e9, t4) {
  if (t4.length - 8 >= 2 ** 32) throw new Error("ciphertext should be less than 4gb");
  const n4 = ti3(e9), r6 = t4.length / 8 - 1;
  if (1 === r6) yi5(n4, t4);
  else {
    const e10 = (0, Kr2.u32)(t4);
    let i6 = e10[0], o4 = e10[1];
    for (let t5 = 0, s3 = 6 * r6; t5 < 6; t5++) for (let t6 = 2 * r6; t6 >= 1; t6 -= 2, s3--) {
      o4 ^= Yr2(s3);
      const { s0: r7, s1: a4, s2: c6, s3: l6 } = oi4(n4, i6, o4, e10[t6], e10[t6 + 1]);
      i6 = r7, o4 = a4, e10[t6] = c6, e10[t6 + 1] = l6;
    }
    e10[0] = i6, e10[1] = o4;
  }
  n4.fill(0);
} };
var bi5 = new Uint8Array(8).fill(166);
kr3.aeskw = (0, Kr2.wrapCipher)({ blockSize: 8 }, ((e9) => ({ encrypt(t4) {
  if ((0, $r5.bytes)(t4), !t4.length || t4.length % 8 != 0) throw new Error("invalid plaintext length");
  if (8 === t4.length) throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
  const n4 = (0, Kr2.concatBytes)(bi5, t4);
  return vi6.encrypt(e9, n4), n4;
}, decrypt(t4) {
  if ((0, $r5.bytes)(t4), t4.length % 8 != 0 || t4.length < 24) throw new Error("invalid ciphertext length");
  const n4 = (0, Kr2.copyBytes)(t4);
  if (vi6.decrypt(e9, n4), !(0, Kr2.equalBytes)(n4.subarray(0, 8), bi5)) throw new Error("integrity check failed");
  return n4.subarray(0, 8).fill(0), n4.subarray(8);
} })));
var wi5 = 2790873510;
kr3.aeskwp = (0, Kr2.wrapCipher)({ blockSize: 8 }, ((e9) => ({ encrypt(t4) {
  if ((0, $r5.bytes)(t4), !t4.length) throw new Error("invalid plaintext length");
  const n4 = 8 * Math.ceil(t4.length / 8), r6 = new Uint8Array(8 + n4);
  r6.set(t4, 8);
  const i6 = (0, Kr2.u32)(r6);
  return i6[0] = wi5, i6[1] = Yr2(t4.length), vi6.encrypt(e9, r6), r6;
}, decrypt(t4) {
  if ((0, $r5.bytes)(t4), t4.length < 16) throw new Error("invalid ciphertext length");
  const n4 = (0, Kr2.copyBytes)(t4), r6 = (0, Kr2.u32)(n4);
  vi6.decrypt(e9, n4);
  const i6 = Yr2(r6[1]) >>> 0, o4 = 8 * Math.ceil(i6 / 8);
  if (r6[0] !== wi5 || n4.length - 8 !== o4) throw new Error("integrity check failed");
  for (let e10 = i6; e10 < o4; e10++) if (0 !== n4[8 + e10]) throw new Error("integrity check failed");
  return n4.subarray(0, 8).fill(0), n4.subarray(8, 8 + i6);
} }))), kr3.unsafe = { expandKeyLE: ei4, expandKeyDecLE: ti3, encrypt: ii4, decrypt: oi4, encryptBlock: mi6, decryptBlock: yi5, ctrCounter: ai4, ctr32: ci4 }, Object.defineProperty(Cr3, "__esModule", { value: true }), Cr3.aes256cbc = Cr3.aes256gcm = void 0;
var Ei5 = kr3;
Cr3.aes256gcm = function(e9, t4, n4) {
  return (0, Ei5.gcm)(e9, t4, n4);
};
Cr3.aes256cbc = function(e9, t4, n4) {
  return (0, Ei5.cbc)(e9, t4);
};
var Si5 = {};
var _i5 = {};
var Ci5 = {};
Object.defineProperty(Ci5, "__esModule", { value: true }), Ci5.sigma = void 0, Ci5.rotl = function(e9, t4) {
  return e9 << t4 | e9 >>> 32 - t4;
}, Ci5.createCipher = function(e9, t4) {
  const { allowShortKeys: n4, extendNonceFn: r6, counterLength: i6, counterRight: o4, rounds: s3 } = (0, Ai5.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t4);
  if ("function" != typeof e9) throw new Error("core must be a function");
  return (0, ki5.number)(i6), (0, ki5.number)(s3), (0, ki5.bool)(o4), (0, ki5.bool)(n4), (t5, a4, c6, l6, d5 = 0) => {
    (0, ki5.bytes)(t5), (0, ki5.bytes)(a4), (0, ki5.bytes)(c6);
    const u6 = c6.length;
    if (void 0 === l6 && (l6 = new Uint8Array(u6)), (0, ki5.bytes)(l6), (0, ki5.number)(d5), d5 < 0 || d5 >= Li5) throw new Error("arx: counter overflow");
    if (l6.length < u6) throw new Error(`arx: output (${l6.length}) is shorter than data (${u6})`);
    const h7 = [];
    let f12, p7, g3 = t5.length;
    if (32 === g3) h7.push(f12 = (0, Ai5.copyBytes)(t5)), p7 = Ri5;
    else {
      if (16 !== g3 || !n4) throw new Error(`arx: invalid 32-byte key, got length=${g3}`);
      f12 = new Uint8Array(32), f12.set(t5), f12.set(t5, 16), p7 = Ti5, h7.push(f12);
    }
    Pi5(a4) || h7.push(a4 = (0, Ai5.copyBytes)(a4));
    const m5 = (0, Ai5.u32)(f12);
    if (r6) {
      if (24 !== a4.length) throw new Error("arx: extended nonce must be 24 bytes");
      r6(p7, m5, (0, Ai5.u32)(a4.subarray(0, 16)), m5), a4 = a4.subarray(16);
    }
    const y8 = 16 - i6;
    if (y8 !== a4.length) throw new Error(`arx: nonce must be ${y8} or 16 bytes`);
    if (12 !== y8) {
      const e10 = new Uint8Array(12);
      e10.set(a4, o4 ? 0 : 12 - a4.length), a4 = e10, h7.push(a4);
    }
    const v7 = (0, Ai5.u32)(a4);
    return (function(e10, t6, n5, r7, i7, o5, s4, a5) {
      const c7 = i7.length, l7 = new Uint8Array(Oi5), d6 = (0, Ai5.u32)(l7), u7 = Pi5(i7) && Pi5(o5), h8 = u7 ? (0, Ai5.u32)(i7) : Di5, f13 = u7 ? (0, Ai5.u32)(o5) : Di5;
      for (let p8 = 0; p8 < c7; s4++) {
        if (e10(t6, n5, r7, d6, s4, a5), s4 >= Li5) throw new Error("arx: counter overflow");
        const g4 = Math.min(Oi5, c7 - p8);
        if (u7 && g4 === Oi5) {
          const e11 = p8 / 4;
          if (p8 % 4 != 0) throw new Error("arx: invalid block position");
          for (let t7, n6 = 0; n6 < Ni5; n6++) t7 = e11 + n6, f13[t7] = h8[t7] ^ d6[n6];
          p8 += Oi5;
        } else {
          for (let e11, t7 = 0; t7 < g4; t7++) e11 = p8 + t7, o5[e11] = i7[e11] ^ l7[t7];
          p8 += g4;
        }
      }
    })(e9, p7, m5, v7, c6, l6, d5, s3), (0, Ai5.clean)(...h7), l6;
  };
};
var ki5 = ge4;
var Ai5 = pe6;
var xi5 = (e9) => Uint8Array.from(e9.split("").map(((e10) => e10.charCodeAt(0))));
var Mi5 = xi5("expand 16-byte k");
var Ii5 = xi5("expand 32-byte k");
var Ti5 = (0, Ai5.u32)(Mi5);
var Ri5 = (0, Ai5.u32)(Ii5);
function Pi5(e9) {
  return e9.byteOffset % 4 == 0;
}
Ci5.sigma = Ri5.slice();
var Oi5 = 64;
var Ni5 = 16;
var Li5 = 2 ** 32 - 1;
var Di5 = new Uint32Array();
var $i5 = {};
Object.defineProperty($i5, "__esModule", { value: true }), $i5.poly1305 = void 0, $i5.wrapConstructorWithKey = Hi4;
var Bi5 = ge4;
var Ki5 = pe6;
var ji5 = (e9, t4) => 255 & e9[t4++] | (255 & e9[t4++]) << 8;
var Ui5 = class {
  constructor(e9) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e9 = (0, Ki5.toBytes)(e9), (0, Bi5.bytes)(e9, 32);
    const t4 = ji5(e9, 0), n4 = ji5(e9, 2), r6 = ji5(e9, 4), i6 = ji5(e9, 6), o4 = ji5(e9, 8), s3 = ji5(e9, 10), a4 = ji5(e9, 12), c6 = ji5(e9, 14);
    this.r[0] = 8191 & t4, this.r[1] = 8191 & (t4 >>> 13 | n4 << 3), this.r[2] = 7939 & (n4 >>> 10 | r6 << 6), this.r[3] = 8191 & (r6 >>> 7 | i6 << 9), this.r[4] = 255 & (i6 >>> 4 | o4 << 12), this.r[5] = o4 >>> 1 & 8190, this.r[6] = 8191 & (o4 >>> 14 | s3 << 2), this.r[7] = 8065 & (s3 >>> 11 | a4 << 5), this.r[8] = 8191 & (a4 >>> 8 | c6 << 8), this.r[9] = c6 >>> 5 & 127;
    for (let t5 = 0; t5 < 8; t5++) this.pad[t5] = ji5(e9, 16 + 2 * t5);
  }
  process(e9, t4, n4 = false) {
    const r6 = n4 ? 0 : 2048, { h: i6, r: o4 } = this, s3 = o4[0], a4 = o4[1], c6 = o4[2], l6 = o4[3], d5 = o4[4], u6 = o4[5], h7 = o4[6], f12 = o4[7], p7 = o4[8], g3 = o4[9], m5 = ji5(e9, t4 + 0), y8 = ji5(e9, t4 + 2), v7 = ji5(e9, t4 + 4), b5 = ji5(e9, t4 + 6), w6 = ji5(e9, t4 + 8), E7 = ji5(e9, t4 + 10), S7 = ji5(e9, t4 + 12), _4 = ji5(e9, t4 + 14);
    let C8 = i6[0] + (8191 & m5), k8 = i6[1] + (8191 & (m5 >>> 13 | y8 << 3)), A8 = i6[2] + (8191 & (y8 >>> 10 | v7 << 6)), x5 = i6[3] + (8191 & (v7 >>> 7 | b5 << 9)), M7 = i6[4] + (8191 & (b5 >>> 4 | w6 << 12)), I7 = i6[5] + (w6 >>> 1 & 8191), T6 = i6[6] + (8191 & (w6 >>> 14 | E7 << 2)), R6 = i6[7] + (8191 & (E7 >>> 11 | S7 << 5)), P6 = i6[8] + (8191 & (S7 >>> 8 | _4 << 8)), O6 = i6[9] + (_4 >>> 5 | r6), N8 = 0, L6 = N8 + C8 * s3 + k8 * (5 * g3) + A8 * (5 * p7) + x5 * (5 * f12) + M7 * (5 * h7);
    N8 = L6 >>> 13, L6 &= 8191, L6 += I7 * (5 * u6) + T6 * (5 * d5) + R6 * (5 * l6) + P6 * (5 * c6) + O6 * (5 * a4), N8 += L6 >>> 13, L6 &= 8191;
    let D9 = N8 + C8 * a4 + k8 * s3 + A8 * (5 * g3) + x5 * (5 * p7) + M7 * (5 * f12);
    N8 = D9 >>> 13, D9 &= 8191, D9 += I7 * (5 * h7) + T6 * (5 * u6) + R6 * (5 * d5) + P6 * (5 * l6) + O6 * (5 * c6), N8 += D9 >>> 13, D9 &= 8191;
    let $7 = N8 + C8 * c6 + k8 * a4 + A8 * s3 + x5 * (5 * g3) + M7 * (5 * p7);
    N8 = $7 >>> 13, $7 &= 8191, $7 += I7 * (5 * f12) + T6 * (5 * h7) + R6 * (5 * u6) + P6 * (5 * d5) + O6 * (5 * l6), N8 += $7 >>> 13, $7 &= 8191;
    let B7 = N8 + C8 * l6 + k8 * c6 + A8 * a4 + x5 * s3 + M7 * (5 * g3);
    N8 = B7 >>> 13, B7 &= 8191, B7 += I7 * (5 * p7) + T6 * (5 * f12) + R6 * (5 * h7) + P6 * (5 * u6) + O6 * (5 * d5), N8 += B7 >>> 13, B7 &= 8191;
    let K4 = N8 + C8 * d5 + k8 * l6 + A8 * c6 + x5 * a4 + M7 * s3;
    N8 = K4 >>> 13, K4 &= 8191, K4 += I7 * (5 * g3) + T6 * (5 * p7) + R6 * (5 * f12) + P6 * (5 * h7) + O6 * (5 * u6), N8 += K4 >>> 13, K4 &= 8191;
    let j6 = N8 + C8 * u6 + k8 * d5 + A8 * l6 + x5 * c6 + M7 * a4;
    N8 = j6 >>> 13, j6 &= 8191, j6 += I7 * s3 + T6 * (5 * g3) + R6 * (5 * p7) + P6 * (5 * f12) + O6 * (5 * h7), N8 += j6 >>> 13, j6 &= 8191;
    let U6 = N8 + C8 * h7 + k8 * u6 + A8 * d5 + x5 * l6 + M7 * c6;
    N8 = U6 >>> 13, U6 &= 8191, U6 += I7 * a4 + T6 * s3 + R6 * (5 * g3) + P6 * (5 * p7) + O6 * (5 * f12), N8 += U6 >>> 13, U6 &= 8191;
    let H4 = N8 + C8 * f12 + k8 * h7 + A8 * u6 + x5 * d5 + M7 * l6;
    N8 = H4 >>> 13, H4 &= 8191, H4 += I7 * c6 + T6 * a4 + R6 * s3 + P6 * (5 * g3) + O6 * (5 * p7), N8 += H4 >>> 13, H4 &= 8191;
    let F8 = N8 + C8 * p7 + k8 * f12 + A8 * h7 + x5 * u6 + M7 * d5;
    N8 = F8 >>> 13, F8 &= 8191, F8 += I7 * l6 + T6 * c6 + R6 * a4 + P6 * s3 + O6 * (5 * g3), N8 += F8 >>> 13, F8 &= 8191;
    let z6 = N8 + C8 * g3 + k8 * p7 + A8 * f12 + x5 * h7 + M7 * u6;
    N8 = z6 >>> 13, z6 &= 8191, z6 += I7 * d5 + T6 * l6 + R6 * c6 + P6 * a4 + O6 * s3, N8 += z6 >>> 13, z6 &= 8191, N8 = (N8 << 2) + N8 | 0, N8 = N8 + L6 | 0, L6 = 8191 & N8, N8 >>>= 13, D9 += N8, i6[0] = L6, i6[1] = D9, i6[2] = $7, i6[3] = B7, i6[4] = K4, i6[5] = j6, i6[6] = U6, i6[7] = H4, i6[8] = F8, i6[9] = z6;
  }
  finalize() {
    const { h: e9, pad: t4 } = this, n4 = new Uint16Array(10);
    let r6 = e9[1] >>> 13;
    e9[1] &= 8191;
    for (let t5 = 2; t5 < 10; t5++) e9[t5] += r6, r6 = e9[t5] >>> 13, e9[t5] &= 8191;
    e9[0] += 5 * r6, r6 = e9[0] >>> 13, e9[0] &= 8191, e9[1] += r6, r6 = e9[1] >>> 13, e9[1] &= 8191, e9[2] += r6, n4[0] = e9[0] + 5, r6 = n4[0] >>> 13, n4[0] &= 8191;
    for (let t5 = 1; t5 < 10; t5++) n4[t5] = e9[t5] + r6, r6 = n4[t5] >>> 13, n4[t5] &= 8191;
    n4[9] -= 8192;
    let i6 = (1 ^ r6) - 1;
    for (let e10 = 0; e10 < 10; e10++) n4[e10] &= i6;
    i6 = ~i6;
    for (let t5 = 0; t5 < 10; t5++) e9[t5] = e9[t5] & i6 | n4[t5];
    e9[0] = 65535 & (e9[0] | e9[1] << 13), e9[1] = 65535 & (e9[1] >>> 3 | e9[2] << 10), e9[2] = 65535 & (e9[2] >>> 6 | e9[3] << 7), e9[3] = 65535 & (e9[3] >>> 9 | e9[4] << 4), e9[4] = 65535 & (e9[4] >>> 12 | e9[5] << 1 | e9[6] << 14), e9[5] = 65535 & (e9[6] >>> 2 | e9[7] << 11), e9[6] = 65535 & (e9[7] >>> 5 | e9[8] << 8), e9[7] = 65535 & (e9[8] >>> 8 | e9[9] << 5);
    let o4 = e9[0] + t4[0];
    e9[0] = 65535 & o4;
    for (let n5 = 1; n5 < 8; n5++) o4 = (e9[n5] + t4[n5] | 0) + (o4 >>> 16) | 0, e9[n5] = 65535 & o4;
    (0, Ki5.clean)(n4);
  }
  update(e9) {
    (0, Bi5.exists)(this);
    const { buffer: t4, blockLen: n4 } = this, r6 = (e9 = (0, Ki5.toBytes)(e9)).length;
    for (let i6 = 0; i6 < r6; ) {
      const o4 = Math.min(n4 - this.pos, r6 - i6);
      if (o4 !== n4) t4.set(e9.subarray(i6, i6 + o4), this.pos), this.pos += o4, i6 += o4, this.pos === n4 && (this.process(t4, 0, false), this.pos = 0);
      else for (; n4 <= r6 - i6; i6 += n4) this.process(e9, i6);
    }
    return this;
  }
  destroy() {
    (0, Ki5.clean)(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e9) {
    (0, Bi5.exists)(this), (0, Bi5.output)(e9, this), this.finished = true;
    const { buffer: t4, h: n4 } = this;
    let { pos: r6 } = this;
    if (r6) {
      for (t4[r6++] = 1; r6 < 16; r6++) t4[r6] = 0;
      this.process(t4, 0, true);
    }
    this.finalize();
    let i6 = 0;
    for (let t5 = 0; t5 < 8; t5++) e9[i6++] = n4[t5] >>> 0, e9[i6++] = n4[t5] >>> 8;
    return e9;
  }
  digest() {
    const { buffer: e9, outputLen: t4 } = this;
    this.digestInto(e9);
    const n4 = e9.slice(0, t4);
    return this.destroy(), n4;
  }
};
function Hi4(e9) {
  const t4 = (t5, n5) => e9(n5).update((0, Ki5.toBytes)(t5)).digest(), n4 = e9(new Uint8Array(32));
  return t4.outputLen = n4.outputLen, t4.blockLen = n4.blockLen, t4.create = (t5) => e9(t5), t4;
}
$i5.poly1305 = Hi4(((e9) => new Ui5(e9))), (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.xchacha20poly1305 = e9.chacha20poly1305 = e9._poly1305_aead = e9.chacha12 = e9.chacha8 = e9.xchacha20 = e9.chacha20 = e9.chacha20orig = void 0, e9.hchacha = s3;
  const t4 = Ci5, n4 = ge4, r6 = $i5, i6 = pe6;
  function o4(e10, n5, r7, i7, o5, s4 = 20) {
    let a5 = e10[0], c7 = e10[1], l7 = e10[2], d6 = e10[3], u6 = n5[0], h7 = n5[1], f12 = n5[2], p7 = n5[3], g3 = n5[4], m5 = n5[5], y8 = n5[6], v7 = n5[7], b5 = o5, w6 = r7[0], E7 = r7[1], S7 = r7[2], _4 = a5, C8 = c7, k8 = l7, A8 = d6, x5 = u6, M7 = h7, I7 = f12, T6 = p7, R6 = g3, P6 = m5, O6 = y8, N8 = v7, L6 = b5, D9 = w6, $7 = E7, B7 = S7;
    for (let e11 = 0; e11 < s4; e11 += 2) _4 = _4 + x5 | 0, L6 = (0, t4.rotl)(L6 ^ _4, 16), R6 = R6 + L6 | 0, x5 = (0, t4.rotl)(x5 ^ R6, 12), _4 = _4 + x5 | 0, L6 = (0, t4.rotl)(L6 ^ _4, 8), R6 = R6 + L6 | 0, x5 = (0, t4.rotl)(x5 ^ R6, 7), C8 = C8 + M7 | 0, D9 = (0, t4.rotl)(D9 ^ C8, 16), P6 = P6 + D9 | 0, M7 = (0, t4.rotl)(M7 ^ P6, 12), C8 = C8 + M7 | 0, D9 = (0, t4.rotl)(D9 ^ C8, 8), P6 = P6 + D9 | 0, M7 = (0, t4.rotl)(M7 ^ P6, 7), k8 = k8 + I7 | 0, $7 = (0, t4.rotl)($7 ^ k8, 16), O6 = O6 + $7 | 0, I7 = (0, t4.rotl)(I7 ^ O6, 12), k8 = k8 + I7 | 0, $7 = (0, t4.rotl)($7 ^ k8, 8), O6 = O6 + $7 | 0, I7 = (0, t4.rotl)(I7 ^ O6, 7), A8 = A8 + T6 | 0, B7 = (0, t4.rotl)(B7 ^ A8, 16), N8 = N8 + B7 | 0, T6 = (0, t4.rotl)(T6 ^ N8, 12), A8 = A8 + T6 | 0, B7 = (0, t4.rotl)(B7 ^ A8, 8), N8 = N8 + B7 | 0, T6 = (0, t4.rotl)(T6 ^ N8, 7), _4 = _4 + M7 | 0, B7 = (0, t4.rotl)(B7 ^ _4, 16), O6 = O6 + B7 | 0, M7 = (0, t4.rotl)(M7 ^ O6, 12), _4 = _4 + M7 | 0, B7 = (0, t4.rotl)(B7 ^ _4, 8), O6 = O6 + B7 | 0, M7 = (0, t4.rotl)(M7 ^ O6, 7), C8 = C8 + I7 | 0, L6 = (0, t4.rotl)(L6 ^ C8, 16), N8 = N8 + L6 | 0, I7 = (0, t4.rotl)(I7 ^ N8, 12), C8 = C8 + I7 | 0, L6 = (0, t4.rotl)(L6 ^ C8, 8), N8 = N8 + L6 | 0, I7 = (0, t4.rotl)(I7 ^ N8, 7), k8 = k8 + T6 | 0, D9 = (0, t4.rotl)(D9 ^ k8, 16), R6 = R6 + D9 | 0, T6 = (0, t4.rotl)(T6 ^ R6, 12), k8 = k8 + T6 | 0, D9 = (0, t4.rotl)(D9 ^ k8, 8), R6 = R6 + D9 | 0, T6 = (0, t4.rotl)(T6 ^ R6, 7), A8 = A8 + x5 | 0, $7 = (0, t4.rotl)($7 ^ A8, 16), P6 = P6 + $7 | 0, x5 = (0, t4.rotl)(x5 ^ P6, 12), A8 = A8 + x5 | 0, $7 = (0, t4.rotl)($7 ^ A8, 8), P6 = P6 + $7 | 0, x5 = (0, t4.rotl)(x5 ^ P6, 7);
    let K4 = 0;
    i7[K4++] = a5 + _4 | 0, i7[K4++] = c7 + C8 | 0, i7[K4++] = l7 + k8 | 0, i7[K4++] = d6 + A8 | 0, i7[K4++] = u6 + x5 | 0, i7[K4++] = h7 + M7 | 0, i7[K4++] = f12 + I7 | 0, i7[K4++] = p7 + T6 | 0, i7[K4++] = g3 + R6 | 0, i7[K4++] = m5 + P6 | 0, i7[K4++] = y8 + O6 | 0, i7[K4++] = v7 + N8 | 0, i7[K4++] = b5 + L6 | 0, i7[K4++] = w6 + D9 | 0, i7[K4++] = E7 + $7 | 0, i7[K4++] = S7 + B7 | 0;
  }
  function s3(e10, n5, r7, i7) {
    let o5 = e10[0], s4 = e10[1], a5 = e10[2], c7 = e10[3], l7 = n5[0], d6 = n5[1], u6 = n5[2], h7 = n5[3], f12 = n5[4], p7 = n5[5], g3 = n5[6], m5 = n5[7], y8 = r7[0], v7 = r7[1], b5 = r7[2], w6 = r7[3];
    for (let e11 = 0; e11 < 20; e11 += 2) o5 = o5 + l7 | 0, y8 = (0, t4.rotl)(y8 ^ o5, 16), f12 = f12 + y8 | 0, l7 = (0, t4.rotl)(l7 ^ f12, 12), o5 = o5 + l7 | 0, y8 = (0, t4.rotl)(y8 ^ o5, 8), f12 = f12 + y8 | 0, l7 = (0, t4.rotl)(l7 ^ f12, 7), s4 = s4 + d6 | 0, v7 = (0, t4.rotl)(v7 ^ s4, 16), p7 = p7 + v7 | 0, d6 = (0, t4.rotl)(d6 ^ p7, 12), s4 = s4 + d6 | 0, v7 = (0, t4.rotl)(v7 ^ s4, 8), p7 = p7 + v7 | 0, d6 = (0, t4.rotl)(d6 ^ p7, 7), a5 = a5 + u6 | 0, b5 = (0, t4.rotl)(b5 ^ a5, 16), g3 = g3 + b5 | 0, u6 = (0, t4.rotl)(u6 ^ g3, 12), a5 = a5 + u6 | 0, b5 = (0, t4.rotl)(b5 ^ a5, 8), g3 = g3 + b5 | 0, u6 = (0, t4.rotl)(u6 ^ g3, 7), c7 = c7 + h7 | 0, w6 = (0, t4.rotl)(w6 ^ c7, 16), m5 = m5 + w6 | 0, h7 = (0, t4.rotl)(h7 ^ m5, 12), c7 = c7 + h7 | 0, w6 = (0, t4.rotl)(w6 ^ c7, 8), m5 = m5 + w6 | 0, h7 = (0, t4.rotl)(h7 ^ m5, 7), o5 = o5 + d6 | 0, w6 = (0, t4.rotl)(w6 ^ o5, 16), g3 = g3 + w6 | 0, d6 = (0, t4.rotl)(d6 ^ g3, 12), o5 = o5 + d6 | 0, w6 = (0, t4.rotl)(w6 ^ o5, 8), g3 = g3 + w6 | 0, d6 = (0, t4.rotl)(d6 ^ g3, 7), s4 = s4 + u6 | 0, y8 = (0, t4.rotl)(y8 ^ s4, 16), m5 = m5 + y8 | 0, u6 = (0, t4.rotl)(u6 ^ m5, 12), s4 = s4 + u6 | 0, y8 = (0, t4.rotl)(y8 ^ s4, 8), m5 = m5 + y8 | 0, u6 = (0, t4.rotl)(u6 ^ m5, 7), a5 = a5 + h7 | 0, v7 = (0, t4.rotl)(v7 ^ a5, 16), f12 = f12 + v7 | 0, h7 = (0, t4.rotl)(h7 ^ f12, 12), a5 = a5 + h7 | 0, v7 = (0, t4.rotl)(v7 ^ a5, 8), f12 = f12 + v7 | 0, h7 = (0, t4.rotl)(h7 ^ f12, 7), c7 = c7 + l7 | 0, b5 = (0, t4.rotl)(b5 ^ c7, 16), p7 = p7 + b5 | 0, l7 = (0, t4.rotl)(l7 ^ p7, 12), c7 = c7 + l7 | 0, b5 = (0, t4.rotl)(b5 ^ c7, 8), p7 = p7 + b5 | 0, l7 = (0, t4.rotl)(l7 ^ p7, 7);
    let E7 = 0;
    i7[E7++] = o5, i7[E7++] = s4, i7[E7++] = a5, i7[E7++] = c7, i7[E7++] = y8, i7[E7++] = v7, i7[E7++] = b5, i7[E7++] = w6;
  }
  e9.chacha20orig = (0, t4.createCipher)(o4, { counterRight: false, counterLength: 8, allowShortKeys: true }), e9.chacha20 = (0, t4.createCipher)(o4, { counterRight: false, counterLength: 4, allowShortKeys: false }), e9.xchacha20 = (0, t4.createCipher)(o4, { counterRight: false, counterLength: 8, extendNonceFn: s3, allowShortKeys: false }), e9.chacha8 = (0, t4.createCipher)(o4, { counterRight: false, counterLength: 4, rounds: 8 }), e9.chacha12 = (0, t4.createCipher)(o4, { counterRight: false, counterLength: 4, rounds: 12 });
  const a4 = new Uint8Array(16), c6 = (e10, t5) => {
    e10.update(t5);
    const n5 = t5.length % 16;
    n5 && e10.update(a4.subarray(n5));
  }, l6 = new Uint8Array(32);
  function d5(e10, t5, n5, o5, s4) {
    const a5 = e10(t5, n5, l6), d6 = r6.poly1305.create(a5);
    s4 && c6(d6, s4), c6(d6, o5);
    const u6 = new Uint8Array(16), h7 = (0, i6.createView)(u6);
    (0, i6.setBigUint64)(h7, 0, BigInt(s4 ? s4.length : 0), true), (0, i6.setBigUint64)(h7, 8, BigInt(o5.length), true), d6.update(u6);
    const f12 = d6.digest();
    return (0, i6.clean)(a5, u6), f12;
  }
  e9._poly1305_aead = (e10) => (t5, r7, o5) => {
    const s4 = 16;
    return (0, n4.bytes)(t5, 32), (0, n4.bytes)(r7), { encrypt(a5, c7) {
      const l7 = a5.length, u6 = l7 + s4;
      c7 ? (0, n4.bytes)(c7, u6) : c7 = new Uint8Array(u6), e10(t5, r7, a5, c7, 1);
      const h7 = d5(e10, t5, r7, c7.subarray(0, -16), o5);
      return c7.set(h7, l7), (0, i6.clean)(h7), c7;
    }, decrypt(a5, c7) {
      const l7 = a5.length, u6 = l7 - s4;
      if (l7 < s4) throw new Error("encrypted data must be at least 16 bytes");
      c7 ? (0, n4.bytes)(c7, u6) : c7 = new Uint8Array(u6);
      const h7 = a5.subarray(0, -16), f12 = a5.subarray(-16), p7 = d5(e10, t5, r7, h7, o5);
      if (!(0, i6.equalBytes)(f12, p7)) throw new Error("invalid tag");
      return e10(t5, r7, h7, c7, 1), (0, i6.clean)(p7), c7;
    } };
  }, e9.chacha20poly1305 = (0, i6.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, e9._poly1305_aead)(e9.chacha20)), e9.xchacha20poly1305 = (0, i6.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, e9._poly1305_aead)(e9.xchacha20));
})(_i5), Object.defineProperty(Si5, "__esModule", { value: true }), Si5.xchacha20 = void 0;
var Fi5;
var zi5;
var qi5;
var Wi5 = _i5;
Si5.xchacha20 = function(e9, t4, n4) {
  return (0, Wi5.xchacha20poly1305)(e9, t4, n4);
}, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.aesDecrypt = e9.aesEncrypt = e9.symDecrypt = e9.symEncrypt = void 0;
  var t4 = pe6, n4 = Te4, r6 = Cr3, i6 = Si5, o4 = Ce7, s3 = ke7;
  e9.symEncrypt = function(e10, t5, n5) {
    return a4(c6, e10, t5, n5);
  };
  function a4(e10, t5, n5, a5) {
    var c7 = (0, o4.symmetricAlgorithm)();
    if ("aes-256-gcm" === c7) return e10(r6.aes256gcm, t5, n5, (0, o4.symmetricNonceLength)(), s3.AEAD_TAG_LENGTH, a5);
    if ("xchacha20" === c7) return e10(i6.xchacha20, t5, n5, s3.XCHACHA20_NONCE_LENGTH, s3.AEAD_TAG_LENGTH, a5);
    if ("aes-256-cbc" === c7) return e10(r6.aes256cbc, t5, n5, 16, 0);
    throw new Error("Not implemented");
  }
  function c6(e10, r7, i7, o5, s4, a5) {
    var c7 = (0, n4.randomBytes)(o5), l7 = e10(r7, c7, a5).encrypt(i7);
    if (0 === s4) return (0, t4.concatBytes)(c7, l7);
    var d5 = l7.length - s4, u6 = l7.subarray(0, d5), h7 = l7.subarray(d5);
    return (0, t4.concatBytes)(c7, h7, u6);
  }
  function l6(e10, n5, r7, i7, o5, s4) {
    var a5 = r7.subarray(0, i7), c7 = e10(n5, Uint8Array.from(a5), s4), l7 = r7.subarray(i7);
    if (0 === o5) return c7.decrypt(l7);
    var d5 = l7.subarray(0, o5), u6 = l7.subarray(o5);
    return c7.decrypt((0, t4.concatBytes)(u6, d5));
  }
  e9.symDecrypt = function(e10, t5, n5) {
    return a4(l6, e10, t5, n5);
  }, e9.aesEncrypt = e9.symEncrypt, e9.aesDecrypt = e9.symDecrypt;
})(_r5), Fi5 = Me5, zi5 = de6 && de6.__createBinding || (Object.create ? function(e9, t4, n4, r6) {
  void 0 === r6 && (r6 = n4);
  var i6 = Object.getOwnPropertyDescriptor(t4, n4);
  i6 && !("get" in i6 ? !t4.__esModule : i6.writable || i6.configurable) || (i6 = { enumerable: true, get: function() {
    return t4[n4];
  } }), Object.defineProperty(e9, r6, i6);
} : function(e9, t4, n4, r6) {
  void 0 === r6 && (r6 = n4), e9[r6] = t4[n4];
}), qi5 = de6 && de6.__exportStar || function(e9, t4) {
  for (var n4 in e9) "default" === n4 || Object.prototype.hasOwnProperty.call(t4, n4) || zi5(t4, e9, n4);
}, Object.defineProperty(Fi5, "__esModule", { value: true }), qi5(Ie6, Fi5), qi5(pr3, Fi5), qi5(fr3, Fi5), qi5(_r5, Fi5);
var Vi5 = {};
Object.defineProperty(Vi5, "__esModule", { value: true }), Vi5.PublicKey = void 0;
var Gi5 = pe6;
var Yi4 = Me5;
var Zi4 = (function() {
  function e9(e10) {
    this.data = (0, Yi4.convertPublicKeyFormat)(e10, true);
  }
  return e9.fromHex = function(t4) {
    return new e9((0, Yi4.hexToPublicKey)(t4));
  }, Object.defineProperty(e9.prototype, "uncompressed", { get: function() {
    return C7.from((0, Yi4.convertPublicKeyFormat)(this.data, false));
  }, enumerable: false, configurable: true }), Object.defineProperty(e9.prototype, "compressed", { get: function() {
    return C7.from(this.data);
  }, enumerable: false, configurable: true }), e9.prototype.toHex = function(e10) {
    return void 0 === e10 && (e10 = true), (0, Gi5.bytesToHex)(e10 ? this.data : this.uncompressed);
  }, e9.prototype.decapsulate = function(e10, t4) {
    void 0 === t4 && (t4 = false);
    var n4 = t4 ? this.data : this.uncompressed, r6 = e10.multiply(this, t4);
    return (0, Yi4.getSharedKey)(n4, r6);
  }, e9.prototype.equals = function(e10) {
    return (0, Gi5.equalBytes)(this.data, e10.data);
  }, e9;
})();
Vi5.PublicKey = Zi4, Object.defineProperty(xe4, "__esModule", { value: true }), xe4.PrivateKey = void 0;
var Ji4 = pe6;
var Qi4 = Me5;
var Xi4 = Vi5;
var eo5 = (function() {
  function e9(e10) {
    if (void 0 === e10) this.data = (0, Qi4.getValidSecret)();
    else {
      if (!(0, Qi4.isValidPrivateKey)(e10)) throw new Error("Invalid private key");
      this.data = e10;
    }
    this.publicKey = new Xi4.PublicKey((0, Qi4.getPublicKey)(this.data));
  }
  return e9.fromHex = function(t4) {
    return new e9((0, Qi4.decodeHex)(t4));
  }, Object.defineProperty(e9.prototype, "secret", { get: function() {
    return C7.from(this.data);
  }, enumerable: false, configurable: true }), e9.prototype.toHex = function() {
    return (0, Ji4.bytesToHex)(this.data);
  }, e9.prototype.encapsulate = function(e10, t4) {
    void 0 === t4 && (t4 = false);
    var n4 = t4 ? this.publicKey.compressed : this.publicKey.uncompressed, r6 = this.multiply(e10, t4);
    return (0, Qi4.getSharedKey)(n4, r6);
  }, e9.prototype.multiply = function(e10, t4) {
    return void 0 === t4 && (t4 = false), (0, Qi4.getSharedPoint)(this.data, e10.compressed, t4);
  }, e9.prototype.equals = function(e10) {
    return (0, Ji4.equalBytes)(this.data, e10.data);
  }, e9;
})();
xe4.PrivateKey = eo5, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.PublicKey = e9.PrivateKey = void 0;
  var t4 = xe4;
  Object.defineProperty(e9, "PrivateKey", { enumerable: true, get: function() {
    return t4.PrivateKey;
  } });
  var n4 = Vi5;
  Object.defineProperty(e9, "PublicKey", { enumerable: true, get: function() {
    return n4.PublicKey;
  } });
})(Ae5), (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.utils = e9.PublicKey = e9.PrivateKey = e9.ECIES_CONFIG = void 0, e9.encrypt = function(e10, o5) {
    var s4 = new r6.PrivateKey(), a4 = e10 instanceof Uint8Array ? new r6.PublicKey(e10) : r6.PublicKey.fromHex(e10), c6 = s4.encapsulate(a4, (0, n4.isHkdfKeyCompressed)()), l6 = (0, n4.isEphemeralKeyCompressed)() ? s4.publicKey.compressed : s4.publicKey.uncompressed, d5 = (0, i6.symEncrypt)(c6, o5);
    return C7.from((0, t4.concatBytes)(l6, d5));
  }, e9.decrypt = function(e10, t5) {
    var o5 = e10 instanceof Uint8Array ? new r6.PrivateKey(e10) : r6.PrivateKey.fromHex(e10), s4 = (0, n4.ephemeralKeySize)(), a4 = new r6.PublicKey(t5.subarray(0, s4)), c6 = t5.subarray(s4), l6 = a4.decapsulate(o5, (0, n4.isHkdfKeyCompressed)());
    return C7.from((0, i6.symDecrypt)(l6, c6));
  };
  var t4 = pe6, n4 = Ce7, r6 = Ae5, i6 = Me5;
  var o4 = Ce7;
  Object.defineProperty(e9, "ECIES_CONFIG", { enumerable: true, get: function() {
    return o4.ECIES_CONFIG;
  } });
  var s3 = Ae5;
  Object.defineProperty(e9, "PrivateKey", { enumerable: true, get: function() {
    return s3.PrivateKey;
  } }), Object.defineProperty(e9, "PublicKey", { enumerable: true, get: function() {
    return s3.PublicKey;
  } }), e9.utils = { aesEncrypt: i6.aesEncrypt, aesDecrypt: i6.aesDecrypt, symEncrypt: i6.symEncrypt, symDecrypt: i6.symDecrypt, decodeHex: i6.decodeHex, getValidSecret: i6.getValidSecret, remove0x: i6.remove0x };
})(fe6);
var to5 = (0, import_debug.default)("KeyExchange:Layer");
var no5 = (0, import_debug.default)("SocketService:Layer");
var ro5 = (0, import_debug.default)("Ecies:Layer");
var io5 = (0, import_debug.default)("RemoteCommunication:Layer");
to5.color = "##95c44e", no5.color = "#f638d7", ro5.color = "#465b9c", io5.color = "#47a2be";
var oo5 = { KeyExchange: to5, SocketService: no5, Ecies: ro5, RemoteCommunication: io5 };
var so5;
var ao5 = [];
var co5 = [];
var lo5 = (t4, n4) => c5(void 0, void 0, void 0, (function* () {
  so5 = n4, co5.push(t4), (function(t5) {
    return c5(this, void 0, void 0, (function* () {
      if (!so5 || !t5) return;
      !(function() {
        const e9 = co5;
        co5 = ao5, ao5 = e9;
      })();
      const n5 = so5.endsWith("/") ? `${so5}evt` : `${so5}/evt`, r6 = Object.assign({}, t5);
      if (delete r6.params, t5.params) for (const [e9, n6] of Object.entries(t5.params)) r6[e9] = n6;
      const i6 = JSON.stringify(r6);
      oo5.RemoteCommunication(`[sendBufferedEvents] Sending ${ao5.length} analytics events to ${n5}`);
      try {
        const t6 = yield (0, import_cross_fetch.default)(n5, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: i6 }), r7 = yield t6.text();
        oo5.RemoteCommunication(`[sendBufferedEvents] Response: ${r7}`), ao5.length = 0;
      } catch (n6) {
      }
    }));
  })(t4).catch((() => {
  }));
}));
var uo5 = class {
  constructor(e9) {
    this.enabled = true, (null == e9 ? void 0 : e9.debug) && import_debug.default.enable("Ecies:Layer"), this.ecies = (null == e9 ? void 0 : e9.privateKey) ? fe6.PrivateKey.fromHex(e9.privateKey) : new fe6.PrivateKey(), oo5.Ecies("[ECIES constructor()] initialized secret: ", this.ecies.toHex()), oo5.Ecies("[ECIES constructor()] initialized public: ", this.ecies.publicKey.toHex()), oo5.Ecies("[ECIES constructor()] init with", this);
  }
  generateECIES() {
    this.ecies = new fe6.PrivateKey();
  }
  getPublicKey() {
    return this.ecies.publicKey.toHex();
  }
  encrypt(e9, t4) {
    let n4 = e9;
    if (this.enabled) try {
      oo5.Ecies("[ECIES: encrypt()] using otherPublicKey", t4);
      const r6 = C7.from(e9), i6 = fe6.encrypt(t4, r6);
      n4 = C7.from(i6).toString("base64");
    } catch (n5) {
      throw oo5.Ecies("[ECIES: encrypt()] error encrypt:", n5), oo5.Ecies("[ECIES: encrypt()] private: ", this.ecies.toHex()), oo5.Ecies("[ECIES: encrypt()] data: ", e9), oo5.Ecies("[ECIES: encrypt()] otherkey: ", t4), n5;
    }
    return n4;
  }
  decrypt(e9) {
    let t4 = e9;
    if (this.enabled) try {
      oo5.Ecies("[ECIES: decrypt()] using privateKey", this.ecies.toHex());
      const n4 = C7.from(e9.toString(), "base64");
      t4 = fe6.decrypt(this.ecies.toHex(), n4).toString();
    } catch (t5) {
      throw oo5.Ecies("[ECIES: decrypt()] error decrypt", t5), oo5.Ecies("[ECIES: decrypt()] private: ", this.ecies.toHex()), oo5.Ecies("[ECIES: decrypt()] encryptedData: ", e9), t5;
    }
    return t4;
  }
  getKeyInfo() {
    return { private: this.ecies.toHex(), public: this.ecies.publicKey.toHex() };
  }
  toString() {
    oo5.Ecies("[ECIES: toString()]", this.getKeyInfo());
  }
};
var ho5 = { name: "@metamask/sdk-communication-layer", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk.git", directory: "packages/sdk-communication-layer" }, main: "dist/node/cjs/metamask-sdk-communication-layer.js", unpkg: "dist/browser/umd/metamask-sdk-communication-layer.js", module: "dist/node/es/metamask-sdk-communication-layer.js", browser: "dist/browser/es/metamask-sdk-communication-layer.js", "react-native": "dist/react-native/es/metamask-sdk-communication-layer.js", types: "dist/types/src/index.d.ts", files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", "build:clean": "yarn clean && yarn build", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs", dev: 'concurrently "tsc --watch" "rollup -c --bundleConfigAsCjs -w"', "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", size: "size-limit", clean: "rimraf ./dist", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk-communication-layer", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", "publish:preview": "yarn npm publish --tag preview", prepack: "../../scripts/prepack.sh", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:coverage": "jest --coverage", "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": "jest", watch: "rollup -c --bundleConfigAsCjs -w" }, dependencies: { "@metamask/sdk-analytics": "workspace:*", bufferutil: "^4.0.8", "date-fns": "^2.29.3", debug: "^4.3.4", "utf-8-validate": "^5.0.2", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@rollup/plugin-commonjs": "^25.0.0", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.4", "@size-limit/preset-big-lib": "^11.0.2", "@types/jest": "^29.2.4", "@types/node": "^20.1.3", "@types/uuid": "^9.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", concurrently: "^9.1.2", "cross-fetch": "^4.0.0", eciesjs: "^0.4.11", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", eventemitter2: "^6.4.9", jest: "^29.3.1", prettier: "^2.3.0", rimraf: "^3.0.2", rollup: "^4.26.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-node-globals": "^1.4.0", "rollup-plugin-peer-deps-external": "^2.2.4", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.1.6", "socket.io-client": "^4.5.1", "stream-browserify": "^3.0.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^5.6.3" }, peerDependencies: { "cross-fetch": "^4.0.0", eciesjs: "*", eventemitter2: "^6.4.9", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "@lavamoat/preinstall-always-fail": false, canvas: true, "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, bufferutil: false, "utf-8-validate": false } } };
var fo5 = "https://metamask-sdk.api.cx.metamask.io/";
var po5 = ["websocket"];
var go5 = 6048e5;
var mo5 = 3e3;
var yo5 = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_SWITCHETHEREUMCHAIN: "wallet_switchEthereumChain", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var vo5 = [yo5.METAMASK_CONNECTSIGN, yo5.METAMASK_CONNECTWITH, yo5.METAMASK_OPEN, yo5.METAMASK_BATCH, yo5.PERSONAL_SIGN, yo5.WALLET_REQUESTPERMISSIONS, yo5.WALLET_REVOKEPERMISSIONS, yo5.WALLET_WATCHASSET, yo5.ETH_SENDTRANSACTION, yo5.ETH_SIGNTYPEDDATA, yo5.ETH_SIGNTYPEDDATA_V3, yo5.ETH_SIGNTYPEDDATA_V4, yo5.ETH_SIGNTRANSACTION, yo5.ETH_SIGN, yo5.PERSONAL_EC_RECOVER];
function bo5(e9) {
  return vo5.includes(e9);
}
function wo5(e9) {
  const { context: t4 } = e9;
  oo5.RemoteCommunication(`[RemoteCommunication: clean()] context=${t4}`), e9.channelConfig = void 0, e9.ready = false, e9.originatorConnectStarted = false;
}
var Eo5;
var So5;
var _o5;
var Co5;
var ko3;
var Ao5;
var xo5;
(xo5 = Eo5 || (Eo5 = {})).DISCONNECTED = "disconnected", xo5.WAITING = "waiting", xo5.TIMEOUT = "timeout", xo5.LINKED = "linked", xo5.PAUSED = "paused", xo5.TERMINATED = "terminated", (function(e9) {
  e9.KEY_INFO = "key_info", e9.SERVICE_STATUS = "service_status", e9.PROVIDER_UPDATE = "provider_update", e9.RPC_UPDATE = "rpc_update", e9.KEYS_EXCHANGED = "keys_exchanged", e9.JOIN_CHANNEL = "join_channel", e9.PUBLIC_KEY = "public_key", e9.CHANNEL_CREATED = "channel_created", e9.CLIENTS_CONNECTED = "clients_connected", e9.CLIENTS_DISCONNECTED = "clients_disconnected", e9.CLIENTS_WAITING = "clients_waiting", e9.CLIENTS_READY = "clients_ready", e9.REJECTED = "rejected", e9.WALLET_INIT = "wallet_init", e9.CHANNEL_PERSISTENCE = "channel_persistence", e9.CONFIG = "config", e9.MESSAGE_ACK = "ack", e9.SOCKET_DISCONNECTED = "socket_disconnected", e9.SOCKET_RECONNECT = "socket_reconnect", e9.OTP = "otp", e9.SDK_RPC_CALL = "sdk_rpc_call", e9.AUTHORIZED = "authorized", e9.CONNECTION_STATUS = "connection_status", e9.MESSAGE = "message", e9.TERMINATE = "terminate";
})(So5 || (So5 = {})), (_o5 || (_o5 = {})).KEY_EXCHANGE = "key_exchange", (function(e9) {
  e9.KEY_HANDSHAKE_START = "key_handshake_start", e9.KEY_HANDSHAKE_CHECK = "key_handshake_check", e9.KEY_HANDSHAKE_SYN = "key_handshake_SYN", e9.KEY_HANDSHAKE_SYNACK = "key_handshake_SYNACK", e9.KEY_HANDSHAKE_ACK = "key_handshake_ACK", e9.KEY_HANDSHAKE_WALLET = "key_handshake_wallet", e9.KEY_HANDSHAKE_NONE = "none";
})(Co5 || (Co5 = {}));
var Mo3 = class extends import_eventemitter2.EventEmitter2 {
  constructor({ communicationLayer: e9, otherPublicKey: t4, context: n4, ecies: r6, logging: i6 }) {
    super(), this.keysExchanged = false, this.step = Co5.KEY_HANDSHAKE_NONE, this.debug = false, this.context = n4, this.communicationLayer = e9, (null == r6 ? void 0 : r6.privateKey) && t4 && (oo5.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${t4} set keysExchanged to true!`, r6), this.keysExchanged = true), this.myECIES = new uo5(Object.assign(Object.assign({}, r6), { debug: null == i6 ? void 0 : i6.eciesLayer })), this.communicationLayer.state.eciesInstance = this.myECIES, this.myPublicKey = this.myECIES.getPublicKey(), this.debug = true === (null == i6 ? void 0 : i6.keyExchangeLayer), t4 && this.setOtherPublicKey(t4), this.communicationLayer.on(_o5.KEY_EXCHANGE, this.onKeyExchangeMessage.bind(this));
  }
  onKeyExchangeMessage(e9) {
    const { relayPersistence: t4 } = this.communicationLayer.remote.state;
    if (oo5.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${t4}`, e9), t4) return void oo5.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");
    const { message: n4 } = e9;
    this.keysExchanged && oo5.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`), this.emit(So5.KEY_INFO, n4.type), n4.type === Co5.KEY_HANDSHAKE_SYN ? (this.checkStep([Co5.KEY_HANDSHAKE_NONE, Co5.KEY_HANDSHAKE_ACK]), oo5.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN", n4), n4.pubkey && this.setOtherPublicKey(n4.pubkey), this.communicationLayer.sendMessage({ type: Co5.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey }).catch(((e10) => {
      oo5.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK", e10);
    })), this.setStep(Co5.KEY_HANDSHAKE_ACK)) : n4.type === Co5.KEY_HANDSHAKE_SYNACK ? (this.checkStep([Co5.KEY_HANDSHAKE_SYNACK, Co5.KEY_HANDSHAKE_ACK, Co5.KEY_HANDSHAKE_NONE]), oo5.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"), n4.pubkey && this.setOtherPublicKey(n4.pubkey), this.communicationLayer.sendMessage({ type: Co5.KEY_HANDSHAKE_ACK }).catch(((e10) => {
      oo5.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK", e10);
    })), this.keysExchanged = true, this.setStep(Co5.KEY_HANDSHAKE_ACK), this.emit(So5.KEYS_EXCHANGED)) : n4.type === Co5.KEY_HANDSHAKE_ACK && (oo5.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"), this.checkStep([Co5.KEY_HANDSHAKE_ACK, Co5.KEY_HANDSHAKE_NONE]), this.keysExchanged = true, this.setStep(Co5.KEY_HANDSHAKE_ACK), this.emit(So5.KEYS_EXCHANGED));
  }
  resetKeys(e9) {
    this.clean(), this.myECIES = new uo5(e9);
  }
  clean() {
    oo5.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`), this.setStep(Co5.KEY_HANDSHAKE_NONE), this.emit(So5.KEY_INFO, this.step), this.keysExchanged = false;
  }
  start({ isOriginator: e9, force: t4 }) {
    const { relayPersistence: n4, protocolVersion: r6 } = this.communicationLayer.remote.state, i6 = r6 >= 2;
    n4 ? oo5.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated") : (oo5.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${r6} isOriginator=${e9} step=${this.step} force=${t4} relayPersistence=${n4} keysExchanged=${this.keysExchanged}`), e9 ? !(this.keysExchanged || this.step !== Co5.KEY_HANDSHAKE_NONE && this.step !== Co5.KEY_HANDSHAKE_SYNACK) || t4 ? (oo5.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${t4}) -- step=${this.step}`, this.step), this.clean(), this.setStep(Co5.KEY_HANDSHAKE_SYNACK), this.communicationLayer.sendMessage({ type: Co5.KEY_HANDSHAKE_SYN, pubkey: this.myPublicKey, v: 2 }).catch(((e10) => {
      oo5.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN", e10);
    }))) : oo5.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged ? "done" : "in progress"} -- aborted.`, this.step) : this.keysExchanged && true !== t4 ? oo5.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done.") : i6 ? this.communicationLayer.sendMessage({ type: Co5.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey, v: 2 }).catch(((e10) => {
      oo5.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK", e10);
    })) : (this.communicationLayer.sendMessage({ type: Co5.KEY_HANDSHAKE_START }).catch(((e10) => {
      oo5.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START", e10);
    })), this.clean()));
  }
  setStep(e9) {
    this.step = e9, this.emit(So5.KEY_INFO, e9);
  }
  checkStep(e9) {
    e9.length > 0 && e9.indexOf(this.step.toString());
  }
  setRelayPersistence({ localKey: e9, otherKey: t4 }) {
    this.otherPublicKey = t4, this.myECIES = new uo5({ privateKey: e9, debug: this.debug }), this.keysExchanged = true;
  }
  setKeysExchanged(e9) {
    this.keysExchanged = e9;
  }
  areKeysExchanged() {
    return this.keysExchanged;
  }
  getMyPublicKey() {
    return this.myPublicKey;
  }
  getOtherPublicKey() {
    return this.otherPublicKey;
  }
  setOtherPublicKey(e9) {
    oo5.KeyExchange("[KeyExchange: setOtherPubKey()]", e9), this.otherPublicKey = e9;
  }
  encryptMessage(e9) {
    if (!this.otherPublicKey) throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.encrypt(e9, this.otherPublicKey);
  }
  decryptMessage(e9) {
    if (!this.otherPublicKey) throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.decrypt(e9);
  }
  getKeyInfo() {
    return { ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), { otherPubKey: this.otherPublicKey }), step: this.step, keysExchanged: this.areKeysExchanged() };
  }
  toString() {
    const e9 = { keyInfo: this.getKeyInfo(), keysExchanged: this.keysExchanged, step: this.step };
    return JSON.stringify(e9);
  }
};
!(function(e9) {
  e9.TERMINATE = "terminate", e9.ANSWER = "answer", e9.OFFER = "offer", e9.CANDIDATE = "candidate", e9.JSONRPC = "jsonrpc", e9.WALLET_INFO = "wallet_info", e9.WALLET_INIT = "wallet_init", e9.ORIGINATOR_INFO = "originator_info", e9.PAUSE = "pause", e9.OTP = "otp", e9.AUTHORIZED = "authorized", e9.PING = "ping", e9.READY = "ready";
})(ko3 || (ko3 = {})), (function(e9) {
  e9.REQUEST = "sdk_connect_request_started", e9.REQUEST_MOBILE = "sdk_connect_request_started_mobile", e9.RECONNECT = "sdk_reconnect_request_started", e9.CONNECTED = "sdk_connection_established", e9.CONNECTED_MOBILE = "sdk_connection_established_mobile", e9.AUTHORIZED = "sdk_connection_authorized", e9.REJECTED = "sdk_connection_rejected", e9.TERMINATED = "sdk_connection_terminated", e9.DISCONNECTED = "sdk_disconnected", e9.SDK_USE_EXTENSION = "sdk_use_extension", e9.SDK_RPC_REQUEST = "sdk_rpc_request", e9.SDK_RPC_REQUEST_RECEIVED = "sdk_rpc_request_received", e9.SDK_RPC_REQUEST_DONE = "sdk_rpc_request_done", e9.SDK_EXTENSION_UTILIZED = "sdk_extension_utilized", e9.SDK_USE_INAPP_BROWSER = "sdk_use_inapp_browser";
})(Ao5 || (Ao5 = {}));
var Io5 = (e9, t4, n4) => c5(void 0, void 0, void 0, (function* () {
  var r6, i6, o4, s3, a4, c6;
  const { remote: l6, state: d5 } = e9, { channelId: u6, isOriginator: h7 } = d5;
  if ("error_terminated" === t4) return oo5.SocketService(`handleJoinChannelResults: Channel ${u6} terminated`), void e9.emit(So5.TERMINATE);
  if (!n4) return void oo5.SocketService(`handleJoinChannelResults: No result for channel ${u6}`);
  const { persistence: f12, walletKey: p7, rejected: g3 } = n4;
  if (oo5.SocketService(`handleJoinChannelResults: Channel ${u6} persistence=${f12} walletKey=${p7} rejected=${g3}`), g3) return oo5.SocketService(`handleJoinChannelResults: Channel ${u6} rejected`), yield e9.remote.disconnect({ terminate: true }), e9.remote.emit(So5.REJECTED, { channelId: u6 }), void e9.remote.emitServiceStatusEvent();
  if (p7 && !(null === (r6 = l6.state.channelConfig) || void 0 === r6 ? void 0 : r6.otherKey)) {
    e9.getKeyExchange().setOtherPublicKey(p7), null === (i6 = e9.state.keyExchange) || void 0 === i6 || i6.setKeysExchanged(true), l6.state.ready = true, l6.state.authorized = true, l6.emit(So5.AUTHORIZED);
    const { communicationLayer: t5, storageManager: n5 } = l6.state, r7 = Object.assign(Object.assign({}, l6.state.channelConfig), { channelId: null !== (o4 = l6.state.channelId) && void 0 !== o4 ? o4 : "", validUntil: Date.now() + go5, localKey: null == t5 ? void 0 : t5.getKeyInfo().ecies.private, otherKey: p7 });
    e9.sendMessage({ type: Co5.KEY_HANDSHAKE_ACK }).catch(((e10) => {
    })), null === (s3 = e9.state.socket) || void 0 === s3 || s3.emit(ko3.PING, { id: u6, clientType: h7 ? "dapp" : "wallet", context: "on_channel_reconnect", message: "" }), yield null == n5 ? void 0 : n5.persistChannelConfig(r7), l6.emitServiceStatusEvent(), l6.setConnectionStatus(Eo5.LINKED);
  }
  f12 && (e9.emit(So5.CHANNEL_PERSISTENCE), null === (a4 = e9.state.keyExchange) || void 0 === a4 || a4.setKeysExchanged(true), l6.state.ready = true, l6.state.authorized = true, l6.emit(So5.AUTHORIZED), lo5(Object.assign(Object.assign({ id: null != u6 ? u6 : "", event: h7 ? Ao5.CONNECTED : Ao5.CONNECTED_MOBILE }, e9.remote.state.originatorInfo), { sdkVersion: e9.remote.state.sdkVersion, commLayer: e9.state.communicationLayerPreference, commLayerVersion: ho5.version, walletVersion: null === (c6 = e9.remote.state.walletInfo) || void 0 === c6 ? void 0 : c6.version }), d5.communicationServerUrl).catch(((e10) => {
  })));
}));
var To5 = (e9) => new Promise(((t4) => {
  setTimeout(t4, e9);
}));
var Ro5 = (e9, t4, ...n4) => c5(void 0, [e9, t4, ...n4], void 0, (function* (e10, t5, n5 = 200) {
  let r6;
  const i6 = Date.now();
  let o4 = false;
  for (; !o4; ) {
    if (o4 = Date.now() - i6 > 3e5, r6 = t5[e10], void 0 !== r6.elapsedTime) return r6;
    yield To5(n5);
  }
  throw new Error(`RPC ${e10} timed out`);
}));
var Po4 = (e9) => c5(void 0, void 0, void 0, (function* () {
  const { state: t4 } = e9, { socket: n4, channelId: r6, context: i6, isOriginator: o4, isReconnecting: s3 } = t4;
  if (s3) return oo5.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping", e9), false;
  if (!n4) return oo5.SocketService("[SocketService: reconnectSocket()] socket is not defined", e9), false;
  if (!r6) return false;
  const { connected: a4 } = n4;
  t4.isReconnecting = true, t4.reconnectionAttempts = 0, oo5.SocketService(`[SocketService: reconnectSocket()] connected=${a4} trying to reconnect after socketio disconnection`, e9);
  try {
    for (; 3 > t4.reconnectionAttempts; ) {
      if (oo5.SocketService(`[SocketService: reconnectSocket()] Attempt ${t4.reconnectionAttempts + 1} of 3`, e9), yield To5(200), n4.connected) return oo5.SocketService("Socket already connected --- ping to retrieve messages"), n4.emit(ko3.PING, { id: r6, clientType: o4 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), true;
      t4.resumed = true, n4.connect(), e9.emit(So5.SOCKET_RECONNECT);
      try {
        if (yield new Promise(((t5, s4) => {
          n4.emit(So5.JOIN_CHANNEL, { channelId: r6, context: `${i6}connect_again`, clientType: o4 ? "dapp" : "wallet" }, ((n5, r7) => c5(void 0, void 0, void 0, (function* () {
            try {
              yield Io5(e9, n5, r7), t5();
            } catch (e10) {
              s4(e10);
            }
          }))));
        })), yield To5(100), n4.connected) return oo5.SocketService(`Reconnection successful on attempt ${t4.reconnectionAttempts + 1}`), true;
      } catch (e10) {
        oo5.SocketService(`Error during reconnection attempt ${t4.reconnectionAttempts + 1}:`, e10);
      }
      t4.reconnectionAttempts += 1, 3 > t4.reconnectionAttempts && (yield To5(200));
    }
    return oo5.SocketService("Failed to reconnect after 3 attempts"), false;
  } finally {
    t4.isReconnecting = false, t4.reconnectionAttempts = 0;
  }
}));
function Oo5(e9, t4) {
  return c5(this, void 0, void 0, (function* () {
    var n4;
    const r6 = null === (n4 = e9.state.keyExchange) || void 0 === n4 ? void 0 : n4.encryptMessage(JSON.stringify(t4)), i6 = { id: e9.state.channelId, context: e9.state.context, clientType: e9.state.isOriginator ? "dapp" : "wallet", message: r6, plaintext: e9.state.hasPlaintext ? JSON.stringify(t4) : void 0 };
    return oo5.SocketService(`[SocketService: encryptAndSendMessage()] context=${e9.state.context}`, i6), t4.type === ko3.TERMINATE && (e9.state.manualDisconnect = true), new Promise(((t5, n5) => {
      var r7;
      null === (r7 = e9.state.socket) || void 0 === r7 || r7.emit(So5.MESSAGE, i6, ((e10, r8) => {
        var i7;
        e10 && (oo5.SocketService(`[SocketService: encryptAndSendMessage()] error=${e10}`), n5(e10)), oo5.SocketService("[encryptAndSendMessage] response", r8), t5(null !== (i7 = null == r8 ? void 0 : r8.success) && void 0 !== i7 && i7);
      }));
    }));
  }));
}
var No5;
!(function(e9) {
  e9.RPC_CHECK = "rpcCheck", e9.SKIPPED_RPC = "skippedRpc";
})(No5 || (No5 = {}));
var Lo5 = ["eth_sendTransaction", "eth_signTypedData", "eth_signTransaction", "personal_sign", "wallet_requestPermissions", "wallet_switchEthereumChain", "eth_signTypedData_v3", "eth_signTypedData_v4", "metamask_connectSign", "metamask_connectWith", "metamask_batch"].map(((e9) => e9.toLowerCase()));
var Do3 = [{ event: So5.CLIENTS_CONNECTED, handler: function(e9, t4) {
  return (n4) => c5(this, void 0, void 0, (function* () {
    var n5, r6, i6, o4, s3, a4, c6, l6, d5, u6, h7;
    const f12 = null !== (r6 = null === (n5 = e9.remote.state.channelConfig) || void 0 === n5 ? void 0 : n5.relayPersistence) && void 0 !== r6 && r6;
    if (oo5.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} on 'clients_connected-${t4}' relayPersistence=${f12} resumed=${e9.state.resumed}  clientsPaused=${e9.state.clientsPaused} keysExchanged=${null === (i6 = e9.state.keyExchange) || void 0 === i6 ? void 0 : i6.areKeysExchanged()} isOriginator=${e9.state.isOriginator}`), e9.emit(So5.CLIENTS_CONNECTED, { isOriginator: e9.state.isOriginator, keysExchanged: null === (o4 = e9.state.keyExchange) || void 0 === o4 ? void 0 : o4.areKeysExchanged(), context: e9.state.context }), e9.state.resumed) e9.state.isOriginator || (oo5.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} 'clients_connected' / keysExchanged=${null === (s3 = e9.state.keyExchange) || void 0 === s3 ? void 0 : s3.areKeysExchanged()} -- backward compatibility`), null === (a4 = e9.state.keyExchange) || void 0 === a4 || a4.start({ isOriginator: null !== (c6 = e9.state.isOriginator) && void 0 !== c6 && c6 })), e9.state.resumed = false;
    else if (e9.state.clientsPaused) oo5.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");
    else if (!e9.state.isOriginator) {
      const t5 = !f12;
      oo5.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} on 'clients_connected' / keysExchanged=${null === (l6 = e9.state.keyExchange) || void 0 === l6 ? void 0 : l6.areKeysExchanged()} -- force=${t5} -- backward compatibility`), oo5.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} on 'clients_connected' / keysExchanged=${null === (d5 = e9.state.keyExchange) || void 0 === d5 ? void 0 : d5.areKeysExchanged()} -- force=${t5} -- backward compatibility`), null === (u6 = e9.state.keyExchange) || void 0 === u6 || u6.start({ isOriginator: null !== (h7 = e9.state.isOriginator) && void 0 !== h7 && h7, force: t5 });
    }
    e9.state.clientsConnected = true, e9.state.clientsPaused = false;
  }));
} }, { event: So5.CHANNEL_CREATED, handler: function(e9, t4) {
  return (n4) => {
    oo5.SocketService(`[SocketService: handleChannelCreated()] context=${e9.state.context} on 'channel_created-${t4}'`, n4), e9.emit(So5.CHANNEL_CREATED, n4);
  };
} }, { event: So5.CLIENTS_DISCONNECTED, handler: function(e9, t4) {
  return () => {
    var n4;
    e9.state.clientsConnected = false, oo5.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e9.state.context} on 'clients_disconnected-${t4}'`), e9.remote.state.relayPersistence ? oo5.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e9.state.context} on 'clients_disconnected-${t4}' - relayPersistence enabled, skipping key exchange cleanup.`) : (e9.state.isOriginator && !e9.state.clientsPaused && (null === (n4 = e9.state.keyExchange) || void 0 === n4 || n4.clean()), e9.emit(So5.CLIENTS_DISCONNECTED, t4));
  };
} }, { event: So5.CONFIG, handler: function(e9, t4) {
  return (n4) => c5(this, void 0, void 0, (function* () {
    var r6, i6, o4;
    oo5.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${t4}'`, n4);
    const { persistence: s3, walletKey: a4 } = n4;
    e9.state.isOriginator && e9.remote.state.channelConfig ? (n4.walletKey && !e9.remote.state.channelConfig.otherKey && (oo5.SocketService(`Setting wallet key ${a4}`), e9.remote.state.channelConfig.otherKey = a4, e9.getKeyExchange().setOtherPublicKey(n4.walletKey), null === (r6 = e9.state.keyExchange) || void 0 === r6 || r6.setKeysExchanged(true), yield e9.remote.sendMessage({ type: Co5.KEY_HANDSHAKE_ACK }), yield e9.remote.sendMessage({ type: ko3.PING }), yield null === (i6 = e9.remote.state.storageManager) || void 0 === i6 ? void 0 : i6.persistChannelConfig(e9.remote.state.channelConfig)), true !== s3 || e9.remote.state.channelConfig.relayPersistence || (oo5.SocketService(`Setting relay persistence ${s3}`), e9.remote.state.channelConfig.relayPersistence = s3, e9.remote.state.relayPersistence = true, e9.remote.emit(So5.CHANNEL_PERSISTENCE), e9.remote.state.authorized = true, e9.remote.state.ready = true, e9.remote.emit(So5.AUTHORIZED), yield null === (o4 = e9.remote.state.storageManager) || void 0 === o4 ? void 0 : o4.persistChannelConfig(e9.remote.state.channelConfig))) : e9.state.isOriginator || n4.persistence && (e9.remote.state.relayPersistence = true, e9.remote.emit(So5.CHANNEL_PERSISTENCE));
  }));
} }, { event: So5.MESSAGE, handler: function(e9, t4) {
  return (r6) => {
    var i6, o4, s3, a4, c6, l6, d5, u6, h7, f12, p7, g3, m5, y8, v7, b5, w6, E7;
    const { ackId: S7, message: _4, error: C8 } = r6, k8 = null !== (i6 = e9.remote.state.relayPersistence) && void 0 !== i6 && i6;
    if (oo5.SocketService(`[SocketService handleMessage()]  relayPersistence=${k8}  context=${e9.state.context} on 'message' ${t4} keysExchanged=${null === (o4 = e9.state.keyExchange) || void 0 === o4 ? void 0 : o4.areKeysExchanged()}`, r6), C8) throw oo5.SocketService(`
      [SocketService handleMessage()] context=${e9.state.context}::on 'message' error=${C8}`), new Error(C8);
    const A8 = "string" == typeof _4;
    if (!A8 && (null == _4 ? void 0 : _4.type) === Co5.KEY_HANDSHAKE_START) {
      if (k8) return;
      return oo5.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e9.state.isOriginator}`, _4), void (null === (s3 = e9.state.keyExchange) || void 0 === s3 || s3.start({ isOriginator: null !== (a4 = e9.state.isOriginator) && void 0 !== a4 && a4, force: true }));
    }
    if (!A8 && (null === (c6 = null == _4 ? void 0 : _4.type) || void 0 === c6 ? void 0 : c6.startsWith("key_handshake"))) {
      if (k8) return;
      return oo5.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' emit KEY_EXCHANGE`, _4), void e9.emit(_o5.KEY_EXCHANGE, { message: _4, context: e9.state.context });
    }
    if (A8 && !(null === (l6 = e9.state.keyExchange) || void 0 === l6 ? void 0 : l6.areKeysExchanged())) {
      let t5 = false;
      try {
        oo5.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' trying to decrypt message`), null === (d5 = e9.state.keyExchange) || void 0 === d5 || d5.decryptMessage(_4), t5 = true;
      } catch (t6) {
        oo5.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' error`, t6);
      }
      if (!t5) return e9.state.isOriginator ? null === (h7 = e9.state.keyExchange) || void 0 === h7 || h7.start({ isOriginator: null !== (f12 = e9.state.isOriginator) && void 0 !== f12 && f12 }) : e9.sendMessage({ type: Co5.KEY_HANDSHAKE_START }).catch(((e10) => {
      })), void oo5.SocketService(`Message ignored because invalid key exchange status. step=${null === (p7 = e9.state.keyExchange) || void 0 === p7 ? void 0 : p7.getKeyInfo().step}`, null === (g3 = e9.state.keyExchange) || void 0 === g3 ? void 0 : g3.getKeyInfo(), _4);
      oo5.SocketService("Invalid key exchange status detected --- updating it."), null === (u6 = e9.state.keyExchange) || void 0 === u6 || u6.setKeysExchanged(true);
    } else if (!A8 && (null == _4 ? void 0 : _4.type)) return void e9.emit(So5.MESSAGE, _4);
    if (!A8) return void e9.emit(So5.MESSAGE, _4);
    const x5 = null === (m5 = e9.state.keyExchange) || void 0 === m5 ? void 0 : m5.decryptMessage(_4), M7 = JSON.parse(null != x5 ? x5 : "{}");
    if (S7 && (null == S7 ? void 0 : S7.length) > 0 && (oo5.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' ackid=${S7} channelId=${t4}`), null === (y8 = e9.state.socket) || void 0 === y8 || y8.emit(So5.MESSAGE_ACK, { ackId: S7, channelId: t4, clientType: e9.state.isOriginator ? "dapp" : "wallet" })), e9.state.clientsPaused = (null == M7 ? void 0 : M7.type) === ko3.PAUSE, e9.state.isOriginator && M7.data) {
      const t5 = M7.data, r7 = e9.state.rpcMethodTracker[t5.id];
      if (r7) {
        const i7 = Date.now() - r7.timestamp;
        oo5.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' received answer for id=${t5.id} method=${r7.method} responseTime=${i7}`, M7), e9.remote.state.analytics && Lo5.includes(r7.method.toLowerCase()) && lo5(Object.assign(Object.assign({ id: null !== (v7 = e9.remote.state.channelId) && void 0 !== v7 ? v7 : "", event: Ao5.SDK_RPC_REQUEST_DONE, sdkVersion: e9.remote.state.sdkVersion, commLayerVersion: ho5.version }, e9.remote.state.originatorInfo), { walletVersion: null === (b5 = e9.remote.state.walletInfo) || void 0 === b5 ? void 0 : b5.version, params: { method: r7.method, from: "mobile" } }), e9.remote.state.communicationServerUrl).catch(((e10) => {
        })), bo5(r7.method) && import_sdk_analytics.analytics.track(t5.error ? 4001 === t5.error.code ? "sdk_action_rejected" : "sdk_action_failed" : "sdk_action_succeeded", { action: r7.method });
        const o5 = Object.assign(Object.assign({}, r7), { result: t5.result, error: t5.error ? { code: null === (w6 = t5.error) || void 0 === w6 ? void 0 : w6.code, message: null === (E7 = t5.error) || void 0 === E7 ? void 0 : E7.message } : void 0, elapsedTime: i7 });
        e9.state.rpcMethodTracker[t5.id] = o5, e9.emit(So5.RPC_UPDATE, o5);
      }
    }
    e9.emit(So5.MESSAGE, { message: M7 });
  };
} }, { event: So5.REJECTED, handler: function(e9, t4) {
  return (r6) => c5(this, void 0, void 0, (function* () {
    var r7;
    e9.state.isOriginator && !e9.remote.state.ready ? (oo5.SocketService(`[SocketService: handleChannelRejected()] context=${e9.state.context} channelId=${t4} isOriginator=${e9.state.isOriginator} ready=${e9.remote.state.ready}`, e9.remote.state.originatorInfo), lo5(Object.assign(Object.assign({ id: t4, event: Ao5.REJECTED }, e9.remote.state.originatorInfo), { sdkVersion: e9.remote.state.sdkVersion, commLayer: e9.state.communicationLayerPreference, commLayerVersion: ho5.version, walletVersion: null === (r7 = e9.remote.state.walletInfo) || void 0 === r7 ? void 0 : r7.version }), e9.remote.state.communicationServerUrl).catch(((e10) => {
    })), import_sdk_analytics.analytics.track("sdk_connection_rejected", { transport_type: "websocket" }), yield e9.remote.disconnect({ terminate: true }), e9.remote.emit(So5.REJECTED, { channelId: t4 }), e9.remote.setConnectionStatus(Eo5.DISCONNECTED)) : oo5.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${t4} isOriginator=${e9.state.isOriginator} ready=${e9.remote.state.ready}`);
  }));
} }, { event: "clients_waiting_to_join", handler: function(e9, t4) {
  return (n4) => {
    oo5.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${e9.state.context} on 'clients_waiting_to_join-${t4}'`, n4), e9.emit(So5.CLIENTS_WAITING, n4);
  };
} }];
var $o5 = [{ event: So5.KEY_INFO, handler: function(e9) {
  return (t4) => {
    oo5.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'", t4), e9.emit(So5.KEY_INFO, t4);
  };
} }, { event: So5.KEYS_EXCHANGED, handler: function(e9) {
  return () => {
    var t4, n4, r6;
    oo5.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null === (t4 = e9.state.keyExchange) || void 0 === t4 ? void 0 : t4.areKeysExchanged()}`);
    const { channelConfig: i6 } = e9.remote.state;
    if (i6) {
      const t5 = e9.getKeyExchange().getKeyInfo().ecies;
      i6.localKey = t5.private, i6.otherKey = t5.otherPubKey, e9.remote.state.channelConfig = i6, null === (n4 = e9.remote.state.storageManager) || void 0 === n4 || n4.persistChannelConfig(i6).catch(((e10) => {
      }));
    }
    e9.emit(So5.KEYS_EXCHANGED, { keysExchanged: null === (r6 = e9.state.keyExchange) || void 0 === r6 ? void 0 : r6.areKeysExchanged(), isOriginator: e9.state.isOriginator });
    const o4 = { keyInfo: e9.getKeyInfo() };
    e9.emit(So5.SERVICE_STATUS, o4);
  };
} }];
function Bo5(e9, t4) {
  oo5.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} setting socket listeners for channel ${t4}...`);
  const { socket: n4 } = e9.state, { keyExchange: r6 } = e9.state;
  n4 && e9.state.isOriginator && (e9.state.debug && (null == n4 || n4.io.on("error", ((t5) => {
    oo5.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=error`, t5);
  })), null == n4 || n4.io.on("reconnect", ((t5) => {
    oo5.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=reconnect`, t5), Po4(e9).catch(((e10) => {
    }));
  })), null == n4 || n4.io.on("reconnect_error", ((t5) => {
    oo5.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=reconnect_error`, t5);
  })), null == n4 || n4.io.on("reconnect_failed", (() => {
    oo5.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=reconnect_failed`);
  }))), null == n4 || n4.on("disconnect", ((t5) => (oo5.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${t5}' begin recovery...`), (/* @__PURE__ */ (function(e10) {
    return (t6) => {
      oo5.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${e10.state.manualDisconnect}`, t6), e10.state.manualDisconnect || (e10.emit(So5.SOCKET_DISCONNECTED), Po4(e10).catch(((e11) => {
      })));
    };
  })(e9))(t5))))), Do3.forEach((({ event: r7, handler: i6 }) => {
    null == n4 || n4.on(`${r7}-${t4}`, i6(e9, t4));
  })), $o5.forEach((({ event: t5, handler: n5 }) => {
    null == r6 || r6.on(t5, n5(e9));
  })), e9.state.setupChannelListeners = true;
}
var Ko3 = class extends import_eventemitter2.EventEmitter2 {
  constructor(e9) {
    super(), this.state = { clientsConnected: false, clientsPaused: false, manualDisconnect: false, lastRpcId: void 0, rpcMethodTracker: {}, hasPlaintext: false, communicationServerUrl: "", focusListenerAdded: false, removeFocusListener: void 0, isReconnecting: false, reconnectionAttempts: 0 }, this.options = e9;
    const { reconnect: n4, communicationLayerPreference: r6, communicationServerUrl: i6, context: o4, remote: s3, logging: a4 } = e9;
    this.state.resumed = n4, this.state.context = o4, this.state.isOriginator = s3.state.isOriginator, this.state.communicationLayerPreference = r6, this.state.debug = true === (null == a4 ? void 0 : a4.serviceLayer), this.remote = s3, true === (null == a4 ? void 0 : a4.serviceLayer) && import_debug.default.enable("SocketService:Layer"), this.state.communicationServerUrl = i6, this.state.hasPlaintext = this.state.communicationServerUrl !== fo5 && true === (null == a4 ? void 0 : a4.plaintext), oo5.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`), this.initSocket();
  }
  initSocket() {
    var e9;
    const { otherPublicKey: t4, ecies: n4, logging: r6 } = this.options, i6 = { autoConnect: false, transports: po5, withCredentials: true }, o4 = this.state.communicationServerUrl;
    oo5.SocketService(`[SocketService: initSocket()] Socket IO url: ${o4}`), this.state.socket = lookup2(o4, i6), (function(e10) {
      if ("undefined" != typeof window && "undefined" != typeof document && (oo5.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`, e10), !e10.state.focusListenerAdded)) {
        const t5 = () => {
          oo5.SocketService("Document has focus --- reconnecting socket"), Po4(e10).catch(((e11) => {
          }));
        };
        window.addEventListener("focus", t5), e10.state.focusListenerAdded = true, e10.state.removeFocusListener = () => {
          window.removeEventListener("focus", t5), e10.state.focusListenerAdded = false;
        };
      }
    })(this);
    const s3 = { communicationLayer: this, otherPublicKey: t4, sendPublicKey: false, context: null !== (e9 = this.state.context) && void 0 !== e9 ? e9 : "", ecies: n4, logging: r6 };
    this.state.keyExchange = new Mo3(s3);
  }
  resetKeys() {
    return oo5.SocketService("[SocketService: resetKeys()] Resetting keys."), void (null === (e9 = this.state.keyExchange) || void 0 === e9 || e9.resetKeys());
    var e9;
  }
  createChannel() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        return c5(this, void 0, void 0, (function* () {
          var t4, n4, r6;
          if (oo5.SocketService(`[SocketService: createChannel()] context=${e9.state.context}`), e9.state.socket || e9.initSocket(), null === (t4 = e9.state.socket) || void 0 === t4 ? void 0 : t4.connected) throw new Error("socket already connected");
          null === (n4 = e9.state.socket) || void 0 === n4 || n4.connect(), e9.state.manualDisconnect = false, e9.state.isOriginator = true;
          const i6 = v4_default();
          e9.state.channelId = i6, Bo5(e9, i6), yield new Promise(((t5, n5) => {
            var r7;
            null === (r7 = e9.state.socket) || void 0 === r7 || r7.emit(So5.JOIN_CHANNEL, { channelId: i6, context: `${e9.state.context}createChannel`, clientType: "dapp" }, ((r8, i7) => c5(this, void 0, void 0, (function* () {
              try {
                yield Io5(e9, r8, i7), t5();
              } catch (e10) {
                n5(e10);
              }
            }))));
          }));
          const o4 = null === (r6 = e9.state.keyExchange) || void 0 === r6 ? void 0 : r6.getKeyInfo();
          return { channelId: i6, pubKey: (null == o4 ? void 0 : o4.ecies.public) || "", privKey: (null == o4 ? void 0 : o4.ecies.private) || "" };
        }));
      })(this);
    }));
  }
  connectToChannel({ channelId: e9, withKeyExchange: t4 = false, authorized: n4 }) {
    return (function(e10) {
      return c5(this, arguments, void 0, (function* ({ options: e11, instance: t5 }) {
        const { channelId: n5, authorized: r6, withKeyExchange: i6 } = e11, { state: o4, remote: s3 } = t5, { isOriginator: a4 = false, socket: l6, keyExchange: d5 } = o4, { channelConfig: u6 } = s3.state;
        if (null == l6 ? void 0 : l6.connected) throw new Error("socket already connected");
        if (a4 && (null == u6 ? void 0 : u6.relayPersistence)) {
          const { localKey: e12, otherKey: t6 } = u6;
          e12 && t6 && (null == d5 || d5.setRelayPersistence({ localKey: e12, otherKey: t6 }));
        }
        return Object.assign(o4, { manualDisconnect: false, withKeyExchange: i6, isOriginator: a4, channelId: n5 }), null == l6 || l6.connect(), Bo5(t5, n5), !a4 && r6 && (null == d5 || d5.setKeysExchanged(true), Object.assign(s3.state, { ready: true, authorized: true })), new Promise(((e12) => {
          var i7;
          const s4 = null === (i7 = null == d5 ? void 0 : d5.getKeyInfo()) || void 0 === i7 ? void 0 : i7.ecies.public;
          null == l6 || l6.emit(So5.JOIN_CHANNEL, { channelId: n5, context: `${o4.context}_connectToChannel`, clientType: a4 ? "dapp" : "wallet", publicKey: r6 && !a4 ? s4 : void 0 }, ((n6, r7) => c5(this, void 0, void 0, (function* () {
            yield Io5(t5, n6, r7), e12();
          }))));
        }));
      }));
    })({ options: { channelId: e9, withKeyExchange: t4, authorized: n4 }, instance: this });
  }
  getKeyInfo() {
    return this.state.keyExchange.getKeyInfo();
  }
  keyCheck() {
    var e9, t4;
    null === (t4 = (e9 = this).state.socket) || void 0 === t4 || t4.emit(So5.MESSAGE, { id: e9.state.channelId, context: e9.state.context, message: { type: Co5.KEY_HANDSHAKE_CHECK, pubkey: e9.getKeyInfo().ecies.otherPubKey } });
  }
  getKeyExchange() {
    return this.state.keyExchange;
  }
  sendMessage(e9) {
    return c5(this, void 0, void 0, (function* () {
      return (function(e10, t4) {
        return c5(this, void 0, void 0, (function* () {
          var r6, i6, o4;
          if (!e10.state.channelId) throw oo5.SocketService("handleSendMessage: no channelId - Create a channel first"), new Error("Create a channel first");
          if (oo5.SocketService(`[SocketService: handleSendMessage()] context=${e10.state.context} areKeysExchanged=${null === (r6 = e10.state.keyExchange) || void 0 === r6 ? void 0 : r6.areKeysExchanged()}`, t4), null === (i6 = null == t4 ? void 0 : t4.type) || void 0 === i6 ? void 0 : i6.startsWith("key_handshake")) return (function(e11, t5) {
            var n4;
            oo5.SocketService(`[SocketService: handleKeyHandshake()] context=${e11.state.context}`, t5), null === (n4 = e11.state.socket) || void 0 === n4 || n4.emit(So5.MESSAGE, { id: e11.state.channelId, context: e11.state.context, clientType: e11.state.isOriginator ? "dapp" : "wallet", message: t5 });
          })(e10, t4), true;
          !(function(e11, t5) {
            var n4;
            if (!(null === (n4 = e11.state.keyExchange) || void 0 === n4 ? void 0 : n4.areKeysExchanged()) && !e11.remote.state.relayPersistence) throw oo5.SocketService(`[SocketService: validateKeyExchange()] context=${e11.state.context} ERROR keys not exchanged`, t5), new Error("Keys not exchanged BBB");
          })(e10, t4), (function(e11, t5) {
            var n4;
            const r7 = null !== (n4 = null == t5 ? void 0 : t5.method) && void 0 !== n4 ? n4 : "", i7 = null == t5 ? void 0 : t5.id;
            e11.state.isOriginator && i7 && (e11.state.rpcMethodTracker[i7] = { id: i7, timestamp: Date.now(), method: r7 }, e11.emit(So5.RPC_UPDATE, e11.state.rpcMethodTracker[i7]));
          })(e10, t4);
          const s3 = yield Oo5(e10, t4);
          return e10.remote.state.analytics && e10.remote.state.isOriginator && t4.method && Lo5.includes(t4.method.toLowerCase()) && lo5({ id: null !== (o4 = e10.remote.state.channelId) && void 0 !== o4 ? o4 : "", event: Ao5.SDK_RPC_REQUEST, params: { method: t4.method, from: "mobile" } }, e10.remote.state.communicationServerUrl).catch(((e11) => {
          })), e10.remote.state.isOriginator && t4.method && bo5(t4.method) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: t4.method }), (function(e11, t5) {
            return c5(this, void 0, void 0, (function* () {
              var n4;
              const r7 = null == t5 ? void 0 : t5.id, i7 = null !== (n4 = null == t5 ? void 0 : t5.method) && void 0 !== n4 ? n4 : "";
              if (e11.state.isOriginator && r7) try {
                const n5 = Ro5(r7, e11.state.rpcMethodTracker, 200).then(((e12) => ({ type: No5.RPC_CHECK, result: e12 }))), o5 = (() => c5(this, void 0, void 0, (function* () {
                  const t6 = yield ((e12) => c5(void 0, [e12], void 0, (function* ({ rpcId: e13, instance: t7 }) {
                    for (; t7.state.lastRpcId === e13 || void 0 === t7.state.lastRpcId; ) yield To5(200);
                    return t7.state.lastRpcId;
                  })))({ instance: e11, rpcId: r7 }), n6 = yield Ro5(t6, e11.state.rpcMethodTracker, 200);
                  return { type: No5.SKIPPED_RPC, result: n6 };
                })))(), s4 = yield Promise.race([n5, o5]);
                if (s4.type === No5.RPC_CHECK) {
                  const e12 = s4.result;
                  oo5.SocketService(`[SocketService:handleRpcReplies()] id=${t5.id} ${i7} ( ${e12.elapsedTime} ms)`, e12.result);
                } else {
                  if (s4.type !== No5.SKIPPED_RPC) throw new Error(`Error handling RPC replies for ${r7}`);
                  {
                    const t6 = Object.assign(Object.assign({}, e11.state.rpcMethodTracker[r7]), { error: new Error("SDK_CONNECTION_ISSUE") });
                    e11.emit(So5.RPC_UPDATE, t6);
                    const n6 = { data: Object.assign(Object.assign({}, t6), { jsonrpc: "2.0" }), name: "metamask-provider" };
                    e11.emit(So5.MESSAGE, { message: n6 });
                  }
                }
              } catch (e12) {
                throw e12;
              }
            }));
          })(e10, t4).catch(((e11) => {
          })), s3;
        }));
      })(this, e9);
    }));
  }
  ping() {
    return (function(e9) {
      return c5(this, void 0, void 0, (function* () {
        var t4, n4;
        oo5.SocketService(`[SocketService: ping()] context=${e9.state.context} originator=${e9.state.isOriginator} keysExchanged=${null === (t4 = e9.state.keyExchange) || void 0 === t4 ? void 0 : t4.areKeysExchanged()}`), null === (n4 = e9.state.socket) || void 0 === n4 || n4.emit(ko3.PING, { id: e9.state.channelId, context: "ping", clientType: e9.remote.state.isOriginator ? "dapp" : "wallet", message: "" });
      }));
    })(this);
  }
  pause() {
    return (function(e9) {
      return c5(this, void 0, void 0, (function* () {
        var t4, n4;
        oo5.SocketService(`[SocketService: pause()] context=${e9.state.context}`), e9.state.manualDisconnect = true, (null === (t4 = e9.state.keyExchange) || void 0 === t4 ? void 0 : t4.areKeysExchanged()) && (yield e9.sendMessage({ type: ko3.PAUSE })), null === (n4 = e9.state.socket) || void 0 === n4 || n4.disconnect();
      }));
    })(this);
  }
  isConnected() {
    var e9;
    return null === (e9 = this.state.socket) || void 0 === e9 ? void 0 : e9.connected;
  }
  resume() {
    return (function(e9) {
      return c5(this, void 0, void 0, (function* () {
        const { state: t4, remote: n4 } = e9, { socket: r6, channelId: i6, context: o4, keyExchange: s3, isOriginator: a4 } = t4, { isOriginator: l6 } = n4.state;
        if (oo5.SocketService(`[SocketService: resume()] channelId=${i6} context=${o4} connected=${null == r6 ? void 0 : r6.connected} manualDisconnect=${t4.manualDisconnect} resumed=${t4.resumed} keysExchanged=${null == s3 ? void 0 : s3.areKeysExchanged()}`), !i6) throw oo5.SocketService("[SocketService: resume()] channelId is not defined"), new Error("ChannelId is not defined");
        (null == r6 ? void 0 : r6.connected) ? (oo5.SocketService("[SocketService: resume()] already connected."), r6.emit(ko3.PING, { id: i6, clientType: l6 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), n4.hasRelayPersistence() || (null == s3 ? void 0 : s3.areKeysExchanged()) || (a4 ? yield e9.sendMessage({ type: ko3.READY }) : null == s3 || s3.start({ isOriginator: false }))) : (null == r6 || r6.connect(), oo5.SocketService(`[SocketService: resume()] after connecting socket --> connected=${null == r6 ? void 0 : r6.connected}`), null == r6 || r6.emit(So5.JOIN_CHANNEL, { channelId: i6, context: `${o4}_resume`, clientType: l6 ? "dapp" : "wallet" }, ((t5, n5) => c5(this, void 0, void 0, (function* () {
          try {
            yield Io5(e9, t5, n5);
          } catch (e10) {
          }
        }))))), t4.manualDisconnect = false, t4.resumed = true;
      }));
    })(this);
  }
  getRPCMethodTracker() {
    return this.state.rpcMethodTracker;
  }
  disconnect(e9) {
    return (function(e10, t4) {
      var n4, r6, i6, o4, s3;
      oo5.SocketService(`[SocketService: disconnect()] context=${e10.state.context}`, t4), (null == t4 ? void 0 : t4.terminate) && (null === (r6 = (n4 = e10.state).removeFocusListener) || void 0 === r6 || r6.call(n4), e10.state.channelId = t4.channelId, null === (i6 = e10.state.socket) || void 0 === i6 || i6.removeAllListeners(), null === (o4 = e10.state.keyExchange) || void 0 === o4 || o4.clean(), e10.remote.state.ready = false, e10.state.socket = void 0, e10.state.rpcMethodTracker = {}), e10.state.manualDisconnect = true, null === (s3 = e10.state.socket) || void 0 === s3 || s3.disconnect();
    })(this, e9);
  }
};
var jo3;
var Uo5;
var Ho3;
function Fo3(e9) {
  return () => c5(this, void 0, void 0, (function* () {
    var t4, n4, r6;
    const { state: i6 } = e9;
    if (i6.authorized) return;
    yield (() => c5(this, void 0, void 0, (function* () {
      for (; !i6.walletInfo; ) yield To5(500);
    })))();
    const o4 = "7.3".localeCompare((null === (t4 = i6.walletInfo) || void 0 === t4 ? void 0 : t4.version) || "");
    if (oo5.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null === (n4 = i6.walletInfo) || void 0 === n4 ? void 0 : n4.version} compareValue=${o4}`), 1 !== o4) return;
    const s3 = i6.platformType === Uo5.MobileWeb || i6.platformType === Uo5.ReactNative || i6.platformType === Uo5.MetaMaskMobileWebview;
    oo5.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i6.platformType} secure=${s3} channel=${i6.channelId} walletVersion=${null === (r6 = i6.walletInfo) || void 0 === r6 ? void 0 : r6.version}`), s3 && (i6.authorized = true, e9.emit(So5.AUTHORIZED));
  }));
}
function zo3(e9) {
  return (t4) => {
    const { state: n4 } = e9;
    oo5.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n4.context} on 'channel_created' channelId=${t4}`), e9.emit(So5.CHANNEL_CREATED, t4);
  };
}
function qo3(e9, t4) {
  return () => {
    var r6, i6, o4, s3;
    const { state: a4 } = e9;
    oo5.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${a4.channelId} keysExchanged=${null === (i6 = null === (r6 = a4.communicationLayer) || void 0 === r6 ? void 0 : r6.getKeyInfo()) || void 0 === i6 ? void 0 : i6.keysExchanged}`), a4.analytics && lo5(Object.assign(Object.assign({ id: null !== (o4 = a4.channelId) && void 0 !== o4 ? o4 : "", event: a4.reconnection ? Ao5.RECONNECT : a4.isOriginator ? Ao5.REQUEST : Ao5.REQUEST_MOBILE }, a4.originatorInfo), { commLayer: t4, sdkVersion: a4.sdkVersion, walletVersion: null === (s3 = a4.walletInfo) || void 0 === s3 ? void 0 : s3.version, commLayerVersion: ho5.version }), a4.communicationServerUrl).catch(((e10) => {
    })), a4.isOriginator && !a4.reconnection && import_sdk_analytics.analytics.track("sdk_connection_established", { transport_type: "websocket" }), a4.clientsConnected = true, a4.originatorInfoSent = false, e9.emit(So5.CLIENTS_CONNECTED);
  };
}
function Wo3(e9) {
  return (t4) => {
    const { state: n4 } = e9;
    oo5.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n4.context} on 'clients_disconnected' channelId=${t4}`), n4.relayPersistence || (n4.clientsConnected = false, n4.ready = false, n4.authorized = false), e9.emit(So5.CLIENTS_DISCONNECTED, n4.channelId), e9.setConnectionStatus(Eo5.DISCONNECTED);
  };
}
function Vo3(e9) {
  return (t4) => {
    var n4;
    const { state: r6 } = e9;
    if (oo5.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${r6.context} on 'clients_waiting' numberUsers=${t4} ready=${r6.ready} autoStarted=${r6.originatorConnectStarted}`), e9.setConnectionStatus(Eo5.WAITING), e9.emit(So5.CLIENTS_WAITING, t4), r6.originatorConnectStarted) {
      oo5.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${r6.originatorConnectStarted} timeout`, r6.autoConnectOptions);
      const t5 = (null === (n4 = r6.autoConnectOptions) || void 0 === n4 ? void 0 : n4.timeout) || 3e3, i6 = setTimeout((() => {
        oo5.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${t5}) terminate channelConfig`, r6.autoConnectOptions), r6.originatorConnectStarted = false, r6.ready || e9.setConnectionStatus(Eo5.TIMEOUT), clearTimeout(i6);
      }), t5);
    }
  };
}
function Go3(e9, t4) {
  return (n4) => {
    var r6, i6, o4, s3, a4, c6, l6, d5;
    const { state: u6 } = e9;
    if (oo5.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${u6.context} on commLayer.'keys_exchanged' channel=${u6.channelId}`, n4), null === (i6 = null === (r6 = u6.communicationLayer) || void 0 === r6 ? void 0 : r6.getKeyInfo()) || void 0 === i6 ? void 0 : i6.keysExchanged) {
      const t5 = Object.assign(Object.assign({}, u6.channelConfig), { channelId: null !== (o4 = u6.channelId) && void 0 !== o4 ? o4 : "", validUntil: (null === (s3 = u6.channelConfig) || void 0 === s3 ? void 0 : s3.validUntil) || go5, localKey: u6.communicationLayer.getKeyInfo().ecies.private, otherKey: u6.communicationLayer.getKeyInfo().ecies.otherPubKey });
      null === (a4 = u6.storageManager) || void 0 === a4 || a4.persistChannelConfig(t5).catch(((e10) => {
      })), e9.setConnectionStatus(Eo5.LINKED);
    }
    !(function(e10, t5) {
      var n5, r7, i7, o5, s4, a5, c7, l7;
      const { state: d6 } = e10;
      oo5.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${d6.channelId}`, t5);
      const u7 = Object.assign(Object.assign({}, d6.channelConfig), { channelId: null !== (n5 = d6.channelId) && void 0 !== n5 ? n5 : "", validUntil: null !== (i7 = null === (r7 = d6.channelConfig) || void 0 === r7 ? void 0 : r7.validUntil) && void 0 !== i7 ? i7 : 0, relayPersistence: d6.relayPersistence, localKey: null === (s4 = null === (o5 = d6.communicationLayer) || void 0 === o5 ? void 0 : o5.state.keyExchange) || void 0 === s4 ? void 0 : s4.getKeyInfo().ecies.private, otherKey: null === (c7 = null === (a5 = d6.communicationLayer) || void 0 === a5 ? void 0 : a5.state.keyExchange) || void 0 === c7 ? void 0 : c7.getKeyInfo().ecies.otherPubKey, lastActive: t5.getTime() });
      null === (l7 = d6.storageManager) || void 0 === l7 || l7.persistChannelConfig(u7);
    })(e9, /* @__PURE__ */ new Date()), u6.analytics && u6.channelId && lo5(Object.assign(Object.assign({ id: u6.channelId, event: n4.isOriginator ? Ao5.CONNECTED : Ao5.CONNECTED_MOBILE }, u6.originatorInfo), { sdkVersion: u6.sdkVersion, commLayer: t4, commLayerVersion: ho5.version, walletVersion: null === (c6 = u6.walletInfo) || void 0 === c6 ? void 0 : c6.version }), u6.communicationServerUrl).catch(((e10) => {
    })), u6.isOriginator = n4.isOriginator, n4.isOriginator || (null === (l6 = u6.communicationLayer) || void 0 === l6 || l6.sendMessage({ type: ko3.READY }), u6.ready = true, u6.paused = false), n4.isOriginator && !u6.originatorInfoSent && (null === (d5 = u6.communicationLayer) || void 0 === d5 || d5.sendMessage({ type: ko3.ORIGINATOR_INFO, originatorInfo: u6.originatorInfo, originator: u6.originatorInfo }), u6.originatorInfoSent = true);
  };
}
function Yo4(e9) {
  return (t4) => {
    let n4 = t4;
    t4.message && (n4 = n4.message), (function(e10, t5) {
      const { state: n5 } = t5;
      if (oo5.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${n5.context} on 'message' typeof=${typeof e10}`, e10), t5.state.ready = true, n5.isOriginator || e10.type !== ko3.ORIGINATOR_INFO) if (n5.isOriginator && e10.type === ko3.WALLET_INFO) !(function(e11, t6) {
        const { state: n6 } = e11;
        n6.walletInfo = t6.walletInfo, n6.paused = false;
      })(t5, e10);
      else {
        if (n5.isOriginator && e10.type === ko3.WALLET_INIT) (function(e11, t6) {
          return c5(this, void 0, void 0, (function* () {
            var n6, r6, i6;
            const { state: o4 } = e11;
            if (o4.isOriginator) {
              const o5 = t6.data || {};
              if ("object" == typeof o5 && "accounts" in o5 && "chainId" in o5 && "walletKey" in o5) try {
                const { channelConfig: t7 } = e11.state;
                if (oo5.RemoteCommunication("WALLET_INIT: channelConfig", JSON.stringify(t7, null, 2)), t7) {
                  const s3 = o5.accounts, a4 = o5.chainId, c6 = o5.walletKey;
                  let l6, d5 = false;
                  "deeplinkProtocol" in o5 && (d5 = Boolean(o5.deeplinkProtocol), e11.state.deeplinkProtocolAvailable = d5), "walletVersion" in o5 && (l6 = o5.walletVersion), yield null === (n6 = e11.state.storageManager) || void 0 === n6 ? void 0 : n6.persistChannelConfig(Object.assign(Object.assign({}, t7), { otherKey: c6, walletVersion: l6, deeplinkProtocolAvailable: d5, relayPersistence: true })), yield null === (r6 = e11.state.storageManager) || void 0 === r6 ? void 0 : r6.persistAccounts(s3), yield null === (i6 = e11.state.storageManager) || void 0 === i6 ? void 0 : i6.persistChainId(a4);
                }
                e11.emit(So5.WALLET_INIT, { accounts: o5.accounts, chainId: o5.chainId });
              } catch (n7) {
              }
            }
          }));
        })(t5, e10).catch(((e11) => {
          oo5.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e11}`);
        }));
        else if (e10.type === ko3.TERMINATE) (function(e11) {
          return c5(this, void 0, void 0, (function* () {
            const { state: t6 } = e11;
            t6.isOriginator && (yield es2({ options: { terminate: true, sendMessage: false }, instance: e11 }), e11.emit(So5.TERMINATE));
          }));
        })(t5).catch(((e11) => {
          oo5.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e11}`);
        }));
        else if (e10.type === ko3.PAUSE) !(function(e11) {
          const { state: t6 } = e11;
          t6.paused = true, e11.setConnectionStatus(Eo5.PAUSED);
        })(t5);
        else if (e10.type === ko3.READY && n5.isOriginator) !(function(e11) {
          const { state: t6 } = e11;
          e11.setConnectionStatus(Eo5.LINKED);
          const n6 = t6.paused;
          t6.paused = false, e11.emit(So5.CLIENTS_READY, { isOriginator: t6.isOriginator, walletInfo: t6.walletInfo }), n6 && (t6.authorized = true, e11.emit(So5.AUTHORIZED));
        })(t5);
        else {
          if (e10.type === ko3.OTP && n5.isOriginator) return void (function(e11, t6) {
            var n6;
            const { state: r6 } = e11;
            e11.emit(So5.OTP, t6.otpAnswer), 1 === "6.6".localeCompare((null === (n6 = r6.walletInfo) || void 0 === n6 ? void 0 : n6.version) || "") && e11.emit(So5.SDK_RPC_CALL, { method: yo5.ETH_REQUESTACCOUNTS, params: [] });
          })(t5, e10);
          e10.type === ko3.AUTHORIZED && n5.isOriginator && (function(e11) {
            const { state: t6 } = e11;
            t6.authorized = true, e11.emit(So5.AUTHORIZED);
          })(t5);
        }
        t5.emit(So5.MESSAGE, e10);
      }
      else !(function(e11, t6) {
        var n6;
        const { state: r6 } = e11;
        null === (n6 = r6.communicationLayer) || void 0 === n6 || n6.sendMessage({ type: ko3.WALLET_INFO, walletInfo: r6.walletInfo }), r6.originatorInfo = t6.originatorInfo || t6.originator, e11.emit(So5.CLIENTS_READY, { isOriginator: r6.isOriginator, originatorInfo: r6.originatorInfo }), r6.paused = false;
      })(t5, e10);
    })(n4, e9);
  };
}
function Zo3(e9) {
  return () => {
    const { state: t4 } = e9;
    oo5.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"), t4.ready = false, t4.authorized = false, wo5(t4), e9.emitServiceStatusEvent({ context: "socket_reconnect" });
  };
}
function Jo5(e9) {
  return () => {
    const { state: t4 } = e9;
    oo5.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"), t4.ready = false;
  };
}
function Qo3(e9) {
  return () => c5(this, void 0, void 0, (function* () {
    var t4, n4, r6, i6, o4, s3, a4;
    const { state: c6 } = e9;
    oo5.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${c6.context}`), e9.state.ready = true, e9.state.clientsConnected = true, e9.state.authorized = true, e9.state.relayPersistence = true, null === (t4 = e9.state.communicationLayer) || void 0 === t4 || t4.getKeyExchange().setKeysExchanged(true), e9.emit(So5.KEYS_EXCHANGED, { keysExchanged: true, isOriginator: true }), e9.emit(So5.AUTHORIZED), e9.emit(So5.CLIENTS_READY), e9.emit(So5.CHANNEL_PERSISTENCE);
    try {
      c6.channelConfig = Object.assign(Object.assign({}, c6.channelConfig), { localKey: null === (n4 = c6.communicationLayer) || void 0 === n4 ? void 0 : n4.getKeyExchange().getKeyInfo().ecies.private, otherKey: null === (r6 = c6.communicationLayer) || void 0 === r6 ? void 0 : r6.getKeyExchange().getOtherPublicKey(), channelId: null !== (i6 = c6.channelId) && void 0 !== i6 ? i6 : "", validUntil: null !== (s3 = null === (o4 = c6.channelConfig) || void 0 === o4 ? void 0 : o4.validUntil) && void 0 !== s3 ? s3 : go5, relayPersistence: true }), yield null === (a4 = c6.storageManager) || void 0 === a4 ? void 0 : a4.persistChannelConfig(c6.channelConfig);
    } catch (t5) {
    }
  }));
}
function Xo3({ communicationLayerPreference: e9, otherPublicKey: t4, reconnect: n4, ecies: r6, communicationServerUrl: i6 = fo5, instance: o4 }) {
  var s3, a4, c6, l6, d5, u6, h7, f12, p7, g3, m5;
  const { state: y8 } = o4;
  if (oo5.RemoteCommunication("[initCommunicationLayer()] ", JSON.stringify(y8, null, 2)), e9 !== jo3.SOCKET) throw new Error("Invalid communication protocol");
  y8.communicationLayer = new Ko3({ communicationLayerPreference: e9, otherPublicKey: t4, reconnect: n4, transports: y8.transports, communicationServerUrl: i6, context: y8.context, ecies: r6, logging: y8.logging, remote: o4 });
  let v7 = "undefined" != typeof document && document.URL || "", b5 = "undefined" != typeof document && document.title || "";
  (null === (s3 = y8.dappMetadata) || void 0 === s3 ? void 0 : s3.url) && (v7 = y8.dappMetadata.url), (null === (a4 = y8.dappMetadata) || void 0 === a4 ? void 0 : a4.name) && (b5 = y8.dappMetadata.name);
  const w6 = null !== (u6 = null !== (l6 = null === (c6 = y8.dappMetadata) || void 0 === c6 ? void 0 : c6.name) && void 0 !== l6 ? l6 : null === (d5 = y8.dappMetadata) || void 0 === d5 ? void 0 : d5.url) && void 0 !== u6 ? u6 : "N/A", E7 = "undefined" != typeof window && void 0 !== window.location && null !== (h7 = window.location.hostname) && void 0 !== h7 ? h7 : w6, S7 = { url: v7, title: b5, source: null === (f12 = y8.dappMetadata) || void 0 === f12 ? void 0 : f12.source, dappId: E7, anonId: y8.anonId, icon: (null === (p7 = y8.dappMetadata) || void 0 === p7 ? void 0 : p7.iconUrl) || (null === (g3 = y8.dappMetadata) || void 0 === g3 ? void 0 : g3.base64Icon), platform: y8.platformType, apiVersion: ho5.version, connector: null === (m5 = y8.dappMetadata) || void 0 === m5 ? void 0 : m5.connector };
  y8.originatorInfo = S7;
  const _4 = { [So5.AUTHORIZED]: Fo3(o4), [So5.MESSAGE]: Yo4(o4), [So5.CHANNEL_PERSISTENCE]: Qo3(o4), [So5.CLIENTS_CONNECTED]: qo3(o4, e9), [So5.KEYS_EXCHANGED]: Go3(o4, e9), [So5.SOCKET_DISCONNECTED]: Jo5(o4), [So5.SOCKET_RECONNECT]: Zo3(o4), [So5.CLIENTS_DISCONNECTED]: Wo3(o4), [So5.KEY_INFO]: () => {
  }, [So5.CHANNEL_CREATED]: zo3(o4), [So5.CLIENTS_WAITING]: Vo3(o4), [So5.RPC_UPDATE]: (e10) => {
    o4.emit(So5.RPC_UPDATE, e10);
  } };
  for (const [t5, n5] of Object.entries(_4)) try {
    y8.communicationLayer.on(t5, n5);
  } catch (e10) {
  }
}
function es2(e9) {
  return c5(this, arguments, void 0, (function* ({ options: e10, instance: t4 }) {
    const { state: n4 } = t4;
    return oo5.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${n4.channelId}`, e10), new Promise(((r6, i6) => {
      var o4, a4, c6, l6, d5, u6;
      (null == e10 ? void 0 : e10.terminate) ? (t4.state.ready && lo5({ id: null !== (o4 = t4.state.channelId) && void 0 !== o4 ? o4 : "", event: Ao5.TERMINATED }, t4.state.communicationServerUrl).catch(((e11) => {
      })), n4.ready = false, n4.paused = false, null === (a4 = n4.storageManager) || void 0 === a4 || a4.terminate(null !== (c6 = n4.channelId) && void 0 !== c6 ? c6 : ""), t4.state.terminated = true, e10.sendMessage ? (null === (l6 = n4.communicationLayer) || void 0 === l6 ? void 0 : l6.getKeyInfo().keysExchanged) && t4.state.communicationLayer && Oo5(t4.state.communicationLayer, { type: ko3.TERMINATE }).then((() => {
        r6(true);
      })).catch(((e11) => {
        i6(e11);
      })) : r6(true), n4.authorized = false, n4.relayPersistence = false, n4.channelId = v4_default(), e10.channelId = n4.channelId, n4.channelConfig = void 0, n4.originatorConnectStarted = false, null === (d5 = n4.communicationLayer) || void 0 === d5 || d5.disconnect(e10), t4.setConnectionStatus(Eo5.TERMINATED)) : (null === (u6 = n4.communicationLayer) || void 0 === u6 || u6.disconnect(e10), t4.setConnectionStatus(Eo5.DISCONNECTED), r6(true));
    }));
  }));
}
(jo3 || (jo3 = {})).SOCKET = "socket", (function(e9) {
  e9.NonBrowser = "nodejs", e9.MetaMaskMobileWebview = "in-app-browser", e9.DesktopWeb = "web-desktop", e9.MobileWeb = "web-mobile", e9.ReactNative = "react-native";
})(Uo5 || (Uo5 = {}));
var ts2 = class extends import_eventemitter2.EventEmitter2 {
  constructor(e9) {
    super(), this.state = { ready: false, anonId: "", authorized: false, isOriginator: false, terminated: false, protocolVersion: 1, paused: false, deeplinkProtocolAvailable: false, platformType: "metamask-mobile", analytics: false, reconnection: false, originatorInfoSent: false, communicationServerUrl: fo5, context: "", persist: false, clientsConnected: false, sessionDuration: go5, originatorConnectStarted: false, debug: false, _connectionStatus: Eo5.DISCONNECTED }, this._options = e9;
    const { anonId: n4, platformType: r6, communicationLayerPreference: i6, otherPublicKey: o4, reconnect: s3, walletInfo: a4, dappMetadata: c6, protocolVersion: l6, transports: d5, context: u6, relayPersistence: h7, ecies: f12, analytics: p7 = false, storage: g3, sdkVersion: m5, communicationServerUrl: y8 = fo5, logging: v7, autoConnect: b5 = { timeout: mo5 } } = e9;
    this.state.anonId = n4, this.state.otherPublicKey = o4, this.state.dappMetadata = c6, this.state.walletInfo = a4, this.state.transports = d5, this.state.platformType = r6, this.state.analytics = p7, this.state.protocolVersion = null != l6 ? l6 : 1, this.state.isOriginator = !o4, this.state.relayPersistence = h7, this.state.communicationServerUrl = y8, this.state.context = u6, this.state.terminated = false, this.state.sdkVersion = m5, this.setMaxListeners(50), this.setConnectionStatus(Eo5.DISCONNECTED), (null == g3 ? void 0 : g3.duration) && (this.state.sessionDuration = go5), this.state.storageOptions = g3, this.state.autoConnectOptions = b5, this.state.debug = true === (null == v7 ? void 0 : v7.remoteLayer), true === (null == v7 ? void 0 : v7.remoteLayer) && import_debug.default.enable("RemoteCommunication:Layer"), true === (null == v7 ? void 0 : v7.serviceLayer) && import_debug.default.enable("SocketService:Layer"), true === (null == v7 ? void 0 : v7.eciesLayer) && import_debug.default.enable("ECIES:Layer"), true === (null == v7 ? void 0 : v7.keyExchangeLayer) && import_debug.default.enable("KeyExchange:Layer"), this.state.logging = v7, (null == g3 ? void 0 : g3.storageManager) && (this.state.storageManager = g3.storageManager), oo5.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${l6} relayPersistence=${h7} isOriginator=${this.state.isOriginator} communicationLayerPreference=${i6} otherPublicKey=${o4} reconnect=${s3}`), this.state.isOriginator || Xo3({ communicationLayerPreference: i6, otherPublicKey: o4, reconnect: s3, ecies: f12, communicationServerUrl: y8, instance: this }), this.emitServiceStatusEvent({ context: "constructor" });
  }
  initFromDappStorage() {
    return c5(this, void 0, void 0, (function* () {
      var e9;
      if (this.state.storageManager) {
        const t4 = yield this.state.storageManager.getPersistedChannelConfig({});
        t4 && (this.state.channelConfig = t4, this.state.channelId = t4.channelId, this.state.deeplinkProtocolAvailable = null !== (e9 = t4.deeplinkProtocolAvailable) && void 0 !== e9 && e9, t4.relayPersistence && (this.state.authorized = true, this.state.ready = true, this.setConnectionStatus(Eo5.LINKED), yield this.connectToChannel({ channelId: t4.channelId })));
      }
      Xo3({ communicationLayerPreference: jo3.SOCKET, otherPublicKey: this.state.otherPublicKey, reconnect: this._options.reconnect, ecies: this._options.ecies, communicationServerUrl: this.state.communicationServerUrl, instance: this });
    }));
  }
  originatorSessionConnect() {
    return c5(this, void 0, void 0, (function* () {
      return yield (function(e9) {
        return c5(this, void 0, void 0, (function* () {
          var t4;
          const { state: n4 } = e9;
          if (!n4.storageManager) return void oo5.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");
          const r6 = yield n4.storageManager.getPersistedChannelConfig({});
          if (oo5.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${n4.originatorConnectStarted} channelConfig`, r6), null === (t4 = n4.communicationLayer) || void 0 === t4 ? void 0 : t4.isConnected()) return oo5.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"), r6;
          if (r6) {
            if (r6.validUntil > Date.now()) return n4.channelConfig = r6, n4.originatorConnectStarted = true, n4.channelId = null == r6 ? void 0 : r6.channelId, n4.reconnection = true, r6;
            oo5.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired");
          }
          n4.originatorConnectStarted = false;
        }));
      })(this);
    }));
  }
  generateChannelIdConnect() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        return c5(this, void 0, void 0, (function* () {
          var t4, n4, r6, i6, o4, s3;
          if (!e9.communicationLayer) throw new Error("communication layer not initialized");
          if (e9.ready) throw new Error("Channel already connected");
          if (e9.channelId && (null === (t4 = e9.communicationLayer) || void 0 === t4 ? void 0 : t4.isConnected())) return e9.channelConfig = Object.assign(Object.assign({}, e9.channelConfig), { channelId: e9.channelId, validUntil: Date.now() + e9.sessionDuration }), null === (n4 = e9.storageManager) || void 0 === n4 || n4.persistChannelConfig(e9.channelConfig), { channelId: e9.channelId, privKey: null === (i6 = null === (r6 = e9.communicationLayer) || void 0 === r6 ? void 0 : r6.getKeyInfo()) || void 0 === i6 ? void 0 : i6.ecies.private, pubKey: null === (s3 = null === (o4 = e9.communicationLayer) || void 0 === o4 ? void 0 : o4.getKeyInfo()) || void 0 === s3 ? void 0 : s3.ecies.public };
          oo5.RemoteCommunication("[RemoteCommunication: generateChannelId()]");
          const a4 = yield e9.communicationLayer.createChannel();
          oo5.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created", a4);
          const c6 = Object.assign(Object.assign({}, e9.channelConfig), { channelId: a4.channelId, localKey: a4.privKey, validUntil: Date.now() + e9.sessionDuration });
          return e9.channelId = a4.channelId, e9.channelConfig = c6, { channelId: e9.channelId, pubKey: a4.pubKey, privKey: a4.privKey };
        }));
      })(this.state);
    }));
  }
  clean() {
    return wo5(this.state);
  }
  connectToChannel({ channelId: e9, withKeyExchange: t4, authorized: n4 }) {
    return (function(e10) {
      return c5(this, arguments, void 0, (function* ({ channelId: e11, withKeyExchange: t5, authorized: n5, state: r6 }) {
        var i6, s3, a4;
        if (!validate_default(e11)) throw oo5.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r6.context} invalid channel channelId=${e11}`), new Error(`Invalid channel ${e11}`);
        if (oo5.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r6.context} channelId=${e11} withKeyExchange=${t5}`), null === (i6 = r6.communicationLayer) || void 0 === i6 ? void 0 : i6.isConnected()) return void oo5.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r6.context} already connected - interrupt connection.`);
        r6.channelId = e11, yield null === (s3 = r6.communicationLayer) || void 0 === s3 ? void 0 : s3.connectToChannel({ channelId: e11, authorized: n5, withKeyExchange: t5 });
        const c6 = Object.assign(Object.assign({}, r6.channelConfig), { channelId: e11, validUntil: Date.now() + r6.sessionDuration });
        r6.channelConfig = c6, null === (a4 = r6.storageManager) || void 0 === a4 || a4.persistChannelConfig(c6);
      }));
    })({ channelId: e9, authorized: n4, withKeyExchange: t4, state: this.state });
  }
  sendMessage(e9) {
    return c5(this, void 0, void 0, (function* () {
      const t4 = this.state.isOriginator && e9.method && bo5(e9.method);
      t4 && import_sdk_analytics.analytics.track("sdk_action_requested", { action: e9.method });
      try {
        return yield (function(e10, t5) {
          return c5(this, void 0, void 0, (function* () {
            var n4, r6;
            const { state: i6 } = e10;
            oo5.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i6.context} paused=${i6.paused} ready=${i6.ready} relayPersistence=${i6.relayPersistence} authorized=${i6.authorized} socket=${null === (n4 = i6.communicationLayer) || void 0 === n4 ? void 0 : n4.isConnected()} clientsConnected=${i6.clientsConnected} status=${i6._connectionStatus}`, t5), i6.relayPersistence || i6.ready && (null === (r6 = i6.communicationLayer) || void 0 === r6 ? void 0 : r6.isConnected()) && i6.clientsConnected || (oo5.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i6.context}  SKIP message waiting for MM mobile readiness.`), yield new Promise(((t6) => {
              e10.once(So5.CLIENTS_READY, t6);
            })), oo5.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i6.context}  AFTER SKIP / READY -- sending pending message`));
            try {
              const n5 = yield (function(e11, t6) {
                return c5(this, void 0, void 0, (function* () {
                  return new Promise(((n6) => {
                    var r7;
                    const { state: i7 } = e11;
                    oo5.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i7.context} ready=${i7.ready} authorized=${i7.authorized} method=${t6.method}`), !i7.isOriginator || i7.authorized || i7.relayPersistence ? null === (r7 = i7.communicationLayer) || void 0 === r7 || r7.sendMessage(t6).then(((e12) => {
                      n6(e12);
                    })).catch(((e12) => {
                      n6(false);
                    })) : e11.once(So5.AUTHORIZED, (() => {
                      var e12;
                      oo5.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i7.context}  AFTER SKIP / AUTHORIZED -- sending pending message`), null === (e12 = i7.communicationLayer) || void 0 === e12 || e12.sendMessage(t6).then(((e13) => {
                        n6(e13);
                      })).catch(((e13) => {
                        n6(false);
                      }));
                    }));
                  }));
                }));
              })(e10, t5);
              return n5;
            } catch (e11) {
              throw e11;
            }
          }));
        })(this, e9);
      } catch (r6) {
        throw t4 && import_sdk_analytics.analytics.track("sdk_action_failed", { action: e9.method }), r6;
      }
    }));
  }
  testStorage() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        return c5(this, void 0, void 0, (function* () {
          var t4;
          const n4 = yield null === (t4 = e9.storageManager) || void 0 === t4 ? void 0 : t4.getPersistedChannelConfig();
          oo5.RemoteCommunication("[RemoteCommunication: testStorage()] res", n4);
        }));
      })(this.state);
    }));
  }
  hasDeeplinkProtocol() {
    return this.state.deeplinkProtocolAvailable;
  }
  getChannelConfig() {
    return this.state.channelConfig;
  }
  isReady() {
    return this.state.ready;
  }
  isConnected() {
    var e9;
    return null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.isConnected();
  }
  isAuthorized() {
    return this.state.authorized;
  }
  isPaused() {
    return this.state.paused;
  }
  getCommunicationLayer() {
    return this.state.communicationLayer;
  }
  ping() {
    return c5(this, void 0, void 0, (function* () {
      var e9;
      oo5.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`), yield null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.ping();
    }));
  }
  testLogger() {
    oo5.RemoteCommunication(`testLogger() channel=${this.state.channelId}`), oo5.SocketService(`testLogger() channel=${this.state.channelId}`), oo5.Ecies(`testLogger() channel=${this.state.channelId}`), oo5.KeyExchange(`testLogger() channel=${this.state.channelId}`);
  }
  keyCheck() {
    var e9;
    oo5.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`), null === (e9 = this.state.communicationLayer) || void 0 === e9 || e9.keyCheck();
  }
  setConnectionStatus(e9) {
    this.state._connectionStatus !== e9 && (this.state._connectionStatus = e9, this.emit(So5.CONNECTION_STATUS, e9), this.emitServiceStatusEvent({ context: "setConnectionStatus" }));
  }
  emitServiceStatusEvent(e9 = {}) {
    this.emit(So5.SERVICE_STATUS, this.getServiceStatus());
  }
  getConnectionStatus() {
    return this.state._connectionStatus;
  }
  getServiceStatus() {
    return { originatorInfo: this.state.originatorInfo, keyInfo: this.getKeyInfo(), connectionStatus: this.state._connectionStatus, channelConfig: this.state.channelConfig, channelId: this.state.channelId };
  }
  getKeyInfo() {
    var e9;
    return null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.getKeyInfo();
  }
  resetKeys() {
    var e9;
    null === (e9 = this.state.communicationLayer) || void 0 === e9 || e9.resetKeys();
  }
  setOtherPublicKey(e9) {
    var t4;
    const n4 = null === (t4 = this.state.communicationLayer) || void 0 === t4 ? void 0 : t4.getKeyExchange();
    if (!n4) throw new Error("KeyExchange is not initialized.");
    n4.getOtherPublicKey() !== e9 && n4.setOtherPublicKey(e9);
  }
  pause() {
    return c5(this, void 0, void 0, (function* () {
      var e9;
      oo5.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`), yield null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.pause(), this.setConnectionStatus(Eo5.PAUSED);
    }));
  }
  getVersion() {
    return ho5.version;
  }
  hasRelayPersistence() {
    var e9;
    return null !== (e9 = this.state.relayPersistence) && void 0 !== e9 && e9;
  }
  resume() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        return c5(this, void 0, void 0, (function* () {
          var t4;
          const { state: n4 } = e9;
          oo5.RemoteCommunication(`[RemoteCommunication: resume()] channel=${n4.channelId}`), yield null === (t4 = n4.communicationLayer) || void 0 === t4 ? void 0 : t4.resume(), e9.setConnectionStatus(Eo5.LINKED);
        }));
      })(this);
    }));
  }
  encrypt(e9) {
    var t4, n4, r6;
    const i6 = null === (t4 = this.state.communicationLayer) || void 0 === t4 ? void 0 : t4.getKeyExchange(), o4 = null == i6 ? void 0 : i6.getOtherPublicKey();
    if (!o4) throw new Error("KeyExchange not completed");
    return null === (r6 = null === (n4 = this.state.communicationLayer) || void 0 === n4 ? void 0 : n4.state.eciesInstance) || void 0 === r6 ? void 0 : r6.encrypt(e9, o4);
  }
  decrypt(e9) {
    var t4, n4, r6;
    if (!(null === (t4 = this.state.communicationLayer) || void 0 === t4 ? void 0 : t4.state.eciesInstance)) throw new Error("ECIES instance is not initialized");
    return null === (r6 = null === (n4 = this.state.communicationLayer) || void 0 === n4 ? void 0 : n4.state.eciesInstance) || void 0 === r6 ? void 0 : r6.decrypt(e9);
  }
  getChannelId() {
    return this.state.channelId;
  }
  getRPCMethodTracker() {
    var e9;
    return null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.getRPCMethodTracker();
  }
  reject({ channelId: e9 }) {
    return (function(e10) {
      return c5(this, arguments, void 0, (function* ({ channelId: e11, state: t4 }) {
        var n4, r6, i6;
        if (!validate_default(e11)) throw oo5.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${t4.context} invalid channel channelId=${e11}`), new Error(`Invalid channel ${e11}`);
        if (t4.isOriginator) return void oo5.RemoteCommunication(`[RemoteCommunication: reject()] context=${t4.context} isOriginator=${t4.isOriginator} channelId=${e11}`);
        const { socket: s3 } = null !== (r6 = null === (n4 = t4.communicationLayer) || void 0 === n4 ? void 0 : n4.state) && void 0 !== r6 ? r6 : {};
        (null == s3 ? void 0 : s3.connected) || (oo5.RemoteCommunication(`[RemoteCommunication: reject()] context=${t4.context} socket already connected`), null == s3 || s3.connect()), lo5(Object.assign(Object.assign({ id: e11, event: Ao5.REJECTED }, t4.originatorInfo), { sdkVersion: t4.sdkVersion, commLayerVersion: ho5.version, walletVersion: null === (i6 = t4.walletInfo) || void 0 === i6 ? void 0 : i6.version }), t4.communicationServerUrl).catch(((e12) => {
        })), yield new Promise(((n5, r7) => {
          null == s3 || s3.emit(So5.REJECTED, { channelId: e11 }, ((e12, i7) => {
            oo5.RemoteCommunication(`[RemoteCommunication: reject()] context=${t4.context} socket=${null == s3 ? void 0 : s3.id}`, { error: e12, response: i7 }), e12 ? r7(e12) : n5(i7);
          }));
        }));
      }));
    })({ channelId: e9, state: this.state });
  }
  disconnect(e9) {
    return c5(this, void 0, void 0, (function* () {
      return es2({ options: e9, instance: this });
    }));
  }
};
!(function(e9) {
  e9.RENEW = "renew", e9.LINK = "link";
})(Ho3 || (Ho3 = {}));
var ns2 = "ERC721";
var rs2 = "ERC1155";
var is2 = { errors: { disconnected: () => "MetaMask: Disconnected from chain. Attempting to connect.", permanentlyDisconnected: () => "MetaMask: Disconnected from MetaMask background. Page reload required.", sendSiteMetadata: () => "MetaMask: Failed to send site metadata. This is an internal error, please report this bug.", unsupportedSync: (e9) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${e9} without a callback parameter.`, invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.", invalidNetworkParams: () => "MetaMask: Received invalid network parameters. Please report this bug.", invalidRequestArgs: () => "Expected a single, non-array, object argument.", invalidRequestMethod: () => "'args.method' must be a non-empty string.", invalidRequestParams: () => "'args.params' must be an object or array if provided.", invalidLoggerObject: () => "'args.logger' must be an object if provided.", invalidLoggerMethod: (e9) => `'args.logger' must include required method '${e9}'.` }, info: { connected: (e9) => `MetaMask: Connected to chain with ID "${e9}".` }, warnings: { chainIdDeprecation: "MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", networkVersionDeprecation: "MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", selectedAddressDeprecation: "MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", enableDeprecation: "MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102", sendDeprecation: "MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193", events: { close: "MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect", data: "MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message", networkChanged: "MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged", notification: "MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message" }, rpc: { ethDecryptDeprecation: "MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", ethGetEncryptionPublicKeyDeprecation: "MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", walletWatchAssetNFTExperimental: "MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle" }, experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning." } };
function os2(e9) {
  const t4 = { ethDecryptDeprecation: false, ethGetEncryptionPublicKeyDeprecation: false, walletWatchAssetNFTExperimental: false };
  return (n4, r6, i6) => {
    t4.ethDecryptDeprecation || "eth_decrypt" !== n4.method ? t4.ethGetEncryptionPublicKeyDeprecation || "eth_getEncryptionPublicKey" !== n4.method ? !t4.walletWatchAssetNFTExperimental && "wallet_watchAsset" === n4.method && [ns2, rs2].includes(n4.params?.type || "") && (e9.warn(is2.warnings.rpc.walletWatchAssetNFTExperimental), t4.walletWatchAssetNFTExperimental = true) : (e9.warn(is2.warnings.rpc.ethGetEncryptionPublicKeyDeprecation), t4.ethGetEncryptionPublicKeyDeprecation = true) : (e9.warn(is2.warnings.rpc.ethDecryptDeprecation), t4.ethDecryptDeprecation = true), i6();
  };
}
var ss2 = 4294967295;
var as2 = Math.floor(Math.random() * ss2);
function cs2() {
  return (e9, t4, n4, r6) => {
    const i6 = e9.id, o4 = as2 = (as2 + 1) % ss2;
    e9.id = o4, t4.id = o4, n4(((n5) => {
      e9.id = i6, t4.id = i6, n5();
    }));
  };
}
var ls2 = (e9, t4, n4) => {
  if (!t4.has(e9)) throw TypeError("Cannot " + n4);
};
var ds2 = (e9, t4, n4) => (ls2(e9, t4, "read from private field"), n4 ? n4.call(e9) : t4.get(e9));
var us2 = (e9, t4, n4) => {
  if (t4.has(e9)) throw TypeError("Cannot add the same private member more than once");
  t4 instanceof WeakSet ? t4.add(e9) : t4.set(e9, n4);
};
var hs3 = (e9, t4, n4, r6) => (ls2(e9, t4, "write to private field"), t4.set(e9, n4), n4);
var fs2 = (e9, t4, n4) => (ls2(e9, t4, "access private method"), n4);
var ps2 = { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 };
var gs3 = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } };
function ms2(e9) {
  return Boolean(e9) && "object" == typeof e9 && !Array.isArray(e9);
}
var ys3 = (e9, t4) => Object.hasOwnProperty.call(e9, t4);
var vs = class extends TypeError {
  constructor(e9, t4) {
    let n4;
    const { message: r6, explanation: i6, ...o4 } = e9, { path: s3 } = e9, a4 = 0 === s3.length ? r6 : `At path: ${s3.join(".")} -- ${r6}`;
    super(i6 ?? a4), null != i6 && (this.cause = a4), Object.assign(this, o4), this.name = this.constructor.name, this.failures = () => n4 ?? (n4 = [e9, ...t4()]);
  }
};
function bs3(e9) {
  return "object" == typeof e9 && null != e9;
}
function ws5(e9) {
  return "symbol" == typeof e9 ? e9.toString() : "string" == typeof e9 ? JSON.stringify(e9) : `${e9}`;
}
function Es(e9, t4, n4, r6) {
  if (true === e9) return;
  false === e9 ? e9 = {} : "string" == typeof e9 && (e9 = { message: e9 });
  const { path: i6, branch: o4 } = t4, { type: s3 } = n4, { refinement: a4, message: c6 = `Expected a value of type \`${s3}\`${a4 ? ` with refinement \`${a4}\`` : ""}, but received: \`${ws5(r6)}\`` } = e9;
  return { value: r6, type: s3, refinement: a4, key: i6[i6.length - 1], path: i6, branch: o4, ...e9, message: c6 };
}
function* Ss(e9, t4, n4, r6) {
  (function(e10) {
    return bs3(e10) && "function" == typeof e10[Symbol.iterator];
  })(e9) || (e9 = [e9]);
  for (const i6 of e9) {
    const e10 = Es(i6, t4, n4, r6);
    e10 && (yield e10);
  }
}
function* _s2(e9, t4, n4 = {}) {
  const { path: r6 = [], branch: i6 = [e9], coerce: o4 = false, mask: s3 = false } = n4, a4 = { path: r6, branch: i6 };
  if (o4 && (e9 = t4.coercer(e9, a4), s3 && "type" !== t4.type && bs3(t4.schema) && bs3(e9) && !Array.isArray(e9))) for (const n5 in e9) void 0 === t4.schema[n5] && delete e9[n5];
  let c6 = "valid";
  for (const r7 of t4.validator(e9, a4)) r7.explanation = n4.message, c6 = "not_valid", yield [r7, void 0];
  for (let [l6, d5, u6] of t4.entries(e9, a4)) {
    const t5 = _s2(d5, u6, { path: void 0 === l6 ? r6 : [...r6, l6], branch: void 0 === l6 ? i6 : [...i6, d5], coerce: o4, mask: s3, message: n4.message });
    for (const n5 of t5) n5[0] ? (c6 = null != n5[0].refinement ? "not_refined" : "not_valid", yield [n5[0], void 0]) : o4 && (d5 = n5[1], void 0 === l6 ? e9 = d5 : e9 instanceof Map ? e9.set(l6, d5) : e9 instanceof Set ? e9.add(d5) : bs3(e9) && (void 0 !== d5 || l6 in e9) && (e9[l6] = d5));
  }
  if ("not_valid" !== c6) for (const r7 of t4.refiner(e9, a4)) r7.explanation = n4.message, c6 = "not_refined", yield [r7, void 0];
  "valid" === c6 && (yield [void 0, e9]);
}
var Cs3 = class {
  constructor(e9) {
    const { type: t4, schema: n4, validator: r6, refiner: i6, coercer: o4 = ((e10) => e10), entries: s3 = function* () {
    } } = e9;
    this.type = t4, this.schema = n4, this.entries = s3, this.coercer = o4, this.validator = r6 ? (e10, t5) => Ss(r6(e10, t5), t5, this, e10) : () => [], this.refiner = i6 ? (e10, t5) => Ss(i6(e10, t5), t5, this, e10) : () => [];
  }
  assert(e9, t4) {
    return ks3(e9, this, t4);
  }
  create(e9, t4) {
    return As2(e9, this, t4);
  }
  is(e9) {
    return xs5(e9, this);
  }
  mask(e9, t4) {
    return (function(e10, t5, n4) {
      const r6 = Ms3(e10, t5, { coerce: true, mask: true, message: n4 });
      if (r6[0]) throw r6[0];
      return r6[1];
    })(e9, this, t4);
  }
  validate(e9, t4 = {}) {
    return Ms3(e9, this, t4);
  }
};
function ks3(e9, t4, n4) {
  const r6 = Ms3(e9, t4, { message: n4 });
  if (r6[0]) throw r6[0];
}
function As2(e9, t4, n4) {
  const r6 = Ms3(e9, t4, { coerce: true, message: n4 });
  if (r6[0]) throw r6[0];
  return r6[1];
}
function xs5(e9, t4) {
  return !Ms3(e9, t4)[0];
}
function Ms3(e9, t4, n4 = {}) {
  const r6 = _s2(e9, t4, n4), i6 = (function(e10) {
    const { done: t5, value: n5 } = e10.next();
    return t5 ? void 0 : n5;
  })(r6);
  if (i6[0]) {
    const e10 = new vs(i6[0], (function* () {
      for (const e11 of r6) e11[0] && (yield e11[0]);
    }));
    return [e10, void 0];
  }
  return [void 0, i6[1]];
}
function Is(e9, t4) {
  return new Cs3({ type: e9, schema: null, validator: t4 });
}
function Ts(e9) {
  let t4;
  return new Cs3({ type: "lazy", schema: null, *entries(n4, r6) {
    t4 ?? (t4 = e9()), yield* t4.entries(n4, r6);
  }, validator: (n4, r6) => (t4 ?? (t4 = e9()), t4.validator(n4, r6)), coercer: (n4, r6) => (t4 ?? (t4 = e9()), t4.coercer(n4, r6)), refiner: (n4, r6) => (t4 ?? (t4 = e9()), t4.refiner(n4, r6)) });
}
function Rs(e9) {
  return new Cs3({ type: "array", schema: e9, *entries(t4) {
    if (e9 && Array.isArray(t4)) for (const [n4, r6] of t4.entries()) yield [n4, r6, e9];
  }, coercer: (e10) => Array.isArray(e10) ? e10.slice() : e10, validator: (e10) => Array.isArray(e10) || `Expected an array value, but received: ${ws5(e10)}` });
}
function Ps2(e9) {
  const t4 = ws5(e9), n4 = typeof e9;
  return new Cs3({ type: "literal", schema: "string" === n4 || "number" === n4 || "boolean" === n4 ? e9 : null, validator: (n5) => n5 === e9 || `Expected the literal \`${t4}\`, but received: ${ws5(n5)}` });
}
function Os2() {
  return Is("number", ((e9) => "number" == typeof e9 && !isNaN(e9) || `Expected a number, but received: ${ws5(e9)}`));
}
function Ns4(e9) {
  const t4 = e9 ? Object.keys(e9) : [], n4 = Is("never", (() => false));
  return new Cs3({ type: "object", schema: e9 || null, *entries(r6) {
    if (e9 && bs3(r6)) {
      const i6 = new Set(Object.keys(r6));
      for (const n5 of t4) i6.delete(n5), yield [n5, r6[n5], e9[n5]];
      for (const e10 of i6) yield [e10, r6[e10], n4];
    }
  }, validator: (e10) => bs3(e10) || `Expected an object, but received: ${ws5(e10)}`, coercer: (e10) => bs3(e10) ? { ...e10 } : e10 });
}
function Ls3(e9) {
  return new Cs3({ ...e9, validator: (t4, n4) => void 0 === t4 || e9.validator(t4, n4), refiner: (t4, n4) => void 0 === t4 || e9.refiner(t4, n4) });
}
function Ds2(e9, t4) {
  return new Cs3({ type: "record", schema: null, *entries(n4) {
    if (bs3(n4)) for (const r6 in n4) {
      const i6 = n4[r6];
      yield [r6, r6, e9], yield [r6, i6, t4];
    }
  }, validator: (e10) => bs3(e10) || `Expected an object, but received: ${ws5(e10)}` });
}
function $s3() {
  return Is("string", ((e9) => "string" == typeof e9 || `Expected a string, but received: ${ws5(e9)}`));
}
function Bs(e9) {
  const t4 = e9.map(((e10) => e10.type)).join(" | ");
  return new Cs3({ type: "union", schema: null, coercer(t5) {
    for (const n4 of e9) {
      const [e10, r6] = n4.validate(t5, { coerce: true });
      if (!e10) return r6;
    }
    return t5;
  }, validator(n4, r6) {
    const i6 = [];
    for (const t5 of e9) {
      const [...e10] = _s2(n4, t5, r6), [o4] = e10;
      if (!o4[0]) return [];
      for (const [t6] of e10) t6 && i6.push(t6);
    }
    return [`Expected the value to satisfy a union of \`${t4}\`, but received: ${ws5(n4)}`, ...i6];
  } });
}
function Ks3(e9) {
  return (function(e10) {
    return (function(e11) {
      return "object" == typeof e11 && null !== e11 && "message" in e11;
    })(e10) && "string" == typeof e10.message ? e10.message : null == e10 ? "" : String(e10);
  })(e9).replace(/\.$/u, "");
}
function js3(e9, t4) {
  return n4 = e9, Boolean("string" == typeof n4?.prototype?.constructor?.name) ? new e9({ message: t4 }) : e9({ message: t4 });
  var n4;
}
var Us2 = class extends Error {
  constructor(e9) {
    super(e9.message), this.code = "ERR_ASSERTION";
  }
};
function Hs() {
  throw new Error("setTimeout has not been defined");
}
function Fs2() {
  throw new Error("clearTimeout has not been defined");
}
var zs2 = Hs;
var qs2 = Fs2;
function Ws(e9) {
  if (zs2 === setTimeout) return setTimeout(e9, 0);
  if ((zs2 === Hs || !zs2) && setTimeout) return zs2 = setTimeout, setTimeout(e9, 0);
  try {
    return zs2(e9, 0);
  } catch (t4) {
    try {
      return zs2.call(null, e9, 0);
    } catch (t5) {
      return zs2.call(this, e9, 0);
    }
  }
}
"function" == typeof l5.setTimeout && (zs2 = setTimeout), "function" == typeof l5.clearTimeout && (qs2 = clearTimeout);
var Vs3;
var Gs3 = [];
var Ys2 = false;
var Zs = -1;
function Js2() {
  Ys2 && Vs3 && (Ys2 = false, Vs3.length ? Gs3 = Vs3.concat(Gs3) : Zs = -1, Gs3.length && Qs2());
}
function Qs2() {
  if (!Ys2) {
    var e9 = Ws(Js2);
    Ys2 = true;
    for (var t4 = Gs3.length; t4; ) {
      for (Vs3 = Gs3, Gs3 = []; ++Zs < t4; ) Vs3 && Vs3[Zs].run();
      Zs = -1, t4 = Gs3.length;
    }
    Vs3 = null, Ys2 = false, (function(e10) {
      if (qs2 === clearTimeout) return clearTimeout(e10);
      if ((qs2 === Fs2 || !qs2) && clearTimeout) return qs2 = clearTimeout, clearTimeout(e10);
      try {
        return qs2(e10);
      } catch (t5) {
        try {
          return qs2.call(null, e10);
        } catch (t6) {
          return qs2.call(this, e10);
        }
      }
    })(e9);
  }
}
function Xs2(e9, t4) {
  this.fun = e9, this.array = t4;
}
Xs2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function ea2() {
}
var ta2 = ea2;
var na2 = ea2;
var ra2 = ea2;
var ia2 = ea2;
var oa2 = ea2;
var sa2 = ea2;
var aa2 = ea2;
var ca2 = l5.performance || {};
var la2 = ca2.now || ca2.mozNow || ca2.msNow || ca2.oNow || ca2.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var da2 = /* @__PURE__ */ new Date();
var ua2 = { nextTick: function(e9) {
  var t4 = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var n4 = 1; n4 < arguments.length; n4++) t4[n4 - 1] = arguments[n4];
  Gs3.push(new Xs2(e9, t4)), 1 !== Gs3.length || Ys2 || Ws(Qs2);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: ta2, addListener: na2, once: ra2, off: ia2, removeListener: oa2, removeAllListeners: sa2, emit: aa2, binding: function(e9) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e9) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e9) {
  var t4 = 1e-3 * la2.call(ca2), n4 = Math.floor(t4), r6 = Math.floor(t4 % 1 * 1e9);
  return e9 && (n4 -= e9[0], (r6 -= e9[1]) < 0 && (n4--, r6 += 1e9)), [n4, r6];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (/* @__PURE__ */ new Date() - da2) / 1e3;
} };
var ha = (e9) => Ns4(e9);
function fa2({ path: e9, branch: t4 }) {
  const n4 = e9[e9.length - 1];
  return ys3(t4[t4.length - 2], n4);
}
function pa(e9) {
  return new Cs3({ ...e9, type: `optional ${e9.type}`, validator: (t4, n4) => !fa2(n4) || e9.validator(t4, n4), refiner: (t4, n4) => !fa2(n4) || e9.refiner(t4, n4) });
}
var ga2;
var ma2;
var ya2;
var va2 = Bs([Ps2(null), Is("boolean", ((e9) => "boolean" == typeof e9)), Is("finite number", ((e9) => xs5(e9, Os2()) && Number.isFinite(e9))), $s3(), Rs(Ts((() => va2))), Ds2($s3(), Ts((() => va2)))]);
var ba2 = (ga2 = va2, ma2 = Is("any", (() => true)), ya2 = (e9) => ((function(e10, t4, n4 = "Assertion failed", r6 = Us2) {
  try {
    ks3(e10, t4);
  } catch (e11) {
    throw js3(r6, `${n4}: ${Ks3(e11)}.`);
  }
})(e9, va2), JSON.parse(JSON.stringify(e9, ((e10, t4) => {
  if ("__proto__" !== e10 && "constructor" !== e10) return t4;
})))), new Cs3({ ...ga2, coercer: (e9, t4) => xs5(e9, ma2) ? ga2.coercer(ya2(e9, t4), t4) : ga2.coercer(e9, t4) }));
function wa2(e9) {
  try {
    return (function(e10) {
      As2(e10, ba2);
    })(e9), true;
  } catch {
    return false;
  }
}
var Ea2 = Ps2("2.0");
var Sa2 = (function(e9) {
  return new Cs3({ ...e9, validator: (t4, n4) => null === t4 || e9.validator(t4, n4), refiner: (t4, n4) => null === t4 || e9.refiner(t4, n4) });
})(Bs([Os2(), $s3()]));
var _a3 = ha({ code: Is("integer", ((e9) => "number" == typeof e9 && !isNaN(e9) && Number.isInteger(e9) || `Expected an integer, but received: ${ws5(e9)}`)), message: $s3(), data: pa(ba2), stack: pa($s3()) });
var Ca2 = Bs([Ds2($s3(), ba2), Rs(ba2)]);
var ka2 = ha({ id: Sa2, jsonrpc: Ea2, method: $s3(), params: pa(Ca2) });
var Aa2 = ha({ jsonrpc: Ea2, method: $s3(), params: pa(Ca2) });
function xa2(e9) {
  return xs5(e9, ka2);
}
function Ma2(e9) {
  return xs5(e9, _a3);
}
Ns4({ id: Sa2, jsonrpc: Ea2, result: Ls3(Is("unknown", (() => true))), error: Ls3(_a3) }), Bs([ha({ id: Sa2, jsonrpc: Ea2, result: ba2 }), ha({ id: Sa2, jsonrpc: Ea2, error: _a3 })]);
var Ia2 = ps2.internal;
var Ta2 = "Unspecified error message. This is a bug, please report it.";
var Ra2 = { code: Ia2, message: Oa2(Ia2) };
var Pa2 = "Unspecified server error.";
function Oa2(e9, t4 = Ta2) {
  if ((function(e10) {
    return Number.isInteger(e10);
  })(e9)) {
    const t5 = e9.toString();
    if (ys3(gs3, t5)) return gs3[t5].message;
    if ((function(e10) {
      return e10 >= -32099 && e10 <= -32e3;
    })(e9)) return Pa2;
  }
  return t4;
}
function Na2(e9, { fallbackError: t4 = Ra2, shouldIncludeStack: n4 = true } = {}) {
  if (!Ma2(t4)) throw new Error("Must provide fallback error with integer number code and string message.");
  const r6 = (function(e10, t5) {
    if (e10 && "object" == typeof e10 && "serialize" in e10 && "function" == typeof e10.serialize) return e10.serialize();
    if (Ma2(e10)) return e10;
    const n5 = La2(e10), r7 = { ...t5, data: { cause: n5 } };
    return r7;
  })(e9, t4);
  return n4 || delete r6.stack, r6;
}
function La2(e9) {
  return Array.isArray(e9) ? e9.map(((e10) => wa2(e10) ? e10 : ms2(e10) ? Da2(e10) : null)) : ms2(e9) ? Da2(e9) : wa2(e9) ? e9 : null;
}
function Da2(e9) {
  return Object.getOwnPropertyNames(e9).reduce(((t4, n4) => {
    const r6 = e9[n4];
    return wa2(r6) && (t4[n4] = r6), t4;
  }), {});
}
var $a2 = Fa;
Fa.default = Fa, Fa.stable = Va2, Fa.stableStringify = Va2;
var Ba2 = "[...]";
var Ka2 = "[Circular]";
var ja2 = [];
var Ua2 = [];
function Ha2() {
  return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
}
function Fa(e9, t4, n4, r6) {
  var i6;
  void 0 === r6 && (r6 = Ha2()), qa2(e9, "", 0, [], void 0, 0, r6);
  try {
    i6 = 0 === Ua2.length ? JSON.stringify(e9, t4, n4) : JSON.stringify(e9, Ya(t4), n4);
  } catch (e10) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja2.length; ) {
      var o4 = ja2.pop();
      4 === o4.length ? Object.defineProperty(o4[0], o4[1], o4[3]) : o4[0][o4[1]] = o4[2];
    }
  }
  return i6;
}
function za(e9, t4, n4, r6) {
  var i6 = Object.getOwnPropertyDescriptor(r6, n4);
  void 0 !== i6.get ? i6.configurable ? (Object.defineProperty(r6, n4, { value: e9 }), ja2.push([r6, n4, t4, i6])) : Ua2.push([t4, n4, e9]) : (r6[n4] = e9, ja2.push([r6, n4, t4]));
}
function qa2(e9, t4, n4, r6, i6, o4, s3) {
  var a4;
  if (o4 += 1, "object" == typeof e9 && null !== e9) {
    for (a4 = 0; a4 < r6.length; a4++) if (r6[a4] === e9) return void za(Ka2, e9, t4, i6);
    if (void 0 !== s3.depthLimit && o4 > s3.depthLimit) return void za(Ba2, e9, t4, i6);
    if (void 0 !== s3.edgesLimit && n4 + 1 > s3.edgesLimit) return void za(Ba2, e9, t4, i6);
    if (r6.push(e9), Array.isArray(e9)) for (a4 = 0; a4 < e9.length; a4++) qa2(e9[a4], a4, a4, r6, e9, o4, s3);
    else {
      var c6 = Object.keys(e9);
      for (a4 = 0; a4 < c6.length; a4++) {
        var l6 = c6[a4];
        qa2(e9[l6], l6, a4, r6, e9, o4, s3);
      }
    }
    r6.pop();
  }
}
function Wa(e9, t4) {
  return e9 < t4 ? -1 : e9 > t4 ? 1 : 0;
}
function Va2(e9, t4, n4, r6) {
  void 0 === r6 && (r6 = Ha2());
  var i6, o4 = Ga(e9, "", 0, [], void 0, 0, r6) || e9;
  try {
    i6 = 0 === Ua2.length ? JSON.stringify(o4, t4, n4) : JSON.stringify(o4, Ya(t4), n4);
  } catch (e10) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja2.length; ) {
      var s3 = ja2.pop();
      4 === s3.length ? Object.defineProperty(s3[0], s3[1], s3[3]) : s3[0][s3[1]] = s3[2];
    }
  }
  return i6;
}
function Ga(e9, t4, n4, r6, i6, o4, s3) {
  var a4;
  if (o4 += 1, "object" == typeof e9 && null !== e9) {
    for (a4 = 0; a4 < r6.length; a4++) if (r6[a4] === e9) return void za(Ka2, e9, t4, i6);
    try {
      if ("function" == typeof e9.toJSON) return;
    } catch (e10) {
      return;
    }
    if (void 0 !== s3.depthLimit && o4 > s3.depthLimit) return void za(Ba2, e9, t4, i6);
    if (void 0 !== s3.edgesLimit && n4 + 1 > s3.edgesLimit) return void za(Ba2, e9, t4, i6);
    if (r6.push(e9), Array.isArray(e9)) for (a4 = 0; a4 < e9.length; a4++) Ga(e9[a4], a4, a4, r6, e9, o4, s3);
    else {
      var c6 = {}, l6 = Object.keys(e9).sort(Wa);
      for (a4 = 0; a4 < l6.length; a4++) {
        var d5 = l6[a4];
        Ga(e9[d5], d5, a4, r6, e9, o4, s3), c6[d5] = e9[d5];
      }
      if (void 0 === i6) return c6;
      ja2.push([i6, t4, e9]), i6[t4] = c6;
    }
    r6.pop();
  }
}
function Ya(e9) {
  return e9 = void 0 !== e9 ? e9 : function(e10, t4) {
    return t4;
  }, function(t4, n4) {
    if (Ua2.length > 0) for (var r6 = 0; r6 < Ua2.length; r6++) {
      var i6 = Ua2[r6];
      if (i6[1] === t4 && i6[0] === n4) {
        n4 = i6[2], Ua2.splice(r6, 1);
        break;
      }
    }
    return e9.call(this, t4, n4);
  };
}
var Za = ue6($a2);
var Ja = class extends Error {
  constructor(e9, t4, n4) {
    if (!Number.isInteger(e9)) throw new Error('"code" must be an integer.');
    if (!t4 || "string" != typeof t4) throw new Error('"message" must be a non-empty string.');
    super(t4), this.code = e9, void 0 !== n4 && (this.data = n4);
  }
  serialize() {
    const e9 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e9.data = this.data, (function(e10) {
      if ("object" != typeof e10 || null === e10) return false;
      try {
        let t4 = e10;
        for (; null !== Object.getPrototypeOf(t4); ) t4 = Object.getPrototypeOf(t4);
        return Object.getPrototypeOf(e10) === t4;
      } catch (e11) {
        return false;
      }
    })(this.data) && (e9.data.cause = La2(this.data.cause))), this.stack && (e9.stack = this.stack), e9;
  }
  toString() {
    return Za(this.serialize(), Qa, 2);
  }
};
function Qa(e9, t4) {
  if ("[Circular]" !== t4) return t4;
}
var Xa = (e9) => ec4(ps2.invalidRequest, e9);
function ec4(e9, t4) {
  const [n4, r6] = (function(e10) {
    if (e10) {
      if ("string" == typeof e10) return [e10];
      if ("object" == typeof e10 && !Array.isArray(e10)) {
        const { message: t5, data: n5 } = e10;
        if (t5 && "string" != typeof t5) throw new Error("Must specify string message.");
        return [t5 ?? void 0, n5];
      }
    }
    return [];
  })(t4);
  return new Ja(e9, n4 ?? Oa2(e9), r6);
}
var tc4 = {};
function nc4() {
}
function rc4() {
  rc4.init.call(this);
}
function ic4(e9) {
  return void 0 === e9._maxListeners ? rc4.defaultMaxListeners : e9._maxListeners;
}
function oc4(e9, t4, n4, r6) {
  var i6, o4, s3;
  if ("function" != typeof n4) throw new TypeError('"listener" argument must be a function');
  if ((o4 = e9._events) ? (o4.newListener && (e9.emit("newListener", t4, n4.listener ? n4.listener : n4), o4 = e9._events), s3 = o4[t4]) : (o4 = e9._events = new nc4(), e9._eventsCount = 0), s3) {
    if ("function" == typeof s3 ? s3 = o4[t4] = r6 ? [n4, s3] : [s3, n4] : r6 ? s3.unshift(n4) : s3.push(n4), !s3.warned && (i6 = ic4(e9)) && i6 > 0 && s3.length > i6) {
      s3.warned = true;
      var a4 = new Error("Possible EventEmitter memory leak detected. " + s3.length + " " + t4 + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a4.name = "MaxListenersExceededWarning", a4.emitter = e9, a4.type = t4, a4.count = s3.length, (function(e10) {
        "function" == typeof console.warn ? console.warn(e10) : console.log(e10);
      })(a4);
    }
  } else s3 = o4[t4] = n4, ++e9._eventsCount;
  return e9;
}
function sc4(e9, t4, n4) {
  var r6 = false;
  function i6() {
    e9.removeListener(t4, i6), r6 || (r6 = true, n4.apply(e9, arguments));
  }
  return i6.listener = n4, i6;
}
function ac4(e9) {
  var t4 = this._events;
  if (t4) {
    var n4 = t4[e9];
    if ("function" == typeof n4) return 1;
    if (n4) return n4.length;
  }
  return 0;
}
function cc4(e9, t4) {
  for (var n4 = new Array(t4); t4--; ) n4[t4] = e9[t4];
  return n4;
}
nc4.prototype = /* @__PURE__ */ Object.create(null), rc4.EventEmitter = rc4, rc4.usingDomains = false, rc4.prototype.domain = void 0, rc4.prototype._events = void 0, rc4.prototype._maxListeners = void 0, rc4.defaultMaxListeners = 10, rc4.init = function() {
  this.domain = null, rc4.usingDomains && (void 0).active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new nc4(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, rc4.prototype.setMaxListeners = function(e9) {
  if ("number" != typeof e9 || e9 < 0 || isNaN(e9)) throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = e9, this;
}, rc4.prototype.getMaxListeners = function() {
  return ic4(this);
}, rc4.prototype.emit = function(e9) {
  var t4, n4, r6, i6, o4, s3, a4, c6 = "error" === e9;
  if (s3 = this._events) c6 = c6 && null == s3.error;
  else if (!c6) return false;
  if (a4 = this.domain, c6) {
    if (t4 = arguments[1], !a4) {
      if (t4 instanceof Error) throw t4;
      var l6 = new Error('Uncaught, unspecified "error" event. (' + t4 + ")");
      throw l6.context = t4, l6;
    }
    return t4 || (t4 = new Error('Uncaught, unspecified "error" event')), t4.domainEmitter = this, t4.domain = a4, t4.domainThrown = false, a4.emit("error", t4), false;
  }
  if (!(n4 = s3[e9])) return false;
  var d5 = "function" == typeof n4;
  switch (r6 = arguments.length) {
    case 1:
      !(function(e10, t5, n5) {
        if (t5) e10.call(n5);
        else for (var r7 = e10.length, i7 = cc4(e10, r7), o5 = 0; o5 < r7; ++o5) i7[o5].call(n5);
      })(n4, d5, this);
      break;
    case 2:
      !(function(e10, t5, n5, r7) {
        if (t5) e10.call(n5, r7);
        else for (var i7 = e10.length, o5 = cc4(e10, i7), s4 = 0; s4 < i7; ++s4) o5[s4].call(n5, r7);
      })(n4, d5, this, arguments[1]);
      break;
    case 3:
      !(function(e10, t5, n5, r7, i7) {
        if (t5) e10.call(n5, r7, i7);
        else for (var o5 = e10.length, s4 = cc4(e10, o5), a5 = 0; a5 < o5; ++a5) s4[a5].call(n5, r7, i7);
      })(n4, d5, this, arguments[1], arguments[2]);
      break;
    case 4:
      !(function(e10, t5, n5, r7, i7, o5) {
        if (t5) e10.call(n5, r7, i7, o5);
        else for (var s4 = e10.length, a5 = cc4(e10, s4), c7 = 0; c7 < s4; ++c7) a5[c7].call(n5, r7, i7, o5);
      })(n4, d5, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      for (i6 = new Array(r6 - 1), o4 = 1; o4 < r6; o4++) i6[o4 - 1] = arguments[o4];
      !(function(e10, t5, n5, r7) {
        if (t5) e10.apply(n5, r7);
        else for (var i7 = e10.length, o5 = cc4(e10, i7), s4 = 0; s4 < i7; ++s4) o5[s4].apply(n5, r7);
      })(n4, d5, this, i6);
  }
  return true;
}, rc4.prototype.addListener = function(e9, t4) {
  return oc4(this, e9, t4, false);
}, rc4.prototype.on = rc4.prototype.addListener, rc4.prototype.prependListener = function(e9, t4) {
  return oc4(this, e9, t4, true);
}, rc4.prototype.once = function(e9, t4) {
  if ("function" != typeof t4) throw new TypeError('"listener" argument must be a function');
  return this.on(e9, sc4(this, e9, t4)), this;
}, rc4.prototype.prependOnceListener = function(e9, t4) {
  if ("function" != typeof t4) throw new TypeError('"listener" argument must be a function');
  return this.prependListener(e9, sc4(this, e9, t4)), this;
}, rc4.prototype.removeListener = function(e9, t4) {
  var n4, r6, i6, o4, s3;
  if ("function" != typeof t4) throw new TypeError('"listener" argument must be a function');
  if (!(r6 = this._events)) return this;
  if (!(n4 = r6[e9])) return this;
  if (n4 === t4 || n4.listener && n4.listener === t4) 0 == --this._eventsCount ? this._events = new nc4() : (delete r6[e9], r6.removeListener && this.emit("removeListener", e9, n4.listener || t4));
  else if ("function" != typeof n4) {
    for (i6 = -1, o4 = n4.length; o4-- > 0; ) if (n4[o4] === t4 || n4[o4].listener && n4[o4].listener === t4) {
      s3 = n4[o4].listener, i6 = o4;
      break;
    }
    if (i6 < 0) return this;
    if (1 === n4.length) {
      if (n4[0] = void 0, 0 == --this._eventsCount) return this._events = new nc4(), this;
      delete r6[e9];
    } else !(function(e10, t5) {
      for (var n5 = t5, r7 = n5 + 1, i7 = e10.length; r7 < i7; n5 += 1, r7 += 1) e10[n5] = e10[r7];
      e10.pop();
    })(n4, i6);
    r6.removeListener && this.emit("removeListener", e9, s3 || t4);
  }
  return this;
}, rc4.prototype.off = function(e9, t4) {
  return this.removeListener(e9, t4);
}, rc4.prototype.removeAllListeners = function(e9) {
  var t4, n4;
  if (!(n4 = this._events)) return this;
  if (!n4.removeListener) return 0 === arguments.length ? (this._events = new nc4(), this._eventsCount = 0) : n4[e9] && (0 == --this._eventsCount ? this._events = new nc4() : delete n4[e9]), this;
  if (0 === arguments.length) {
    for (var r6, i6 = Object.keys(n4), o4 = 0; o4 < i6.length; ++o4) "removeListener" !== (r6 = i6[o4]) && this.removeAllListeners(r6);
    return this.removeAllListeners("removeListener"), this._events = new nc4(), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t4 = n4[e9])) this.removeListener(e9, t4);
  else if (t4) do {
    this.removeListener(e9, t4[t4.length - 1]);
  } while (t4[0]);
  return this;
}, rc4.prototype.listeners = function(e9) {
  var t4, n4, r6 = this._events;
  return n4 = r6 && (t4 = r6[e9]) ? "function" == typeof t4 ? [t4.listener || t4] : (function(e10) {
    for (var t5 = new Array(e10.length), n5 = 0; n5 < t5.length; ++n5) t5[n5] = e10[n5].listener || e10[n5];
    return t5;
  })(t4) : [], n4;
}, rc4.listenerCount = function(e9, t4) {
  return "function" == typeof e9.listenerCount ? e9.listenerCount(t4) : ac4.call(e9, t4);
}, rc4.prototype.listenerCount = ac4, rc4.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
var lc4 = he6(Object.freeze({ __proto__: null, EventEmitter: rc4, default: rc4 }));
Object.defineProperty(tc4, "__esModule", { value: true });
var dc4 = lc4;
function uc4(e9, t4, n4) {
  try {
    Reflect.apply(e9, t4, n4);
  } catch (e10) {
    setTimeout((() => {
      throw e10;
    }));
  }
}
var hc4 = class extends dc4.EventEmitter {
  emit(e9, ...t4) {
    let n4 = "error" === e9;
    const r6 = this._events;
    if (void 0 !== r6) n4 = n4 && void 0 === r6.error;
    else if (!n4) return false;
    if (n4) {
      let e10;
      if (t4.length > 0 && ([e10] = t4), e10 instanceof Error) throw e10;
      const n5 = new Error("Unhandled error." + (e10 ? ` (${e10.message})` : ""));
      throw n5.context = e10, n5;
    }
    const i6 = r6[e9];
    if (void 0 === i6) return false;
    if ("function" == typeof i6) uc4(i6, this, t4);
    else {
      const e10 = i6.length, n5 = (function(e11) {
        const t5 = e11.length, n6 = new Array(t5);
        for (let r7 = 0; r7 < t5; r7 += 1) n6[r7] = e11[r7];
        return n6;
      })(i6);
      for (let r7 = 0; r7 < e10; r7 += 1) uc4(n5[r7], this, t4);
    }
    return true;
  }
};
var fc4;
var pc4;
var gc4;
var mc4;
var yc4;
var vc4;
var bc4;
var wc4;
var Ec4;
var Sc4;
var _c4;
var Cc4;
var kc4;
var Ac4;
var xc4;
var Mc2;
var Ic4;
var Tc4;
var Rc4;
var Pc4 = tc4.default = hc4;
var Oc4 = class e4 extends Pc4 {
  constructor({ notificationHandler: e9 } = {}) {
    super(), us2(this, mc4), us2(this, vc4), us2(this, wc4), us2(this, fc4, false), us2(this, pc4, void 0), us2(this, gc4, void 0), hs3(this, pc4, []), hs3(this, gc4, e9);
  }
  destroy() {
    ds2(this, pc4).forEach(((e9) => {
      "destroy" in e9 && "function" == typeof e9.destroy && e9.destroy();
    })), hs3(this, pc4, []), hs3(this, fc4, true);
  }
  push(e9) {
    fs2(this, mc4, yc4).call(this), ds2(this, pc4).push(e9);
  }
  handle(e9, t4) {
    if (fs2(this, mc4, yc4).call(this), t4 && "function" != typeof t4) throw new Error('"callback" must be a function if provided.');
    return Array.isArray(e9) ? t4 ? fs2(this, vc4, bc4).call(this, e9, t4) : fs2(this, vc4, bc4).call(this, e9) : t4 ? fs2(this, wc4, Ec4).call(this, e9, t4) : this._promiseHandle(e9);
  }
  asMiddleware() {
    return fs2(this, mc4, yc4).call(this), async (t4, n4, r6, i6) => {
      var o4, s3;
      try {
        const [a4, c6, l6] = await fs2(o4 = e4, Cc4, kc4).call(o4, t4, n4, ds2(this, pc4));
        return c6 ? (await fs2(s3 = e4, Mc2, Ic4).call(s3, l6), i6(a4)) : r6((async (t5) => {
          var n5;
          try {
            await fs2(n5 = e4, Mc2, Ic4).call(n5, l6);
          } catch (e9) {
            return t5(e9);
          }
          return t5();
        }));
      } catch (e9) {
        return i6(e9);
      }
    };
  }
  async _promiseHandle(e9) {
    return new Promise(((t4, n4) => {
      fs2(this, wc4, Ec4).call(this, e9, ((e10, r6) => {
        e10 && void 0 === r6 ? n4(e10) : t4(r6);
      })).catch(n4);
    }));
  }
};
fc4 = /* @__PURE__ */ new WeakMap(), pc4 = /* @__PURE__ */ new WeakMap(), gc4 = /* @__PURE__ */ new WeakMap(), mc4 = /* @__PURE__ */ new WeakSet(), yc4 = function() {
  if (ds2(this, fc4)) throw new Error("This engine is destroyed and can no longer be used.");
}, vc4 = /* @__PURE__ */ new WeakSet(), bc4 = async function(e9, t4) {
  try {
    if (0 === e9.length) {
      const e10 = [{ id: null, jsonrpc: "2.0", error: new Ja(ps2.invalidRequest, "Request batch must contain plain objects. Received an empty array") }];
      return t4 ? t4(null, e10) : e10;
    }
    const n4 = (await Promise.all(e9.map(this._promiseHandle.bind(this)))).filter(((e10) => void 0 !== e10));
    return t4 ? t4(null, n4) : n4;
  } catch (e10) {
    if (t4) return t4(e10);
    throw e10;
  }
}, wc4 = /* @__PURE__ */ new WeakSet(), Ec4 = async function(e9, t4) {
  var n4;
  if (!e9 || Array.isArray(e9) || "object" != typeof e9) {
    const n5 = new Ja(ps2.invalidRequest, "Requests must be plain objects. Received: " + typeof e9, { request: e9 });
    return t4(n5, { id: null, jsonrpc: "2.0", error: n5 });
  }
  if ("string" != typeof e9.method) {
    const n5 = new Ja(ps2.invalidRequest, "Must specify a string method. Received: " + typeof e9.method, { request: e9 });
    return ds2(this, gc4) && !xa2(e9) ? t4(null) : t4(n5, { id: e9.id ?? null, jsonrpc: "2.0", error: n5 });
  }
  if (ds2(this, gc4) && xs5(e9, Aa2) && !xa2(e9)) {
    try {
      await ds2(this, gc4).call(this, e9);
    } catch (e10) {
      return t4(e10);
    }
    return t4(null);
  }
  let r6 = null;
  const i6 = { ...e9 }, o4 = { id: i6.id, jsonrpc: i6.jsonrpc };
  try {
    await fs2(n4 = Oc4, Sc4, _c4).call(n4, i6, o4, ds2(this, pc4));
  } catch (e10) {
    r6 = e10;
  }
  return r6 && (delete o4.result, o4.error || (o4.error = Na2(r6))), t4(r6, o4);
}, Sc4 = /* @__PURE__ */ new WeakSet(), _c4 = async function(e9, t4, n4) {
  var r6, i6, o4;
  const [s3, a4, c6] = await fs2(r6 = Oc4, Cc4, kc4).call(r6, e9, t4, n4);
  if (fs2(i6 = Oc4, Tc4, Rc4).call(i6, e9, t4, a4), await fs2(o4 = Oc4, Mc2, Ic4).call(o4, c6), s3) throw s3;
}, Cc4 = /* @__PURE__ */ new WeakSet(), kc4 = async function(e9, t4, n4) {
  var r6;
  const i6 = [];
  let o4 = null, s3 = false;
  for (const a4 of n4) if ([o4, s3] = await fs2(r6 = Oc4, Ac4, xc4).call(r6, e9, t4, a4, i6), s3) break;
  return [o4, s3, i6.reverse()];
}, Ac4 = /* @__PURE__ */ new WeakSet(), xc4 = async function(e9, t4, n4, r6) {
  return new Promise(((i6) => {
    const o4 = (e10) => {
      const n5 = e10 || t4.error;
      n5 && (t4.error = Na2(n5)), i6([n5, true]);
    }, s3 = (n5) => {
      t4.error ? o4(t4.error) : (n5 && ("function" != typeof n5 && o4(new Ja(ps2.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof n5}" for request:
${Lc4(e9)}`, { request: e9 })), r6.push(n5)), i6([null, false]));
    };
    try {
      n4(e9, t4, s3, o4);
    } catch (e10) {
      o4(e10);
    }
  }));
}, Mc2 = /* @__PURE__ */ new WeakSet(), Ic4 = async function(e9) {
  for (const t4 of e9) await new Promise(((e10, n4) => {
    t4(((t5) => t5 ? n4(t5) : e10()));
  }));
}, Tc4 = /* @__PURE__ */ new WeakSet(), Rc4 = function(e9, t4, n4) {
  if (!ys3(t4, "result") && !ys3(t4, "error")) throw new Ja(ps2.internal, `JsonRpcEngine: Response has no error or result for request:
${Lc4(e9)}`, { request: e9 });
  if (!n4) throw new Ja(ps2.internal, `JsonRpcEngine: Nothing ended request:
${Lc4(e9)}`, { request: e9 });
}, us2(Oc4, Sc4), us2(Oc4, Cc4), us2(Oc4, Ac4), us2(Oc4, Mc2), us2(Oc4, Tc4);
var Nc4 = Oc4;
function Lc4(e9) {
  return JSON.stringify(e9, null, 2);
}
var Dc2 = Object.freeze(["eth_subscription"]);
var $c4 = (e9 = console) => [cs2(), Bc4(e9), os2(e9)];
function Bc4(e9) {
  return (t4, n4, r6) => {
    "string" == typeof t4.method && t4.method || (n4.error = Xa({ message: "The request 'method' must be a non-empty string.", data: t4 })), r6(((t5) => {
      const { error: r7 } = n4;
      return r7 ? (e9.error(`MetaMask - RPC Error: ${r7.message}`, r7), t5()) : t5();
    }));
  };
}
var Kc2 = (e9, t4, n4 = true) => (r6, i6) => {
  r6 || i6.error ? t4(r6 || i6.error) : !n4 || Array.isArray(i6) ? e9(i6) : e9(i6.result);
};
var jc4 = (e9) => Boolean(e9) && "string" == typeof e9 && e9.startsWith("0x");
var Uc4 = () => {
};
async function Hc4(e9, t4) {
  try {
    const t5 = await (async function() {
      return { name: Fc2(window), icon: await zc2(window) };
    })();
    e9.handle({ jsonrpc: "2.0", id: 1, method: "metamask_sendDomainMetadata", params: t5 }, Uc4);
  } catch (e10) {
    t4.error({ message: is2.errors.sendSiteMetadata(), originalError: e10 });
  }
}
function Fc2(e9) {
  const { document: t4 } = e9, n4 = t4.querySelector('head > meta[property="og:site_name"]');
  if (n4) return n4.content;
  const r6 = t4.querySelector('head > meta[name="title"]');
  return r6 ? r6.content : t4.title && t4.title.length > 0 ? t4.title : window.location.hostname;
}
async function zc2(e9) {
  const { document: t4 } = e9, n4 = t4.querySelectorAll('head > link[rel~="icon"]');
  for (const e10 of Array.from(n4)) if (e10 && await qc2(e10.href)) return e10.href;
  return null;
}
async function qc2(e9) {
  return new Promise(((t4, n4) => {
    try {
      const n5 = document.createElement("img");
      n5.onload = () => t4(true), n5.onerror = () => t4(false), n5.src = e9;
    } catch (e10) {
      n4(e10);
    }
  }));
}
var Wc2 = (e9, t4, n4) => {
  if (!t4.has(e9)) throw TypeError("Cannot " + n4);
};
var Vc2 = (e9, t4, n4) => (Wc2(e9, t4, "read from private field"), n4 ? n4.call(e9) : t4.get(e9));
var Gc2 = (e9, t4, n4) => {
  if (t4.has(e9)) throw TypeError("Cannot add the same private member more than once");
  t4 instanceof WeakSet ? t4.add(e9) : t4.set(e9, n4);
};
var Yc2 = (e9, t4, n4, r6) => (Wc2(e9, t4, "write to private field"), t4.set(e9, n4), n4);
function Zc2(e9, t4, n4) {
  try {
    Reflect.apply(e9, t4, n4);
  } catch (e10) {
    setTimeout((() => {
      throw e10;
    }));
  }
}
var Jc2 = class extends rc4 {
  emit(e9, ...t4) {
    let n4 = "error" === e9;
    const r6 = this._events;
    if (void 0 !== r6) n4 = n4 && void 0 === r6.error;
    else if (!n4) return false;
    if (n4) {
      let e10;
      if (t4.length > 0 && ([e10] = t4), e10 instanceof Error) throw e10;
      const n5 = new Error("Unhandled error." + (e10 ? ` (${e10.message})` : ""));
      throw n5.context = e10, n5;
    }
    const i6 = r6[e9];
    if (void 0 === i6) return false;
    if ("function" == typeof i6) Zc2(i6, this, t4);
    else {
      const e10 = i6.length, n5 = (function(e11) {
        const t5 = e11.length, n6 = new Array(t5);
        for (let r7 = 0; r7 < t5; r7 += 1) n6[r7] = e11[r7];
        return n6;
      })(i6);
      for (let r7 = 0; r7 < e10; r7 += 1) Zc2(n5[r7], this, t4);
    }
    return true;
  }
};
var Qc2;
var Xc2;
var el = function e5(t4, n4) {
  if (t4 === n4) return true;
  if (t4 && n4 && "object" == typeof t4 && "object" == typeof n4) {
    if (t4.constructor !== n4.constructor) return false;
    var r6, i6, o4;
    if (Array.isArray(t4)) {
      if ((r6 = t4.length) != n4.length) return false;
      for (i6 = r6; 0 != i6--; ) if (!e5(t4[i6], n4[i6])) return false;
      return true;
    }
    if (t4.constructor === RegExp) return t4.source === n4.source && t4.flags === n4.flags;
    if (t4.valueOf !== Object.prototype.valueOf) return t4.valueOf() === n4.valueOf();
    if (t4.toString !== Object.prototype.toString) return t4.toString() === n4.toString();
    if ((r6 = (o4 = Object.keys(t4)).length) !== Object.keys(n4).length) return false;
    for (i6 = r6; 0 != i6--; ) if (!Object.prototype.hasOwnProperty.call(n4, o4[i6])) return false;
    for (i6 = r6; 0 != i6--; ) {
      var s3 = o4[i6];
      if (!e5(t4[s3], n4[s3])) return false;
    }
    return true;
  }
  return t4 != t4 && n4 != n4;
};
var tl = ue6(el);
var nl = class e6 extends Jc2 {
  constructor({ logger: t4 = console, maxEventListeners: n4 = 100, rpcMiddleware: r6 = [] } = {}) {
    super(), Gc2(this, Qc2, void 0), Gc2(this, Xc2, void 0), this._log = t4, this.setMaxListeners(n4), this._state = { ...e6._defaultState }, Yc2(this, Xc2, null), Yc2(this, Qc2, null), this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const i6 = new Nc4();
    r6.forEach(((e9) => i6.push(e9))), this._rpcEngine = i6;
  }
  get chainId() {
    return Vc2(this, Qc2);
  }
  get selectedAddress() {
    return Vc2(this, Xc2);
  }
  isConnected() {
    return this._state.isConnected;
  }
  async request(e9) {
    if (!e9 || "object" != typeof e9 || Array.isArray(e9)) throw Xa({ message: is2.errors.invalidRequestArgs(), data: e9 });
    const { method: t4, params: n4 } = e9;
    if ("string" != typeof t4 || 0 === t4.length) throw Xa({ message: is2.errors.invalidRequestMethod(), data: e9 });
    if (void 0 !== n4 && !Array.isArray(n4) && ("object" != typeof n4 || null === n4)) throw Xa({ message: is2.errors.invalidRequestParams(), data: e9 });
    const r6 = null == n4 ? { method: t4 } : { method: t4, params: n4 };
    return new Promise(((e10, t5) => {
      this._rpcRequest(r6, Kc2(e10, t5));
    }));
  }
  _initializeState(e9) {
    if (this._state.initialized) throw new Error("Provider already initialized.");
    if (e9) {
      const { accounts: t4, chainId: n4, isUnlocked: r6, networkVersion: i6 } = e9;
      this._handleConnect(n4), this._handleChainChanged({ chainId: n4, networkVersion: i6 }), this._handleUnlockStateChanged({ accounts: t4, isUnlocked: r6 }), this._handleAccountsChanged(t4);
    }
    this._state.initialized = true, this.emit("_initialized");
  }
  _rpcRequest(e9, t4) {
    let n4 = t4;
    return Array.isArray(e9) || (e9.jsonrpc || (e9.jsonrpc = "2.0"), "eth_accounts" !== e9.method && "eth_requestAccounts" !== e9.method || (n4 = (n5, r6) => {
      this._handleAccountsChanged(r6.result ?? [], "eth_accounts" === e9.method), t4(n5, r6);
    })), this._rpcEngine.handle(e9, n4);
  }
  _handleConnect(e9) {
    this._state.isConnected || (this._state.isConnected = true, this.emit("connect", { chainId: e9 }), this._log.debug(is2.info.connected(e9)));
  }
  _handleDisconnect(e9, t4) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !e9) {
      let n4;
      this._state.isConnected = false, e9 ? (n4 = new Ja(1013, t4 ?? is2.errors.disconnected()), this._log.debug(n4)) : (n4 = new Ja(1011, t4 ?? is2.errors.permanentlyDisconnected()), this._log.error(n4), Yc2(this, Qc2, null), this._state.accounts = null, Yc2(this, Xc2, null), this._state.isUnlocked = false, this._state.isPermanentlyDisconnected = true), this.emit("disconnect", n4);
    }
  }
  _handleChainChanged({ chainId: e9 } = {}) {
    jc4(e9) ? (this._handleConnect(e9), e9 !== Vc2(this, Qc2) && (Yc2(this, Qc2, e9), this._state.initialized && this.emit("chainChanged", Vc2(this, Qc2)))) : this._log.error(is2.errors.invalidNetworkParams(), { chainId: e9 });
  }
  _handleAccountsChanged(e9, t4 = false) {
    let n4 = e9;
    Array.isArray(e9) || (this._log.error("MetaMask: Received invalid accounts parameter. Please report this bug.", e9), n4 = []);
    for (const t5 of e9) if ("string" != typeof t5) {
      this._log.error("MetaMask: Received non-string account. Please report this bug.", e9), n4 = [];
      break;
    }
    if (!tl(this._state.accounts, n4) && (t4 && null !== this._state.accounts && this._log.error("MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.", n4), this._state.accounts = n4, Vc2(this, Xc2) !== n4[0] && Yc2(this, Xc2, n4[0] || null), this._state.initialized)) {
      const e10 = [...n4];
      this.emit("accountsChanged", e10);
    }
  }
  _handleUnlockStateChanged({ accounts: e9, isUnlocked: t4 } = {}) {
    "boolean" == typeof t4 ? t4 !== this._state.isUnlocked && (this._state.isUnlocked = t4, this._handleAccountsChanged(e9 ?? [])) : this._log.error("MetaMask: Received invalid isUnlocked parameter. Please report this bug.");
  }
};
Qc2 = /* @__PURE__ */ new WeakMap(), Xc2 = /* @__PURE__ */ new WeakMap(), nl._defaultState = { accounts: null, isConnected: false, isUnlocked: false, initialized: false, isPermanentlyDisconnected: false };
var rl;
var il;
var ol = nl;
var sl = { exports: {} };
function al() {
  return il ? rl : (il = 1, rl = lc4.EventEmitter);
}
var cl;
var ll = he6(le6);
cl = "function" == typeof Object.create ? function(e9, t4) {
  e9.super_ = t4, e9.prototype = Object.create(t4.prototype, { constructor: { value: e9, enumerable: false, writable: true, configurable: true } });
} : function(e9, t4) {
  e9.super_ = t4;
  var n4 = function() {
  };
  n4.prototype = t4.prototype, e9.prototype = new n4(), e9.prototype.constructor = e9;
};
var dl = Object.getOwnPropertyDescriptors || function(e9) {
  for (var t4 = Object.keys(e9), n4 = {}, r6 = 0; r6 < t4.length; r6++) n4[t4[r6]] = Object.getOwnPropertyDescriptor(e9, t4[r6]);
  return n4;
};
var ul = /%[sdj%]/g;
function hl(e9) {
  if (!Ml(e9)) {
    for (var t4 = [], n4 = 0; n4 < arguments.length; n4++) t4.push(yl(arguments[n4]));
    return t4.join(" ");
  }
  n4 = 1;
  for (var r6 = arguments, i6 = r6.length, o4 = String(e9).replace(ul, (function(e10) {
    if ("%%" === e10) return "%";
    if (n4 >= i6) return e10;
    switch (e10) {
      case "%s":
        return String(r6[n4++]);
      case "%d":
        return Number(r6[n4++]);
      case "%j":
        try {
          return JSON.stringify(r6[n4++]);
        } catch (e11) {
          return "[Circular]";
        }
      default:
        return e10;
    }
  })), s3 = r6[n4]; n4 < i6; s3 = r6[++n4]) kl(s3) || !Pl(s3) ? o4 += " " + s3 : o4 += " " + yl(s3);
  return o4;
}
function fl(e9, t4) {
  if (Tl(l5.process)) return function() {
    return fl(e9, t4).apply(this, arguments);
  };
  if (true === ua2.noDeprecation) return e9;
  var n4 = false;
  return function() {
    if (!n4) {
      if (ua2.throwDeprecation) throw new Error(t4);
      ua2.traceDeprecation ? console.trace(t4) : console.error(t4), n4 = true;
    }
    return e9.apply(this, arguments);
  };
}
var pl;
var gl = {};
function ml(e9) {
  if (Tl(pl) && (pl = ua2.env.NODE_DEBUG || ""), e9 = e9.toUpperCase(), !gl[e9]) if (new RegExp("\\b" + e9 + "\\b", "i").test(pl)) {
    gl[e9] = function() {
      var t4 = hl.apply(null, arguments);
      console.error("%s %d: %s", e9, 0, t4);
    };
  } else gl[e9] = function() {
  };
  return gl[e9];
}
function yl(e9, t4) {
  var n4 = { seen: [], stylize: bl };
  return arguments.length >= 3 && (n4.depth = arguments[2]), arguments.length >= 4 && (n4.colors = arguments[3]), Cl(t4) ? n4.showHidden = t4 : t4 && Hl(n4, t4), Tl(n4.showHidden) && (n4.showHidden = false), Tl(n4.depth) && (n4.depth = 2), Tl(n4.colors) && (n4.colors = false), Tl(n4.customInspect) && (n4.customInspect = true), n4.colors && (n4.stylize = vl), wl(n4, e9, n4.depth);
}
function vl(e9, t4) {
  var n4 = yl.styles[t4];
  return n4 ? "\x1B[" + yl.colors[n4][0] + "m" + e9 + "\x1B[" + yl.colors[n4][1] + "m" : e9;
}
function bl(e9, t4) {
  return e9;
}
function wl(e9, t4, n4) {
  if (e9.customInspect && t4 && Ll(t4.inspect) && t4.inspect !== yl && (!t4.constructor || t4.constructor.prototype !== t4)) {
    var r6 = t4.inspect(n4, e9);
    return Ml(r6) || (r6 = wl(e9, r6, n4)), r6;
  }
  var i6 = (function(e10, t5) {
    if (Tl(t5)) return e10.stylize("undefined", "undefined");
    if (Ml(t5)) {
      var n5 = "'" + JSON.stringify(t5).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e10.stylize(n5, "string");
    }
    if (xl(t5)) return e10.stylize("" + t5, "number");
    if (Cl(t5)) return e10.stylize("" + t5, "boolean");
    if (kl(t5)) return e10.stylize("null", "null");
  })(e9, t4);
  if (i6) return i6;
  var o4 = Object.keys(t4), s3 = (function(e10) {
    var t5 = {};
    return e10.forEach((function(e11, n5) {
      t5[e11] = true;
    })), t5;
  })(o4);
  if (e9.showHidden && (o4 = Object.getOwnPropertyNames(t4)), Nl(t4) && (o4.indexOf("message") >= 0 || o4.indexOf("description") >= 0)) return El(t4);
  if (0 === o4.length) {
    if (Ll(t4)) {
      var a4 = t4.name ? ": " + t4.name : "";
      return e9.stylize("[Function" + a4 + "]", "special");
    }
    if (Rl(t4)) return e9.stylize(RegExp.prototype.toString.call(t4), "regexp");
    if (Ol(t4)) return e9.stylize(Date.prototype.toString.call(t4), "date");
    if (Nl(t4)) return El(t4);
  }
  var c6, l6 = "", d5 = false, u6 = ["{", "}"];
  (_l(t4) && (d5 = true, u6 = ["[", "]"]), Ll(t4)) && (l6 = " [Function" + (t4.name ? ": " + t4.name : "") + "]");
  return Rl(t4) && (l6 = " " + RegExp.prototype.toString.call(t4)), Ol(t4) && (l6 = " " + Date.prototype.toUTCString.call(t4)), Nl(t4) && (l6 = " " + El(t4)), 0 !== o4.length || d5 && 0 != t4.length ? n4 < 0 ? Rl(t4) ? e9.stylize(RegExp.prototype.toString.call(t4), "regexp") : e9.stylize("[Object]", "special") : (e9.seen.push(t4), c6 = d5 ? (function(e10, t5, n5, r7, i7) {
    for (var o5 = [], s4 = 0, a5 = t5.length; s4 < a5; ++s4) Fl(t5, String(s4)) ? o5.push(Sl(e10, t5, n5, r7, String(s4), true)) : o5.push("");
    return i7.forEach((function(i8) {
      i8.match(/^\d+$/) || o5.push(Sl(e10, t5, n5, r7, i8, true));
    })), o5;
  })(e9, t4, n4, s3, o4) : o4.map((function(r7) {
    return Sl(e9, t4, n4, s3, r7, d5);
  })), e9.seen.pop(), (function(e10, t5, n5) {
    var r7 = e10.reduce((function(e11, t6) {
      return t6.indexOf("\n"), e11 + t6.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }), 0);
    if (r7 > 60) return n5[0] + ("" === t5 ? "" : t5 + "\n ") + " " + e10.join(",\n  ") + " " + n5[1];
    return n5[0] + t5 + " " + e10.join(", ") + " " + n5[1];
  })(c6, l6, u6)) : u6[0] + l6 + u6[1];
}
function El(e9) {
  return "[" + Error.prototype.toString.call(e9) + "]";
}
function Sl(e9, t4, n4, r6, i6, o4) {
  var s3, a4, c6;
  if ((c6 = Object.getOwnPropertyDescriptor(t4, i6) || { value: t4[i6] }).get ? a4 = c6.set ? e9.stylize("[Getter/Setter]", "special") : e9.stylize("[Getter]", "special") : c6.set && (a4 = e9.stylize("[Setter]", "special")), Fl(r6, i6) || (s3 = "[" + i6 + "]"), a4 || (e9.seen.indexOf(c6.value) < 0 ? (a4 = kl(n4) ? wl(e9, c6.value, null) : wl(e9, c6.value, n4 - 1)).indexOf("\n") > -1 && (a4 = o4 ? a4.split("\n").map((function(e10) {
    return "  " + e10;
  })).join("\n").substr(2) : "\n" + a4.split("\n").map((function(e10) {
    return "   " + e10;
  })).join("\n")) : a4 = e9.stylize("[Circular]", "special")), Tl(s3)) {
    if (o4 && i6.match(/^\d+$/)) return a4;
    (s3 = JSON.stringify("" + i6)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s3 = s3.substr(1, s3.length - 2), s3 = e9.stylize(s3, "name")) : (s3 = s3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s3 = e9.stylize(s3, "string"));
  }
  return s3 + ": " + a4;
}
function _l(e9) {
  return Array.isArray(e9);
}
function Cl(e9) {
  return "boolean" == typeof e9;
}
function kl(e9) {
  return null === e9;
}
function Al(e9) {
  return null == e9;
}
function xl(e9) {
  return "number" == typeof e9;
}
function Ml(e9) {
  return "string" == typeof e9;
}
function Il(e9) {
  return "symbol" == typeof e9;
}
function Tl(e9) {
  return void 0 === e9;
}
function Rl(e9) {
  return Pl(e9) && "[object RegExp]" === Bl(e9);
}
function Pl(e9) {
  return "object" == typeof e9 && null !== e9;
}
function Ol(e9) {
  return Pl(e9) && "[object Date]" === Bl(e9);
}
function Nl(e9) {
  return Pl(e9) && ("[object Error]" === Bl(e9) || e9 instanceof Error);
}
function Ll(e9) {
  return "function" == typeof e9;
}
function Dl(e9) {
  return null === e9 || "boolean" == typeof e9 || "number" == typeof e9 || "string" == typeof e9 || "symbol" == typeof e9 || void 0 === e9;
}
function $l(e9) {
  return C7.isBuffer(e9);
}
function Bl(e9) {
  return Object.prototype.toString.call(e9);
}
function Kl(e9) {
  return e9 < 10 ? "0" + e9.toString(10) : e9.toString(10);
}
yl.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, yl.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
var jl = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Ul() {
  var e9, t4;
  console.log("%s - %s", (e9 = /* @__PURE__ */ new Date(), t4 = [Kl(e9.getHours()), Kl(e9.getMinutes()), Kl(e9.getSeconds())].join(":"), [e9.getDate(), jl[e9.getMonth()], t4].join(" ")), hl.apply(null, arguments));
}
function Hl(e9, t4) {
  if (!t4 || !Pl(t4)) return e9;
  for (var n4 = Object.keys(t4), r6 = n4.length; r6--; ) e9[n4[r6]] = t4[n4[r6]];
  return e9;
}
function Fl(e9, t4) {
  return Object.prototype.hasOwnProperty.call(e9, t4);
}
var zl = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function ql(e9) {
  if ("function" != typeof e9) throw new TypeError('The "original" argument must be of type Function');
  if (zl && e9[zl]) {
    var t4;
    if ("function" != typeof (t4 = e9[zl])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t4, zl, { value: t4, enumerable: false, writable: false, configurable: true }), t4;
  }
  function t4() {
    for (var t5, n4, r6 = new Promise((function(e10, r7) {
      t5 = e10, n4 = r7;
    })), i6 = [], o4 = 0; o4 < arguments.length; o4++) i6.push(arguments[o4]);
    i6.push((function(e10, r7) {
      e10 ? n4(e10) : t5(r7);
    }));
    try {
      e9.apply(this, i6);
    } catch (e10) {
      n4(e10);
    }
    return r6;
  }
  return Object.setPrototypeOf(t4, Object.getPrototypeOf(e9)), zl && Object.defineProperty(t4, zl, { value: t4, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t4, dl(e9));
}
function Wl(e9, t4) {
  if (!e9) {
    var n4 = new Error("Promise was rejected with a falsy value");
    n4.reason = e9, e9 = n4;
  }
  return t4(e9);
}
function Vl(e9) {
  if ("function" != typeof e9) throw new TypeError('The "original" argument must be of type Function');
  function t4() {
    for (var t5 = [], n4 = 0; n4 < arguments.length; n4++) t5.push(arguments[n4]);
    var r6 = t5.pop();
    if ("function" != typeof r6) throw new TypeError("The last argument must be of type Function");
    var i6 = this, o4 = function() {
      return r6.apply(i6, arguments);
    };
    e9.apply(this, t5).then((function(e10) {
      ua2.nextTick(o4.bind(null, null, e10));
    }), (function(e10) {
      ua2.nextTick(Wl.bind(null, e10, o4));
    }));
  }
  return Object.setPrototypeOf(t4, Object.getPrototypeOf(e9)), Object.defineProperties(t4, dl(e9)), t4;
}
ql.custom = zl;
var Gl;
var Yl;
var Zl;
var Jl;
var Ql = { inherits: cl, _extend: Hl, log: Ul, isBuffer: $l, isPrimitive: Dl, isFunction: Ll, isError: Nl, isDate: Ol, isObject: Pl, isRegExp: Rl, isUndefined: Tl, isSymbol: Il, isString: Ml, isNumber: xl, isNullOrUndefined: Al, isNull: kl, isBoolean: Cl, isArray: _l, inspect: yl, deprecate: fl, format: hl, debuglog: ml, promisify: ql, callbackify: Vl };
var Xl = he6(Object.freeze({ __proto__: null, _extend: Hl, callbackify: Vl, debuglog: ml, default: Ql, deprecate: fl, format: hl, inherits: cl, inspect: yl, isArray: _l, isBoolean: Cl, isBuffer: $l, isDate: Ol, isError: Nl, isFunction: Ll, isNull: kl, isNullOrUndefined: Al, isNumber: xl, isObject: Pl, isPrimitive: Dl, isRegExp: Rl, isString: Ml, isSymbol: Il, isUndefined: Tl, log: Ul, promisify: ql }));
function ed() {
  if (Yl) return Gl;
  function e9(e10, t5) {
    var n5 = Object.keys(e10);
    if (Object.getOwnPropertySymbols) {
      var r7 = Object.getOwnPropertySymbols(e10);
      t5 && (r7 = r7.filter((function(t6) {
        return Object.getOwnPropertyDescriptor(e10, t6).enumerable;
      }))), n5.push.apply(n5, r7);
    }
    return n5;
  }
  function t4(t5) {
    for (var r7 = 1; r7 < arguments.length; r7++) {
      var i7 = null != arguments[r7] ? arguments[r7] : {};
      r7 % 2 ? e9(Object(i7), true).forEach((function(e10) {
        n4(t5, e10, i7[e10]);
      })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(i7)) : e9(Object(i7)).forEach((function(e10) {
        Object.defineProperty(t5, e10, Object.getOwnPropertyDescriptor(i7, e10));
      }));
    }
    return t5;
  }
  function n4(e10, t5, n5) {
    return (t5 = i6(t5)) in e10 ? Object.defineProperty(e10, t5, { value: n5, enumerable: true, configurable: true, writable: true }) : e10[t5] = n5, e10;
  }
  function r6(e10, t5, n5) {
    return t5 && (function(e11, t6) {
      for (var n6 = 0; n6 < t6.length; n6++) {
        var r7 = t6[n6];
        r7.enumerable = r7.enumerable || false, r7.configurable = true, "value" in r7 && (r7.writable = true), Object.defineProperty(e11, i6(r7.key), r7);
      }
    })(e10.prototype, t5), Object.defineProperty(e10, "prototype", { writable: false }), e10;
  }
  function i6(e10) {
    var t5 = (function(e11, t6) {
      if ("object" != typeof e11 || null === e11) return e11;
      var n5 = e11[Symbol.toPrimitive];
      if (void 0 !== n5) {
        var r7 = n5.call(e11, t6 || "default");
        if ("object" != typeof r7) return r7;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t6 ? String : Number)(e11);
    })(e10, "string");
    return "symbol" == typeof t5 ? t5 : String(t5);
  }
  Yl = 1;
  var o4 = ll.Buffer, s3 = Xl.inspect, a4 = s3 && s3.custom || "inspect";
  return Gl = (function() {
    function e10() {
      !(function(e11, t5) {
        if (!(e11 instanceof t5)) throw new TypeError("Cannot call a class as a function");
      })(this, e10), this.head = null, this.tail = null, this.length = 0;
    }
    return r6(e10, [{ key: "push", value: function(e11) {
      var t5 = { data: e11, next: null };
      this.length > 0 ? this.tail.next = t5 : this.head = t5, this.tail = t5, ++this.length;
    } }, { key: "unshift", value: function(e11) {
      var t5 = { data: e11, next: this.head };
      0 === this.length && (this.tail = t5), this.head = t5, ++this.length;
    } }, { key: "shift", value: function() {
      if (0 !== this.length) {
        var e11 = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e11;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(e11) {
      if (0 === this.length) return "";
      for (var t5 = this.head, n5 = "" + t5.data; t5 = t5.next; ) n5 += e11 + t5.data;
      return n5;
    } }, { key: "concat", value: function(e11) {
      if (0 === this.length) return o4.alloc(0);
      for (var t5, n5, r7, i7 = o4.allocUnsafe(e11 >>> 0), s4 = this.head, a5 = 0; s4; ) t5 = s4.data, n5 = i7, r7 = a5, o4.prototype.copy.call(t5, n5, r7), a5 += s4.data.length, s4 = s4.next;
      return i7;
    } }, { key: "consume", value: function(e11, t5) {
      var n5;
      return e11 < this.head.data.length ? (n5 = this.head.data.slice(0, e11), this.head.data = this.head.data.slice(e11)) : n5 = e11 === this.head.data.length ? this.shift() : t5 ? this._getString(e11) : this._getBuffer(e11), n5;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(e11) {
      var t5 = this.head, n5 = 1, r7 = t5.data;
      for (e11 -= r7.length; t5 = t5.next; ) {
        var i7 = t5.data, o5 = e11 > i7.length ? i7.length : e11;
        if (o5 === i7.length ? r7 += i7 : r7 += i7.slice(0, e11), 0 === (e11 -= o5)) {
          o5 === i7.length ? (++n5, t5.next ? this.head = t5.next : this.head = this.tail = null) : (this.head = t5, t5.data = i7.slice(o5));
          break;
        }
        ++n5;
      }
      return this.length -= n5, r7;
    } }, { key: "_getBuffer", value: function(e11) {
      var t5 = o4.allocUnsafe(e11), n5 = this.head, r7 = 1;
      for (n5.data.copy(t5), e11 -= n5.data.length; n5 = n5.next; ) {
        var i7 = n5.data, s4 = e11 > i7.length ? i7.length : e11;
        if (i7.copy(t5, t5.length - e11, 0, s4), 0 === (e11 -= s4)) {
          s4 === i7.length ? (++r7, n5.next ? this.head = n5.next : this.head = this.tail = null) : (this.head = n5, n5.data = i7.slice(s4));
          break;
        }
        ++r7;
      }
      return this.length -= r7, t5;
    } }, { key: a4, value: function(e11, n5) {
      return s3(this, t4(t4({}, n5), {}, { depth: 0, customInspect: false }));
    } }]), e10;
  })(), Gl;
}
function td() {
  if (Jl) return Zl;
  function e9(e10, r6) {
    n4(e10, r6), t4(e10);
  }
  function t4(e10) {
    e10._writableState && !e10._writableState.emitClose || e10._readableState && !e10._readableState.emitClose || e10.emit("close");
  }
  function n4(e10, t5) {
    e10.emit("error", t5);
  }
  return Jl = 1, Zl = { destroy: function(r6, i6) {
    var o4 = this, s3 = this._readableState && this._readableState.destroyed, a4 = this._writableState && this._writableState.destroyed;
    return s3 || a4 ? (i6 ? i6(r6) : r6 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, ua2.nextTick(n4, this, r6)) : ua2.nextTick(n4, this, r6)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(r6 || null, (function(n5) {
      !i6 && n5 ? o4._writableState ? o4._writableState.errorEmitted ? ua2.nextTick(t4, o4) : (o4._writableState.errorEmitted = true, ua2.nextTick(e9, o4, n5)) : ua2.nextTick(e9, o4, n5) : i6 ? (ua2.nextTick(t4, o4), i6(n5)) : ua2.nextTick(t4, o4);
    })), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }, errorOrDestroy: function(e10, t5) {
    var n5 = e10._readableState, r6 = e10._writableState;
    n5 && n5.autoDestroy || r6 && r6.autoDestroy ? e10.destroy(t5) : e10.emit("error", t5);
  } }, Zl;
}
var nd = {};
var rd;
var id;
var od = {};
function sd(e9, t4, n4) {
  n4 || (n4 = Error);
  var r6 = (function(e10) {
    var n5, r7;
    function i6(n6, r8, i7) {
      return e10.call(this, (function(e11, n7, r9) {
        return "string" == typeof t4 ? t4 : t4(e11, n7, r9);
      })(n6, r8, i7)) || this;
    }
    return r7 = e10, (n5 = i6).prototype = Object.create(r7.prototype), n5.prototype.constructor = n5, n5.__proto__ = r7, i6;
  })(n4);
  r6.prototype.name = n4.name, r6.prototype.code = e9, od[e9] = r6;
}
function ad(e9, t4) {
  if (Array.isArray(e9)) {
    var n4 = e9.length;
    return e9 = e9.map((function(e10) {
      return String(e10);
    })), n4 > 2 ? "one of ".concat(t4, " ").concat(e9.slice(0, n4 - 1).join(", "), ", or ") + e9[n4 - 1] : 2 === n4 ? "one of ".concat(t4, " ").concat(e9[0], " or ").concat(e9[1]) : "of ".concat(t4, " ").concat(e9[0]);
  }
  return "of ".concat(t4, " ").concat(String(e9));
}
function cd() {
  if (id) return rd;
  id = 1;
  var e9 = nd.codes.ERR_INVALID_OPT_VALUE;
  return rd = { getHighWaterMark: function(t4, n4, r6, i6) {
    var o4 = (function(e10, t5, n5) {
      return null != e10.highWaterMark ? e10.highWaterMark : t5 ? e10[n5] : null;
    })(n4, i6, r6);
    if (null != o4) {
      if (!isFinite(o4) || Math.floor(o4) !== o4 || o4 < 0) throw new e9(i6 ? r6 : "highWaterMark", o4);
      return Math.floor(o4);
    }
    return t4.objectMode ? 16 : 16384;
  } };
}
sd("ERR_INVALID_OPT_VALUE", (function(e9, t4) {
  return 'The value "' + t4 + '" is invalid for option "' + e9 + '"';
}), TypeError), sd("ERR_INVALID_ARG_TYPE", (function(e9, t4, n4) {
  var r6, i6, o4;
  if ("string" == typeof t4 && (i6 = "not ", t4.substr(0, i6.length) === i6) ? (r6 = "must not be", t4 = t4.replace(/^not /, "")) : r6 = "must be", (function(e10, t5, n5) {
    return (void 0 === n5 || n5 > e10.length) && (n5 = e10.length), e10.substring(n5 - t5.length, n5) === t5;
  })(e9, " argument")) o4 = "The ".concat(e9, " ").concat(r6, " ").concat(ad(t4, "type"));
  else {
    var s3 = (function(e10, t5, n5) {
      return "number" != typeof n5 && (n5 = 0), !(n5 + t5.length > e10.length) && -1 !== e10.indexOf(t5, n5);
    })(e9, ".") ? "property" : "argument";
    o4 = 'The "'.concat(e9, '" ').concat(s3, " ").concat(r6, " ").concat(ad(t4, "type"));
  }
  return o4 += ". Received type ".concat(typeof n4);
}), TypeError), sd("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), sd("ERR_METHOD_NOT_IMPLEMENTED", (function(e9) {
  return "The " + e9 + " method is not implemented";
})), sd("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), sd("ERR_STREAM_DESTROYED", (function(e9) {
  return "Cannot call " + e9 + " after a stream was destroyed";
})), sd("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), sd("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), sd("ERR_STREAM_WRITE_AFTER_END", "write after end"), sd("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), sd("ERR_UNKNOWN_ENCODING", (function(e9) {
  return "Unknown encoding: " + e9;
}), TypeError), sd("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), nd.codes = od;
var ld;
var dd;
var ud;
var hd;
var fd;
var pd;
var gd = "function" == typeof Object.create ? function(e9, t4) {
  e9.super_ = t4, e9.prototype = Object.create(t4.prototype, { constructor: { value: e9, enumerable: false, writable: true, configurable: true } });
} : function(e9, t4) {
  e9.super_ = t4;
  var n4 = function() {
  };
  n4.prototype = t4.prototype, e9.prototype = new n4(), e9.prototype.constructor = e9;
};
var md = he6(Object.freeze({ __proto__: null, default: gd }));
function yd() {
  if (dd) return ld;
  function e9(e10) {
    try {
      if (!de6.localStorage) return false;
    } catch (e11) {
      return false;
    }
    var t4 = de6.localStorage[e10];
    return null != t4 && "true" === String(t4).toLowerCase();
  }
  return dd = 1, ld = function(t4, n4) {
    if (e9("noDeprecation")) return t4;
    var r6 = false;
    return function() {
      if (!r6) {
        if (e9("throwDeprecation")) throw new Error(n4);
        e9("traceDeprecation") ? console.trace(n4) : console.warn(n4), r6 = true;
      }
      return t4.apply(this, arguments);
    };
  }, ld;
}
function vd() {
  if (hd) return ud;
  function e9(e10) {
    var t5 = this;
    this.next = null, this.entry = null, this.finish = function() {
      !(function(e11, t6, n5) {
        var r7 = e11.entry;
        e11.entry = null;
        for (; r7; ) {
          var i7 = r7.callback;
          t6.pendingcb--, i7(n5), r7 = r7.next;
        }
        t6.corkedRequestsFree.next = e11;
      })(t5, e10);
    };
  }
  var t4;
  hd = 1, ud = E7, E7.WritableState = w6;
  var n4 = { deprecate: yd() }, r6 = al(), i6 = ll.Buffer, o4 = (void 0 !== de6 ? de6 : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var s3, a4 = td(), c6 = cd().getHighWaterMark, l6 = nd.codes, d5 = l6.ERR_INVALID_ARG_TYPE, u6 = l6.ERR_METHOD_NOT_IMPLEMENTED, h7 = l6.ERR_MULTIPLE_CALLBACK, f12 = l6.ERR_STREAM_CANNOT_PIPE, p7 = l6.ERR_STREAM_DESTROYED, g3 = l6.ERR_STREAM_NULL_VALUES, m5 = l6.ERR_STREAM_WRITE_AFTER_END, y8 = l6.ERR_UNKNOWN_ENCODING, v7 = a4.errorOrDestroy;
  function b5() {
  }
  function w6(n5, r7, i7) {
    t4 = t4 || bd(), n5 = n5 || {}, "boolean" != typeof i7 && (i7 = r7 instanceof t4), this.objectMode = !!n5.objectMode, i7 && (this.objectMode = this.objectMode || !!n5.writableObjectMode), this.highWaterMark = c6(this, n5, "writableHighWaterMark", i7), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var o5 = false === n5.decodeStrings;
    this.decodeStrings = !o5, this.defaultEncoding = n5.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e10) {
      !(function(e11, t5) {
        var n6 = e11._writableState, r8 = n6.sync, i8 = n6.writecb;
        if ("function" != typeof i8) throw new h7();
        if ((function(e12) {
          e12.writing = false, e12.writecb = null, e12.length -= e12.writelen, e12.writelen = 0;
        })(n6), t5) !(function(e12, t6, n7, r9, i9) {
          --t6.pendingcb, n7 ? (ua2.nextTick(i9, r9), ua2.nextTick(x5, e12, t6), e12._writableState.errorEmitted = true, v7(e12, r9)) : (i9(r9), e12._writableState.errorEmitted = true, v7(e12, r9), x5(e12, t6));
        })(e11, n6, r8, t5, i8);
        else {
          var o6 = k8(n6) || e11.destroyed;
          o6 || n6.corked || n6.bufferProcessing || !n6.bufferedRequest || C8(e11, n6), r8 ? ua2.nextTick(_4, e11, n6, o6, i8) : _4(e11, n6, o6, i8);
        }
      })(r7, e10);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== n5.emitClose, this.autoDestroy = !!n5.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e9(this);
  }
  function E7(e10) {
    var n5 = this instanceof (t4 = t4 || bd());
    if (!n5 && !s3.call(E7, this)) return new E7(e10);
    this._writableState = new w6(e10, this, n5), this.writable = true, e10 && ("function" == typeof e10.write && (this._write = e10.write), "function" == typeof e10.writev && (this._writev = e10.writev), "function" == typeof e10.destroy && (this._destroy = e10.destroy), "function" == typeof e10.final && (this._final = e10.final)), r6.call(this);
  }
  function S7(e10, t5, n5, r7, i7, o5, s4) {
    t5.writelen = r7, t5.writecb = s4, t5.writing = true, t5.sync = true, t5.destroyed ? t5.onwrite(new p7("write")) : n5 ? e10._writev(i7, t5.onwrite) : e10._write(i7, o5, t5.onwrite), t5.sync = false;
  }
  function _4(e10, t5, n5, r7) {
    n5 || (function(e11, t6) {
      0 === t6.length && t6.needDrain && (t6.needDrain = false, e11.emit("drain"));
    })(e10, t5), t5.pendingcb--, r7(), x5(e10, t5);
  }
  function C8(t5, n5) {
    n5.bufferProcessing = true;
    var r7 = n5.bufferedRequest;
    if (t5._writev && r7 && r7.next) {
      var i7 = n5.bufferedRequestCount, o5 = new Array(i7), s4 = n5.corkedRequestsFree;
      s4.entry = r7;
      for (var a5 = 0, c7 = true; r7; ) o5[a5] = r7, r7.isBuf || (c7 = false), r7 = r7.next, a5 += 1;
      o5.allBuffers = c7, S7(t5, n5, true, n5.length, o5, "", s4.finish), n5.pendingcb++, n5.lastBufferedRequest = null, s4.next ? (n5.corkedRequestsFree = s4.next, s4.next = null) : n5.corkedRequestsFree = new e9(n5), n5.bufferedRequestCount = 0;
    } else {
      for (; r7; ) {
        var l7 = r7.chunk, d6 = r7.encoding, u7 = r7.callback;
        if (S7(t5, n5, false, n5.objectMode ? 1 : l7.length, l7, d6, u7), r7 = r7.next, n5.bufferedRequestCount--, n5.writing) break;
      }
      null === r7 && (n5.lastBufferedRequest = null);
    }
    n5.bufferedRequest = r7, n5.bufferProcessing = false;
  }
  function k8(e10) {
    return e10.ending && 0 === e10.length && null === e10.bufferedRequest && !e10.finished && !e10.writing;
  }
  function A8(e10, t5) {
    e10._final((function(n5) {
      t5.pendingcb--, n5 && v7(e10, n5), t5.prefinished = true, e10.emit("prefinish"), x5(e10, t5);
    }));
  }
  function x5(e10, t5) {
    var n5 = k8(t5);
    if (n5 && ((function(e11, t6) {
      t6.prefinished || t6.finalCalled || ("function" != typeof e11._final || t6.destroyed ? (t6.prefinished = true, e11.emit("prefinish")) : (t6.pendingcb++, t6.finalCalled = true, ua2.nextTick(A8, e11, t6)));
    })(e10, t5), 0 === t5.pendingcb && (t5.finished = true, e10.emit("finish"), t5.autoDestroy))) {
      var r7 = e10._readableState;
      (!r7 || r7.autoDestroy && r7.endEmitted) && e10.destroy();
    }
    return n5;
  }
  return md(E7, r6), w6.prototype.getBuffer = function() {
    for (var e10 = this.bufferedRequest, t5 = []; e10; ) t5.push(e10), e10 = e10.next;
    return t5;
  }, (function() {
    try {
      Object.defineProperty(w6.prototype, "buffer", { get: n4.deprecate((function() {
        return this.getBuffer();
      }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch (e10) {
    }
  })(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (s3 = Function.prototype[Symbol.hasInstance], Object.defineProperty(E7, Symbol.hasInstance, { value: function(e10) {
    return !!s3.call(this, e10) || this === E7 && (e10 && e10._writableState instanceof w6);
  } })) : s3 = function(e10) {
    return e10 instanceof this;
  }, E7.prototype.pipe = function() {
    v7(this, new f12());
  }, E7.prototype.write = function(e10, t5, n5) {
    var r7, s4 = this._writableState, a5 = false, c7 = !s4.objectMode && (r7 = e10, i6.isBuffer(r7) || r7 instanceof o4);
    return c7 && !i6.isBuffer(e10) && (e10 = (function(e11) {
      return i6.from(e11);
    })(e10)), "function" == typeof t5 && (n5 = t5, t5 = null), c7 ? t5 = "buffer" : t5 || (t5 = s4.defaultEncoding), "function" != typeof n5 && (n5 = b5), s4.ending ? (function(e11, t6) {
      var n6 = new m5();
      v7(e11, n6), ua2.nextTick(t6, n6);
    })(this, n5) : (c7 || (function(e11, t6, n6, r8) {
      var i7;
      return null === n6 ? i7 = new g3() : "string" == typeof n6 || t6.objectMode || (i7 = new d5("chunk", ["string", "Buffer"], n6)), !i7 || (v7(e11, i7), ua2.nextTick(r8, i7), false);
    })(this, s4, e10, n5)) && (s4.pendingcb++, a5 = (function(e11, t6, n6, r8, o5, s5) {
      if (!n6) {
        var a6 = (function(e12, t7, n7) {
          e12.objectMode || false === e12.decodeStrings || "string" != typeof t7 || (t7 = i6.from(t7, n7));
          return t7;
        })(t6, r8, o5);
        r8 !== a6 && (n6 = true, o5 = "buffer", r8 = a6);
      }
      var c8 = t6.objectMode ? 1 : r8.length;
      t6.length += c8;
      var l7 = t6.length < t6.highWaterMark;
      l7 || (t6.needDrain = true);
      if (t6.writing || t6.corked) {
        var d6 = t6.lastBufferedRequest;
        t6.lastBufferedRequest = { chunk: r8, encoding: o5, isBuf: n6, callback: s5, next: null }, d6 ? d6.next = t6.lastBufferedRequest : t6.bufferedRequest = t6.lastBufferedRequest, t6.bufferedRequestCount += 1;
      } else S7(e11, t6, false, c8, r8, o5, s5);
      return l7;
    })(this, s4, c7, e10, t5, n5)), a5;
  }, E7.prototype.cork = function() {
    this._writableState.corked++;
  }, E7.prototype.uncork = function() {
    var e10 = this._writableState;
    e10.corked && (e10.corked--, e10.writing || e10.corked || e10.bufferProcessing || !e10.bufferedRequest || C8(this, e10));
  }, E7.prototype.setDefaultEncoding = function(e10) {
    if ("string" == typeof e10 && (e10 = e10.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e10 + "").toLowerCase()) > -1)) throw new y8(e10);
    return this._writableState.defaultEncoding = e10, this;
  }, Object.defineProperty(E7.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(E7.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), E7.prototype._write = function(e10, t5, n5) {
    n5(new u6("_write()"));
  }, E7.prototype._writev = null, E7.prototype.end = function(e10, t5, n5) {
    var r7 = this._writableState;
    return "function" == typeof e10 ? (n5 = e10, e10 = null, t5 = null) : "function" == typeof t5 && (n5 = t5, t5 = null), null != e10 && this.write(e10, t5), r7.corked && (r7.corked = 1, this.uncork()), r7.ending || (function(e11, t6, n6) {
      t6.ending = true, x5(e11, t6), n6 && (t6.finished ? ua2.nextTick(n6) : e11.once("finish", n6));
      t6.ended = true, e11.writable = false;
    })(this, r7, n5), this;
  }, Object.defineProperty(E7.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(E7.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._writableState && this._writableState.destroyed;
  }, set: function(e10) {
    this._writableState && (this._writableState.destroyed = e10);
  } }), E7.prototype.destroy = a4.destroy, E7.prototype._undestroy = a4.undestroy, E7.prototype._destroy = function(e10, t5) {
    t5(e10);
  }, ud;
}
function bd() {
  if (pd) return fd;
  pd = 1;
  var e9 = Object.keys || function(e10) {
    var t5 = [];
    for (var n5 in e10) t5.push(n5);
    return t5;
  };
  fd = s3;
  var t4 = Dd(), n4 = vd();
  md(s3, t4);
  for (var r6 = e9(n4.prototype), i6 = 0; i6 < r6.length; i6++) {
    var o4 = r6[i6];
    s3.prototype[o4] || (s3.prototype[o4] = n4.prototype[o4]);
  }
  function s3(e10) {
    if (!(this instanceof s3)) return new s3(e10);
    t4.call(this, e10), n4.call(this, e10), this.allowHalfOpen = true, e10 && (false === e10.readable && (this.readable = false), false === e10.writable && (this.writable = false), false === e10.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a4)));
  }
  function a4() {
    this._writableState.ended || ua2.nextTick(c6, this);
  }
  function c6(e10) {
    e10.end();
  }
  return Object.defineProperty(s3.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(s3.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(s3.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(s3.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
  }, set: function(e10) {
    void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e10, this._writableState.destroyed = e10);
  } }), fd;
}
var wd = C7.isEncoding || function(e9) {
  switch (e9 && e9.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function Ed(e9) {
  switch (this.encoding = (e9 || "utf8").toLowerCase().replace(/[-_]/, ""), (function(e10) {
    if (e10 && !wd(e10)) throw new Error("Unknown encoding: " + e10);
  })(e9), this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2, this.detectIncompleteChar = _d;
      break;
    case "base64":
      this.surrogateSize = 3, this.detectIncompleteChar = Cd;
      break;
    default:
      return void (this.write = Sd);
  }
  this.charBuffer = new C7(6), this.charReceived = 0, this.charLength = 0;
}
function Sd(e9) {
  return e9.toString(this.encoding);
}
function _d(e9) {
  this.charReceived = e9.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function Cd(e9) {
  this.charReceived = e9.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
Ed.prototype.write = function(e9) {
  for (var t4 = ""; this.charLength; ) {
    var n4 = e9.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : e9.length;
    if (e9.copy(this.charBuffer, this.charReceived, 0, n4), this.charReceived += n4, this.charReceived < this.charLength) return "";
    if (e9 = e9.slice(n4, e9.length), !((i6 = (t4 = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(t4.length - 1)) >= 55296 && i6 <= 56319)) {
      if (this.charReceived = this.charLength = 0, 0 === e9.length) return t4;
      break;
    }
    this.charLength += this.surrogateSize, t4 = "";
  }
  this.detectIncompleteChar(e9);
  var r6 = e9.length;
  this.charLength && (e9.copy(this.charBuffer, 0, e9.length - this.charReceived, r6), r6 -= this.charReceived);
  var i6;
  r6 = (t4 += e9.toString(this.encoding, 0, r6)).length - 1;
  if ((i6 = t4.charCodeAt(r6)) >= 55296 && i6 <= 56319) {
    var o4 = this.surrogateSize;
    return this.charLength += o4, this.charReceived += o4, this.charBuffer.copy(this.charBuffer, o4, 0, o4), e9.copy(this.charBuffer, 0, 0, o4), t4.substring(0, r6);
  }
  return t4;
}, Ed.prototype.detectIncompleteChar = function(e9) {
  for (var t4 = e9.length >= 3 ? 3 : e9.length; t4 > 0; t4--) {
    var n4 = e9[e9.length - t4];
    if (1 == t4 && n4 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (t4 <= 2 && n4 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (t4 <= 3 && n4 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = t4;
}, Ed.prototype.end = function(e9) {
  var t4 = "";
  if (e9 && e9.length && (t4 = this.write(e9)), this.charReceived) {
    var n4 = this.charReceived, r6 = this.charBuffer, i6 = this.encoding;
    t4 += r6.slice(0, n4).toString(i6);
  }
  return t4;
};
var kd = he6(Object.freeze({ __proto__: null, StringDecoder: Ed }));
var Ad = nd.codes.ERR_STREAM_PREMATURE_CLOSE;
function xd() {
}
var Md;
var Id;
var Td;
var Rd;
var Pd;
var Od;
var Nd = function e7(t4, n4, r6) {
  if ("function" == typeof n4) return e7(t4, null, n4);
  n4 || (n4 = {}), r6 = /* @__PURE__ */ (function(e9) {
    var t5 = false;
    return function() {
      if (!t5) {
        t5 = true;
        for (var n5 = arguments.length, r7 = new Array(n5), i7 = 0; i7 < n5; i7++) r7[i7] = arguments[i7];
        e9.apply(this, r7);
      }
    };
  })(r6 || xd);
  var i6 = n4.readable || false !== n4.readable && t4.readable, o4 = n4.writable || false !== n4.writable && t4.writable, s3 = function() {
    t4.writable || c6();
  }, a4 = t4._writableState && t4._writableState.finished, c6 = function() {
    o4 = false, a4 = true, i6 || r6.call(t4);
  }, l6 = t4._readableState && t4._readableState.endEmitted, d5 = function() {
    i6 = false, l6 = true, o4 || r6.call(t4);
  }, u6 = function(e9) {
    r6.call(t4, e9);
  }, h7 = function() {
    var e9;
    return i6 && !l6 ? (t4._readableState && t4._readableState.ended || (e9 = new Ad()), r6.call(t4, e9)) : o4 && !a4 ? (t4._writableState && t4._writableState.ended || (e9 = new Ad()), r6.call(t4, e9)) : void 0;
  }, f12 = function() {
    t4.req.on("finish", c6);
  };
  return !(function(e9) {
    return e9.setHeader && "function" == typeof e9.abort;
  })(t4) ? o4 && !t4._writableState && (t4.on("end", s3), t4.on("close", s3)) : (t4.on("complete", c6), t4.on("abort", h7), t4.req ? f12() : t4.on("request", f12)), t4.on("end", d5), t4.on("finish", c6), false !== n4.error && t4.on("error", u6), t4.on("close", h7), function() {
    t4.removeListener("complete", c6), t4.removeListener("abort", h7), t4.removeListener("request", f12), t4.req && t4.req.removeListener("finish", c6), t4.removeListener("end", s3), t4.removeListener("close", s3), t4.removeListener("finish", c6), t4.removeListener("end", d5), t4.removeListener("error", u6), t4.removeListener("close", h7);
  };
};
function Ld() {
  if (Id) return Md;
  var e9;
  function t4(e10, t5, n5) {
    return (t5 = (function(e11) {
      var t6 = (function(e12, t7) {
        if ("object" != typeof e12 || null === e12) return e12;
        var n6 = e12[Symbol.toPrimitive];
        if (void 0 !== n6) {
          var r7 = n6.call(e12, t7 || "default");
          if ("object" != typeof r7) return r7;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t7 ? String : Number)(e12);
      })(e11, "string");
      return "symbol" == typeof t6 ? t6 : String(t6);
    })(t5)) in e10 ? Object.defineProperty(e10, t5, { value: n5, enumerable: true, configurable: true, writable: true }) : e10[t5] = n5, e10;
  }
  Id = 1;
  var n4 = Nd, r6 = Symbol("lastResolve"), i6 = Symbol("lastReject"), o4 = Symbol("error"), s3 = Symbol("ended"), a4 = Symbol("lastPromise"), c6 = Symbol("handlePromise"), l6 = Symbol("stream");
  function d5(e10, t5) {
    return { value: e10, done: t5 };
  }
  function u6(e10) {
    var t5 = e10[r6];
    if (null !== t5) {
      var n5 = e10[l6].read();
      null !== n5 && (e10[a4] = null, e10[r6] = null, e10[i6] = null, t5(d5(n5, false)));
    }
  }
  function h7(e10) {
    ua2.nextTick(u6, e10);
  }
  var f12 = Object.getPrototypeOf((function() {
  })), p7 = Object.setPrototypeOf((t4(e9 = { get stream() {
    return this[l6];
  }, next: function() {
    var e10 = this, t5 = this[o4];
    if (null !== t5) return Promise.reject(t5);
    if (this[s3]) return Promise.resolve(d5(void 0, true));
    if (this[l6].destroyed) return new Promise((function(t6, n6) {
      ua2.nextTick((function() {
        e10[o4] ? n6(e10[o4]) : t6(d5(void 0, true));
      }));
    }));
    var n5, r7 = this[a4];
    if (r7) n5 = new Promise(/* @__PURE__ */ (function(e11, t6) {
      return function(n6, r8) {
        e11.then((function() {
          t6[s3] ? n6(d5(void 0, true)) : t6[c6](n6, r8);
        }), r8);
      };
    })(r7, this));
    else {
      var i7 = this[l6].read();
      if (null !== i7) return Promise.resolve(d5(i7, false));
      n5 = new Promise(this[c6]);
    }
    return this[a4] = n5, n5;
  } }, Symbol.asyncIterator, (function() {
    return this;
  })), t4(e9, "return", (function() {
    var e10 = this;
    return new Promise((function(t5, n5) {
      e10[l6].destroy(null, (function(e11) {
        e11 ? n5(e11) : t5(d5(void 0, true));
      }));
    }));
  })), e9), f12);
  return Md = function(e10) {
    var u7, f13 = Object.create(p7, (t4(u7 = {}, l6, { value: e10, writable: true }), t4(u7, r6, { value: null, writable: true }), t4(u7, i6, { value: null, writable: true }), t4(u7, o4, { value: null, writable: true }), t4(u7, s3, { value: e10._readableState.endEmitted, writable: true }), t4(u7, c6, { value: function(e11, t5) {
      var n5 = f13[l6].read();
      n5 ? (f13[a4] = null, f13[r6] = null, f13[i6] = null, e11(d5(n5, false))) : (f13[r6] = e11, f13[i6] = t5);
    }, writable: true }), u7));
    return f13[a4] = null, n4(e10, (function(e11) {
      if (e11 && "ERR_STREAM_PREMATURE_CLOSE" !== e11.code) {
        var t5 = f13[i6];
        return null !== t5 && (f13[a4] = null, f13[r6] = null, f13[i6] = null, t5(e11)), void (f13[o4] = e11);
      }
      var n5 = f13[r6];
      null !== n5 && (f13[a4] = null, f13[r6] = null, f13[i6] = null, n5(d5(void 0, true))), f13[s3] = true;
    })), e10.on("readable", h7.bind(null, f13)), f13;
  }, Md;
}
function Dd() {
  if (Od) return Pd;
  var e9;
  Od = 1, Pd = E7, E7.ReadableState = w6, lc4.EventEmitter;
  var t4 = function(e10, t5) {
    return e10.listeners(t5).length;
  }, n4 = al(), r6 = ll.Buffer, i6 = (void 0 !== de6 ? de6 : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var o4, s3 = Xl;
  o4 = s3 && s3.debuglog ? s3.debuglog("stream") : function() {
  };
  var a4, c6, l6, d5 = ed(), u6 = td(), h7 = cd().getHighWaterMark, f12 = nd.codes, p7 = f12.ERR_INVALID_ARG_TYPE, g3 = f12.ERR_STREAM_PUSH_AFTER_EOF, m5 = f12.ERR_METHOD_NOT_IMPLEMENTED, y8 = f12.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  md(E7, n4);
  var v7 = u6.errorOrDestroy, b5 = ["error", "close", "destroy", "pause", "resume"];
  function w6(t5, n5, r7) {
    e9 = e9 || bd(), t5 = t5 || {}, "boolean" != typeof r7 && (r7 = n5 instanceof e9), this.objectMode = !!t5.objectMode, r7 && (this.objectMode = this.objectMode || !!t5.readableObjectMode), this.highWaterMark = h7(this, t5, "readableHighWaterMark", r7), this.buffer = new d5(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t5.emitClose, this.autoDestroy = !!t5.autoDestroy, this.destroyed = false, this.defaultEncoding = t5.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t5.encoding && (a4 || (a4 = kd.StringDecoder), this.decoder = new a4(t5.encoding), this.encoding = t5.encoding);
  }
  function E7(t5) {
    if (e9 = e9 || bd(), !(this instanceof E7)) return new E7(t5);
    var r7 = this instanceof e9;
    this._readableState = new w6(t5, this, r7), this.readable = true, t5 && ("function" == typeof t5.read && (this._read = t5.read), "function" == typeof t5.destroy && (this._destroy = t5.destroy)), n4.call(this);
  }
  function S7(e10, t5, n5, s4, a5) {
    o4("readableAddChunk", t5);
    var c7, l7 = e10._readableState;
    if (null === t5) l7.reading = false, (function(e11, t6) {
      if (o4("onEofChunk"), t6.ended) return;
      if (t6.decoder) {
        var n6 = t6.decoder.end();
        n6 && n6.length && (t6.buffer.push(n6), t6.length += t6.objectMode ? 1 : n6.length);
      }
      t6.ended = true, t6.sync ? A8(e11) : (t6.needReadable = false, t6.emittedReadable || (t6.emittedReadable = true, x5(e11)));
    })(e10, l7);
    else if (a5 || (c7 = (function(e11, t6) {
      var n6;
      o5 = t6, r6.isBuffer(o5) || o5 instanceof i6 || "string" == typeof t6 || void 0 === t6 || e11.objectMode || (n6 = new p7("chunk", ["string", "Buffer", "Uint8Array"], t6));
      var o5;
      return n6;
    })(l7, t5)), c7) v7(e10, c7);
    else if (l7.objectMode || t5 && t5.length > 0) if ("string" == typeof t5 || l7.objectMode || Object.getPrototypeOf(t5) === r6.prototype || (t5 = (function(e11) {
      return r6.from(e11);
    })(t5)), s4) l7.endEmitted ? v7(e10, new y8()) : _4(e10, l7, t5, true);
    else if (l7.ended) v7(e10, new g3());
    else {
      if (l7.destroyed) return false;
      l7.reading = false, l7.decoder && !n5 ? (t5 = l7.decoder.write(t5), l7.objectMode || 0 !== t5.length ? _4(e10, l7, t5, false) : M7(e10, l7)) : _4(e10, l7, t5, false);
    }
    else s4 || (l7.reading = false, M7(e10, l7));
    return !l7.ended && (l7.length < l7.highWaterMark || 0 === l7.length);
  }
  function _4(e10, t5, n5, r7) {
    t5.flowing && 0 === t5.length && !t5.sync ? (t5.awaitDrain = 0, e10.emit("data", n5)) : (t5.length += t5.objectMode ? 1 : n5.length, r7 ? t5.buffer.unshift(n5) : t5.buffer.push(n5), t5.needReadable && A8(e10)), M7(e10, t5);
  }
  Object.defineProperty(E7.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && this._readableState.destroyed;
  }, set: function(e10) {
    this._readableState && (this._readableState.destroyed = e10);
  } }), E7.prototype.destroy = u6.destroy, E7.prototype._undestroy = u6.undestroy, E7.prototype._destroy = function(e10, t5) {
    t5(e10);
  }, E7.prototype.push = function(e10, t5) {
    var n5, i7 = this._readableState;
    return i7.objectMode ? n5 = true : "string" == typeof e10 && ((t5 = t5 || i7.defaultEncoding) !== i7.encoding && (e10 = r6.from(e10, t5), t5 = ""), n5 = true), S7(this, e10, t5, false, n5);
  }, E7.prototype.unshift = function(e10) {
    return S7(this, e10, null, true, false);
  }, E7.prototype.isPaused = function() {
    return false === this._readableState.flowing;
  }, E7.prototype.setEncoding = function(e10) {
    a4 || (a4 = kd.StringDecoder);
    var t5 = new a4(e10);
    this._readableState.decoder = t5, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var n5 = this._readableState.buffer.head, r7 = ""; null !== n5; ) r7 += t5.write(n5.data), n5 = n5.next;
    return this._readableState.buffer.clear(), "" !== r7 && this._readableState.buffer.push(r7), this._readableState.length = r7.length, this;
  };
  var C8 = 1073741824;
  function k8(e10, t5) {
    return e10 <= 0 || 0 === t5.length && t5.ended ? 0 : t5.objectMode ? 1 : e10 != e10 ? t5.flowing && t5.length ? t5.buffer.head.data.length : t5.length : (e10 > t5.highWaterMark && (t5.highWaterMark = (function(e11) {
      return e11 >= C8 ? e11 = C8 : (e11--, e11 |= e11 >>> 1, e11 |= e11 >>> 2, e11 |= e11 >>> 4, e11 |= e11 >>> 8, e11 |= e11 >>> 16, e11++), e11;
    })(e10)), e10 <= t5.length ? e10 : t5.ended ? t5.length : (t5.needReadable = true, 0));
  }
  function A8(e10) {
    var t5 = e10._readableState;
    o4("emitReadable", t5.needReadable, t5.emittedReadable), t5.needReadable = false, t5.emittedReadable || (o4("emitReadable", t5.flowing), t5.emittedReadable = true, ua2.nextTick(x5, e10));
  }
  function x5(e10) {
    var t5 = e10._readableState;
    o4("emitReadable_", t5.destroyed, t5.length, t5.ended), t5.destroyed || !t5.length && !t5.ended || (e10.emit("readable"), t5.emittedReadable = false), t5.needReadable = !t5.flowing && !t5.ended && t5.length <= t5.highWaterMark, O6(e10);
  }
  function M7(e10, t5) {
    t5.readingMore || (t5.readingMore = true, ua2.nextTick(I7, e10, t5));
  }
  function I7(e10, t5) {
    for (; !t5.reading && !t5.ended && (t5.length < t5.highWaterMark || t5.flowing && 0 === t5.length); ) {
      var n5 = t5.length;
      if (o4("maybeReadMore read 0"), e10.read(0), n5 === t5.length) break;
    }
    t5.readingMore = false;
  }
  function T6(e10) {
    var t5 = e10._readableState;
    t5.readableListening = e10.listenerCount("readable") > 0, t5.resumeScheduled && !t5.paused ? t5.flowing = true : e10.listenerCount("data") > 0 && e10.resume();
  }
  function R6(e10) {
    o4("readable nexttick read 0"), e10.read(0);
  }
  function P6(e10, t5) {
    o4("resume", t5.reading), t5.reading || e10.read(0), t5.resumeScheduled = false, e10.emit("resume"), O6(e10), t5.flowing && !t5.reading && e10.read(0);
  }
  function O6(e10) {
    var t5 = e10._readableState;
    for (o4("flow", t5.flowing); t5.flowing && null !== e10.read(); ) ;
  }
  function N8(e10, t5) {
    return 0 === t5.length ? null : (t5.objectMode ? n5 = t5.buffer.shift() : !e10 || e10 >= t5.length ? (n5 = t5.decoder ? t5.buffer.join("") : 1 === t5.buffer.length ? t5.buffer.first() : t5.buffer.concat(t5.length), t5.buffer.clear()) : n5 = t5.buffer.consume(e10, t5.decoder), n5);
    var n5;
  }
  function L6(e10) {
    var t5 = e10._readableState;
    o4("endReadable", t5.endEmitted), t5.endEmitted || (t5.ended = true, ua2.nextTick(D9, t5, e10));
  }
  function D9(e10, t5) {
    if (o4("endReadableNT", e10.endEmitted, e10.length), !e10.endEmitted && 0 === e10.length && (e10.endEmitted = true, t5.readable = false, t5.emit("end"), e10.autoDestroy)) {
      var n5 = t5._writableState;
      (!n5 || n5.autoDestroy && n5.finished) && t5.destroy();
    }
  }
  function $7(e10, t5) {
    for (var n5 = 0, r7 = e10.length; n5 < r7; n5++) if (e10[n5] === t5) return n5;
    return -1;
  }
  return E7.prototype.read = function(e10) {
    o4("read", e10), e10 = parseInt(e10, 10);
    var t5 = this._readableState, n5 = e10;
    if (0 !== e10 && (t5.emittedReadable = false), 0 === e10 && t5.needReadable && ((0 !== t5.highWaterMark ? t5.length >= t5.highWaterMark : t5.length > 0) || t5.ended)) return o4("read: emitReadable", t5.length, t5.ended), 0 === t5.length && t5.ended ? L6(this) : A8(this), null;
    if (0 === (e10 = k8(e10, t5)) && t5.ended) return 0 === t5.length && L6(this), null;
    var r7, i7 = t5.needReadable;
    return o4("need readable", i7), (0 === t5.length || t5.length - e10 < t5.highWaterMark) && o4("length less than watermark", i7 = true), t5.ended || t5.reading ? o4("reading or ended", i7 = false) : i7 && (o4("do read"), t5.reading = true, t5.sync = true, 0 === t5.length && (t5.needReadable = true), this._read(t5.highWaterMark), t5.sync = false, t5.reading || (e10 = k8(n5, t5))), null === (r7 = e10 > 0 ? N8(e10, t5) : null) ? (t5.needReadable = t5.length <= t5.highWaterMark, e10 = 0) : (t5.length -= e10, t5.awaitDrain = 0), 0 === t5.length && (t5.ended || (t5.needReadable = true), n5 !== e10 && t5.ended && L6(this)), null !== r7 && this.emit("data", r7), r7;
  }, E7.prototype._read = function(e10) {
    v7(this, new m5("_read()"));
  }, E7.prototype.pipe = function(e10, n5) {
    var r7 = this, i7 = this._readableState;
    switch (i7.pipesCount) {
      case 0:
        i7.pipes = e10;
        break;
      case 1:
        i7.pipes = [i7.pipes, e10];
        break;
      default:
        i7.pipes.push(e10);
    }
    i7.pipesCount += 1, o4("pipe count=%d opts=%j", i7.pipesCount, n5);
    var s4 = (!n5 || false !== n5.end) && e10 !== ua2.stdout && e10 !== ua2.stderr ? c7 : g4;
    function a5(t5, n6) {
      o4("onunpipe"), t5 === r7 && n6 && false === n6.hasUnpiped && (n6.hasUnpiped = true, o4("cleanup"), e10.removeListener("close", f13), e10.removeListener("finish", p8), e10.removeListener("drain", l7), e10.removeListener("error", h8), e10.removeListener("unpipe", a5), r7.removeListener("end", c7), r7.removeListener("end", g4), r7.removeListener("data", u7), d6 = true, !i7.awaitDrain || e10._writableState && !e10._writableState.needDrain || l7());
    }
    function c7() {
      o4("onend"), e10.end();
    }
    i7.endEmitted ? ua2.nextTick(s4) : r7.once("end", s4), e10.on("unpipe", a5);
    var l7 = /* @__PURE__ */ (function(e11) {
      return function() {
        var n6 = e11._readableState;
        o4("pipeOnDrain", n6.awaitDrain), n6.awaitDrain && n6.awaitDrain--, 0 === n6.awaitDrain && t4(e11, "data") && (n6.flowing = true, O6(e11));
      };
    })(r7);
    e10.on("drain", l7);
    var d6 = false;
    function u7(t5) {
      o4("ondata");
      var n6 = e10.write(t5);
      o4("dest.write", n6), false === n6 && ((1 === i7.pipesCount && i7.pipes === e10 || i7.pipesCount > 1 && -1 !== $7(i7.pipes, e10)) && !d6 && (o4("false write response, pause", i7.awaitDrain), i7.awaitDrain++), r7.pause());
    }
    function h8(n6) {
      o4("onerror", n6), g4(), e10.removeListener("error", h8), 0 === t4(e10, "error") && v7(e10, n6);
    }
    function f13() {
      e10.removeListener("finish", p8), g4();
    }
    function p8() {
      o4("onfinish"), e10.removeListener("close", f13), g4();
    }
    function g4() {
      o4("unpipe"), r7.unpipe(e10);
    }
    return r7.on("data", u7), (function(e11, t5, n6) {
      if ("function" == typeof e11.prependListener) return e11.prependListener(t5, n6);
      e11._events && e11._events[t5] ? Array.isArray(e11._events[t5]) ? e11._events[t5].unshift(n6) : e11._events[t5] = [n6, e11._events[t5]] : e11.on(t5, n6);
    })(e10, "error", h8), e10.once("close", f13), e10.once("finish", p8), e10.emit("pipe", r7), i7.flowing || (o4("pipe resume"), r7.resume()), e10;
  }, E7.prototype.unpipe = function(e10) {
    var t5 = this._readableState, n5 = { hasUnpiped: false };
    if (0 === t5.pipesCount) return this;
    if (1 === t5.pipesCount) return e10 && e10 !== t5.pipes || (e10 || (e10 = t5.pipes), t5.pipes = null, t5.pipesCount = 0, t5.flowing = false, e10 && e10.emit("unpipe", this, n5)), this;
    if (!e10) {
      var r7 = t5.pipes, i7 = t5.pipesCount;
      t5.pipes = null, t5.pipesCount = 0, t5.flowing = false;
      for (var o5 = 0; o5 < i7; o5++) r7[o5].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var s4 = $7(t5.pipes, e10);
    return -1 === s4 || (t5.pipes.splice(s4, 1), t5.pipesCount -= 1, 1 === t5.pipesCount && (t5.pipes = t5.pipes[0]), e10.emit("unpipe", this, n5)), this;
  }, E7.prototype.on = function(e10, t5) {
    var r7 = n4.prototype.on.call(this, e10, t5), i7 = this._readableState;
    return "data" === e10 ? (i7.readableListening = this.listenerCount("readable") > 0, false !== i7.flowing && this.resume()) : "readable" === e10 && (i7.endEmitted || i7.readableListening || (i7.readableListening = i7.needReadable = true, i7.flowing = false, i7.emittedReadable = false, o4("on readable", i7.length, i7.reading), i7.length ? A8(this) : i7.reading || ua2.nextTick(R6, this))), r7;
  }, E7.prototype.addListener = E7.prototype.on, E7.prototype.removeListener = function(e10, t5) {
    var r7 = n4.prototype.removeListener.call(this, e10, t5);
    return "readable" === e10 && ua2.nextTick(T6, this), r7;
  }, E7.prototype.removeAllListeners = function(e10) {
    var t5 = n4.prototype.removeAllListeners.apply(this, arguments);
    return "readable" !== e10 && void 0 !== e10 || ua2.nextTick(T6, this), t5;
  }, E7.prototype.resume = function() {
    var e10 = this._readableState;
    return e10.flowing || (o4("resume"), e10.flowing = !e10.readableListening, (function(e11, t5) {
      t5.resumeScheduled || (t5.resumeScheduled = true, ua2.nextTick(P6, e11, t5));
    })(this, e10)), e10.paused = false, this;
  }, E7.prototype.pause = function() {
    return o4("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (o4("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  }, E7.prototype.wrap = function(e10) {
    var t5 = this, n5 = this._readableState, r7 = false;
    for (var i7 in e10.on("end", (function() {
      if (o4("wrapped end"), n5.decoder && !n5.ended) {
        var e11 = n5.decoder.end();
        e11 && e11.length && t5.push(e11);
      }
      t5.push(null);
    })), e10.on("data", (function(i8) {
      (o4("wrapped data"), n5.decoder && (i8 = n5.decoder.write(i8)), n5.objectMode && null == i8) || (n5.objectMode || i8 && i8.length) && (t5.push(i8) || (r7 = true, e10.pause()));
    })), e10) void 0 === this[i7] && "function" == typeof e10[i7] && (this[i7] = /* @__PURE__ */ (function(t6) {
      return function() {
        return e10[t6].apply(e10, arguments);
      };
    })(i7));
    for (var s4 = 0; s4 < b5.length; s4++) e10.on(b5[s4], this.emit.bind(this, b5[s4]));
    return this._read = function(t6) {
      o4("wrapped _read", t6), r7 && (r7 = false, e10.resume());
    }, this;
  }, "function" == typeof Symbol && (E7.prototype[Symbol.asyncIterator] = function() {
    return void 0 === c6 && (c6 = Ld()), c6(this);
  }), Object.defineProperty(E7.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(E7.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(E7.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e10) {
    this._readableState && (this._readableState.flowing = e10);
  } }), E7._fromList = N8, Object.defineProperty(E7.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } }), "function" == typeof Symbol && (E7.from = function(e10, t5) {
    return void 0 === l6 && (l6 = Rd ? Td : (Rd = 1, Td = function() {
      throw new Error("Readable.from is not available in the browser");
    })), l6(E7, e10, t5);
  }), Pd;
}
var $d = qd;
var Bd = nd.codes;
var Kd = Bd.ERR_METHOD_NOT_IMPLEMENTED;
var jd = Bd.ERR_MULTIPLE_CALLBACK;
var Ud = Bd.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var Hd = Bd.ERR_TRANSFORM_WITH_LENGTH_0;
var Fd = bd();
function zd(e9, t4) {
  var n4 = this._transformState;
  n4.transforming = false;
  var r6 = n4.writecb;
  if (null === r6) return this.emit("error", new jd());
  n4.writechunk = null, n4.writecb = null, null != t4 && this.push(t4), r6(e9);
  var i6 = this._readableState;
  i6.reading = false, (i6.needReadable || i6.length < i6.highWaterMark) && this._read(i6.highWaterMark);
}
function qd(e9) {
  if (!(this instanceof qd)) return new qd(e9);
  Fd.call(this, e9), this._transformState = { afterTransform: zd.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e9 && ("function" == typeof e9.transform && (this._transform = e9.transform), "function" == typeof e9.flush && (this._flush = e9.flush)), this.on("prefinish", Wd);
}
function Wd() {
  var e9 = this;
  "function" != typeof this._flush || this._readableState.destroyed ? Vd(this, null, null) : this._flush((function(t4, n4) {
    Vd(e9, t4, n4);
  }));
}
function Vd(e9, t4, n4) {
  if (t4) return e9.emit("error", t4);
  if (null != n4 && e9.push(n4), e9._writableState.length) throw new Hd();
  if (e9._transformState.transforming) throw new Ud();
  return e9.push(null);
}
md(qd, Fd), qd.prototype.push = function(e9, t4) {
  return this._transformState.needTransform = false, Fd.prototype.push.call(this, e9, t4);
}, qd.prototype._transform = function(e9, t4, n4) {
  n4(new Kd("_transform()"));
}, qd.prototype._write = function(e9, t4, n4) {
  var r6 = this._transformState;
  if (r6.writecb = n4, r6.writechunk = e9, r6.writeencoding = t4, !r6.transforming) {
    var i6 = this._readableState;
    (r6.needTransform || i6.needReadable || i6.length < i6.highWaterMark) && this._read(i6.highWaterMark);
  }
}, qd.prototype._read = function(e9) {
  var t4 = this._transformState;
  null === t4.writechunk || t4.transforming ? t4.needTransform = true : (t4.transforming = true, this._transform(t4.writechunk, t4.writeencoding, t4.afterTransform));
}, qd.prototype._destroy = function(e9, t4) {
  Fd.prototype._destroy.call(this, e9, (function(e10) {
    t4(e10);
  }));
};
var Gd;
var Yd = Jd;
var Zd = $d;
function Jd(e9) {
  if (!(this instanceof Jd)) return new Jd(e9);
  Zd.call(this, e9);
}
md(Jd, Zd), Jd.prototype._transform = function(e9, t4, n4) {
  n4(null, e9);
};
var Qd = nd.codes;
var Xd = Qd.ERR_MISSING_ARGS;
var eu = Qd.ERR_STREAM_DESTROYED;
function tu(e9) {
  if (e9) throw e9;
}
function nu(e9) {
  e9();
}
function ru(e9, t4) {
  return e9.pipe(t4);
}
var iu = function() {
  for (var e9 = arguments.length, t4 = new Array(e9), n4 = 0; n4 < e9; n4++) t4[n4] = arguments[n4];
  var r6, i6 = (function(e10) {
    return e10.length ? "function" != typeof e10[e10.length - 1] ? tu : e10.pop() : tu;
  })(t4);
  if (Array.isArray(t4[0]) && (t4 = t4[0]), t4.length < 2) throw new Xd("streams");
  var o4 = t4.map((function(e10, n5) {
    var s3 = n5 < t4.length - 1;
    return (function(e11, t5, n6, r7) {
      r7 = /* @__PURE__ */ (function(e12) {
        var t6 = false;
        return function() {
          t6 || (t6 = true, e12.apply(void 0, arguments));
        };
      })(r7);
      var i7 = false;
      e11.on("close", (function() {
        i7 = true;
      })), void 0 === Gd && (Gd = Nd), Gd(e11, { readable: t5, writable: n6 }, (function(e12) {
        if (e12) return r7(e12);
        i7 = true, r7();
      }));
      var o5 = false;
      return function(t6) {
        if (!i7 && !o5) return o5 = true, (function(e12) {
          return e12.setHeader && "function" == typeof e12.abort;
        })(e11) ? e11.abort() : "function" == typeof e11.destroy ? e11.destroy() : void r7(t6 || new eu("pipe"));
      };
    })(e10, s3, n5 > 0, (function(e11) {
      r6 || (r6 = e11), e11 && o4.forEach(nu), s3 || (o4.forEach(nu), i6(r6));
    }));
  }));
  return t4.reduce(ru);
};
!(function(e9, t4) {
  (t4 = sl.exports = Dd()).Stream = t4, t4.Readable = t4, t4.Writable = vd(), t4.Duplex = bd(), t4.Transform = $d, t4.PassThrough = Yd, t4.finished = Nd, t4.pipeline = iu;
})(0, sl.exports);
var ou = sl.exports;
function su(e9 = {}) {
  const t4 = {}, n4 = new ou.Duplex({ objectMode: true, read: () => {
  }, write: function(n5, o4, s3) {
    let a4 = null;
    try {
      !n5.id ? (function(n6) {
        e9?.retryOnMessage && n6.method === e9.retryOnMessage && Object.values(t4).forEach((({ req: e10, retryCount: n7 = 0 }) => {
          if (!e10.id) return;
          if (n7 >= 3) throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${e10.id}"`);
          const r7 = t4[e10.id];
          r7 && (r7.retryCount = n7 + 1), i6(e10);
        }));
        r6.emit("notification", n6);
      })(n5) : (function(e10) {
        const { id: n6 } = e10;
        if (null === n6) return;
        const r7 = t4[n6];
        if (!r7) return void console.warn(`StreamMiddleware - Unknown response id "${n6}"`);
        delete t4[n6], Object.assign(r7.res, e10), setTimeout(r7.end);
      })(n5);
    } catch (e10) {
      a4 = e10;
    }
    s3(a4);
  } }), r6 = new Pc4();
  return { events: r6, middleware: (e10, n5, r7, o4) => {
    t4[e10.id] = { req: e10, res: n5, next: r7, end: o4 }, i6(e10);
  }, stream: n4 };
  function i6(e10) {
    n4.push(e10);
  }
}
var au = {};
var cu = { exports: {} };
var lu = function e8(t4, n4) {
  if (t4 && n4) return e8(t4)(n4);
  if ("function" != typeof t4) throw new TypeError("need wrapper function");
  return Object.keys(t4).forEach((function(e9) {
    r6[e9] = t4[e9];
  })), r6;
  function r6() {
    for (var e9 = new Array(arguments.length), n5 = 0; n5 < e9.length; n5++) e9[n5] = arguments[n5];
    var r7 = t4.apply(this, e9), i6 = e9[e9.length - 1];
    return "function" == typeof r7 && r7 !== i6 && Object.keys(i6).forEach((function(e10) {
      r7[e10] = i6[e10];
    })), r7;
  }
};
var du = lu;
function uu(e9) {
  var t4 = function() {
    return t4.called ? t4.value : (t4.called = true, t4.value = e9.apply(this, arguments));
  };
  return t4.called = false, t4;
}
function hu(e9) {
  var t4 = function() {
    if (t4.called) throw new Error(t4.onceError);
    return t4.called = true, t4.value = e9.apply(this, arguments);
  }, n4 = e9.name || "Function wrapped with `once`";
  return t4.onceError = n4 + " shouldn't be called more than once", t4.called = false, t4;
}
cu.exports = du(uu), cu.exports.strict = du(hu), uu.proto = uu((function() {
  Object.defineProperty(Function.prototype, "once", { value: function() {
    return uu(this);
  }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
    return hu(this);
  }, configurable: true });
}));
var fu = cu.exports;
var pu = {};
Object.defineProperty(pu, "__esModule", { value: true }), pu.Substream = void 0;
var gu = ou;
var mu = class extends gu.Duplex {
  constructor({ parent: e9, name: t4 }) {
    super({ objectMode: true }), this._parent = e9, this._name = t4;
  }
  _read() {
  }
  _write(e9, t4, n4) {
    this._parent.push({ name: this._name, data: e9 }), n4();
  }
};
pu.Substream = mu;
var yu = de6 && de6.__importDefault || function(e9) {
  return e9 && e9.__esModule ? e9 : { default: e9 };
};
Object.defineProperty(au, "__esModule", { value: true }), au.ObjectMultiplex = void 0;
var vu = ou;
var bu = yu(fu);
var wu = pu;
var Eu = Symbol("IGNORE_SUBSTREAM");
var Su = class extends vu.Duplex {
  constructor(e9 = {}) {
    super(Object.assign(Object.assign({}, e9), { objectMode: true })), this._substreams = {};
  }
  createStream(e9) {
    if (this.destroyed) throw new Error(`ObjectMultiplex - parent stream for name "${e9}" already destroyed`);
    if (this._readableState.ended || this._writableState.ended) throw new Error(`ObjectMultiplex - parent stream for name "${e9}" already ended`);
    if (!e9) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e9]) throw new Error(`ObjectMultiplex - Substream for name "${e9}" already exists`);
    const t4 = new wu.Substream({ parent: this, name: e9 });
    return this._substreams[e9] = t4, (function(e10, t5) {
      const n4 = (0, bu.default)(t5);
      (0, vu.finished)(e10, { readable: false }, n4), (0, vu.finished)(e10, { writable: false }, n4);
    })(this, ((e10) => t4.destroy(e10 || void 0))), t4;
  }
  ignoreStream(e9) {
    if (!e9) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e9]) throw new Error(`ObjectMultiplex - Substream for name "${e9}" already exists`);
    this._substreams[e9] = Eu;
  }
  _read() {
  }
  _write(e9, t4, n4) {
    const { name: r6, data: i6 } = e9;
    if (!r6) return console.warn(`ObjectMultiplex - malformed chunk without name "${e9}"`), n4();
    const o4 = this._substreams[r6];
    return o4 ? (o4 !== Eu && o4.push(i6), n4()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${r6}"`), n4());
  }
};
au.ObjectMultiplex = Su;
var _u = ue6(au.ObjectMultiplex);
var Cu = (e9) => null !== e9 && "object" == typeof e9 && "function" == typeof e9.pipe;
Cu.writable = (e9) => Cu(e9) && false !== e9.writable && "function" == typeof e9._write && "object" == typeof e9._writableState, Cu.readable = (e9) => Cu(e9) && false !== e9.readable && "function" == typeof e9._read && "object" == typeof e9._readableState, Cu.duplex = (e9) => Cu.writable(e9) && Cu.readable(e9), Cu.transform = (e9) => Cu.duplex(e9) && "function" == typeof e9._transform;
var ku;
var Au = Cu;
var xu = class extends ol {
  constructor(e9, { jsonRpcStreamName: t4, logger: n4 = console, maxEventListeners: r6 = 100, rpcMiddleware: i6 = [] }) {
    if (super({ logger: n4, maxEventListeners: r6, rpcMiddleware: i6 }), !Au.duplex(e9)) throw new Error(is2.errors.invalidDuplexStream());
    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
    const o4 = new _u();
    ou.pipeline(e9, o4, e9, this._handleStreamDisconnect.bind(this, "MetaMask")), this._jsonRpcConnection = su({ retryOnMessage: "METAMASK_EXTENSION_CONNECT_CAN_RETRY" }), ou.pipeline(this._jsonRpcConnection.stream, o4.createStream(t4), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "MetaMask RpcProvider")), this._rpcEngine.push(this._jsonRpcConnection.middleware), this._jsonRpcConnection.events.on("notification", ((t5) => {
      const { method: n5, params: r7 } = t5;
      "metamask_accountsChanged" === n5 ? this._handleAccountsChanged(r7) : "metamask_unlockStateChanged" === n5 ? this._handleUnlockStateChanged(r7) : "metamask_chainChanged" === n5 ? this._handleChainChanged(r7) : Dc2.includes(n5) ? this.emit("message", { type: n5, data: r7 }) : "METAMASK_STREAM_FAILURE" === n5 && e9.destroy(new Error(is2.errors.permanentlyDisconnected()));
    }));
  }
  async _initializeStateAsync() {
    let e9;
    try {
      e9 = await this.request({ method: "metamask_getProviderState" });
    } catch (e10) {
      this._log.error("MetaMask: Failed to get initial state. Please report this bug.", e10);
    }
    this._initializeState(e9);
  }
  _handleStreamDisconnect(e9, t4) {
    let n4 = `MetaMask: Lost connection to "${e9}".`;
    t4?.stack && (n4 += `
${t4.stack}`), this._log.warn(n4), this.listenerCount("error") > 0 && this.emit("error", n4), this._handleDisconnect(false, t4 ? t4.message : void 0);
  }
  _handleChainChanged({ chainId: e9, networkVersion: t4 } = {}) {
    jc4(e9) && ((e10) => Boolean(e10) && "string" == typeof e10)(t4) ? "loading" === t4 ? this._handleDisconnect(true) : super._handleChainChanged({ chainId: e9 }) : this._log.error(is2.errors.invalidNetworkParams(), { chainId: e9, networkVersion: t4 });
  }
};
var Mu = class extends xu {
  constructor(e9, { jsonRpcStreamName: t4 = "metamask-provider", logger: n4 = console, maxEventListeners: r6 = 100, shouldSendMetadata: i6 } = {}) {
    if (super(e9, { jsonRpcStreamName: t4, logger: n4, maxEventListeners: r6, rpcMiddleware: $c4(n4) }), this._sentWarnings = { chainId: false, networkVersion: false, selectedAddress: false, enable: false, experimentalMethods: false, send: false, events: { close: false, data: false, networkChanged: false, notification: false } }, Gc2(this, ku, void 0), this._initializeStateAsync(), Yc2(this, ku, null), this.isMetaMask = true, this._sendSync = this._sendSync.bind(this), this.enable = this.enable.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this._warnOfDeprecation = this._warnOfDeprecation.bind(this), this._metamask = this._getExperimentalApi(), this._jsonRpcConnection.events.on("notification", ((e10) => {
      const { method: t5 } = e10;
      Dc2.includes(t5) && (this.emit("data", e10), this.emit("notification", e10.params.result));
    })), i6) if ("complete" === document.readyState) Hc4(this._rpcEngine, this._log);
    else {
      const e10 = () => {
        Hc4(this._rpcEngine, this._log), window.removeEventListener("DOMContentLoaded", e10);
      };
      window.addEventListener("DOMContentLoaded", e10);
    }
  }
  get chainId() {
    return this._sentWarnings.chainId || (this._log.warn(is2.warnings.chainIdDeprecation), this._sentWarnings.chainId = true), super.chainId;
  }
  get networkVersion() {
    return this._sentWarnings.networkVersion || (this._log.warn(is2.warnings.networkVersionDeprecation), this._sentWarnings.networkVersion = true), Vc2(this, ku);
  }
  get selectedAddress() {
    return this._sentWarnings.selectedAddress || (this._log.warn(is2.warnings.selectedAddressDeprecation), this._sentWarnings.selectedAddress = true), super.selectedAddress;
  }
  sendAsync(e9, t4) {
    this._rpcRequest(e9, t4);
  }
  addListener(e9, t4) {
    return this._warnOfDeprecation(e9), super.addListener(e9, t4);
  }
  on(e9, t4) {
    return this._warnOfDeprecation(e9), super.on(e9, t4);
  }
  once(e9, t4) {
    return this._warnOfDeprecation(e9), super.once(e9, t4);
  }
  prependListener(e9, t4) {
    return this._warnOfDeprecation(e9), super.prependListener(e9, t4);
  }
  prependOnceListener(e9, t4) {
    return this._warnOfDeprecation(e9), super.prependOnceListener(e9, t4);
  }
  _handleDisconnect(e9, t4) {
    super._handleDisconnect(e9, t4), Vc2(this, ku) && !e9 && Yc2(this, ku, null);
  }
  _warnOfDeprecation(e9) {
    false === this._sentWarnings?.events[e9] && (this._log.warn(is2.warnings.events[e9]), this._sentWarnings.events[e9] = true);
  }
  async enable() {
    return this._sentWarnings.enable || (this._log.warn(is2.warnings.enableDeprecation), this._sentWarnings.enable = true), new Promise(((e9, t4) => {
      try {
        this._rpcRequest({ method: "eth_requestAccounts", params: [] }, Kc2(e9, t4));
      } catch (e10) {
        t4(e10);
      }
    }));
  }
  send(e9, t4) {
    return this._sentWarnings.send || (this._log.warn(is2.warnings.sendDeprecation), this._sentWarnings.send = true), "string" != typeof e9 || t4 && !Array.isArray(t4) ? e9 && "object" == typeof e9 && "function" == typeof t4 ? this._rpcRequest(e9, t4) : this._sendSync(e9) : new Promise(((n4, r6) => {
      try {
        this._rpcRequest({ method: e9, params: t4 }, Kc2(n4, r6, false));
      } catch (e10) {
        r6(e10);
      }
    }));
  }
  _sendSync(e9) {
    let t4;
    switch (e9.method) {
      case "eth_accounts":
        t4 = this.selectedAddress ? [this.selectedAddress] : [];
        break;
      case "eth_coinbase":
        t4 = this.selectedAddress ?? null;
        break;
      case "eth_uninstallFilter":
        this._rpcRequest(e9, Uc4), t4 = true;
        break;
      case "net_version":
        t4 = Vc2(this, ku) ?? null;
        break;
      default:
        throw new Error(is2.errors.unsupportedSync(e9.method));
    }
    return { id: e9.id, jsonrpc: e9.jsonrpc, result: t4 };
  }
  _getExperimentalApi() {
    return new Proxy({ isUnlocked: async () => (this._state.initialized || await new Promise(((e9) => {
      this.on("_initialized", (() => e9()));
    })), this._state.isUnlocked), requestBatch: async (e9) => {
      if (!Array.isArray(e9)) throw Xa({ message: "Batch requests must be made with an array of request objects.", data: e9 });
      return new Promise(((t4, n4) => {
        this._rpcRequest(e9, Kc2(t4, n4));
      }));
    } }, { get: (e9, t4, ...n4) => (this._sentWarnings.experimentalMethods || (this._log.warn(is2.warnings.experimentalMethods), this._sentWarnings.experimentalMethods = true), Reflect.get(e9, t4, ...n4)) });
  }
  _handleChainChanged({ chainId: e9, networkVersion: t4 } = {}) {
    super._handleChainChanged({ chainId: e9, networkVersion: t4 }), this._state.isConnected && t4 !== Vc2(this, ku) && (Yc2(this, ku, t4), this._state.initialized && this.emit("networkChanged", Vc2(this, ku)));
  }
};
ku = /* @__PURE__ */ new WeakMap();
var Iu = (0, import_debug.default)("MM_SDK");
var Tu;
Iu.color = "#FFAC1C";
var Ru = {};
var Pu = {};
Object.defineProperty(Pu, "__esModule", { value: true }), Pu.EthereumProviderError = Pu.EthereumRpcError = void 0;
var Ou = $a2;
var Nu = class extends Error {
  constructor(e9, t4, n4) {
    if (!Number.isInteger(e9)) throw new Error('"code" must be an integer.');
    if (!t4 || "string" != typeof t4) throw new Error('"message" must be a nonempty string.');
    super(t4), this.code = e9, void 0 !== n4 && (this.data = n4);
  }
  serialize() {
    const e9 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e9.data = this.data), this.stack && (e9.stack = this.stack), e9;
  }
  toString() {
    return Ou.default(this.serialize(), Lu, 2);
  }
};
Pu.EthereumRpcError = Nu;
function Lu(e9, t4) {
  if ("[Circular]" !== t4) return t4;
}
Pu.EthereumProviderError = class extends Nu {
  constructor(e9, t4, n4) {
    if (!(function(e10) {
      return Number.isInteger(e10) && e10 >= 1e3 && e10 <= 4999;
    })(e9)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e9, t4, n4);
  }
};
var Du = {};
var $u = {};
Object.defineProperty($u, "__esModule", { value: true }), $u.errorValues = $u.errorCodes = void 0, $u.errorCodes = { rpc: { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 }, provider: { userRejectedRequest: 4001, unauthorized: 4100, unsupportedMethod: 4200, disconnected: 4900, chainDisconnected: 4901 } }, $u.errorValues = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } }, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.serializeError = e9.isValidCode = e9.getMessageFromCode = e9.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t4 = $u, n4 = Pu, r6 = t4.errorCodes.rpc.internal, i6 = "Unspecified error message. This is a bug, please report it.", o4 = { code: r6, message: s3(r6) };
  function s3(n5, r7 = i6) {
    if (Number.isInteger(n5)) {
      const r8 = n5.toString();
      if (d5(t4.errorValues, r8)) return t4.errorValues[r8].message;
      if (c6(n5)) return e9.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return r7;
  }
  function a4(e10) {
    if (!Number.isInteger(e10)) return false;
    const n5 = e10.toString();
    return !!t4.errorValues[n5] || !!c6(e10);
  }
  function c6(e10) {
    return e10 >= -32099 && e10 <= -32e3;
  }
  function l6(e10) {
    return e10 && "object" == typeof e10 && !Array.isArray(e10) ? Object.assign({}, e10) : e10;
  }
  function d5(e10, t5) {
    return Object.prototype.hasOwnProperty.call(e10, t5);
  }
  e9.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.", e9.getMessageFromCode = s3, e9.isValidCode = a4, e9.serializeError = function(e10, { fallbackError: t5 = o4, shouldIncludeStack: r7 = false } = {}) {
    var i7, c7;
    if (!t5 || !Number.isInteger(t5.code) || "string" != typeof t5.message) throw new Error("Must provide fallback error with integer number code and string message.");
    if (e10 instanceof n4.EthereumRpcError) return e10.serialize();
    const u6 = {};
    if (e10 && "object" == typeof e10 && !Array.isArray(e10) && d5(e10, "code") && a4(e10.code)) {
      const t6 = e10;
      u6.code = t6.code, t6.message && "string" == typeof t6.message ? (u6.message = t6.message, d5(t6, "data") && (u6.data = t6.data)) : (u6.message = s3(u6.code), u6.data = { originalError: l6(e10) });
    } else {
      u6.code = t5.code;
      const n5 = null === (i7 = e10) || void 0 === i7 ? void 0 : i7.message;
      u6.message = n5 && "string" == typeof n5 ? n5 : t5.message, u6.data = { originalError: l6(e10) };
    }
    const h7 = null === (c7 = e10) || void 0 === c7 ? void 0 : c7.stack;
    return r7 && e10 && h7 && "string" == typeof h7 && (u6.stack = h7), u6;
  };
})(Du);
var Bu = {};
Object.defineProperty(Bu, "__esModule", { value: true }), Bu.ethErrors = void 0;
var Ku = Pu;
var ju = Du;
var Uu = $u;
function Hu(e9, t4) {
  const [n4, r6] = zu(t4);
  return new Ku.EthereumRpcError(e9, n4 || ju.getMessageFromCode(e9), r6);
}
function Fu(e9, t4) {
  const [n4, r6] = zu(t4);
  return new Ku.EthereumProviderError(e9, n4 || ju.getMessageFromCode(e9), r6);
}
function zu(e9) {
  if (e9) {
    if ("string" == typeof e9) return [e9];
    if ("object" == typeof e9 && !Array.isArray(e9)) {
      const { message: t4, data: n4 } = e9;
      if (t4 && "string" != typeof t4) throw new Error("Must specify string message.");
      return [t4 || void 0, n4];
    }
  }
  return [];
}
Bu.ethErrors = { rpc: { parse: (e9) => Hu(Uu.errorCodes.rpc.parse, e9), invalidRequest: (e9) => Hu(Uu.errorCodes.rpc.invalidRequest, e9), invalidParams: (e9) => Hu(Uu.errorCodes.rpc.invalidParams, e9), methodNotFound: (e9) => Hu(Uu.errorCodes.rpc.methodNotFound, e9), internal: (e9) => Hu(Uu.errorCodes.rpc.internal, e9), server: (e9) => {
  if (!e9 || "object" != typeof e9 || Array.isArray(e9)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
  const { code: t4 } = e9;
  if (!Number.isInteger(t4) || t4 > -32005 || t4 < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
  return Hu(t4, e9);
}, invalidInput: (e9) => Hu(Uu.errorCodes.rpc.invalidInput, e9), resourceNotFound: (e9) => Hu(Uu.errorCodes.rpc.resourceNotFound, e9), resourceUnavailable: (e9) => Hu(Uu.errorCodes.rpc.resourceUnavailable, e9), transactionRejected: (e9) => Hu(Uu.errorCodes.rpc.transactionRejected, e9), methodNotSupported: (e9) => Hu(Uu.errorCodes.rpc.methodNotSupported, e9), limitExceeded: (e9) => Hu(Uu.errorCodes.rpc.limitExceeded, e9) }, provider: { userRejectedRequest: (e9) => Fu(Uu.errorCodes.provider.userRejectedRequest, e9), unauthorized: (e9) => Fu(Uu.errorCodes.provider.unauthorized, e9), unsupportedMethod: (e9) => Fu(Uu.errorCodes.provider.unsupportedMethod, e9), disconnected: (e9) => Fu(Uu.errorCodes.provider.disconnected, e9), chainDisconnected: (e9) => Fu(Uu.errorCodes.provider.chainDisconnected, e9), custom: (e9) => {
  if (!e9 || "object" != typeof e9 || Array.isArray(e9)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
  const { code: t4, message: n4, data: r6 } = e9;
  if (!n4 || "string" != typeof n4) throw new Error('"message" must be a nonempty string');
  return new Ku.EthereumProviderError(t4, n4, r6);
} } }, (function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.getMessageFromCode = e9.serializeError = e9.EthereumProviderError = e9.EthereumRpcError = e9.ethErrors = e9.errorCodes = void 0;
  const t4 = Pu;
  Object.defineProperty(e9, "EthereumRpcError", { enumerable: true, get: function() {
    return t4.EthereumRpcError;
  } }), Object.defineProperty(e9, "EthereumProviderError", { enumerable: true, get: function() {
    return t4.EthereumProviderError;
  } });
  const n4 = Du;
  Object.defineProperty(e9, "serializeError", { enumerable: true, get: function() {
    return n4.serializeError;
  } }), Object.defineProperty(e9, "getMessageFromCode", { enumerable: true, get: function() {
    return n4.getMessageFromCode;
  } });
  const r6 = Bu;
  Object.defineProperty(e9, "ethErrors", { enumerable: true, get: function() {
    return r6.ethErrors;
  } });
  const i6 = $u;
  Object.defineProperty(e9, "errorCodes", { enumerable: true, get: function() {
    return i6.errorCodes;
  } });
})(Ru);
var qu = { exports: {} };
qu.exports = (function(e9) {
  var t4 = {};
  function n4(r6) {
    if (t4[r6]) return t4[r6].exports;
    var i6 = t4[r6] = { i: r6, l: false, exports: {} };
    return e9[r6].call(i6.exports, i6, i6.exports, n4), i6.l = true, i6.exports;
  }
  return n4.m = e9, n4.c = t4, n4.d = function(e10, t5, r6) {
    n4.o(e10, t5) || Object.defineProperty(e10, t5, { enumerable: true, get: r6 });
  }, n4.r = function(e10) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e10, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e10, "__esModule", { value: true });
  }, n4.t = function(e10, t5) {
    if (1 & t5 && (e10 = n4(e10)), 8 & t5) return e10;
    if (4 & t5 && "object" == typeof e10 && e10 && e10.__esModule) return e10;
    var r6 = /* @__PURE__ */ Object.create(null);
    if (n4.r(r6), Object.defineProperty(r6, "default", { enumerable: true, value: e10 }), 2 & t5 && "string" != typeof e10) for (var i6 in e10) n4.d(r6, i6, (function(t6) {
      return e10[t6];
    }).bind(null, i6));
    return r6;
  }, n4.n = function(e10) {
    var t5 = e10 && e10.__esModule ? function() {
      return e10.default;
    } : function() {
      return e10;
    };
    return n4.d(t5, "a", t5), t5;
  }, n4.o = function(e10, t5) {
    return Object.prototype.hasOwnProperty.call(e10, t5);
  }, n4.p = "", n4(n4.s = 90);
})({ 17: function(e9, t4, n4) {
  t4.__esModule = true, t4.default = void 0;
  var r6 = n4(18), i6 = (function() {
    function e10() {
    }
    return e10.getFirstMatch = function(e11, t5) {
      var n5 = t5.match(e11);
      return n5 && n5.length > 0 && n5[1] || "";
    }, e10.getSecondMatch = function(e11, t5) {
      var n5 = t5.match(e11);
      return n5 && n5.length > 1 && n5[2] || "";
    }, e10.matchAndReturnConst = function(e11, t5, n5) {
      if (e11.test(t5)) return n5;
    }, e10.getWindowsVersionName = function(e11) {
      switch (e11) {
        case "NT":
          return "NT";
        case "XP":
        case "NT 5.1":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return;
      }
    }, e10.getMacOSVersionName = function(e11) {
      var t5 = e11.split(".").splice(0, 2).map((function(e12) {
        return parseInt(e12, 10) || 0;
      }));
      if (t5.push(0), 10 === t5[0]) switch (t5[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
    }, e10.getAndroidVersionName = function(e11) {
      var t5 = e11.split(".").splice(0, 2).map((function(e12) {
        return parseInt(e12, 10) || 0;
      }));
      if (t5.push(0), !(1 === t5[0] && t5[1] < 5)) return 1 === t5[0] && t5[1] < 6 ? "Cupcake" : 1 === t5[0] && t5[1] >= 6 ? "Donut" : 2 === t5[0] && t5[1] < 2 ? "Eclair" : 2 === t5[0] && 2 === t5[1] ? "Froyo" : 2 === t5[0] && t5[1] > 2 ? "Gingerbread" : 3 === t5[0] ? "Honeycomb" : 4 === t5[0] && t5[1] < 1 ? "Ice Cream Sandwich" : 4 === t5[0] && t5[1] < 4 ? "Jelly Bean" : 4 === t5[0] && t5[1] >= 4 ? "KitKat" : 5 === t5[0] ? "Lollipop" : 6 === t5[0] ? "Marshmallow" : 7 === t5[0] ? "Nougat" : 8 === t5[0] ? "Oreo" : 9 === t5[0] ? "Pie" : void 0;
    }, e10.getVersionPrecision = function(e11) {
      return e11.split(".").length;
    }, e10.compareVersions = function(t5, n5, r7) {
      void 0 === r7 && (r7 = false);
      var i7 = e10.getVersionPrecision(t5), o4 = e10.getVersionPrecision(n5), s3 = Math.max(i7, o4), a4 = 0, c6 = e10.map([t5, n5], (function(t6) {
        var n6 = s3 - e10.getVersionPrecision(t6), r8 = t6 + new Array(n6 + 1).join(".0");
        return e10.map(r8.split("."), (function(e11) {
          return new Array(20 - e11.length).join("0") + e11;
        })).reverse();
      }));
      for (r7 && (a4 = s3 - Math.min(i7, o4)), s3 -= 1; s3 >= a4; ) {
        if (c6[0][s3] > c6[1][s3]) return 1;
        if (c6[0][s3] === c6[1][s3]) {
          if (s3 === a4) return 0;
          s3 -= 1;
        } else if (c6[0][s3] < c6[1][s3]) return -1;
      }
    }, e10.map = function(e11, t5) {
      var n5, r7 = [];
      if (Array.prototype.map) return Array.prototype.map.call(e11, t5);
      for (n5 = 0; n5 < e11.length; n5 += 1) r7.push(t5(e11[n5]));
      return r7;
    }, e10.find = function(e11, t5) {
      var n5, r7;
      if (Array.prototype.find) return Array.prototype.find.call(e11, t5);
      for (n5 = 0, r7 = e11.length; n5 < r7; n5 += 1) {
        var i7 = e11[n5];
        if (t5(i7, n5)) return i7;
      }
    }, e10.assign = function(e11) {
      for (var t5, n5, r7 = e11, i7 = arguments.length, o4 = new Array(i7 > 1 ? i7 - 1 : 0), s3 = 1; s3 < i7; s3++) o4[s3 - 1] = arguments[s3];
      if (Object.assign) return Object.assign.apply(Object, [e11].concat(o4));
      var a4 = function() {
        var e12 = o4[t5];
        "object" == typeof e12 && null !== e12 && Object.keys(e12).forEach((function(t6) {
          r7[t6] = e12[t6];
        }));
      };
      for (t5 = 0, n5 = o4.length; t5 < n5; t5 += 1) a4();
      return e11;
    }, e10.getBrowserAlias = function(e11) {
      return r6.BROWSER_ALIASES_MAP[e11];
    }, e10.getBrowserTypeByAlias = function(e11) {
      return r6.BROWSER_MAP[e11] || "";
    }, e10;
  })();
  t4.default = i6, e9.exports = t4.default;
}, 18: function(e9, t4, n4) {
  t4.__esModule = true, t4.ENGINE_MAP = t4.OS_MAP = t4.PLATFORMS_MAP = t4.BROWSER_MAP = t4.BROWSER_ALIASES_MAP = void 0, t4.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" }, t4.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" }, t4.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" }, t4.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" }, t4.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
}, 90: function(e9, t4, n4) {
  t4.__esModule = true, t4.default = void 0;
  var r6, i6 = (r6 = n4(91)) && r6.__esModule ? r6 : { default: r6 }, o4 = n4(18);
  function s3(e10, t5) {
    for (var n5 = 0; n5 < t5.length; n5++) {
      var r7 = t5[n5];
      r7.enumerable = r7.enumerable || false, r7.configurable = true, "value" in r7 && (r7.writable = true), Object.defineProperty(e10, r7.key, r7);
    }
  }
  var a4 = (function() {
    function e10() {
    }
    var t5, n5, r7;
    return e10.getParser = function(e11, t6) {
      if (void 0 === t6 && (t6 = false), "string" != typeof e11) throw new Error("UserAgent should be a string");
      return new i6.default(e11, t6);
    }, e10.parse = function(e11) {
      return new i6.default(e11).getResult();
    }, t5 = e10, r7 = [{ key: "BROWSER_MAP", get: function() {
      return o4.BROWSER_MAP;
    } }, { key: "ENGINE_MAP", get: function() {
      return o4.ENGINE_MAP;
    } }, { key: "OS_MAP", get: function() {
      return o4.OS_MAP;
    } }, { key: "PLATFORMS_MAP", get: function() {
      return o4.PLATFORMS_MAP;
    } }], (n5 = null) && s3(t5.prototype, n5), r7 && s3(t5, r7), e10;
  })();
  t4.default = a4, e9.exports = t4.default;
}, 91: function(e9, t4, n4) {
  t4.__esModule = true, t4.default = void 0;
  var r6 = c6(n4(92)), i6 = c6(n4(93)), o4 = c6(n4(94)), s3 = c6(n4(95)), a4 = c6(n4(17));
  function c6(e10) {
    return e10 && e10.__esModule ? e10 : { default: e10 };
  }
  var l6 = (function() {
    function e10(e11, t6) {
      if (void 0 === t6 && (t6 = false), null == e11 || "" === e11) throw new Error("UserAgent parameter can't be empty");
      this._ua = e11, this.parsedResult = {}, true !== t6 && this.parse();
    }
    var t5 = e10.prototype;
    return t5.getUA = function() {
      return this._ua;
    }, t5.test = function(e11) {
      return e11.test(this._ua);
    }, t5.parseBrowser = function() {
      var e11 = this;
      this.parsedResult.browser = {};
      var t6 = a4.default.find(r6.default, (function(t7) {
        if ("function" == typeof t7.test) return t7.test(e11);
        if (t7.test instanceof Array) return t7.test.some((function(t8) {
          return e11.test(t8);
        }));
        throw new Error("Browser's test function is not valid");
      }));
      return t6 && (this.parsedResult.browser = t6.describe(this.getUA())), this.parsedResult.browser;
    }, t5.getBrowser = function() {
      return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
    }, t5.getBrowserName = function(e11) {
      return e11 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
    }, t5.getBrowserVersion = function() {
      return this.getBrowser().version;
    }, t5.getOS = function() {
      return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
    }, t5.parseOS = function() {
      var e11 = this;
      this.parsedResult.os = {};
      var t6 = a4.default.find(i6.default, (function(t7) {
        if ("function" == typeof t7.test) return t7.test(e11);
        if (t7.test instanceof Array) return t7.test.some((function(t8) {
          return e11.test(t8);
        }));
        throw new Error("Browser's test function is not valid");
      }));
      return t6 && (this.parsedResult.os = t6.describe(this.getUA())), this.parsedResult.os;
    }, t5.getOSName = function(e11) {
      var t6 = this.getOS().name;
      return e11 ? String(t6).toLowerCase() || "" : t6 || "";
    }, t5.getOSVersion = function() {
      return this.getOS().version;
    }, t5.getPlatform = function() {
      return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
    }, t5.getPlatformType = function(e11) {
      void 0 === e11 && (e11 = false);
      var t6 = this.getPlatform().type;
      return e11 ? String(t6).toLowerCase() || "" : t6 || "";
    }, t5.parsePlatform = function() {
      var e11 = this;
      this.parsedResult.platform = {};
      var t6 = a4.default.find(o4.default, (function(t7) {
        if ("function" == typeof t7.test) return t7.test(e11);
        if (t7.test instanceof Array) return t7.test.some((function(t8) {
          return e11.test(t8);
        }));
        throw new Error("Browser's test function is not valid");
      }));
      return t6 && (this.parsedResult.platform = t6.describe(this.getUA())), this.parsedResult.platform;
    }, t5.getEngine = function() {
      return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
    }, t5.getEngineName = function(e11) {
      return e11 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
    }, t5.parseEngine = function() {
      var e11 = this;
      this.parsedResult.engine = {};
      var t6 = a4.default.find(s3.default, (function(t7) {
        if ("function" == typeof t7.test) return t7.test(e11);
        if (t7.test instanceof Array) return t7.test.some((function(t8) {
          return e11.test(t8);
        }));
        throw new Error("Browser's test function is not valid");
      }));
      return t6 && (this.parsedResult.engine = t6.describe(this.getUA())), this.parsedResult.engine;
    }, t5.parse = function() {
      return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
    }, t5.getResult = function() {
      return a4.default.assign({}, this.parsedResult);
    }, t5.satisfies = function(e11) {
      var t6 = this, n5 = {}, r7 = 0, i7 = {}, o5 = 0;
      if (Object.keys(e11).forEach((function(t7) {
        var s5 = e11[t7];
        "string" == typeof s5 ? (i7[t7] = s5, o5 += 1) : "object" == typeof s5 && (n5[t7] = s5, r7 += 1);
      })), r7 > 0) {
        var s4 = Object.keys(n5), c7 = a4.default.find(s4, (function(e12) {
          return t6.isOS(e12);
        }));
        if (c7) {
          var l7 = this.satisfies(n5[c7]);
          if (void 0 !== l7) return l7;
        }
        var d5 = a4.default.find(s4, (function(e12) {
          return t6.isPlatform(e12);
        }));
        if (d5) {
          var u6 = this.satisfies(n5[d5]);
          if (void 0 !== u6) return u6;
        }
      }
      if (o5 > 0) {
        var h7 = Object.keys(i7), f12 = a4.default.find(h7, (function(e12) {
          return t6.isBrowser(e12, true);
        }));
        if (void 0 !== f12) return this.compareVersion(i7[f12]);
      }
    }, t5.isBrowser = function(e11, t6) {
      void 0 === t6 && (t6 = false);
      var n5 = this.getBrowserName().toLowerCase(), r7 = e11.toLowerCase(), i7 = a4.default.getBrowserTypeByAlias(r7);
      return t6 && i7 && (r7 = i7.toLowerCase()), r7 === n5;
    }, t5.compareVersion = function(e11) {
      var t6 = [0], n5 = e11, r7 = false, i7 = this.getBrowserVersion();
      if ("string" == typeof i7) return ">" === e11[0] || "<" === e11[0] ? (n5 = e11.substr(1), "=" === e11[1] ? (r7 = true, n5 = e11.substr(2)) : t6 = [], ">" === e11[0] ? t6.push(1) : t6.push(-1)) : "=" === e11[0] ? n5 = e11.substr(1) : "~" === e11[0] && (r7 = true, n5 = e11.substr(1)), t6.indexOf(a4.default.compareVersions(i7, n5, r7)) > -1;
    }, t5.isOS = function(e11) {
      return this.getOSName(true) === String(e11).toLowerCase();
    }, t5.isPlatform = function(e11) {
      return this.getPlatformType(true) === String(e11).toLowerCase();
    }, t5.isEngine = function(e11) {
      return this.getEngineName(true) === String(e11).toLowerCase();
    }, t5.is = function(e11, t6) {
      return void 0 === t6 && (t6 = false), this.isBrowser(e11, t6) || this.isOS(e11) || this.isPlatform(e11);
    }, t5.some = function(e11) {
      var t6 = this;
      return void 0 === e11 && (e11 = []), e11.some((function(e12) {
        return t6.is(e12);
      }));
    }, e10;
  })();
  t4.default = l6, e9.exports = t4.default;
}, 92: function(e9, t4, n4) {
  t4.__esModule = true, t4.default = void 0;
  var r6, i6 = (r6 = n4(17)) && r6.__esModule ? r6 : { default: r6 }, o4 = /version\/(\d+(\.?_?\d+)+)/i, s3 = [{ test: [/googlebot/i], describe: function(e10) {
    var t5 = { name: "Googlebot" }, n5 = i6.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/opera/i], describe: function(e10) {
    var t5 = { name: "Opera" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/opr\/|opios/i], describe: function(e10) {
    var t5 = { name: "Opera" }, n5 = i6.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/SamsungBrowser/i], describe: function(e10) {
    var t5 = { name: "Samsung Internet for Android" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/Whale/i], describe: function(e10) {
    var t5 = { name: "NAVER Whale Browser" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/MZBrowser/i], describe: function(e10) {
    var t5 = { name: "MZ Browser" }, n5 = i6.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/focus/i], describe: function(e10) {
    var t5 = { name: "Focus" }, n5 = i6.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/swing/i], describe: function(e10) {
    var t5 = { name: "Swing" }, n5 = i6.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/coast/i], describe: function(e10) {
    var t5 = { name: "Opera Coast" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e10) {
    var t5 = { name: "Opera Touch" }, n5 = i6.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/yabrowser/i], describe: function(e10) {
    var t5 = { name: "Yandex Browser" }, n5 = i6.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/ucbrowser/i], describe: function(e10) {
    var t5 = { name: "UC Browser" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/Maxthon|mxios/i], describe: function(e10) {
    var t5 = { name: "Maxthon" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/epiphany/i], describe: function(e10) {
    var t5 = { name: "Epiphany" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/puffin/i], describe: function(e10) {
    var t5 = { name: "Puffin" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/sleipnir/i], describe: function(e10) {
    var t5 = { name: "Sleipnir" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/k-meleon/i], describe: function(e10) {
    var t5 = { name: "K-Meleon" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/micromessenger/i], describe: function(e10) {
    var t5 = { name: "WeChat" }, n5 = i6.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/qqbrowser/i], describe: function(e10) {
    var t5 = { name: /qqbrowserlite/i.test(e10) ? "QQ Browser Lite" : "QQ Browser" }, n5 = i6.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/msie|trident/i], describe: function(e10) {
    var t5 = { name: "Internet Explorer" }, n5 = i6.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/\sedg\//i], describe: function(e10) {
    var t5 = { name: "Microsoft Edge" }, n5 = i6.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/edg([ea]|ios)/i], describe: function(e10) {
    var t5 = { name: "Microsoft Edge" }, n5 = i6.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/vivaldi/i], describe: function(e10) {
    var t5 = { name: "Vivaldi" }, n5 = i6.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/seamonkey/i], describe: function(e10) {
    var t5 = { name: "SeaMonkey" }, n5 = i6.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/sailfish/i], describe: function(e10) {
    var t5 = { name: "Sailfish" }, n5 = i6.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/silk/i], describe: function(e10) {
    var t5 = { name: "Amazon Silk" }, n5 = i6.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/phantom/i], describe: function(e10) {
    var t5 = { name: "PhantomJS" }, n5 = i6.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/slimerjs/i], describe: function(e10) {
    var t5 = { name: "SlimerJS" }, n5 = i6.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e10) {
    var t5 = { name: "BlackBerry" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e10) {
    var t5 = { name: "WebOS Browser" }, n5 = i6.default.getFirstMatch(o4, e10) || i6.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/bada/i], describe: function(e10) {
    var t5 = { name: "Bada" }, n5 = i6.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/tizen/i], describe: function(e10) {
    var t5 = { name: "Tizen" }, n5 = i6.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/qupzilla/i], describe: function(e10) {
    var t5 = { name: "QupZilla" }, n5 = i6.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e10) {
    var t5 = { name: "Firefox" }, n5 = i6.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/electron/i], describe: function(e10) {
    var t5 = { name: "Electron" }, n5 = i6.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/MiuiBrowser/i], describe: function(e10) {
    var t5 = { name: "Miui" }, n5 = i6.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/chromium/i], describe: function(e10) {
    var t5 = { name: "Chromium" }, n5 = i6.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e10) || i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/chrome|crios|crmo/i], describe: function(e10) {
    var t5 = { name: "Chrome" }, n5 = i6.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/GSA/i], describe: function(e10) {
    var t5 = { name: "Google Search" }, n5 = i6.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: function(e10) {
    var t5 = !e10.test(/like android/i), n5 = e10.test(/android/i);
    return t5 && n5;
  }, describe: function(e10) {
    var t5 = { name: "Android Browser" }, n5 = i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/playstation 4/i], describe: function(e10) {
    var t5 = { name: "PlayStation 4" }, n5 = i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/safari|applewebkit/i], describe: function(e10) {
    var t5 = { name: "Safari" }, n5 = i6.default.getFirstMatch(o4, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/.*/i], describe: function(e10) {
    var t5 = -1 !== e10.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
    return { name: i6.default.getFirstMatch(t5, e10), version: i6.default.getSecondMatch(t5, e10) };
  } }];
  t4.default = s3, e9.exports = t4.default;
}, 93: function(e9, t4, n4) {
  t4.__esModule = true, t4.default = void 0;
  var r6, i6 = (r6 = n4(17)) && r6.__esModule ? r6 : { default: r6 }, o4 = n4(18), s3 = [{ test: [/Roku\/DVP/], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e10);
    return { name: o4.OS_MAP.Roku, version: t5 };
  } }, { test: [/windows phone/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e10);
    return { name: o4.OS_MAP.WindowsPhone, version: t5 };
  } }, { test: [/windows /i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e10), n5 = i6.default.getWindowsVersionName(t5);
    return { name: o4.OS_MAP.Windows, version: t5, versionName: n5 };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e10) {
    var t5 = { name: o4.OS_MAP.iOS }, n5 = i6.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/macintosh/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e10).replace(/[_\s]/g, "."), n5 = i6.default.getMacOSVersionName(t5), r7 = { name: o4.OS_MAP.MacOS, version: t5 };
    return n5 && (r7.versionName = n5), r7;
  } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e10).replace(/[_\s]/g, ".");
    return { name: o4.OS_MAP.iOS, version: t5 };
  } }, { test: function(e10) {
    var t5 = !e10.test(/like android/i), n5 = e10.test(/android/i);
    return t5 && n5;
  }, describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e10), n5 = i6.default.getAndroidVersionName(t5), r7 = { name: o4.OS_MAP.Android, version: t5 };
    return n5 && (r7.versionName = n5), r7;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e10), n5 = { name: o4.OS_MAP.WebOS };
    return t5 && t5.length && (n5.version = t5), n5;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e10) || i6.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e10) || i6.default.getFirstMatch(/\bbb(\d+)/i, e10);
    return { name: o4.OS_MAP.BlackBerry, version: t5 };
  } }, { test: [/bada/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e10);
    return { name: o4.OS_MAP.Bada, version: t5 };
  } }, { test: [/tizen/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e10);
    return { name: o4.OS_MAP.Tizen, version: t5 };
  } }, { test: [/linux/i], describe: function() {
    return { name: o4.OS_MAP.Linux };
  } }, { test: [/CrOS/], describe: function() {
    return { name: o4.OS_MAP.ChromeOS };
  } }, { test: [/PlayStation 4/], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e10);
    return { name: o4.OS_MAP.PlayStation4, version: t5 };
  } }];
  t4.default = s3, e9.exports = t4.default;
}, 94: function(e9, t4, n4) {
  t4.__esModule = true, t4.default = void 0;
  var r6, i6 = (r6 = n4(17)) && r6.__esModule ? r6 : { default: r6 }, o4 = n4(18), s3 = [{ test: [/googlebot/i], describe: function() {
    return { type: "bot", vendor: "Google" };
  } }, { test: [/huawei/i], describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/(can-l01)/i, e10) && "Nova", n5 = { type: o4.PLATFORMS_MAP.mobile, vendor: "Huawei" };
    return t5 && (n5.model = t5), n5;
  } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
    return { type: o4.PLATFORMS_MAP.tablet, vendor: "Nexus" };
  } }, { test: [/ipad/i], describe: function() {
    return { type: o4.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
    return { type: o4.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/kftt build/i], describe: function() {
    return { type: o4.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
  } }, { test: [/silk/i], describe: function() {
    return { type: o4.PLATFORMS_MAP.tablet, vendor: "Amazon" };
  } }, { test: [/tablet(?! pc)/i], describe: function() {
    return { type: o4.PLATFORMS_MAP.tablet };
  } }, { test: function(e10) {
    var t5 = e10.test(/ipod|iphone/i), n5 = e10.test(/like (ipod|iphone)/i);
    return t5 && !n5;
  }, describe: function(e10) {
    var t5 = i6.default.getFirstMatch(/(ipod|iphone)/i, e10);
    return { type: o4.PLATFORMS_MAP.mobile, vendor: "Apple", model: t5 };
  } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
    return { type: o4.PLATFORMS_MAP.mobile, vendor: "Nexus" };
  } }, { test: [/[^-]mobi/i], describe: function() {
    return { type: o4.PLATFORMS_MAP.mobile };
  } }, { test: function(e10) {
    return "blackberry" === e10.getBrowserName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
  } }, { test: function(e10) {
    return "bada" === e10.getBrowserName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.mobile };
  } }, { test: function(e10) {
    return "windows phone" === e10.getBrowserName();
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
  } }, { test: function(e10) {
    var t5 = Number(String(e10.getOSVersion()).split(".")[0]);
    return "android" === e10.getOSName(true) && t5 >= 3;
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.tablet };
  } }, { test: function(e10) {
    return "android" === e10.getOSName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.mobile };
  } }, { test: function(e10) {
    return "macos" === e10.getOSName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.desktop, vendor: "Apple" };
  } }, { test: function(e10) {
    return "windows" === e10.getOSName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.desktop };
  } }, { test: function(e10) {
    return "linux" === e10.getOSName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.desktop };
  } }, { test: function(e10) {
    return "playstation 4" === e10.getOSName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.tv };
  } }, { test: function(e10) {
    return "roku" === e10.getOSName(true);
  }, describe: function() {
    return { type: o4.PLATFORMS_MAP.tv };
  } }];
  t4.default = s3, e9.exports = t4.default;
}, 95: function(e9, t4, n4) {
  t4.__esModule = true, t4.default = void 0;
  var r6, i6 = (r6 = n4(17)) && r6.__esModule ? r6 : { default: r6 }, o4 = n4(18), s3 = [{ test: function(e10) {
    return "microsoft edge" === e10.getBrowserName(true);
  }, describe: function(e10) {
    if (/\sedg\//i.test(e10)) return { name: o4.ENGINE_MAP.Blink };
    var t5 = i6.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e10);
    return { name: o4.ENGINE_MAP.EdgeHTML, version: t5 };
  } }, { test: [/trident/i], describe: function(e10) {
    var t5 = { name: o4.ENGINE_MAP.Trident }, n5 = i6.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: function(e10) {
    return e10.test(/presto/i);
  }, describe: function(e10) {
    var t5 = { name: o4.ENGINE_MAP.Presto }, n5 = i6.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: function(e10) {
    var t5 = e10.test(/gecko/i), n5 = e10.test(/like gecko/i);
    return t5 && !n5;
  }, describe: function(e10) {
    var t5 = { name: o4.ENGINE_MAP.Gecko }, n5 = i6.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
    return { name: o4.ENGINE_MAP.Blink };
  } }, { test: [/(apple)?webkit/i], describe: function(e10) {
    var t5 = { name: o4.ENGINE_MAP.WebKit }, n5 = i6.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e10);
    return n5 && (t5.version = n5), t5;
  } }];
  t4.default = s3, e9.exports = t4.default;
} });
var Wu = ue6(qu.exports);
var Vu = { Initialized: "initialized", DisplayURI: "display_uri", ProviderUpdate: "provider_update", ConnectWithResponse: "connectWithResponse", ConnectionStatus: "connection_status", ServiceStatus: "service_status" };
var Gu = class _Gu {
  constructor({ shouldSetOnWindow: e9, connectionStream: t4, shouldSendMetadata: n4 = false, shouldShimWeb3: r6, sdkInstance: i6 }) {
    const o4 = new Ju({ connectionStream: t4, shouldSendMetadata: n4, shouldSetOnWindow: e9, shouldShimWeb3: r6, autoRequestAccounts: false }), s3 = new Proxy(o4, { deleteProperty: () => true });
    if (this.provider = s3, this.sdkInstance = i6, e9 && "undefined" != typeof window) try {
      a4 = o4, window.ethereum = a4, window.dispatchEvent(new Event("ethereum#initialized"));
    } catch (e10) {
      Iu("[Ethereum] Unable to set global provider - window.ethereum may be read-only", e10);
    }
    var a4;
    if (r6 && "undefined" != typeof window) try {
      !(function(e10, t5 = console) {
        let n5 = false, r7 = false;
        if (!window.web3) {
          const i7 = "__isMetaMaskShim__";
          let o5 = { currentProvider: e10 };
          Object.defineProperty(o5, i7, { value: true, enumerable: true, configurable: false, writable: false }), o5 = new Proxy(o5, { get: (o6, s4, ...a5) => ("currentProvider" !== s4 || n5 ? "currentProvider" === s4 || s4 === i7 || r7 || (r7 = true, t5.error("MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), e10.request({ method: "metamask_logWeb3ShimUsage" }).catch(((e11) => {
            t5.debug("MetaMask: Failed to log web3 shim usage.", e11);
          }))) : (n5 = true, t5.warn("You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3")), Reflect.get(o6, s4, ...a5)), set: (...e11) => (t5.warn("You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), Reflect.set(...e11)) }), Object.defineProperty(window, "web3", { value: o5, enumerable: false, configurable: true, writable: true });
        }
      })(this.provider);
    } catch (e10) {
      Iu("[Ethereum] Unable to shim web3 - window.web3 may be read-only", e10);
    }
    this.provider.on("display_uri", ((e10) => {
      this.sdkInstance.emit(Vu.DisplayURI, e10);
    })), this.provider.on("_initialized", (() => {
      const e10 = { chainId: this.provider.getChainId(), isConnected: this.provider.isConnected(), isMetaMask: this.provider.isMetaMask, selectedAddress: this.provider.getSelectedAddress(), networkVersion: this.provider.getNetworkVersion() };
      this.sdkInstance.emit(Vu.Initialized, e10), Iu("[Ethereum: constructor()] provider initialized", e10);
    }));
  }
  static init(e9) {
    var t4;
    return Iu("[Ethereum: init()] Initializing Ethereum service"), this.instance = new _Gu(e9), null === (t4 = this.instance) || void 0 === t4 ? void 0 : t4.provider;
  }
  static destroy() {
  }
  static getInstance() {
    var e9;
    if (!(null === (e9 = this.instance) || void 0 === e9 ? void 0 : e9.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance;
  }
  static getProvider() {
    var e9;
    if (!(null === (e9 = this.instance) || void 0 === e9 ? void 0 : e9.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance.provider;
  }
};
var Yu = class _Yu {
  constructor({ useDeepLink: e9, preferredOpenLink: t4, debug: n4 = false }) {
    this.state = { platformType: void 0, useDeeplink: false, preferredOpenLink: void 0, debug: false }, this.state.platformType = this.getPlatformType(), this.state.useDeeplink = e9, this.state.preferredOpenLink = t4, this.state.debug = n4;
  }
  openDeeplink(e9, t4, n4) {
    return (function(e10, t5, n5, r6) {
      const { state: i6 } = e10;
      Iu(`[PlatfformManager: openDeeplink()] universalLink --> ${t5}`), Iu(`[PlatfformManager: openDeeplink()] deepLink --> ${n5}`);
      try {
        if (i6.preferredOpenLink) return void i6.preferredOpenLink(i6.useDeeplink ? n5 : t5, r6);
        if (Iu(`[PlatfformManager: openDeeplink()] open link now useDeepLink=${i6.useDeeplink} link=${i6.useDeeplink ? n5 : t5}`), i6.useDeeplink) "undefined" != typeof window && (window.location.href = n5);
        else if ("undefined" != typeof document) {
          const e11 = document.createElement("a");
          e11.href = t5, e11.target = "_self", e11.rel = "noreferrer noopener", e11.click();
        }
      } catch (e11) {
        console.log("[PlatfformManager: openDeeplink()] can't open link", e11);
      }
    })(this, e9, t4, n4);
  }
  isReactNative() {
    var e9;
    return this.isNotBrowser() && "undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.navigator) && "ReactNative" === (null === (e9 = window.navigator) || void 0 === e9 ? void 0 : e9.product);
  }
  isMetaMaskInstalled() {
    return (function() {
      const e9 = Gu.getProvider() || (null === window || void 0 === window ? void 0 : window.ethereum);
      return Iu(`[PlatfformManager: isMetaMaskInstalled()] isMetaMask=${null == e9 ? void 0 : e9.isMetaMask} isConnected=${null == e9 ? void 0 : e9.isConnected()}`), (null == e9 ? void 0 : e9.isMetaMask) && (null == e9 ? void 0 : e9.isConnected());
    })();
  }
  isDesktopWeb() {
    return this.isBrowser() && !this.isMobileWeb();
  }
  isMobile() {
    var e9, t4;
    const n4 = Wu.parse(window.navigator.userAgent);
    return "mobile" === (null === (e9 = null == n4 ? void 0 : n4.platform) || void 0 === e9 ? void 0 : e9.type) || "tablet" === (null === (t4 = null == n4 ? void 0 : n4.platform) || void 0 === t4 ? void 0 : t4.type);
  }
  isSecure() {
    return this.isReactNative() || this.isMobileWeb();
  }
  isMetaMaskMobileWebView() {
    return "undefined" != typeof window && (Boolean(window.ReactNativeWebView) && Boolean(navigator.userAgent.endsWith("MetaMaskMobile")));
  }
  isMobileWeb() {
    return this.state.platformType === Uo5.MobileWeb;
  }
  static isNotBrowser() {
    var e9;
    return "undefined" == typeof window || !(null === window || void 0 === window ? void 0 : window.navigator) || void 0 !== l5 && "ReactNative" === (null === (e9 = null == l5 ? void 0 : l5.navigator) || void 0 === e9 ? void 0 : e9.product) || "ReactNative" === (null === navigator || void 0 === navigator ? void 0 : navigator.product);
  }
  isNotBrowser() {
    return _Yu.isNotBrowser();
  }
  static isBrowser() {
    return !this.isNotBrowser();
  }
  isBrowser() {
    return _Yu.isBrowser();
  }
  isNodeJS() {
    return this.isNotBrowser() && !this.isReactNative();
  }
  isUseDeepLink() {
    return this.state.useDeeplink;
  }
  getPlatformType() {
    return (function(e9) {
      const { state: t4 } = e9;
      return t4.platformType ? t4.platformType : e9.isReactNative() ? Uo5.ReactNative : e9.isNotBrowser() ? Uo5.NonBrowser : e9.isMetaMaskMobileWebView() ? Uo5.MetaMaskMobileWebview : e9.isMobile() ? Uo5.MobileWeb : Uo5.DesktopWeb;
    })(this);
  }
};
var Zu = (e9) => c5(void 0, void 0, void 0, (function* () {
  if (Yu.isBrowser()) {
    const { StorageManagerWeb: t5 } = yield Promise.resolve().then((function() {
      return cf2;
    }));
    return new t5(e9);
  }
  const t4 = { persistChannelConfig: () => c5(void 0, void 0, void 0, (function* () {
  })), getPersistedChannelConfig: () => c5(void 0, void 0, void 0, (function* () {
  })), persistAccounts: () => c5(void 0, void 0, void 0, (function* () {
  })), getCachedAccounts: () => c5(void 0, void 0, void 0, (function* () {
    return [];
  })), persistChainId: () => c5(void 0, void 0, void 0, (function* () {
  })), getCachedChainId: () => c5(void 0, void 0, void 0, (function* () {
  })), terminate: () => c5(void 0, void 0, void 0, (function* () {
  })) };
  return Promise.resolve(t4);
}));
var Ju = class extends Mu {
  constructor({ connectionStream: e9, shouldSendMetadata: t4, autoRequestAccounts: n4 = false }) {
    super(e9, { logger: console, maxEventListeners: 100, shouldSendMetadata: t4 }), this.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "", networkVersion: "" }, Iu(`[SDKProvider: constructor()] autoRequestAccounts=${n4}`), this.state.autoRequestAccounts = n4;
  }
  forceInitializeState() {
    return c5(this, void 0, void 0, (function* () {
      return Iu(`[SDKProvider: forceInitializeState()] autoRequestAccounts=${this.state.autoRequestAccounts}`), this._initializeStateAsync();
    }));
  }
  _setConnected() {
    Iu("[SDKProvider: _setConnected()] Setting connected state"), this._state.isConnected = true;
  }
  getState() {
    return this._state;
  }
  getSDKProviderState() {
    return this.state;
  }
  getSelectedAddress() {
    var e9;
    const { accounts: t4 } = this._state;
    return t4 && 0 !== t4.length ? (null === (e9 = t4[0]) || void 0 === e9 ? void 0 : e9.toLowerCase()) || "" : (Iu("[SDKProvider: getSelectedAddress] No accounts found"), null);
  }
  getChainId() {
    return this.state.chainId;
  }
  getNetworkVersion() {
    return this.state.networkVersion;
  }
  setSDKProviderState(e9) {
    this.state = Object.assign(Object.assign({}, this.state), e9);
  }
  handleAccountsChanged(e9, t4) {
    return this._handleAccountsChanged(e9, t4);
  }
  handleDisconnect({ terminate: e9 = false }) {
    !(function({ terminate: e10 = false, instance: t4 }) {
      const { state: n4 } = t4;
      Iu(`[SDKProvider: handleDisconnect()] cleaning up provider state terminate=${e10}`, t4), e10 && (t4._state.accounts = null, t4._state.isUnlocked = false, t4._state.isPermanentlyDisconnected = true, t4._state.initialized = false), t4._handleAccountsChanged([]), t4._state.isConnected = false, t4.emit("disconnect", Ru.ethErrors.provider.disconnected()), n4.providerStateRequested = false;
    })({ terminate: e9, instance: this });
  }
  _initializeStateAsync() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        var t4, n4;
        return c5(this, void 0, void 0, (function* () {
          void 0 === e9.state && (e9.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "" });
          const { state: r6 } = e9;
          let i6;
          if (r6.providerStateRequested) Iu("[SDKProvider: initializeStateAsync()] initialization already in progress");
          else {
            let o4;
            r6.providerStateRequested = true;
            let s3 = null, a4 = false, c6 = false;
            const l6 = yield Zu({ enabled: true });
            if (l6) {
              const e10 = yield l6.getPersistedChannelConfig({});
              a4 = null !== (t4 = null == e10 ? void 0 : e10.relayPersistence) && void 0 !== t4 && t4, o4 = yield l6.getCachedChainId();
              const n5 = yield l6.getCachedAccounts();
              n5.length > 0 && (s3 = n5[0]);
            }
            if (Iu(`[SDKProvider: initializeStateAsync()] relayPersistence=${a4}`, { relayPersistence: a4, cachedChainId: o4, cachedSelectedAddress: s3 }), a4) if (o4 && s3) i6 = { accounts: [s3], chainId: o4, isUnlocked: false }, c6 = true;
            else try {
              i6 = yield e9.request({ method: "metamask_getProviderState" });
            } catch (t5) {
              return e9._log.error("MetaMask: Failed to get initial state. Please report this bug.", t5), void (r6.providerStateRequested = false);
            }
            if (0 === (null === (n4 = null == i6 ? void 0 : i6.accounts) || void 0 === n4 ? void 0 : n4.length)) if (e9.getSelectedAddress()) i6.accounts = [e9.getSelectedAddress()];
            else {
              Iu("[SDKProvider: initializeStateAsync()] Fetch accounts remotely.");
              const t5 = yield e9.request({ method: "eth_requestAccounts", params: [] });
              i6.accounts = t5;
            }
            e9._initializeState(i6), r6.providerStateRequested = false, c6 && (e9._state.isConnected = true, e9.emit("connect", { chainId: null == i6 ? void 0 : i6.chainId }));
          }
        }));
      })(this);
    }));
  }
  _initializeState(e9) {
    return Iu("[SDKProvider: _initializeState()]", e9), (function(e10, t4, n4) {
      return Iu("[SDKProvider: initializeState()] set state._initialized to false"), e10._state.initialized = false, t4(n4);
    })(this, super._initializeState.bind(this), e9);
  }
  _handleChainChanged({ chainId: e9, networkVersion: t4 } = {}) {
    this.state.chainId = e9, this.state.networkVersion = t4, (function({ instance: e10, chainId: t5, networkVersion: r6, superHandleChainChanged: i6 }) {
      Iu(`[SDKProvider: handleChainChanged()] chainId=${t5} networkVersion=${r6}`);
      let o4 = r6;
      r6 || (Iu("[SDKProvider: handleChainChanged()] forced network version to prevent provider error"), o4 = "1"), t5 !== Tu && (import_sdk_analytics.analytics.track("sdk_used_chain", { caip_chain_id: `eip155:${parseInt(null != t5 ? t5 : "0x1", 16)}` }), Tu = t5), e10._state.isConnected = true, e10.emit("connect", { chainId: t5 }), i6({ chainId: t5, networkVersion: o4 });
    })({ instance: this, chainId: e9, networkVersion: t4, superHandleChainChanged: super._handleChainChanged.bind(this) });
  }
};
var Qu;
var Xu = { name: "@metamask/sdk", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk", directory: "packages/sdk" }, main: "dist/node/cjs/metamask-sdk.js", module: "dist/browser/es/metamask-sdk.js", browser: "dist/browser/es/metamask-sdk.js", unpkg: "dist/browser/umd/metamask-sdk.js", "react-native": "dist/react-native/es/metamask-sdk.js", types: "dist/types/src/index.d.ts", sideEffects: false, files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:clean": "yarn clean && yarn build", "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", typecheck: "tsc --noEmit", clean: "rimraf ./dist", size: "node bundle-size && size-limit", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", prepack: "../../scripts/prepack.sh", "publish:preview": "yarn npm publish --tag preview", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:coverage": 'jest --coverage --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": 'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns "/e2e/"', watch: "rollup -c -w", dev: 'concurrently "tsc --watch" "rollup -c -w --bundleConfigAsCjs"', "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs" }, dependencies: { "@babel/runtime": "^7.26.0", "@metamask/onboarding": "^1.0.1", "@metamask/providers": "16.1.0", "@metamask/sdk-analytics": "workspace:*", "@metamask/sdk-communication-layer": "workspace:*", "@metamask/sdk-install-modal-web": "workspace:*", "@paulmillr/qr": "^0.2.1", bowser: "^2.9.0", "cross-fetch": "^4.0.0", debug: "^4.3.4", eciesjs: "^0.4.11", "eth-rpc-errors": "^4.0.3", eventemitter2: "^6.4.9", "obj-multiplex": "^1.0.0", pump: "^3.0.0", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1", tslib: "^2.6.0", util: "^0.12.4", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@react-native-async-storage/async-storage": "^1.19.6", "@rollup/plugin-alias": "^5.1.1", "@rollup/plugin-commonjs": "^25.0.7", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.1", "@size-limit/preset-big-lib": "^11.0.2", "@types/dom-screen-wake-lock": "^1.0.2", "@types/node": "^20.1.3", "@types/pump": "^1.1.1", "@types/qrcode-terminal": "^0.12.0", "@types/uuid": "^10.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", "browserify-zlib": "^0.2.0", buffer: "^6.0.3", concurrently: "^9.1.2", "crypto-browserify": "^3.12.0", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", "https-browserify": "^1.0.0", jest: "^29.3.1", "jest-environment-jsdom": "^29.3.1", prettier: "^2.3.0", process: "^0.11.10", rimraf: "^4.4.0", rollup: "^4.26.0", "rollup-plugin-analyzer": "^4.0.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.0.2", "stream-browserify": "^3.0.0", "stream-http": "^3.2.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^4.3.2", url: "^0.11.0", webpack: "^5.0.0" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, "@metamask/sdk-communication-layer>bufferutil": false, "@metamask/sdk-communication-layer>eciesjs>secp256k1": false, "@metamask/sdk-communication-layer>utf-8-validate": false } } };
!(function(e9) {
  e9.INPAGE = "metamask-inpage", e9.CONTENT_SCRIPT = "metamask-contentscript", e9.PROVIDER = "metamask-provider";
})(Qu || (Qu = {}));
var eh = "direct";
var th = "https://metamask.app.link/connect";
var nh = "metamask://connect";
var rh = { NAME: "MetaMask", RDNS: ["io.metamask", "io.metamask.flask"] };
var ih = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u;
var oh = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", WALLET_SWITCHETHETHEREUMCHAIN: "wallet_switchEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var sh = { [oh.ETH_REQUESTACCOUNTS]: true, [oh.ETH_SENDTRANSACTION]: true, [oh.ETH_SIGNTRANSACTION]: true, [oh.ETH_SIGN]: true, [oh.PERSONAL_SIGN]: true, [oh.ETH_ACCOUNTS]: false, [oh.ETH_CHAINID]: false, [oh.PERSONAL_SIGN]: true, [oh.ETH_SIGNTYPEDDATA]: true, [oh.ETH_SIGNTYPEDDATA_V3]: true, [oh.ETH_SIGNTYPEDDATA_V4]: true, [oh.WALLET_REQUESTPERMISSIONS]: true, [oh.WALLET_GETPERMISSIONS]: true, [oh.WALLET_WATCHASSET]: true, [oh.WALLET_ADDETHEREUMCHAIN]: true, [oh.WALLET_SWITCHETHETHEREUMCHAIN]: true, [oh.METAMASK_CONNECTSIGN]: true, [oh.METAMASK_CONNECTWITH]: true, [oh.PERSONAL_EC_RECOVER]: true, [oh.METAMASK_BATCH]: true, [oh.METAMASK_OPEN]: true };
var ah = Object.keys(sh).filter(((e9) => true === sh[e9])).map(((e9) => e9.toLowerCase()));
var ch = ["eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sign"].map(((e9) => e9.toLowerCase()));
var lh = ".sdk-comm";
var dh = "providerType";
var uh = ".MMSDK_cached_address";
var hh = ".MMSDK_cached_chainId";
var fh = { CHAIN_CHANGED: "chainChanged", ACCOUNTS_CHANGED: "accountsChanged", DISCONNECT: "disconnect", CONNECT: "connect", CONNECTED: "connected" };
var ph = 1e6;
var gh;
!(function(e9) {
  e9.TERMINATE = "terminate", e9.EXTENSION = "extension", e9.INITIALIZED = "initialized";
})(gh || (gh = {}));
var mh = "undefined" != typeof window && window.localStorage;
function yh({ instance: e9, msg: t4 }) {
  return c5(this, void 0, void 0, (function* () {
    if (e9._initialized || (Iu("[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()"), yield e9.init()), Iu(`[MetaMaskSDK: connectAndSign()] activeProvider=${e9.activeProvider}`), !e9.activeProvider) throw new Error("SDK state invalid -- undefined provider");
    const n4 = /^0x([0-9A-Fa-f]{2})*$/u.test(t4) ? t4 : (function(e10) {
      let t5;
      if (void 0 !== C7) t5 = C7.from(e10, "utf8").toString("hex");
      else if ("undefined" != typeof TextEncoder) {
        const n5 = new TextEncoder().encode(e10);
        t5 = Array.from(n5).map(((e11) => e11.toString(16).padStart(2, "0"))).join("");
      } else {
        if ("object" != typeof l5 || !("Buffer" in l5)) throw new Error("Unable to convert string to hex: No available method.");
        t5 = l5.Buffer.from(e10, "utf8").toString("hex");
      }
      return `0x${t5}`;
    })(t4);
    return e9.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [{ method: oh.PERSONAL_SIGN, params: [n4] }] });
  }));
}
function vh(e9) {
  var t4, n4;
  return c5(this, void 0, void 0, (function* () {
    Iu("[MetaMaskSDK: connectWithExtensionProvider()] ", e9), e9.sdkProvider = e9.activeProvider, e9.activeProvider = window.extension, window.ethereum = window.extension;
    try {
      const e10 = yield null === (t4 = window.extension) || void 0 === t4 ? void 0 : t4.request({ method: "eth_requestAccounts" });
      Iu(`[MetaMaskSDK: connectWithExtensionProvider()] accounts=${e10}`);
    } catch (e10) {
      return void console.warn("[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error", e10);
    }
    localStorage.setItem(dh, "extension"), e9.extensionActive = true, e9.emit(Vu.ProviderUpdate, gh.EXTENSION), e9.options.enableAnalytics && (null === (n4 = e9.analytics) || void 0 === n4 || n4.send({ event: Ao5.SDK_USE_EXTENSION }));
  }));
}
function bh(e9) {
  let t4;
  if (void 0 !== C7) t4 = C7.from(e9, "utf8").toString("base64");
  else if ("function" == typeof btoa) t4 = btoa(encodeURIComponent(e9).replace(/%([0-9A-F]{2})/gu, ((e10, t5) => String.fromCharCode(parseInt(t5, 16)))));
  else {
    if ("object" != typeof l5 || !("Buffer" in l5)) throw new Error("Unable to base64 encode: No available method.");
    t4 = l5.Buffer.from(e9, "utf8").toString("base64");
  }
  return t4;
}
function wh(e9, t4, n4, r6) {
  var i6, o4, s3, a4, l6, d5, u6, h7, f12, p7, g3, m5, y8, v7, b5, w6, E7, S7, _4, k8;
  return c5(this, void 0, void 0, (function* () {
    const n5 = null === (i6 = e9.state.remote) || void 0 === i6 ? void 0 : i6.isReady(), c6 = null === (o4 = e9.state.remote) || void 0 === o4 ? void 0 : o4.isConnected(), A8 = null === (s3 = e9.state.remote) || void 0 === s3 ? void 0 : s3.isPaused(), x5 = Gu.getProvider(), M7 = null === (a4 = e9.state.remote) || void 0 === a4 ? void 0 : a4.getChannelId(), I7 = null === (l6 = e9.state.remote) || void 0 === l6 ? void 0 : l6.isAuthorized(), { deeplinkProtocol: T6 } = e9.state, { method: R6, data: P6, triggeredInstaller: O6 } = ((e10) => {
      var t5, n6, r7, i7;
      let o5;
      C7.isBuffer(e10) ? (o5 = e10.toJSON(), o5._isBuffer = true) : o5 = e10;
      const s4 = null === (t5 = null == o5 ? void 0 : o5.data) || void 0 === t5 ? void 0 : t5.method;
      let a5 = false;
      return "object" == typeof (null === (n6 = null == o5 ? void 0 : o5.data) || void 0 === n6 ? void 0 : n6.params) && true === (null === (i7 = null === (r7 = null == o5 ? void 0 : o5.data) || void 0 === r7 ? void 0 : r7.params) || void 0 === i7 ? void 0 : i7.__triggeredInstaller) && (a5 = true, o5.data.params = o5.data.params.wrappedParams), { method: s4, data: o5, triggeredInstaller: a5 };
    })(t4);
    if (Iu(`[RCPMS: write()] method='${R6}' isRemoteReady=${n5} channelId=${M7} isSocketConnected=${c6} isRemotePaused=${A8} providerConnected=${x5.isConnected()}`, t4), !M7) return R6 !== oh.METAMASK_GETPROVIDERSTATE && Iu(`[RCPMS: write()] ${R6} --> channelId is undefined`), r6(new Error("disconnected"));
    Iu(`[RCPMS: write()] remote.isPaused()=${null === (d5 = e9.state.remote) || void 0 === d5 ? void 0 : d5.isPaused()} authorized=${I7} ready=${n5} socketConnected=${c6}`, t4);
    const N8 = null === (u6 = e9.state.platformManager) || void 0 === u6 ? void 0 : u6.isSecure(), L6 = null !== (f12 = null === (h7 = e9.state.platformManager) || void 0 === h7 ? void 0 : h7.isMobileWeb()) && void 0 !== f12 && f12, D9 = null !== (g3 = null === (p7 = e9.state.remote) || void 0 === p7 ? void 0 : p7.hasDeeplinkProtocol()) && void 0 !== g3 && g3 && L6 && I7;
    try {
      if (!O6) {
        const t6 = JSON.stringify(null == P6 ? void 0 : P6.data);
        if (t6.length > ph) return r6(new Error(`Message size ${t6.length} exceeds maximum allowed size of 1000000 bytes`));
        null === (m5 = e9.state.remote) || void 0 === m5 || m5.sendMessage(null == P6 ? void 0 : P6.data).then((() => {
          Iu(`[RCPMS: _write()] ${R6} sent successfully`);
        })).catch(((e10) => {
          Iu("[RCPMS: _write()] error sending message", e10);
        }));
      }
      if (!N8) return Iu(`[RCPMS: _write()] unsecure platform for method ${R6} -- return callback`), r6();
      if (O6) return Iu("[RCPMS: _write()] prevent deeplink -- installation completed separately."), r6();
      const t5 = null !== (b5 = null === (v7 = null === (y8 = e9.state.remote) || void 0 === y8 ? void 0 : y8.getKeyInfo()) || void 0 === v7 ? void 0 : v7.ecies.public) && void 0 !== b5 ? b5 : "";
      let n6 = encodeURI(`channelId=${M7}&pubkey=${t5}&comm=socket&t=d&v=2`);
      if (D9) {
        const t6 = JSON.stringify(null == P6 ? void 0 : P6.data), i7 = null === (w6 = e9.state.remote) || void 0 === w6 ? void 0 : w6.encrypt(t6);
        if (!i7) return Iu("[RCPMS: _write()] error encrypting message"), r6(new Error("RemoteCommunicationPostMessageStream - disconnected"));
        n6 += `&scheme=${T6}&rpc=${bh(i7)}`;
      }
      if (!(null === (E7 = e9.state.platformManager) || void 0 === E7 ? void 0 : E7.isMetaMaskInstalled())) return Iu("[RCPMS: _write()] prevent deeplink until installation is completed."), r6();
      sh[R6] ? (Iu(`[RCPMS: _write()] redirect link for '${R6}' socketConnected=${c6} connect?${n6}`), null === (S7 = e9.state.platformManager) || void 0 === S7 || S7.openDeeplink(`${th}?${n6}`, `${nh}?${n6}`, "_self")) : (null === (_4 = e9.state.remote) || void 0 === _4 ? void 0 : _4.isPaused()) ? (Iu(`[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=${R6}`), null === (k8 = e9.state.platformManager) || void 0 === k8 || k8.openDeeplink(`${th}?redirect=true&${n6}`, `${nh}?redirect=true&${n6}`, "_self")) : Iu(`[RCPMS: _write()] method ${R6} doesn't need redirect.`);
    } catch (e10) {
      return Iu("[RCPMS: _write()] error sending message", e10), r6(new Error("RemoteCommunicationPostMessageStream - disconnected"));
    }
    return r6();
  }));
}
var Eh = class extends ou.Duplex {
  constructor({ name: e9, remote: t4, deeplinkProtocol: n4, platformManager: r6 }) {
    super({ objectMode: true }), this.state = { _name: null, remote: null, deeplinkProtocol: false, platformManager: null }, this.state._name = e9, this.state.remote = t4, this.state.deeplinkProtocol = n4, this.state.platformManager = r6, this._onMessage = this._onMessage.bind(this), this.state.remote.on(So5.MESSAGE, this._onMessage);
  }
  _write(e9, t4, n4) {
    return c5(this, void 0, void 0, (function* () {
      return wh(this, e9, 0, n4);
    }));
  }
  _read() {
  }
  _onMessage(e9) {
    return (function(e10, t4) {
      try {
        if (Iu("[RCPMS: onMessage()] message", t4), !t4 || "object" != typeof t4) return;
        if ("object" != typeof (null == t4 ? void 0 : t4.data)) return;
        if (!(null == t4 ? void 0 : t4.name)) return void Iu("[RCPMS: onMessage()] ignore message without name", t4);
        if ((null == t4 ? void 0 : t4.name) !== Qu.PROVIDER) return void Iu(`[RCPMS: onMessage()] ignore message with wrong name message=${t4}`);
        if (C7.isBuffer(t4)) {
          const n4 = C7.from(t4);
          e10.push(n4);
        } else e10.push(t4);
      } catch (e11) {
        Iu(`[RCPMS: onMessage()] ignore message error err=${e11}`);
      }
    })(this, e9);
  }
  start() {
  }
};
var Sh = 1;
var _h = (e9) => new Promise(((t4) => {
  setTimeout((() => {
    t4(true);
  }), e9);
}));
var Ch = ({ checkInstallationOnAllCalls: t4 = false, communicationLayerPreference: n4, injectProvider: r6, shouldShimWeb3: i6, platformManager: o4, installer: s3, sdk: a4, remoteConnection: l6, debug: d5 }) => c5(void 0, void 0, void 0, (function* () {
  var u6, h7;
  const f12 = (({ name: e9, remoteConnection: t5 }) => {
    if (!t5 || !(null == t5 ? void 0 : t5.getConnector())) throw new Error("Missing remote connection parameter");
    return new Eh({ name: e9, remote: null == t5 ? void 0 : t5.getConnector(), deeplinkProtocol: null == t5 ? void 0 : t5.state.deeplinkProtocol, platformManager: null == t5 ? void 0 : t5.getPlatformManager() });
  })({ name: Qu.INPAGE, target: Qu.CONTENT_SCRIPT, platformManager: o4, communicationLayerPreference: n4, remoteConnection: l6 }), p7 = o4.getPlatformType(), g3 = a4.options.dappMetadata, m5 = `Sdk/Javascript SdkVersion/${Xu.version} Platform/${p7} dApp/${null !== (u6 = g3.url) && void 0 !== u6 ? u6 : g3.name} dAppTitle/${g3.name}`;
  let y8 = null, v7 = null;
  const b5 = null === (h7 = a4.options.storage) || void 0 === h7 ? void 0 : h7.storageManager;
  if (b5) {
    try {
      const e9 = yield b5.getCachedAccounts();
      e9.length > 0 && (y8 = e9[0]);
    } catch (e9) {
      console.error(`[initializeMobileProvider] failed to get cached addresses: ${e9}`);
    }
    try {
      const e9 = yield b5.getCachedChainId();
      e9 && (v7 = e9);
    } catch (e9) {
      console.error(`[initializeMobileProvider] failed to parse cached chainId: ${e9}`);
    }
  }
  Iu(`[initializeMobileProvider] cachedAccountAddress: ${y8}, cachedChainId: ${v7}`);
  const w6 = !(!r6 || p7 === Uo5.NonBrowser || p7 === Uo5.ReactNative), E7 = Gu.init({ shouldSetOnWindow: w6, connectionStream: f12, shouldShimWeb3: i6, sdkInstance: a4 });
  let S7 = false;
  const _4 = (e9) => {
    S7 = e9;
  }, C8 = () => S7, k8 = (n5, r7, i7, d6) => c5(void 0, void 0, void 0, (function* () {
    var u7, h8, f13, p8, g4, w7, E8, k9, A9;
    const x6 = Gu.getProvider();
    if (S7) {
      x6.emit("display_uri", (null == l6 ? void 0 : l6.state.qrcodeLink) || ""), null == l6 || l6.showActiveModal();
      let e9 = C8();
      for (; e9; ) {
        const t5 = C8(), n6 = null == l6 ? void 0 : l6.isAuthorized();
        e9 = t5 && !n6, Iu(`[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: ${t5} authorized: ${n6}`), yield _h(1e3);
      }
      return Iu("[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider"), i7(...r7);
    }
    const M7 = o4.isMetaMaskInstalled(), I7 = null == l6 ? void 0 : l6.isConnected();
    let T6 = null, R6 = null, P6 = null;
    if (T6 = null !== (u7 = x6.getSelectedAddress()) && void 0 !== u7 ? u7 : y8, P6 = x6.getChainId() || v7, T6 && b5 && T6 !== y8 && b5.persistAccounts([T6]).catch(((e9) => {
      console.error(`[initializeMobileProvider] failed to persist account: ${e9}`);
    })), P6 && (v7 = P6, b5 && b5.persistChainId(P6).catch(((e9) => {
      console.error(`[initializeMobileProvider] failed to persist chainId: ${e9}`);
    }))), Iu("[initializeMobileProvider: sendRequest()]", { selectedAddress: T6, chainId: P6 }), d6 && Iu(`[initializeMobileProvider: sendRequest()] method=${n5} ongoing=${S7} selectedAddress=${T6} isInstalled=${M7} checkInstallationOnAllCalls=${t4} socketConnected=${I7}`), T6 && n5.toLowerCase() === oh.ETH_ACCOUNTS.toLowerCase()) return [T6];
    if (P6 && n5.toLowerCase() === oh.ETH_CHAINID.toLowerCase()) return P6;
    const O6 = [oh.ETH_REQUESTACCOUNTS, oh.WALLET_REQUESTPERMISSIONS, oh.METAMASK_CONNECTSIGN, oh.METAMASK_CONNECTWITH], N8 = !sh[n5], L6 = null === (h8 = a4.options.readonlyRPCMap) || void 0 === h8 ? void 0 : h8[P6];
    if (L6 && N8) try {
      const t5 = null === (f13 = null == r7 ? void 0 : r7[0]) || void 0 === f13 ? void 0 : f13.params, i8 = yield (({ rpcEndpoint: t6, method: n6, sdkInfo: r8, params: i9 }) => c5(void 0, void 0, void 0, (function* () {
        const o5 = JSON.stringify({ jsonrpc: "2.0", method: n6, params: i9, id: (Sh += 1, Sh) }), s4 = { Accept: "application/json", "Content-Type": "application/json" };
        let a5;
        t6.includes("infura") && (s4["Metamask-Sdk-Info"] = r8);
        try {
          a5 = yield (0, import_cross_fetch.default)(t6, { method: "POST", headers: s4, body: o5 });
        } catch (e9) {
          throw e9 instanceof Error ? new Error(`Failed to fetch from RPC: ${e9.message}`) : new Error(`Failed to fetch from RPC: ${e9}`);
        }
        if (!a5.ok) throw new Error(`Server responded with a status of ${a5.status}`);
        return (yield a5.json()).result;
      })))({ rpcEndpoint: L6, sdkInfo: m5, method: n5, params: t5 || [] });
      return d6 && Iu(`initializeProvider::ReadOnlyRPCResponse ${i8}`), i8;
    } catch (e9) {
      console.warn(`[initializeMobileProvider: sendRequest()] method=${n5} readOnlyRPCRequest failed:`, e9);
    }
    if ((!M7 || M7 && !I7) && n5 !== oh.METAMASK_GETPROVIDERSTATE) {
      const e9 = (null === (p8 = null == r7 ? void 0 : r7[0]) || void 0 === p8 ? void 0 : p8.params) || [];
      if (-1 !== O6.indexOf(n5) || t4) {
        _4(true);
        const t5 = n5 === oh.METAMASK_CONNECTWITH, o5 = `${Date.now()}`;
        try {
          yield s3.start({ wait: false, connectWith: t5 ? { method: n5, id: o5, params: e9 } : void 0 }), yield new Promise(((e10, t6) => {
            (null == l6 ? void 0 : l6.isAuthorized()) && (Iu("[initializeMobileProvider: sendRequest()] already authorized"), e10(true)), null == l6 || l6.getConnector().once(So5.AUTHORIZED, (() => {
              e10(true);
            })), a4.once(So5.PROVIDER_UPDATE, ((e11) => {
              Iu(`[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=${e11}`), e11 === gh.EXTENSION ? t6(So5.PROVIDER_UPDATE) : t6(new Error("Connection Terminated"));
            }));
          }));
        } catch (t6) {
          if (gh.EXTENSION === t6) {
            if (Iu(`[initializeMobileProvider: sendRequest()] extension provider detect: re-create ${n5} on the active provider`), n5.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase()) {
              const t7 = yield null === (g4 = a4.getProvider()) || void 0 === g4 ? void 0 : g4.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
              if (!t7.length) throw new Error("SDK state invalid -- undefined accounts");
              const n6 = yield null === (w7 = a4.getProvider()) || void 0 === w7 ? void 0 : w7.request({ method: oh.PERSONAL_SIGN, params: [e9[0], t7[0]] });
              return a4.emit(Vu.ConnectWithResponse, n6), n6;
            }
            if (n5.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase()) {
              const [t7] = e9, n6 = yield (({ method: e10, sdk: t8, params: n7 }) => c5(void 0, void 0, void 0, (function* () {
                var r8, i8, o6, s4;
                if (!t8.isExtensionActive()) throw new Error("SDK state invalid -- extension is not active");
                Iu("[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method", e10, n7);
                const a5 = yield null === (r8 = t8.getProvider()) || void 0 === r8 ? void 0 : r8.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
                if (!a5.length) throw new Error("SDK state invalid -- undefined accounts");
                if ((null == e10 ? void 0 : e10.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase()) {
                  const r9 = { method: e10, params: [n7[0], a5[0]] };
                  return yield null === (i8 = t8.getProvider()) || void 0 === i8 ? void 0 : i8.request(r9);
                }
                if ((null == e10 ? void 0 : e10.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase()) {
                  const r9 = { method: e10, params: [Object.assign(Object.assign({}, n7[0]), { from: a5[0] })] };
                  return yield null === (o6 = t8.getProvider()) || void 0 === o6 ? void 0 : o6.request(r9);
                }
                return ch.includes(e10.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${e10} -- not handled by the extension -- call separately`), a5) : yield null === (s4 = t8.getProvider()) || void 0 === s4 ? void 0 : s4.request({ method: e10, params: n7 });
              })))({ method: t7.method, sdk: a4, params: t7.params });
              return a4.emit(Vu.ConnectWithResponse, n6), n6;
            }
            return Iu(`[initializeMobileProvider: sendRequest()] sending '${n5}' on active provider`, e9), yield null === (E8 = a4.getProvider()) || void 0 === E8 ? void 0 : E8.request({ method: n5, params: e9 });
          }
          if (t6 === So5.REJECTED) throw null == l6 || l6.closeModal(), null === (k9 = a4.getProvider()) || void 0 === k9 || k9.handleDisconnect({ terminate: false }), Object.assign(new Error("User rejected connection"), { code: 4001 });
          throw Iu(`[initializeMobileProvider: sendRequest()] failed to start installer: ${t6}`), t6;
        } finally {
          _4(false);
        }
        if (n5 === oh.ETH_REQUESTACCOUNTS) return R6 = yield new Promise(((e10) => {
          const t6 = setInterval((() => {
            const { accounts: n6 } = x6.getState();
            n6 && (clearInterval(t6), e10(n6));
          }), 100);
        })), Iu(`[initializeMobileProvider: sendRequest()] selectedAddress: ${T6} --- SKIP rpc call`), R6;
        if (n5 === oh.METAMASK_CONNECTWITH) try {
          let e10 = 0;
          const t6 = 5, n6 = ({ resolve: n7, reject: r9 }) => {
            e10 += 1;
            const i9 = null == l6 ? void 0 : l6.getConnector().getRPCMethodTracker(), s5 = null == i9 ? void 0 : i9[o5];
            return Iu(`TRACKER: update method ${o5}`, s5), (null == s5 ? void 0 : s5.result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", s5.result), a4.emit(Vu.ConnectWithResponse, s5.result), void n7(s5.result)) : (null == s5 ? void 0 : s5.error) ? (Iu("[initializeMobileProvider: sendRequest()] found error", s5.error), void r9(s5.error)) : e10 >= t6 ? (Iu("[initializeMobileProvider: sendRequest()] max message count reached without result"), void r9(new Error("Max message count reached without result"))) : void Iu("[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update");
          };
          let r8, i8;
          const s4 = yield new Promise(((e11, t7) => {
            const s5 = null == l6 ? void 0 : l6.getConnector().getRPCMethodTracker();
            Iu(`TRACKER: method ${o5}`, s5), (null == s5 ? void 0 : s5[o5].result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", null == s5 ? void 0 : s5[o5].result), e11(null == s5 ? void 0 : s5[o5].result)) : (null == s5 ? void 0 : s5[o5].error) && (Iu("[initializeMobileProvider: sendRequest()] found error", null == s5 ? void 0 : s5[o5].error), t7(null == s5 ? void 0 : s5[o5].error)), i8 = () => n6({ resolve: e11, reject: t7 }), r8 = null == l6 ? void 0 : l6.getConnector().on(So5.RPC_UPDATE, i8);
          }));
          return i8 && (null == r8 || r8.off(So5.RPC_UPDATE, i8)), Iu("TRACKER: result", s4), s4;
        } catch (e10) {
          throw Iu("[initializeMobileProvider: sendRequest()] error:", e10), e10;
        }
        r7[0] && "object" == typeof r7[0] && (r7[0].params = { __triggeredInstaller: true, wrappedParams: r7[0].params });
        return i7(...r7);
      }
      if (o4.isSecure() && sh[n5]) return i7(...r7);
      if (a4.isExtensionActive()) return Iu(`[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '${n5}' to it`, r7, e9), yield null === (A9 = a4.getProvider()) || void 0 === A9 ? void 0 : A9.request({ method: n5, params: e9 });
      throw Iu(`[initializeMobileProvider: sendRequest()] method=${n5} --- skip --- not connected/installed`), new Error("MetaMask is not connected/installed, please call eth_requestAccounts to connect first.");
    }
    try {
      const e9 = yield i7(...r7);
      if (Iu(`[initializeMobileProvider: sendRequest()] method=${n5} rpcResponse`, e9), n5 === oh.WALLET_REQUESTPERMISSIONS) {
        const t5 = e9.reduce(((e10, t6) => {
          var n6;
          if ("eth_accounts" === t6.parentCapability) {
            const r8 = null === (n6 = t6.caveats.find(((e11) => "restrictReturnedAccounts" === e11.type))) || void 0 === n6 ? void 0 : n6.value;
            r8 && e10.push(...r8);
          }
          return e10;
        }), []);
        Iu("[initializeMobileProvider: sendRequest()] accountsToPersist:", t5), t5.length > 0 && (x6.handleAccountsChanged(t5, false), null == b5 || b5.persistAccounts(t5));
      }
      return e9;
    } catch (e9) {
      throw console.error("[initializeMobileProvider: sendRequest()] error:", e9), e9;
    }
  })), { request: A8 } = E7;
  E7.request = (...e9) => c5(void 0, void 0, void 0, (function* () {
    return k8(null == e9 ? void 0 : e9[0].method, e9, A8, d5);
  }));
  const { send: x5 } = E7;
  return E7.send = (...e9) => c5(void 0, void 0, void 0, (function* () {
    return k8(null == e9 ? void 0 : e9[0], e9, x5, d5);
  })), Iu("[initializeMobileProvider: sendRequest()] metamaskStream.start()"), f12.start(), E7;
}));
function kh(e9) {
  var t4, n4, r6, i6;
  return c5(this, void 0, void 0, (function* () {
    const { options: o4 } = e9, s3 = { communicationLayerPreference: null !== (t4 = o4.communicationLayerPreference) && void 0 !== t4 ? t4 : jo3.SOCKET, platformManager: e9.platformManager, sdk: e9, checkInstallationOnAllCalls: o4.checkInstallationOnAllCalls, injectProvider: null === (n4 = o4.injectProvider) || void 0 === n4 || n4, shouldShimWeb3: null === (r6 = o4.shouldShimWeb3) || void 0 === r6 || r6, extensionOnly: null === (i6 = o4.extensionOnly) || void 0 === i6 || i6, installer: e9.installer, remoteConnection: e9.remoteConnection, debug: e9.debug }, a4 = yield Ch(s3);
    e9.activeProvider = a4, (function(e10) {
      var t5, n5, r7, i7;
      null === (n5 = null === (t5 = e10.remoteConnection) || void 0 === t5 ? void 0 : t5.getConnector()) || void 0 === n5 || n5.on(Vu.ConnectionStatus, ((t6) => {
        e10.emit(Vu.ConnectionStatus, t6);
      })), null === (i7 = null === (r7 = e10.remoteConnection) || void 0 === r7 ? void 0 : r7.getConnector()) || void 0 === i7 || i7.on(Vu.ServiceStatus, ((t6) => {
        e10.emit(Vu.ServiceStatus, t6);
      }));
    })(e9);
  }));
}
var Ah = "sdk";
var xh = class {
  constructor({ serverUrl: e9, enabled: t4, originatorInfo: n4 }) {
    this.serverURL = fo5, this.serverURL = e9, this.originatorInfo = n4, this.enabled = null == t4 || t4;
  }
  send({ event: e9, params: t4 }) {
    if (!this.enabled) return;
    const n4 = Object.assign(Object.assign({ id: Ah, event: e9, sdkVersion: Xu.version }, this.originatorInfo), { params: t4 });
    Iu(`[Analytics: send()] event: ${e9}`, n4), lo5(n4, this.serverURL).catch(((e10) => {
      Iu(`[Analytics: send()] error: ${e10}`);
    }));
  }
};
var Mh = () => {
  if ("undefined" == typeof document) return;
  let e9;
  const t4 = document.getElementsByTagName("link");
  for (let n4 = 0; n4 < t4.length; n4++) "icon" !== t4[n4].getAttribute("rel") && "shortcut icon" !== t4[n4].getAttribute("rel") || (e9 = t4[n4].getAttribute("href"));
  return e9;
};
var Ih = 163400;
function Th(e9) {
  var t4, n4, r6;
  const { dappMetadata: i6 } = e9, o4 = (function({ url: e10, name: t5 }) {
    var n5;
    const r7 = e10 + t5, i7 = bh(r7);
    if (!localStorage) return "";
    let o5 = null !== (n5 = localStorage.getItem(i7)) && void 0 !== n5 ? n5 : "";
    if (!o5) {
      o5 = v4_default();
      try {
        localStorage.setItem(i7, o5);
      } catch (e11) {
        return "";
      }
    }
    return o5;
  })({ url: null !== (t4 = null == i6 ? void 0 : i6.url) && void 0 !== t4 ? t4 : "no_url", name: null !== (n4 = null == i6 ? void 0 : i6.name) && void 0 !== n4 ? n4 : "no_name" }), a4 = null === (r6 = e9.platformManager) || void 0 === r6 ? void 0 : r6.getPlatformType(), c6 = a4 === Uo5.DesktopWeb, l6 = a4 === Uo5.MetaMaskMobileWebview;
  let d5 = "N/A";
  return c6 ? d5 = "extension" : l6 && (d5 = "mobile"), { id: o4, from: d5 };
}
var Rh = (e9, t4, r6) => {
  if (bo5(e9)) {
    if (r6 || t4 && "object" == typeof t4 && null !== t4 && "error" in t4) {
      const i6 = r6 || (null == t4 ? void 0 : t4.error);
      i6 && 4001 === i6.code ? import_sdk_analytics.analytics.track("sdk_action_rejected", { action: e9 }) : import_sdk_analytics.analytics.track("sdk_action_failed", { action: e9 });
    } else import_sdk_analytics.analytics.track("sdk_action_succeeded", { action: e9 });
  }
};
var Ph = ({ provider: e9, sdkInstance: t4 }) => {
  if ("state" in e9) throw new Error("INVALID EXTENSION PROVIDER");
  return new Proxy(e9, { get: (r6, i6) => "request" === i6 ? function(e10) {
    var i7, o4;
    return c5(this, void 0, void 0, (function* () {
      Iu("[wrapExtensionProvider()] Overwriting request method", e10);
      const { method: s3, params: a4 } = e10, l6 = ah.includes(s3.toLowerCase()), { id: d5, from: u6 } = Th(t4);
      if (l6 && (null === (i7 = t4.analytics) || void 0 === i7 || i7.send({ event: Ao5.SDK_RPC_REQUEST, params: { method: s3, from: u6, id: d5 } })), bo5(s3) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: s3 }), s3 === oh.METAMASK_BATCH && Array.isArray(a4)) return (({ target: e11, args: t5, trackEvent: n4, sdkInstance: r7 }) => c5(void 0, void 0, void 0, (function* () {
        var i8, o5;
        if ("metamask_batch" !== t5.method) throw new Error("Invalid usage");
        const s4 = [], a5 = null !== (i8 = null == t5 ? void 0 : t5.params) && void 0 !== i8 ? i8 : [];
        for (const t6 of a5) {
          const n5 = yield null == e11 ? void 0 : e11.request({ method: t6.method, params: t6.params });
          s4.push(n5);
        }
        const { id: c6, from: l7 } = Th(r7);
        n4 && (null === (o5 = r7.analytics) || void 0 === o5 || o5.send({ event: Ao5.SDK_RPC_REQUEST_DONE, params: { method: t5.method, from: l7, id: c6 } }));
        for (const e12 of s4) Rh(t5.method, e12, null);
        return s4;
      })))({ target: r6, args: e10, trackEvent: l6, sdkInstance: t4 });
      if (s3.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase() && Array.isArray(a4)) return (({ target: e11, params: t5 }) => c5(void 0, void 0, void 0, (function* () {
        let n4, r7 = null;
        try {
          const r8 = yield e11.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!r8.length) throw new Error("SDK state invalid -- undefined accounts");
          return n4 = yield e11.request({ method: oh.PERSONAL_SIGN, params: [t5[0], r8[0]] }), n4;
        } catch (e12) {
          throw r7 = e12, e12;
        } finally {
          Rh(oh.PERSONAL_SIGN, n4, r7);
        }
      })))({ target: r6, params: a4 });
      if (s3.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase() && Array.isArray(a4)) return (({ target: e11, params: t5 }) => c5(void 0, void 0, void 0, (function* () {
        const [n4] = t5, r7 = n4.method, i8 = n4.params;
        let o5, s4 = null;
        try {
          const t6 = yield e11.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!Array.isArray(t6) || !t6.length) throw new Error("SDK state invalid -- undefined accounts");
          return (null == r7 ? void 0 : r7.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase() ? (o5 = yield e11.request({ method: r7, params: [i8[0], t6[0]] }), o5) : (null == r7 ? void 0 : r7.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase() ? (o5 = yield e11.request({ method: r7, params: [Object.assign(Object.assign({}, i8[0]), { from: t6[0] })] }), o5) : ch.includes(r7.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${r7} -- not handled by the extension -- call separately`), o5 = t6, o5) : (o5 = yield e11.request({ method: r7, params: i8 }), o5);
        } catch (e12) {
          throw s4 = e12, e12;
        } finally {
          Rh(r7, o5, s4);
        }
      })))({ target: r6, params: a4 });
      let h7, f12 = null;
      try {
        return h7 = yield r6.request(e10), h7;
      } catch (e11) {
        throw f12 = e11, e11;
      } finally {
        l6 && (null === (o4 = t4.analytics) || void 0 === o4 || o4.send({ event: Ao5.SDK_RPC_REQUEST_DONE, params: { method: s3, from: u6, id: d5 } })), Rh(s3, h7, f12);
      }
    }));
  } : "getChainId" === i6 ? function() {
    return e9.chainId;
  } : "getNetworkVersion" === i6 ? function() {
    return e9.networkVersion;
  } : "getSelectedAddress" === i6 ? function() {
    return e9.selectedAddress;
  } : "isConnected" === i6 ? function() {
    return e9._state.isConnected;
  } : r6[i6] });
};
var Oh;
function Nh({ mustBeMetaMask: e9, sdkInstance: t4 }) {
  return c5(this, void 0, void 0, (function* () {
    if ("undefined" == typeof window) throw new Error("window not available");
    try {
      const e10 = yield new Promise(((e11, t5) => {
        const n4 = setTimeout((() => {
          t5(new Error("eip6963RequestProvider timed out"));
        }), 500);
        window.addEventListener(Oh.Announce, ((t6) => {
          const r6 = t6, { detail: { info: i6, provider: o4 } = {} } = r6, { name: s3, rdns: a4, uuid: c6 } = null != i6 ? i6 : {};
          ih.test(c6) && s3.startsWith(rh.NAME) && rh.RDNS.includes(a4) && (clearTimeout(n4), e11(o4));
        })), window.dispatchEvent(new Event(Oh.Request));
      }));
      return Ph({ provider: e10, sdkInstance: t4 });
    } catch (n4) {
      if (!e9 && window.ethereum) return Ph({ provider: window.ethereum, sdkInstance: t4 });
      throw new Error("Provider not found");
    }
  }));
}
!(function(e9) {
  e9.Announce = "eip6963:announceProvider", e9.Request = "eip6963:requestProvider";
})(Oh || (Oh = {}));
var Lh = (e9) => c5(void 0, void 0, void 0, (function* () {
  const { options: t4 } = e9, { infuraAPIKey: n4 } = t4;
  if (!n4) return;
  const r6 = { "0x1": `https://mainnet.infura.io/v3/${n4}`, "0x5": `https://goerli.infura.io/v3/${n4}`, "0xaa36a7": `https://sepolia.infura.io/v3/${n4}`, "0xe708": `https://linea-mainnet.infura.io/v3/${n4}`, "0xe704": `https://linea-goerli.infura.io/v3/${n4}`, "0x89": `https://polygon-mainnet.infura.io/v3/${n4}`, "0x13881": `https://polygon-mumbai.infura.io/v3/${n4}`, "0x45": `https://optimism-mainnet.infura.io/v3/${n4}`, "0x1a4": `https://optimism-goerli.infura.io/v3/${n4}`, "0xa4b1": `https://arbitrum-mainnet.infura.io/v3/${n4}`, "0x66eed": `https://arbitrum-goerli.infura.io/v3/${n4}`, "0x2a15c308d": `https://palm-mainnet.infura.io/v3/${n4}`, "0x2a15c3083": `https://palm-testnet.infura.io/v3/${n4}`, "0xa86a": `https://avalanche-mainnet.infura.io/v3/${n4}`, "0xa869": `https://avalanche-fuji.infura.io/v3/${n4}`, "0x4e454152": `https://aurora-mainnet.infura.io/v3/${n4}`, "0x4e454153": `https://aurora-testnet.infura.io/v3/${n4}`, "0x534e5f4d41494e": `https://starknet-mainnet.infura.io/v3/${n4}`, "0x534e5f474f45524c49": `https://starknet-goerli.infura.io/v3/${n4}`, "0x534e5f474f45524c4932": `https://starknet-goerli2.infura.io/v3/${n4}`, "0xa4ec": `https://celo-mainnet.infura.io/v3/${n4}`, "0xaef3": `https://celo-alfajores.infura.io/v3/${n4}` };
  e9.options.readonlyRPCMap ? e9.options.readonlyRPCMap = Object.assign(Object.assign({}, e9.options.readonlyRPCMap), r6) : e9.options.readonlyRPCMap = r6;
}));
var Dh = (e9) => c5(void 0, void 0, void 0, (function* () {
  const { options: t4 } = e9, { readonlyRPCMap: n4 } = t4;
  if (n4) try {
    Iu("[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers", n4), e9.setReadOnlyRPCCalls(true);
  } catch (e10) {
    throw new Error("Invalid Infura Settings");
  }
}));
function $h(e9, t4, n4, r6) {
  return new (n4 || (n4 = Promise))((function(t5, i6) {
    function o4(e10) {
      try {
        a4(r6.next(e10));
      } catch (e11) {
        i6(e11);
      }
    }
    function s3(e10) {
      try {
        a4(r6.throw(e10));
      } catch (e11) {
        i6(e11);
      }
    }
    function a4(e10) {
      var r7;
      e10.done ? t5(e10.value) : (r7 = e10.value, r7 instanceof n4 ? r7 : new n4((function(e11) {
        e11(r7);
      }))).then(o4, s3);
    }
    a4((r6 = r6.apply(e9, [])).next());
  }));
}
function Bh(e9, t4) {
  var n4, r6, i6, o4, s3 = { label: 0, sent: function() {
    if (1 & i6[0]) throw i6[1];
    return i6[1];
  }, trys: [], ops: [] };
  return o4 = { next: a4(0), throw: a4(1), return: a4(2) }, "function" == typeof Symbol && (o4[Symbol.iterator] = function() {
    return this;
  }), o4;
  function a4(o5) {
    return function(a5) {
      return (function(o6) {
        if (n4) throw new TypeError("Generator is already executing.");
        for (; s3; ) try {
          if (n4 = 1, r6 && (i6 = 2 & o6[0] ? r6.return : o6[0] ? r6.throw || ((i6 = r6.return) && i6.call(r6), 0) : r6.next) && !(i6 = i6.call(r6, o6[1])).done) return i6;
          switch (r6 = 0, i6 && (o6 = [2 & o6[0], i6.value]), o6[0]) {
            case 0:
            case 1:
              i6 = o6;
              break;
            case 4:
              return s3.label++, { value: o6[1], done: false };
            case 5:
              s3.label++, r6 = o6[1], o6 = [0];
              continue;
            case 7:
              o6 = s3.ops.pop(), s3.trys.pop();
              continue;
            default:
              if (!(i6 = s3.trys, (i6 = i6.length > 0 && i6[i6.length - 1]) || 6 !== o6[0] && 2 !== o6[0])) {
                s3 = 0;
                continue;
              }
              if (3 === o6[0] && (!i6 || o6[1] > i6[0] && o6[1] < i6[3])) {
                s3.label = o6[1];
                break;
              }
              if (6 === o6[0] && s3.label < i6[1]) {
                s3.label = i6[1], i6 = o6;
                break;
              }
              if (i6 && s3.label < i6[2]) {
                s3.label = i6[2], s3.ops.push(o6);
                break;
              }
              i6[2] && s3.ops.pop(), s3.trys.pop();
              continue;
          }
          o6 = t4.call(e9, s3);
        } catch (e10) {
          o6 = [6, e10], r6 = 0;
        } finally {
          n4 = i6 = 0;
        }
        if (5 & o6[0]) throw o6[1];
        return { value: o6[0] ? o6[1] : void 0, done: true };
      })([o5, a5]);
    };
  }
}
var Kh = "INSTALLED";
var jh = "NOT_INSTALLED";
var Uh = "REGISTERED";
var Hh = "REGISTERING";
var Fh = "RELOADING";
var zh = { CHROME: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn", FIREFOX: "https://addons.mozilla.org/firefox/addon/ether-metamask/", DEFAULT: "https://metamask.io" };
var qh = "REGISTRATION_IN_PROGRESS";
var Wh = "FORWARDER_ID";
var Vh = (function() {
  function e9(t4) {
    var n4 = void 0 === t4 ? {} : t4, r6 = n4.forwarderOrigin, i6 = void 0 === r6 ? "https://fwd.metamask.io" : r6, o4 = n4.forwarderMode, s3 = void 0 === o4 ? e9.FORWARDER_MODE.INJECT : o4;
    this.forwarderOrigin = i6, this.forwarderMode = s3, this.state = e9.isMetaMaskInstalled() ? Kh : jh;
    var a4 = e9._detectBrowser();
    this.downloadUrl = a4 ? zh[a4] : zh.DEFAULT, this._onMessage = this._onMessage.bind(this), this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this), this._openForwarder = this._openForwarder.bind(this), this._openDownloadPage = this._openDownloadPage.bind(this), this.startOnboarding = this.startOnboarding.bind(this), this.stopOnboarding = this.stopOnboarding.bind(this), window.addEventListener("message", this._onMessage), s3 === e9.FORWARDER_MODE.INJECT && "true" === sessionStorage.getItem(qh) && e9._injectForwarder(this.forwarderOrigin);
  }
  return e9.prototype._onMessage = function(e10) {
    if (e10.origin === this.forwarderOrigin) return "metamask:reload" === e10.data.type ? this._onMessageFromForwarder(e10) : void console.debug("Unknown message from '" + e10.origin + "' with data " + JSON.stringify(e10.data));
  }, e9.prototype._onMessageUnknownStateError = function(e10) {
    throw new Error("Unknown state: '" + e10 + "'");
  }, e9.prototype._onMessageFromForwarder = function(t4) {
    return $h(this, 0, void 0, (function() {
      return Bh(this, (function(n4) {
        switch (n4.label) {
          case 0:
            switch (this.state) {
              case Fh:
                return [3, 1];
              case jh:
                return [3, 2];
              case Kh:
                return [3, 3];
              case Hh:
                return [3, 5];
              case Uh:
                return [3, 6];
            }
            return [3, 7];
          case 1:
            return console.debug("Ignoring message while reloading"), [3, 8];
          case 2:
            return console.debug("Reloading now to register with MetaMask"), this.state = Fh, location.reload(), [3, 8];
          case 3:
            return console.debug("Registering with MetaMask"), this.state = Hh, [4, e9._register()];
          case 4:
            return n4.sent(), this.state = Uh, t4.source.postMessage({ type: "metamask:registrationCompleted" }, t4.origin), this.stopOnboarding(), [3, 8];
          case 5:
            return console.debug("Already registering - ignoring reload message"), [3, 8];
          case 6:
            return console.debug("Already registered - ignoring reload message"), [3, 8];
          case 7:
            this._onMessageUnknownStateError(this.state), n4.label = 8;
          case 8:
            return [2];
        }
      }));
    }));
  }, e9.prototype.startOnboarding = function() {
    sessionStorage.setItem(qh, "true"), this._openDownloadPage(), this._openForwarder();
  }, e9.prototype.stopOnboarding = function() {
    "true" === sessionStorage.getItem(qh) && (this.forwarderMode === e9.FORWARDER_MODE.INJECT && (console.debug("Removing forwarder"), e9._removeForwarder()), sessionStorage.setItem(qh, "false"));
  }, e9.prototype._openForwarder = function() {
    this.forwarderMode === e9.FORWARDER_MODE.OPEN_TAB ? window.open(this.forwarderOrigin, "_blank") : e9._injectForwarder(this.forwarderOrigin);
  }, e9.prototype._openDownloadPage = function() {
    window.open(this.downloadUrl, "_blank");
  }, e9.isMetaMaskInstalled = function() {
    return Boolean(window.ethereum && window.ethereum.isMetaMask);
  }, e9._register = function() {
    return window.ethereum.request({ method: "wallet_registerOnboarding" });
  }, e9._injectForwarder = function(e10) {
    var t4 = document.body, n4 = document.createElement("iframe");
    n4.setAttribute("height", "0"), n4.setAttribute("width", "0"), n4.setAttribute("style", "display: none;"), n4.setAttribute("src", e10), n4.setAttribute("id", Wh), t4.insertBefore(n4, t4.children[0]);
  }, e9._removeForwarder = function() {
    var e10;
    null === (e10 = document.getElementById(Wh)) || void 0 === e10 || e10.remove();
  }, e9._detectBrowser = function() {
    var e10 = Wu.parse(window.navigator.userAgent);
    return "Firefox" === e10.browser.name ? "FIREFOX" : ["Chrome", "Chromium"].includes(e10.browser.name || "") ? "CHROME" : null;
  }, e9.FORWARDER_MODE = { INJECT: "INJECT", OPEN_TAB: "OPEN_TAB" }, e9;
})();
function Gh(e9, { wait: t4 = false }) {
  return c5(this, void 0, void 0, (function* () {
    return Iu(`[MetamaskInstaller: startInstaller()] wait=${t4}`), t4 && (yield _h(1e3)), yield e9.checkInstallation();
  }));
}
var Yh = class {
  constructor({ remote: e9, preferDesktop: t4, platformManager: n4, debug: r6 = false }) {
    this.state = { isInstalling: false, hasInstalled: false, resendRequest: null, preferDesktop: false, platformManager: null, remote: null, debug: false, connectWith: void 0 }, this.state.remote = e9, this.state.preferDesktop = t4, this.state.platformManager = n4, this.state.debug = r6;
  }
  startDesktopOnboarding() {
    return (function() {
      return c5(this, void 0, void 0, (function* () {
        Iu("[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding"), window.ethereum && (window.ethereum = void 0), new Vh().startOnboarding();
      }));
    })();
  }
  redirectToProperInstall() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        var t4, n4;
        return c5(this, void 0, void 0, (function* () {
          const { state: r6 } = e9, i6 = null === (t4 = r6.platformManager) || void 0 === t4 ? void 0 : t4.getPlatformType();
          if (Iu(`[MetamaskInstaller: redirectToProperInstall()] platform=${i6}`), i6 === Uo5.MetaMaskMobileWebview) return false;
          r6.isInstalling = true;
          try {
            yield null === (n4 = r6.remote) || void 0 === n4 ? void 0 : n4.startConnection({ connectWith: r6.connectWith }), r6.isInstalling = false, r6.hasInstalled = true;
          } catch (e10) {
            throw r6.isInstalling = false, e10;
          }
          return true;
        }));
      })(this);
    }));
  }
  checkInstallation() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        var t4;
        return c5(this, void 0, void 0, (function* () {
          const { state: n4 } = e9, r6 = null === (t4 = n4.platformManager) || void 0 === t4 ? void 0 : t4.isMetaMaskInstalled();
          return Iu(`[MetamaskInstaller: checkInstallation()] isInstalled=${r6}`), !!r6 || (yield e9.redirectToProperInstall());
        }));
      })(this);
    }));
  }
  start({ wait: e9 = false, connectWith: t4 }) {
    return c5(this, void 0, void 0, (function* () {
      this.state.connectWith = t4, Iu(`[MetaMaskInstaller: start()] wait=${e9}`, t4), yield Gh(this, { wait: e9 });
    }));
  }
};
var Zh = class {
  constructor({ debug: e9, sdkVersion: t4 }) {
    this.containers = { install: void 0, pending: void 0, select: void 0 }, this.defined = { install: false, pending: false, select: false }, this.debug = null != e9 && e9, this.sdkVersion = t4;
  }
  loadComponent(e9) {
    return c5(this, void 0, void 0, (function* () {
      if (!this.defined[e9]) {
        this.defined[e9] = true;
        try {
          const e10 = yield Promise.resolve().then((function() {
            return Lp;
          }));
          console.log("loader", e10), e10.defineCustomElements();
        } catch (t4) {
          console.error(`Failed to load ${e9} modal:`, t4);
        }
      }
    }));
  }
  renderInstallModal(e9) {
    var t4;
    return c5(this, void 0, void 0, (function* () {
      this.debug && console.debug("ModalLoader: renderInstallModal", e9), this.containers.install = e9.parentElement, yield this.loadComponent("install");
      const n4 = document.createElement("mm-install-modal");
      n4.link = e9.link, n4.preferDesktop = e9.preferDesktop, n4.sdkVersion = null !== (t4 = e9.sdkVersion) && void 0 !== t4 ? t4 : this.sdkVersion, n4.addEventListener("close", (({ detail: { shouldTerminate: t5 } }) => e9.onClose(t5))), n4.addEventListener("startDesktopOnboarding", e9.metaMaskInstaller.startDesktopOnboarding), n4.addEventListener("trackAnalytics", ((t5) => {
        var n5;
        return null === (n5 = e9.onAnalyticsEvent) || void 0 === n5 ? void 0 : n5.call(e9, t5.detail);
      })), e9.parentElement.appendChild(n4);
    }));
  }
  renderSelectModal(e9) {
    var t4;
    return c5(this, void 0, void 0, (function* () {
      this.containers.select = e9.parentElement, yield this.loadComponent("select");
      const n4 = document.createElement("mm-select-modal");
      n4.link = e9.link, n4.sdkVersion = null !== (t4 = e9.sdkVersion) && void 0 !== t4 ? t4 : this.sdkVersion, n4.preferDesktop = e9.preferDesktop, n4.addEventListener("close", (({ detail: { shouldTerminate: t5 } }) => e9.onClose(t5))), n4.addEventListener("connectWithExtension", e9.connectWithExtension), e9.parentElement.appendChild(n4), setTimeout((() => this.updateQRCode(e9.link)), 100);
    }));
  }
  renderPendingModal(e9) {
    var t4;
    return c5(this, void 0, void 0, (function* () {
      this.containers.pending = e9.parentElement, yield this.loadComponent("pending");
      const n4 = document.createElement("mm-pending-modal");
      n4.sdkVersion = null !== (t4 = e9.sdkVersion) && void 0 !== t4 ? t4 : this.sdkVersion, n4.displayOTP = e9.displayOTP, n4.addEventListener("close", e9.onClose), n4.addEventListener("updateOTPValue", (({ detail: { otpValue: t5 } }) => e9.updateOTPValue(t5))), e9.onDisconnect && n4.addEventListener("disconnect", e9.onDisconnect), e9.parentElement.appendChild(n4);
    }));
  }
  updateOTPValue(e9) {
    const t4 = () => {
      var t5;
      const n4 = null === (t5 = this.containers.pending) || void 0 === t5 ? void 0 : t5.querySelector("mm-pending-modal");
      return !!n4 && (n4.otpCode = e9, true);
    };
    setTimeout((() => {
      t4();
    }), 800);
  }
  updateQRCode(e9) {
    var t4, n4;
    const r6 = null === (t4 = this.containers.install) || void 0 === t4 ? void 0 : t4.querySelector("mm-install-modal");
    if (r6) r6.link = e9;
    else {
      const t5 = null === (n4 = this.containers.select) || void 0 === n4 ? void 0 : n4.querySelector("mm-select-modal");
      t5 && (t5.link = e9);
    }
  }
  unmount() {
    Object.entries(this.containers).forEach((([e9, t4]) => {
      var n4;
      null === (n4 = null == t4 ? void 0 : t4.parentNode) || void 0 === n4 || n4.removeChild(t4), this.containers[e9] = void 0;
    }));
  }
};
var Jh = ({ link: e9, debug: t4, installer: n4, terminate: r6, connectWithExtension: i6, preferDesktop: o4, onAnalyticsEvent: s3 }) => {
  let a4 = null, c6 = null;
  Iu("[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################"), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] link=${e9}`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e9}" --ios`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e9}" --android`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d "${e9}"`);
  const l6 = (e10) => {
    var t5;
    Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:", e10, c6), (null == c6 ? void 0 : c6.parentNode) && (null === (t5 = c6.parentNode) || void 0 === t5 || t5.removeChild(c6)), c6 = null, a4 = null, true === e10 && (null == r6 || r6());
  };
  return { mount: (r7) => {
    if (Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal", c6), c6) return c6.style.display = "block", void (null == a4 || a4.updateQRCode(r7));
    a4 = new Zh({ debug: t4, sdkVersion: Xu.version }), c6 = document.createElement("div"), document.body.appendChild(c6), window.extension ? a4.renderSelectModal({ parentElement: c6, connectWithExtension: () => {
      l6(), null == i6 || i6();
    }, onClose: l6, link: e9, preferDesktop: null != o4 && o4 }).catch(((e10) => {
      console.error(e10);
    })) : a4.renderInstallModal({ parentElement: c6, preferDesktop: null != o4 && o4, link: e9, metaMaskInstaller: n4, onClose: l6, onAnalyticsEvent: s3 }).catch(((e10) => {
      console.error("[UI: InstallModal-web: sdkWebInstallModal()]", e10);
    }));
  }, unmount: l6 };
};
var Qh = ({ onDisconnect: e9, debug: t4 }) => {
  let n4 = null, r6 = null;
  const i6 = () => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount", n4), (null == n4 ? void 0 : n4.parentNode) && n4.parentNode.removeChild(n4), n4 = null, r6 = null;
  }, o4 = (e10) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue", e10), r6 && r6.updateOTPValue(e10);
  }, s3 = ({ displayOTP: s4 } = { displayOTP: true }) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount", n4), n4 ? n4.style.display = "block" : (r6 = new Zh({ debug: t4, sdkVersion: Xu.version }), n4 = document.createElement("div"), document.body.appendChild(n4), r6.renderPendingModal({ parentElement: n4, onClose: i6, onDisconnect: e9, updateOTPValue: o4, displayOTP: s4 }).catch(((e10) => {
      console.error("[UI: pendingModal-web: sdkWebPendingModal()]", e10);
    })));
  };
  return s3(), { mount: s3, unmount: i6, updateOTPValue: o4 };
};
function Xh(e9, t4) {
  var n4, r6, i6, o4;
  e9.connector || (Iu("[RemoteConnection: initializeConnector()] initialize connector"), e9.connector = new ts2({ anonId: t4.anonId, platformType: t4.platformManager.getPlatformType(), communicationLayerPreference: t4.communicationLayerPreference, transports: t4.transports, dappMetadata: Object.assign(Object.assign({}, t4.dappMetadata), { source: t4._source }), analytics: t4.enableAnalytics, communicationServerUrl: t4.communicationServerUrl, sdkVersion: Xu.version, context: "dapp", ecies: t4.ecies, storage: t4.storage, logging: t4.logging }), t4.timer && (Iu("[RemoteConnection: initializeConnector()] reset background timer", t4.timer), null === (r6 = null === (n4 = t4.timer) || void 0 === n4 ? void 0 : n4.stopBackgroundTimer) || void 0 === r6 || r6.call(n4), null === (o4 = null === (i6 = t4.timer) || void 0 === i6 ? void 0 : i6.runBackgroundTimer) || void 0 === o4 || o4.call(i6, (() => false), 1e4)));
}
function ef4(e9) {
  e9.listeners.forEach((({ event: t4, handler: n4 }) => {
    var r6;
    null === (r6 = e9.connector) || void 0 === r6 || r6.off(t4, n4);
  })), e9.listeners = [];
}
function tf4(e9, t4, r6) {
  return c5(this, void 0, void 0, (function* () {
    const i6 = setTimeout((() => {
      import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
    }), 6e4);
    return new Promise(((n4, o4) => {
      if (!e9.connector) return void o4(new Error("No connector available"));
      Iu("[RemoteConnection: connectWithModalInstaller()]", { state: e9, options: t4, linkParams: r6 });
      const s3 = `${e9.useDeeplink ? nh : th}?${r6}`;
      !(function(e10, t5, n5) {
        var r7, i7, o5, s4;
        e10.installModal = null === (i7 = (r7 = t5.modals).install) || void 0 === i7 ? void 0 : i7.call(r7, { link: n5, preferDesktop: e10.preferDesktop, installer: t5.getMetaMaskInstaller(), terminate: () => {
          Iu("[RemoteConnection: showInstallModal() => terminate()] terminate connection"), t5.sdk.terminate().catch(((e11) => {
            console.warn("[MMSDK] failed to terminate connection", e11);
          }));
        }, debug: e10.developerMode, connectWithExtension: () => {
          var e11;
          return null === (e11 = t5.connectWithExtensionProvider) || void 0 === e11 || e11.call(t5), false;
        }, onAnalyticsEvent: ({ event: n6, params: r8 }) => {
          var i8, o6, s5;
          const a4 = Object.assign(Object.assign({}, r8), { sdkVersion: t5.sdk.getVersion(), dappId: null === (i8 = t5.dappMetadata) || void 0 === i8 ? void 0 : i8.name, source: t5._source, url: null === (o6 = t5.dappMetadata) || void 0 === o6 ? void 0 : o6.url });
          null === (s5 = e10.analytics) || void 0 === s5 || s5.send({ event: n6, params: a4 });
        } }), null === (s4 = null === (o5 = e10.installModal) || void 0 === o5 ? void 0 : o5.mount) || void 0 === s4 || s4.call(o5, n5);
      })(e9, t4, s3), t4.sdk.once(So5.PROVIDER_UPDATE, ((e10) => c5(this, void 0, void 0, (function* () {
        if (Iu("[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise"), e10 === gh.TERMINATE) {
          const e11 = { code: 4001, message: "User rejected the request." };
          return clearTimeout(i6), void o4(e11);
        }
        o4(e10);
      })))), e9.connector.once(So5.AUTHORIZED, (() => {
        clearTimeout(i6), n4();
      })), e9.connector.once(So5.REJECTED, (() => {
        clearTimeout(i6), o4(So5.REJECTED);
      })), e9.connector.once(So5.CLIENTS_READY, (() => c5(this, void 0, void 0, (function* () {
        Iu("[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise"), clearTimeout(i6), n4();
      }))));
    }));
  }));
}
function nf4(e9, t4) {
  function n4(t5, n5) {
    var r6;
    null === (r6 = e9.connector) || void 0 === r6 || r6.on(t5, n5), e9.listeners.push({ event: t5, handler: n5 });
  }
  e9.connector && (ef4(e9), n4(So5.WALLET_INIT, (({ accounts: e10, chainId: t5 }) => c5(this, void 0, void 0, (function* () {
    Iu(`[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=${e10} chainId=${t5}`);
    const n5 = Gu.getProvider();
    n5._setConnected();
    const r6 = { accounts: e10, chainId: t5, isUnlocked: false };
    n5._initializeState(r6), n5.emit("chainChanged", t5), n5.emit("accountsChanged", e10);
  })))), n4(So5.AUTHORIZED, (() => c5(this, void 0, void 0, (function* () {
    var t5, n5, r6, i6;
    try {
      Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals", e9.pendingModal, e9.installModal);
      const o4 = Gu.getProvider();
      o4._setConnected(), null === (n5 = null === (t5 = e9.pendingModal) || void 0 === t5 ? void 0 : t5.unmount) || void 0 === n5 || n5.call(t5), null === (i6 = null === (r6 = e9.installModal) || void 0 === r6 ? void 0 : r6.unmount) || void 0 === i6 || i6.call(r6, false), e9.otpAnswer = void 0, e9.authorized = true, Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state", o4.getState()), yield o4.forceInitializeState();
    } catch (e10) {
    }
  })))), n4(So5.TERMINATE, (() => {
    var t5, n5, r6, i6, o4;
    null === (n5 = null === (t5 = e9.pendingModal) || void 0 === t5 ? void 0 : t5.unmount) || void 0 === n5 || n5.call(t5), null === (i6 = null === (r6 = e9.installModal) || void 0 === r6 ? void 0 : r6.unmount) || void 0 === i6 || i6.call(r6, true), e9.pendingModal = void 0, e9.installModal = void 0, e9.otpAnswer = void 0, null === (o4 = e9.connector) || void 0 === o4 || o4.disconnect({ terminate: true }), e9.authorized = false;
    Gu.getProvider().handleDisconnect({ terminate: true }), ef4(e9), Iu("[RemoteConnection: setupListeners()] All listeners cleaned up");
  })));
}
function rf2(e9, t4, { initialCheck: r6, connectWith: i6 } = {}) {
  var o4, s3, a4, l6, d5, u6, h7, f12, p7, g3, m5, y8, v7, b5, w6, E7, S7, _4, C8;
  return c5(this, void 0, void 0, (function* () {
    try {
      if (Xh(e9, t4), !e9.connector) throw new Error("no connector defined");
      nf4(e9);
      const k8 = Gu.getProvider();
      e9.authorized = false, k8.emit("connecting");
      const A8 = yield null === (o4 = e9.connector) || void 0 === o4 ? void 0 : o4.originatorSessionConnect();
      Iu(`[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=${r6}`, A8);
      let x5 = null !== (s3 = null == A8 ? void 0 : A8.channelId) && void 0 !== s3 ? s3 : "", M7 = null !== (l6 = null === (a4 = e9.connector.getKeyInfo()) || void 0 === a4 ? void 0 : a4.ecies.public) && void 0 !== l6 ? l6 : "", I7 = null !== (u6 = null === (d5 = e9.connector.getKeyInfo()) || void 0 === d5 ? void 0 : d5.ecies.private) && void 0 !== u6 ? u6 : "";
      if (r6 && !A8) return Promise.resolve();
      if (!A8 && !r6) {
        const t5 = yield e9.connector.generateChannelIdConnect();
        x5 = null !== (h7 = t5.channelId) && void 0 !== h7 ? h7 : "", M7 = null !== (f12 = t5.pubKey) && void 0 !== f12 ? f12 : "", I7 = null !== (p7 = t5.privKey) && void 0 !== p7 ? p7 : "";
        const n4 = Date.now();
        null === (g3 = e9.connector.state.storageManager) || void 0 === g3 || g3.persistChannelConfig({ channelId: x5, localKey: I7, lastActive: n4, validUntil: n4 + go5 });
      }
      if (r6 && (null == A8 ? void 0 : A8.channelId)) return (null === (m5 = e9.connector) || void 0 === m5 ? void 0 : m5.isConnected()) || (Iu(`[RemoteConnection: startConnection()] reconnecting to channel initialCheck=${r6}`, A8), yield null === (y8 = e9.connector) || void 0 === y8 ? void 0 : y8.connectToChannel({ channelId: x5 })), Promise.resolve();
      A8 && !(null === (v7 = e9.connector) || void 0 === v7 ? void 0 : v7.isConnected()) && (Iu("[RemoteConnection: startConnection()] reconnecting to channel", A8), yield null === (b5 = e9.connector) || void 0 === b5 ? void 0 : b5.connectToChannel({ channelId: x5 }));
      const T6 = (null === (w6 = e9.platformManager) || void 0 === w6 ? void 0 : w6.isSecure()) ? "" : "&t=q", R6 = Xu.version, { iconUrl: P6, name: O6, url: N8, scheme: L6 } = t4.dappMetadata || {}, D9 = null === (E7 = e9.platformManager) || void 0 === E7 ? void 0 : E7.getPlatformType();
      let $7 = "N/A";
      "undefined" != typeof window && window.location && window.location.hostname ? $7 = window.location.hostname : void 0 !== O6 ? $7 = O6 : void 0 !== N8 && ($7 = N8);
      const B7 = { url: null != N8 ? N8 : "", title: null != O6 ? O6 : "", icon: P6, scheme: null != L6 ? L6 : "", apiVersion: R6, dappId: $7 || N8 || "N/A", anonId: t4.anonId, platform: null != D9 ? D9 : "", source: null !== (S7 = t4._source) && void 0 !== S7 ? S7 : "" }, K4 = bh(JSON.stringify(B7));
      let j6 = `channelId=${x5}&v=2&comm=${null !== (_4 = e9.communicationLayerPreference) && void 0 !== _4 ? _4 : ""}&pubkey=${M7}${T6}&originatorInfo=${K4}`;
      if (i6) {
        j6 += `&rpc=${bh(JSON.stringify(i6))}`;
        const t5 = e9.connector.getRPCMethodTracker();
        t5 && (t5[`${i6.id}`] = Object.assign(Object.assign({}, i6), { id: `${i6.id}`, timestamp: Date.now() }));
      }
      const U6 = encodeURI(j6), H4 = `${e9.useDeeplink ? nh : th}?${j6}`;
      if (e9.qrcodeLink = H4, e9.developerMode && Iu(`[RemoteConnection: startConnection()] qrcodeLink=${U6}`), k8.emit("display_uri", H4), import_sdk_analytics.analytics.track("sdk_connection_initiated", { transport_type: "websocket" }), null === (C8 = e9.platformManager) || void 0 === C8 ? void 0 : C8.isSecure()) {
        const t5 = setTimeout((() => {
          import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
        }), 6e4);
        return yield (function(e10, t6) {
          var n4, r7;
          return c5(this, void 0, void 0, (function* () {
            const i7 = `${th}?${t6}`, o5 = `${nh}?${t6}`;
            null === (r7 = null === (n4 = e10.platformManager) || void 0 === n4 ? void 0 : n4.openDeeplink) || void 0 === r7 || r7.call(n4, i7, o5, "_self");
          }));
        })(e9, U6), new Promise(((n4, r7) => {
          var i7, o5, s4;
          if (null === (i7 = e9.connector) || void 0 === i7 ? void 0 : i7.isAuthorized()) return clearTimeout(t5), void n4();
          null === (o5 = e9.connector) || void 0 === o5 || o5.once(So5.AUTHORIZED, (() => {
            clearTimeout(t5), n4();
          })), null === (s4 = e9.connector) || void 0 === s4 || s4.once(So5.REJECTED, (() => {
            clearTimeout(t5), r7(So5.REJECTED);
          }));
        }));
      }
      return tf4(e9, t4, U6);
    } catch (e10) {
      throw console.error("[startConnection] error", e10), e10;
    }
  }));
}
var of2 = class {
  constructor(e9) {
    var t4, n4, r6;
    this.state = { connector: void 0, qrcodeLink: void 0, analytics: void 0, developerMode: false, authorized: false, reconnection: false, preferDesktop: false, deeplinkProtocol: false, listeners: [], communicationLayerPreference: void 0, platformManager: void 0, pendingModal: void 0, installModal: void 0, otpAnswer: void 0 }, this.options = e9;
    const i6 = true === (null === (t4 = e9.logging) || void 0 === t4 ? void 0 : t4.developerMode) || true === (null === (n4 = e9.logging) || void 0 === n4 ? void 0 : n4.sdk);
    this.state.developerMode = i6, this.state.analytics = e9.analytics, this.state.preferDesktop = null !== (r6 = e9.preferDesktop) && void 0 !== r6 && r6, this.state.useDeeplink = e9.sdk.options.useDeeplink, this.state.communicationLayerPreference = e9.communicationLayerPreference, this.state.platformManager = e9.platformManager, e9.modals.install || (e9.modals.install = Jh), e9.modals.otp || (e9.modals.otp = Qh);
  }
  startConnection(e9) {
    return c5(this, void 0, void 0, (function* () {
      return rf2(this.state, this.options, e9);
    }));
  }
  initRemoteCommunication({ sdkInstance: e9 }) {
    var t4, n4, r6;
    return c5(this, void 0, void 0, (function* () {
      const i6 = yield null === (n4 = null === (t4 = e9.options.storage) || void 0 === t4 ? void 0 : t4.storageManager) || void 0 === n4 ? void 0 : n4.getPersistedChannelConfig();
      if (!this.options.ecies) {
        const e10 = { privateKey: null == i6 ? void 0 : i6.localKey };
        this.options.ecies = e10;
      }
      Xh(this.state, this.options), yield null === (r6 = this.getConnector()) || void 0 === r6 ? void 0 : r6.initFromDappStorage(), nf4(this.state, this.options);
    }));
  }
  showActiveModal() {
    return (function(e9) {
      var t4, n4, r6, i6;
      e9.authorized ? Iu("[RemoteConnection: showActiveModal()] already authorized") : e9.pendingModal ? null === (n4 = (t4 = e9.pendingModal).mount) || void 0 === n4 || n4.call(t4) : e9.installModal && (null === (i6 = (r6 = e9.installModal).mount) || void 0 === i6 || i6.call(r6, e9.qrcodeLink || ""));
    })(this.state);
  }
  closeModal() {
    var e9, t4, n4, r6;
    null === (t4 = null === (e9 = this.state.pendingModal) || void 0 === e9 ? void 0 : e9.unmount) || void 0 === t4 || t4.call(e9), null === (r6 = null === (n4 = this.state.installModal) || void 0 === n4 ? void 0 : n4.unmount) || void 0 === r6 || r6.call(n4, false);
  }
  getUniversalLink() {
    if (!this.state.qrcodeLink) throw new Error("connection not started. run startConnection() first.");
    return this.state.qrcodeLink;
  }
  getChannelConfig() {
    var e9;
    return null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.getChannelConfig();
  }
  getKeyInfo() {
    var e9;
    return null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.getKeyInfo();
  }
  getConnector() {
    if (!this.state.connector) throw new Error("invalid remote connector");
    return this.state.connector;
  }
  getPlatformManager() {
    if (!this.state.platformManager) throw new Error("PlatformManager not available");
    return this.state.platformManager;
  }
  isConnected() {
    var e9;
    return (null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.isReady()) || false;
  }
  isAuthorized() {
    var e9;
    return (null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.isAuthorized()) || false;
  }
  isPaused() {
    var e9;
    return null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.isPaused();
  }
  disconnect(e9) {
    var t4, n4, r6;
    Iu("[RemoteConnection: disconnect()]", e9), (null == e9 ? void 0 : e9.terminate) && (Gu.getProvider().handleDisconnect({ terminate: true }), null === (n4 = null === (t4 = this.state.pendingModal) || void 0 === t4 ? void 0 : t4.unmount) || void 0 === n4 || n4.call(t4), this.state.otpAnswer = void 0), null === (r6 = this.state.connector) || void 0 === r6 || r6.disconnect(e9), (function(e10) {
      Iu("[RemoteConnection: cleanupConnector()] cleaning up connector"), e10.connector && (ef4(e10), e10.connector.disconnect({ terminate: true }).catch(((e11) => {
        Iu("[RemoteConnection: cleanupConnector()] error disconnecting connector", e11);
      })));
    })(this.state);
  }
};
function sf2(e9) {
  var r6, i6, o4, s3, a4, l6, d5, u6, h7, f12, p7;
  return c5(this, void 0, void 0, (function* () {
    const { options: g3 } = e9;
    if (g3.logging = null !== (r6 = g3.logging) && void 0 !== r6 ? r6 : {}, g3.communicationLayerPreference = null !== (i6 = g3.communicationLayerPreference) && void 0 !== i6 ? i6 : jo3.SOCKET, void 0 !== g3.enableDebug && (import_debug.default.enable("MM_SDK"), console.warn("enableDebug is removed. Please use enableAnalytics instead.")), g3.enableAnalytics = null === (o4 = g3.enableAnalytics) || void 0 === o4 || o4, g3.injectProvider = null === (s3 = g3.injectProvider) || void 0 === s3 || s3, g3.shouldShimWeb3 = null === (a4 = g3.shouldShimWeb3) || void 0 === a4 || a4, g3.extensionOnly = null === (l6 = g3.extensionOnly) || void 0 === l6 || l6, g3.useDeeplink = null === (d5 = g3.useDeeplink) || void 0 === d5 || d5, g3.storage = null !== (u6 = g3.storage) && void 0 !== u6 ? u6 : { enabled: true }, g3.headless) {
      (0, import_debug.default)("[MetaMaskSDK: performSDKInitialization()] headless mode enabled");
      const e10 = () => {
      }, n4 = { install: () => ({ mount: e10, unmount: e10 }) }, r7 = { installer: e10 };
      g3.modals = n4, g3.ui = r7;
    }
    const m5 = true === (null === (h7 = g3.logging) || void 0 === h7 ? void 0 : h7.developerMode);
    e9.debug = (null === (f12 = g3.logging) || void 0 === f12 ? void 0 : f12.sdk) || m5, Iu("[MetaMaskSDK: performSDKInitialization()] options", e9.options);
    const y8 = Object.assign({}, g3.logging);
    m5 && (y8.sdk = true, y8.eciesLayer = true, y8.keyExchangeLayer = true, y8.remoteLayer = true, y8.serviceLayer = true, y8.plaintext = true), yield (function(e10) {
      var t4;
      return c5(this, void 0, void 0, (function* () {
        const { options: n4 } = e10;
        e10.platformManager = new Yu({ useDeepLink: null !== (t4 = n4.useDeeplink) && void 0 !== t4 && t4, preferredOpenLink: n4.openDeeplink, debug: e10.debug });
      }));
    })(e9), yield (function(e10) {
      var t4, n4, r7, i7, o5;
      return c5(this, void 0, void 0, (function* () {
        const { options: s4 } = e10, a5 = null === (t4 = e10.platformManager) || void 0 === t4 ? void 0 : t4.getPlatformType();
        e10.analytics = new xh({ serverUrl: null !== (n4 = s4.communicationServerUrl) && void 0 !== n4 ? n4 : fo5, enabled: s4.enableAnalytics, originatorInfo: { url: null !== (r7 = s4.dappMetadata.url) && void 0 !== r7 ? r7 : "", title: null !== (i7 = s4.dappMetadata.name) && void 0 !== i7 ? i7 : "", dappId: e10.getDappId(), platform: null != a5 ? a5 : "", source: null !== (o5 = s4._source) && void 0 !== o5 ? o5 : "", anonId: "" } });
      }));
    })(e9), yield (function(e10) {
      var t4, r7, i7;
      return c5(this, void 0, void 0, (function* () {
        if (!e10.options.enableAnalytics) return;
        if (!(null === (t4 = e10.platformManager) || void 0 === t4 ? void 0 : t4.isBrowser()) && !(null === (r7 = e10.platformManager) || void 0 === r7 ? void 0 : r7.isReactNative())) return;
        const o5 = e10.getVersion(), s4 = e10.getDappId(), a5 = yield e10.getAnonId(), c6 = null === (i7 = e10.platformManager) || void 0 === i7 ? void 0 : i7.getPlatformType(), l7 = e10.options._source;
        import_sdk_analytics.analytics.setGlobalProperty("sdk_version", o5), import_sdk_analytics.analytics.setGlobalProperty("dapp_id", s4), import_sdk_analytics.analytics.setGlobalProperty("anon_id", a5), import_sdk_analytics.analytics.setGlobalProperty("platform", c6), import_sdk_analytics.analytics.setGlobalProperty("integration_type", l7), import_sdk_analytics.analytics.enable(), import_sdk_analytics.analytics.track("sdk_initialized", {});
      }));
    })(e9), yield (function(e10) {
      var t4;
      return c5(this, void 0, void 0, (function* () {
        const { options: n4 } = e10;
        true !== (null === (t4 = n4.storage) || void 0 === t4 ? void 0 : t4.enabled) || n4.storage.storageManager || (n4.storage.storageManager = yield Zu(n4.storage));
      }));
    })(e9), yield (function(e10) {
      return c5(this, void 0, void 0, (function* () {
        const { options: t4 } = e10, n4 = /^(http|https):\/\/[^\s]*$/;
        if (t4.dappMetadata) {
          t4.dappMetadata.iconUrl && !n4.test(t4.dappMetadata.iconUrl) && (console.warn("Invalid dappMetadata.iconUrl: URL must start with http:// or https://"), t4.dappMetadata.iconUrl = void 0), t4.dappMetadata.base64Icon && t4.dappMetadata.base64Icon.length > Ih && (console.warn("Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters"), t4.dappMetadata.base64Icon = void 0), t4.dappMetadata.url && !n4.test(t4.dappMetadata.url) && console.warn("Invalid dappMetadata.url: URL must start with http:// or https://");
          const e11 = Mh();
          if (e11 && !t4.dappMetadata.iconUrl && !t4.dappMetadata.base64Icon) {
            const n5 = `${window.location.protocol}//${window.location.host}${e11}`;
            t4.dappMetadata.iconUrl = n5;
          }
        }
        e10.dappMetadata = t4.dappMetadata;
      }));
    })(e9), yield Lh(e9), yield Dh(e9);
    const { metamaskBrowserExtension: v7, preferExtension: b5, shouldReturn: w6 } = yield (function(e10) {
      var t4, n4, r7, i7;
      return c5(this, void 0, void 0, (function* () {
        const { options: o5 } = e10;
        let s4, a5 = false, l7 = false;
        if ("undefined" != typeof window && window.ethereum && !(null === (t4 = e10.platformManager) || void 0 === t4 ? void 0 : t4.isMetaMaskMobileWebView())) {
          a5 = "extension" === localStorage.getItem(dh);
          try {
            s4 = yield Nh({ mustBeMetaMask: true, sdkInstance: e10 }), window.extension = s4, s4.on(fh.CHAIN_CHANGED, ((t5) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE chainChanged chainId=${t5}`), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.CHAIN_CHANGED, t5);
            })), s4.on(fh.ACCOUNTS_CHANGED, ((t5) => c5(this, void 0, void 0, (function* () {
              var n5;
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE accountsChanged accounts=${t5}`);
              const r8 = Boolean(e10.sdkProvider), i8 = Boolean(e10.extensionActive);
              if (r8 && e10.getMobileProvider().emit(fh.ACCOUNTS_CHANGED, t5), i8 && 0 === (null == t5 ? void 0 : t5.length) && 0 === (yield null === (n5 = e10.getProvider()) || void 0 === n5 ? void 0 : n5.request({ method: oh.WALLET_GETPERMISSIONS, params: [] })).length) try {
                yield e10.terminate();
              } catch (e11) {
                Iu("[MetaMaskSDK: setupExtensionPreferences()] error terminating on permissions revoked", e11);
              }
            })))), s4.on(fh.DISCONNECT, ((t5) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE disconnect error=${t5}`), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.DISCONNECT, t5);
            })), s4.on(fh.CONNECT, ((t5) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connect args=${t5}`), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.CONNECT, t5);
            })), s4.on(fh.CONNECTED, ((t5) => {
              Iu("[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connected", t5), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.CONNECTED, t5);
            }));
          } catch (e11) {
            window.extension = void 0;
          }
        } else (null === (n4 = e10.platformManager) || void 0 === n4 ? void 0 : n4.isMetaMaskMobileWebView()) && (null === (r7 = e10.analytics) || void 0 === r7 || r7.send({ event: Ao5.SDK_USE_INAPP_BROWSER }), e10.activeProvider = Ph({ provider: window.ethereum, sdkInstance: e10 }), e10._initialized = true, l7 = true);
        return s4 && o5.extensionOnly && (Iu("[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization"), null === (i7 = e10.analytics) || void 0 === i7 || i7.send({ event: Ao5.SDK_USE_EXTENSION }), e10.activeProvider = s4, e10.extensionActive = true, e10.extension = s4, e10._initialized = true, l7 = true), { preferExtension: a5, shouldReturn: l7, metamaskBrowserExtension: s4 };
      }));
    })(e9);
    if (w6) Iu("[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization");
    else {
      yield (function(e10, t4) {
        var n4, r7, i7, o5, s4;
        return c5(this, void 0, void 0, (function* () {
          const { options: a5 } = e10, c6 = Object.assign({}, a5.logging);
          e10.remoteConnection = new of2({ anonId: yield e10.getAnonId(), preferDesktop: null !== (n4 = a5.preferDesktop) && void 0 !== n4 && n4, communicationLayerPreference: null !== (r7 = a5.communicationLayerPreference) && void 0 !== r7 ? r7 : jo3.SOCKET, analytics: e10.analytics, dappMetadata: a5.dappMetadata, _source: a5._source, enableAnalytics: null === (i7 = a5.enableAnalytics) || void 0 === i7 || i7, timer: a5.timer, sdk: e10, platformManager: e10.platformManager, transports: a5.transports, communicationServerUrl: a5.communicationServerUrl, storage: null !== (o5 = a5.storage) && void 0 !== o5 ? o5 : { enabled: true }, getMetaMaskInstaller: () => {
            if (!e10.installer) throw new Error("Invalid SDK status -- installer not initialized");
            return e10.installer;
          }, logging: c6, connectWithExtensionProvider: void 0 === t4 ? void 0 : () => vh(e10), modals: Object.assign(Object.assign({}, a5.modals), { onPendingModalDisconnect: e10.terminate.bind(e10) }) }), yield e10.remoteConnection.initRemoteCommunication({ sdkInstance: e10 }), e10.installer = new Yh({ remote: e10.remoteConnection, preferDesktop: null !== (s4 = a5.preferDesktop) && void 0 !== s4 && s4, platformManager: e10.platformManager, debug: e10.debug });
        }));
      })(e9, v7), yield kh(e9), yield (function(e10, t4) {
        var n4, r7;
        return c5(this, void 0, void 0, (function* () {
          const { options: i7 } = e10;
          t4 ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it."), null === (n4 = e10.analytics) || void 0 === n4 || n4.send({ event: Ao5.SDK_EXTENSION_UTILIZED }), vh(e10).catch(((e11) => {
            console.warn("Can't connect with MetaMask extension...", e11), localStorage.removeItem(dh);
          }))) : i7.checkInstallationImmediately && ((null === (r7 = e10.platformManager) || void 0 === r7 ? void 0 : r7.isDesktopWeb()) ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately"), e10.connect().catch(((e11) => {
            Iu(`[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=${e11}`);
          }))) : console.warn("[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop")), e10._initialized = true;
        }));
      })(e9, b5);
      try {
        yield null === (p7 = e9.remoteConnection) || void 0 === p7 ? void 0 : p7.startConnection({ initialCheck: true });
      } catch (e10) {
        console.error("[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation", e10);
      }
      e9.emit(Vu.ProviderUpdate, gh.INITIALIZED);
    }
  }));
}
var af2 = class extends import_eventemitter2.default {
  constructor(e9 = { storage: { enabled: true }, injectProvider: true, forceInjectProvider: false, enableAnalytics: true, shouldShimWeb3: true, useDeeplink: true, extensionOnly: true, headless: false, dappMetadata: { name: "", url: "", iconUrl: "" }, _source: eh, i18nOptions: { enabled: false } }) {
    var n4, r6, i6;
    super(), this.extensionActive = false, this._initialized = false, this.sdkInitPromise = void 0, this.debug = false, this.readonlyRPCCalls = false, this.availableLanguages = ["en"], this.ANON_ID_STORAGE_KEY = "mm-sdk-anon-id", import_debug.default.disable();
    const o4 = true === (null === (n4 = e9.logging) || void 0 === n4 ? void 0 : n4.developerMode);
    if (((null === (r6 = e9.logging) || void 0 === r6 ? void 0 : r6.sdk) || o4) && import_debug.default.enable("MM_SDK"), Iu("[MetaMaskSDK: constructor()]: begin."), this.setMaxListeners(50), !(null === (i6 = e9.dappMetadata) || void 0 === i6 ? void 0 : i6.url)) {
      if ("undefined" == typeof window || "undefined" == typeof document) throw new Error("You must provide dAppMetadata url");
      e9.dappMetadata = Object.assign(Object.assign({}, e9.dappMetadata), { url: `${window.location.protocol}//${window.location.host}` });
    }
    this.options = e9, this.options._source || (e9._source = eh), this.init().then((() => {
      Iu("[MetaMaskSDK: constructor()]: initialized successfully."), "undefined" != typeof window && (window.mmsdk = this);
    })).catch(((e10) => {
      console.error("[MetaMaskSDK: constructor()] error during initialization", e10);
    }));
  }
  init() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        var t4;
        return c5(this, void 0, void 0, (function* () {
          if ("undefined" != typeof window && (null === (t4 = window.mmsdk) || void 0 === t4 ? void 0 : t4.isInitialized())) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), Promise.resolve(window.mmsdk);
          if (e9._initialized) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), e9.sdkInitPromise;
          if (e9.sdkInitPromise) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initializing"), e9.sdkInitPromise;
          try {
            e9.sdkInitPromise = sf2(e9), yield e9.sdkInitPromise;
          } catch (e10) {
            throw console.error(e10), e10;
          }
          return e9.sdkInitPromise;
        }));
      })(this);
    }));
  }
  isExtensionActive() {
    return this.extensionActive;
  }
  checkExtensionAvailability() {
    var e9;
    return "undefined" != typeof window && Boolean(null === (e9 = window.ethereum) || void 0 === e9 ? void 0 : e9.isMetaMask);
  }
  connect() {
    return c5(this, void 0, void 0, (function* () {
      return (function(e9) {
        return c5(this, void 0, void 0, (function* () {
          if (e9._initialized || (Iu("[MetaMaskSDK: connect()] provider not ready -- wait for init()"), yield e9.init()), Iu(`[MetaMaskSDK: connect()] isExtensionActive=${e9.isExtensionActive()} activeProvider`, e9.activeProvider), !e9.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          const t4 = e9.activeProvider.getSelectedAddress();
          return t4 ? [t4] : e9.activeProvider.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
        }));
      })(this);
    }));
  }
  connectAndSign({ msg: e9 }) {
    return c5(this, void 0, void 0, (function* () {
      return yh({ instance: this, msg: e9 });
    }));
  }
  connectWith(e9) {
    return c5(this, void 0, void 0, (function* () {
      return (function({ instance: e10, rpc: t4 }) {
        return c5(this, void 0, void 0, (function* () {
          if (e10._initialized || (Iu("[MetaMaskSDK: connectWith()] provider not ready -- wait for init()"), yield e10.init()), Iu(`[MetaMaskSDK: connectWith()] method: ${t4.method} rpc=${t4}`), !e10.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          return e10.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [t4] });
        }));
      })({ instance: this, rpc: e9 });
    }));
  }
  resume() {
    return (function(e9) {
      var t4, n4, r6;
      return c5(this, void 0, void 0, (function* () {
        if (!(null === (n4 = null === (t4 = e9.remoteConnection) || void 0 === t4 ? void 0 : t4.getConnector()) || void 0 === n4 ? void 0 : n4.isReady())) return Iu("[MetaMaskSDK: resume()] channel is not ready -- starting connection"), void (null === (r6 = e9.remoteConnection) || void 0 === r6 || r6.startConnection());
        Iu("[MetaMaskSDK: resume()] channel is ready");
      }));
    })(this);
  }
  disconnect() {
    return console.warn("MetaMaskSDK.disconnect() is deprecated, use terminate()"), this.terminate();
  }
  isAuthorized() {
    var e9;
    null === (e9 = this.remoteConnection) || void 0 === e9 || e9.isAuthorized();
  }
  terminate() {
    return (function(e9) {
      var t4, n4, r6;
      return c5(this, void 0, void 0, (function* () {
        if (!(null === (t4 = e9.platformManager) || void 0 === t4 ? void 0 : t4.isMetaMaskMobileWebView())) {
          if (mh && (window.localStorage.removeItem(dh), window.localStorage.removeItem(hh), window.localStorage.removeItem(uh)), e9.extensionActive) {
            try {
              yield null === (n4 = e9.activeProvider) || void 0 === n4 ? void 0 : n4.request({ method: oh.WALLET_REVOKEPERMISSIONS, params: [{ eth_accounts: {} }] });
            } catch (e10) {
              Iu("[MetaMaskSDK: terminate()] error revoking permissions", e10);
            }
            return e9.options.extensionOnly ? (e9.emit(Vu.ProviderUpdate, gh.TERMINATE), void Iu("[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers")) : (e9.activeProvider = e9.sdkProvider, window.ethereum = e9.activeProvider, e9.extensionActive = false, void e9.emit(Vu.ProviderUpdate, gh.TERMINATE));
          }
          e9.emit(Vu.ProviderUpdate, gh.TERMINATE), Iu(`[MetaMaskSDK: terminate()] remoteConnection=${e9.remoteConnection}`), null === (r6 = e9.remoteConnection) || void 0 === r6 || r6.disconnect({ terminate: true, sendMessage: true });
        }
      }));
    })(this);
  }
  isInitialized() {
    return this._initialized;
  }
  setReadOnlyRPCCalls(e9) {
    this.readonlyRPCCalls = e9;
  }
  hasReadOnlyRPCCalls() {
    return this.readonlyRPCCalls;
  }
  getProvider() {
    if (this.activeProvider) return this.activeProvider;
    console.warn("MetaMaskSDK: No active provider found");
  }
  getMobileProvider() {
    if (!this.sdkProvider) throw new Error("SDK state invalid -- undefined mobile provider");
    return this.sdkProvider;
  }
  getUniversalLink() {
    var e9;
    const t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getUniversalLink();
    if (!t4) throw new Error("No Universal Link available, please call eth_requestAccounts first.");
    return t4;
  }
  getChannelId() {
    var e9, t4;
    return null === (t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getChannelConfig()) || void 0 === t4 ? void 0 : t4.channelId;
  }
  getRPCHistory() {
    var e9, t4;
    return null === (t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t4 ? void 0 : t4.getRPCMethodTracker();
  }
  getVersion() {
    return Xu.version;
  }
  getDappId() {
    var e9, t4, n4, r6;
    return "undefined" == typeof window || void 0 === window.location ? null !== (r6 = null !== (t4 = null === (e9 = this.options.dappMetadata) || void 0 === e9 ? void 0 : e9.name) && void 0 !== t4 ? t4 : null === (n4 = this.options.dappMetadata) || void 0 === n4 ? void 0 : n4.url) && void 0 !== r6 ? r6 : "N/A" : window.location.hostname;
  }
  getAnonId() {
    var e9, t4;
    return c5(this, void 0, void 0, (function* () {
      if (this._anonId) return this._anonId;
      let n4;
      return n4 = (null === (e9 = this.platformManager) || void 0 === e9 ? void 0 : e9.isBrowser()) ? this.getBrowserAnonId() : (null === (t4 = this.platformManager) || void 0 === t4 ? void 0 : t4.isReactNative()) ? yield this.getReactNativeAnonId() : v4_default(), this._anonId = n4, n4;
    }));
  }
  getBrowserAnonId() {
    const e9 = this.ANON_ID_STORAGE_KEY;
    try {
      const t4 = localStorage.getItem(e9);
      if (t4) return t4;
      const n4 = v4_default();
      return localStorage.setItem(e9, n4), n4;
    } catch (e10) {
      return console.error("[MetaMaskSDK: getBrowserAnonId()] LocalStorage access error:", e10), v4_default();
    }
  }
  getReactNativeAnonId() {
    return c5(this, void 0, void 0, (function* () {
      const e9 = this.ANON_ID_STORAGE_KEY;
      try {
        const t4 = __require("@react-native-async-storage/async-storage").default, n4 = yield t4.getItem(e9);
        if (n4) return n4;
        const r6 = v4_default();
        return yield t4.setItem(e9, r6), r6;
      } catch (e10) {
        return console.error("[MetaMaskSDK: getReactNativeAnonId()] Error accessing AsyncStorage:", e10), v4_default();
      }
    }));
  }
  getWalletStatus() {
    var e9, t4;
    return null === (t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t4 ? void 0 : t4.getConnectionStatus();
  }
  _getChannelConfig() {
    var e9;
    return null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getChannelConfig();
  }
  _ping() {
    var e9, t4;
    null === (t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t4 || t4.ping();
  }
  _keyCheck() {
    var e9, t4;
    null === (t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t4 || t4.keyCheck();
  }
  _getServiceStatus() {
    var e9, t4;
    return null === (t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t4 ? void 0 : t4.getServiceStatus();
  }
  _getRemoteConnection() {
    return this.remoteConnection;
  }
  _getDappMetadata() {
    return this.dappMetadata;
  }
  _getKeyInfo() {
    var e9;
    return null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getKeyInfo();
  }
  _resetKeys() {
    var e9, t4;
    null === (t4 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t4 || t4.resetKeys();
  }
  _getConnection() {
    return this.remoteConnection;
  }
  emit(e9, t4) {
    return super.emit(e9, t4);
  }
  on(e9, t4) {
    return super.on(e9, t4);
  }
};
var cf2 = Object.freeze({ __proto__: null, StorageManagerWeb: class {
  constructor({ enabled: e9 } = { enabled: false }) {
    this.enabled = false, this.enabled = e9;
  }
  persistChannelConfig(e9) {
    return c5(this, void 0, void 0, (function* () {
      const t4 = JSON.stringify(e9);
      Iu(`[StorageManagerWeb: persistChannelConfig()] enabled=${this.enabled}`, e9), localStorage.setItem(lh, t4);
    }));
  }
  getPersistedChannelConfig() {
    return c5(this, void 0, void 0, (function* () {
      let e9;
      try {
        if (Iu(`[StorageManagerWeb: getPersistedChannelConfig()] enabled=${this.enabled}`), e9 = localStorage.getItem(lh), Iu("[StorageManagerWeb: getPersistedChannelConfig()]", e9), !e9) return;
        const t4 = JSON.parse(e9);
        return Iu("[StorageManagerWeb: getPersistedChannelConfig()] channelConfig", t4), t4;
      } catch (e10) {
        return void console.error("[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config", e10);
      }
    }));
  }
  persistAccounts(e9) {
    return c5(this, void 0, void 0, (function* () {
      Iu(`[StorageManagerWeb: persistAccounts()] enabled=${this.enabled}`, e9);
      const t4 = JSON.stringify(e9);
      localStorage.setItem(uh, t4);
    }));
  }
  getCachedAccounts() {
    return c5(this, void 0, void 0, (function* () {
      try {
        const e9 = localStorage.getItem(uh);
        return e9 ? JSON.parse(e9) : [];
      } catch (e9) {
        throw console.error("[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts", e9), e9;
      }
    }));
  }
  persistChainId(e9) {
    return c5(this, void 0, void 0, (function* () {
      Iu(`[StorageManagerWeb: persistChainId()] enabled=${this.enabled}`, e9), localStorage.setItem(hh, e9);
    }));
  }
  getCachedChainId() {
    return c5(this, void 0, void 0, (function* () {
      try {
        const e9 = localStorage.getItem(hh);
        return null != e9 ? e9 : void 0;
      } catch (e9) {
        throw console.error("[StorageManagerWeb: getCachedChainId()] Error reading cached chainId", e9), e9;
      }
    }));
  }
  terminate() {
    return c5(this, void 0, void 0, (function* () {
      Iu(`[StorageManagerWeb: terminate()] enabled=${this.enabled}`), localStorage.removeItem(lh);
    }));
  }
} });
var lf2 = "hydrated";
var df2 = false;
var uf2 = false;
var hf2 = true;
var ff2 = Object.defineProperty;
var pf2 = /* @__PURE__ */ new WeakMap();
var gf2 = (e9) => pf2.get(e9);
var mf = (e9, t4) => pf2.set(t4.$lazyInstance$ = e9, t4);
var yf2 = (e9, t4) => t4 in e9;
var vf = (e9, t4) => (0, console.error)(e9, t4);
var bf2 = /* @__PURE__ */ new Map();
var wf = /* @__PURE__ */ new Map();
var Ef2 = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var Sf4 = "undefined" != typeof window ? window : {};
var _f4 = Sf4.document || { head: {} };
var Cf4 = { $flags$: 0, $resourcesUrl$: "", jmp: (e9) => e9(), raf: (e9) => requestAnimationFrame(e9), ael: (e9, t4, n4, r6) => e9.addEventListener(t4, n4, r6), rel: (e9, t4, n4, r6) => e9.removeEventListener(t4, n4, r6), ce: (e9, t4) => new CustomEvent(e9, t4) };
var kf4 = (() => {
  try {
    return new CSSStyleSheet(), "function" == typeof new CSSStyleSheet().replaceSync;
  } catch (e9) {
  }
  return false;
})();
var Af2 = false;
var xf = [];
var Mf4 = [];
var If2 = (e9, t4) => (t5) => {
  e9.push(t5), Af2 || (Af2 = true, 4 & Cf4.$flags$ ? Pf4(Rf4) : Cf4.raf(Rf4));
};
var Tf4 = (e9) => {
  for (let t4 = 0; t4 < e9.length; t4++) try {
    e9[t4](performance.now());
  } catch (e10) {
    vf(e10);
  }
  e9.length = 0;
};
var Rf4 = () => {
  Tf4(xf), Tf4(Mf4), (Af2 = xf.length > 0) && Cf4.raf(Rf4);
};
var Pf4 = (e9) => ((e10) => Promise.resolve(e10))().then(e9);
var Of4 = If2(Mf4);
var Nf4 = {};
var Lf4 = (e9) => "object" === (e9 = typeof e9) || "function" === e9;
function Df4(e9) {
  var t4, n4, r6;
  return null != (r6 = null == (n4 = null == (t4 = e9.head) ? void 0 : t4.querySelector('meta[name="csp-nonce"]')) ? void 0 : n4.getAttribute("content")) ? r6 : void 0;
}
((e9, t4) => {
  for (var n4 in t4) ff2(e9, n4, { get: t4[n4], enumerable: true });
})({}, { err: () => Bf2, map: () => Kf4, ok: () => $f4, unwrap: () => Hf4, unwrapErr: () => Ff4 });
var $f4 = (e9) => ({ isOk: true, isErr: false, value: e9 });
var Bf2 = (e9) => ({ isOk: false, isErr: true, value: e9 });
function Kf4(e9, t4) {
  if (e9.isOk) {
    const n4 = t4(e9.value);
    return n4 instanceof Promise ? n4.then(((e10) => $f4(e10))) : $f4(n4);
  }
  if (e9.isErr) {
    const t5 = e9.value;
    return Bf2(t5);
  }
  throw "should never get here";
}
var jf4;
var Uf4;
var Hf4 = (e9) => {
  if (e9.isOk) return e9.value;
  throw e9.value;
};
var Ff4 = (e9) => {
  if (e9.isErr) return e9.value;
  throw e9.value;
};
var zf4 = (e9, t4, ...n4) => {
  let r6 = null, i6 = false, o4 = false;
  const s3 = [], a4 = (t5) => {
    for (let n5 = 0; n5 < t5.length; n5++) r6 = t5[n5], Array.isArray(r6) ? a4(r6) : null != r6 && "boolean" != typeof r6 && ((i6 = "function" != typeof e9 && !Lf4(r6)) && (r6 = String(r6)), i6 && o4 ? s3[s3.length - 1].$text$ += r6 : s3.push(i6 ? qf4(null, r6) : r6), o4 = i6);
  };
  if (a4(n4), t4) {
    const e10 = t4.className || t4.class;
    e10 && (t4.class = "object" != typeof e10 ? e10 : Object.keys(e10).filter(((t5) => e10[t5])).join(" "));
  }
  if ("function" == typeof e9) return e9(null === t4 ? {} : t4, s3, Vf4);
  const c6 = qf4(e9, null);
  return c6.$attrs$ = t4, s3.length > 0 && (c6.$children$ = s3), c6;
};
var qf4 = (e9, t4) => {
  const n4 = { $flags$: 0, $tag$: e9, $text$: t4, $elm$: null, $children$: null, $attrs$: null };
  return n4;
};
var Wf4 = {};
var Vf4 = { forEach: (e9, t4) => e9.map(Gf4).forEach(t4), map: (e9, t4) => e9.map(Gf4).map(t4).map(Yf2) };
var Gf4 = (e9) => ({ vattrs: e9.$attrs$, vchildren: e9.$children$, vkey: e9.$key$, vname: e9.$name$, vtag: e9.$tag$, vtext: e9.$text$ });
var Yf2 = (e9) => {
  if ("function" == typeof e9.vtag) {
    const t5 = { ...e9.vattrs };
    return e9.vkey && (t5.key = e9.vkey), e9.vname && (t5.name = e9.vname), zf4(e9.vtag, t5, ...e9.vchildren || []);
  }
  const t4 = qf4(e9.vtag, e9.vtext);
  return t4.$attrs$ = e9.vattrs, t4.$children$ = e9.vchildren, t4.$key$ = e9.vkey, t4.$name$ = e9.vname, t4;
};
var Zf4 = (e9) => gf2(e9).$hostElement$;
var Jf2 = (e9, t4, n4) => {
  const r6 = Zf4(e9);
  return { emit: (e10) => Qf4(r6, t4, { bubbles: !!(4 & n4), composed: !!(2 & n4), cancelable: !!(1 & n4), detail: e10 }) };
};
var Qf4 = (e9, t4, n4) => {
  const r6 = Cf4.ce(t4, n4);
  return e9.dispatchEvent(r6), r6;
};
var Xf2 = /* @__PURE__ */ new WeakMap();
var ep = (e9) => {
  const t4 = e9.$cmpMeta$, n4 = e9.$hostElement$, r6 = t4.$flags$, i6 = (t4.$tagName$, () => {
  }), o4 = ((e10, t5, n5) => {
    var r7;
    const i7 = tp(t5), o5 = wf.get(i7);
    if (e10 = 11 === e10.nodeType ? e10 : _f4, o5) if ("string" == typeof o5) {
      e10 = e10.head || e10;
      let n6, s3 = Xf2.get(e10);
      if (s3 || Xf2.set(e10, s3 = /* @__PURE__ */ new Set()), !s3.has(i7)) {
        {
          n6 = _f4.createElement("style"), n6.innerHTML = o5;
          const i8 = null != (r7 = Cf4.$nonce$) ? r7 : Df4(_f4);
          if (null != i8 && n6.setAttribute("nonce", i8), !(1 & t5.$flags$)) if ("HEAD" === e10.nodeName) {
            const t6 = e10.querySelectorAll("link[rel=preconnect]"), r8 = t6.length > 0 ? t6[t6.length - 1].nextSibling : e10.querySelector("style");
            e10.insertBefore(n6, r8);
          } else if ("host" in e10) if (kf4) {
            const t6 = new CSSStyleSheet();
            t6.replaceSync(o5), e10.adoptedStyleSheets = [t6, ...e10.adoptedStyleSheets];
          } else {
            const t6 = e10.querySelector("style");
            t6 ? t6.innerHTML = o5 + t6.innerHTML : e10.prepend(n6);
          }
          else e10.append(n6);
          1 & t5.$flags$ && "HEAD" !== e10.nodeName && e10.insertBefore(n6, null);
        }
        4 & t5.$flags$ && (n6.innerHTML += Ef2), s3 && s3.add(i7);
      }
    } else e10.adoptedStyleSheets.includes(o5) || (e10.adoptedStyleSheets = [...e10.adoptedStyleSheets, o5]);
    return i7;
  })(n4.shadowRoot ? n4.shadowRoot : n4.getRootNode(), t4);
  10 & r6 && 2 & r6 && (n4["s-sc"] = o4, n4.classList.add(o4 + "-h")), i6();
};
var tp = (e9, t4) => "sc-" + e9.$tagName$;
var np = (e9, t4, n4, r6, i6, o4) => {
  if (n4 !== r6) {
    let s3 = yf2(e9, t4), a4 = t4.toLowerCase();
    if ("class" === t4) {
      const t5 = e9.classList, i7 = ip(n4), o5 = ip(r6);
      t5.remove(...i7.filter(((e10) => e10 && !o5.includes(e10)))), t5.add(...o5.filter(((e10) => e10 && !i7.includes(e10))));
    } else if ("style" === t4) {
      for (const t5 in n4) r6 && null != r6[t5] || (t5.includes("-") ? e9.style.removeProperty(t5) : e9.style[t5] = "");
      for (const t5 in r6) n4 && r6[t5] === n4[t5] || (t5.includes("-") ? e9.style.setProperty(t5, r6[t5]) : e9.style[t5] = r6[t5]);
    } else if (s3 || "o" !== t4[0] || "n" !== t4[1]) {
      const a5 = Lf4(r6);
      if ((s3 || a5 && null !== r6) && !i6) try {
        if (e9.tagName.includes("-")) e9[t4] = r6;
        else {
          const i7 = null == r6 ? "" : r6;
          "list" === t4 ? s3 = false : null != n4 && e9[t4] == i7 || ("function" == typeof e9.__lookupSetter__(t4) ? e9[t4] = i7 : e9.setAttribute(t4, i7));
        }
      } catch (e10) {
      }
      null == r6 || false === r6 ? false === r6 && "" !== e9.getAttribute(t4) || e9.removeAttribute(t4) : (!s3 || 4 & o4 || i6) && !a5 && (r6 = true === r6 ? "" : r6, e9.setAttribute(t4, r6));
    } else if (t4 = "-" === t4[2] ? t4.slice(3) : yf2(Sf4, a4) ? a4.slice(2) : a4[2] + t4.slice(3), n4 || r6) {
      const i7 = t4.endsWith(op);
      t4 = t4.replace(sp, ""), n4 && Cf4.rel(e9, t4, n4, i7), r6 && Cf4.ael(e9, t4, r6, i7);
    }
  }
};
var rp = /\s/;
var ip = (e9) => e9 ? e9.split(rp) : [];
var op = "Capture";
var sp = new RegExp(op + "$");
var ap = (e9, t4, n4) => {
  const r6 = 11 === t4.$elm$.nodeType && t4.$elm$.host ? t4.$elm$.host : t4.$elm$, i6 = e9 && e9.$attrs$ || Nf4, o4 = t4.$attrs$ || Nf4;
  for (const e10 of cp(Object.keys(i6))) e10 in o4 || np(r6, e10, i6[e10], void 0, n4, t4.$flags$);
  for (const e10 of cp(Object.keys(o4))) np(r6, e10, i6[e10], o4[e10], n4, t4.$flags$);
};
function cp(e9) {
  return e9.includes("ref") ? [...e9.filter(((e10) => "ref" !== e10)), "ref"] : e9;
}
var lp = false;
var dp = false;
var up = (e9, t4, n4, r6) => {
  const i6 = t4.$children$[n4];
  let o4, s3, a4 = 0;
  if (null !== i6.$text$) o4 = i6.$elm$ = _f4.createTextNode(i6.$text$);
  else {
    dp || (dp = "svg" === i6.$tag$), o4 = i6.$elm$ = _f4.createElementNS(dp ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", !lp && uf2 && 2 & i6.$flags$ ? "slot-fb" : i6.$tag$), dp && "foreignObject" === i6.$tag$ && (dp = false), ap(null, i6, dp);
    if (!!o4.getRootNode().querySelector("body") && df2 && ((e10) => null != e10)(jf4) && o4["s-si"] !== jf4 && o4.classList.add(o4["s-si"] = jf4), i6.$children$) for (a4 = 0; a4 < i6.$children$.length; ++a4) s3 = up(e9, i6, a4), s3 && o4.appendChild(s3);
    "svg" === i6.$tag$ ? dp = false : "foreignObject" === o4.tagName && (dp = true);
  }
  return o4["s-hn"] = Uf4, o4;
};
var hp = (e9, t4, n4, r6, i6, o4) => {
  let s3, a4 = e9;
  for (a4.shadowRoot && a4.tagName === Uf4 && (a4 = a4.shadowRoot); i6 <= o4; ++i6) r6[i6] && (s3 = up(null, n4, i6), s3 && (r6[i6].$elm$ = s3, mp(a4, s3, t4)));
};
var fp = (e9, t4, n4) => {
  for (let r6 = t4; r6 <= n4; ++r6) {
    const t5 = e9[r6];
    if (t5) {
      const e10 = t5.$elm$;
      e10 && e10.remove();
    }
  }
};
var pp = (e9, t4, n4 = false) => e9.$tag$ === t4.$tag$;
var gp = (e9, t4, n4 = false) => {
  const r6 = t4.$elm$ = e9.$elm$, i6 = e9.$children$, o4 = t4.$children$, s3 = t4.$tag$, a4 = t4.$text$;
  null === a4 ? (ap(e9, t4, dp = "svg" === s3 || "foreignObject" !== s3 && dp), null !== i6 && null !== o4 ? ((e10, t5, n5, r7, i7 = false) => {
    let o5, s4 = 0, a5 = 0, c6 = t5.length - 1, l6 = t5[0], d5 = t5[c6], u6 = r7.length - 1, h7 = r7[0], f12 = r7[u6];
    for (; s4 <= c6 && a5 <= u6; ) null == l6 ? l6 = t5[++s4] : null == d5 ? d5 = t5[--c6] : null == h7 ? h7 = r7[++a5] : null == f12 ? f12 = r7[--u6] : pp(l6, h7, i7) ? (gp(l6, h7, i7), l6 = t5[++s4], h7 = r7[++a5]) : pp(d5, f12, i7) ? (gp(d5, f12, i7), d5 = t5[--c6], f12 = r7[--u6]) : pp(l6, f12, i7) ? (gp(l6, f12, i7), mp(e10, l6.$elm$, d5.$elm$.nextSibling), l6 = t5[++s4], f12 = r7[--u6]) : pp(d5, h7, i7) ? (gp(d5, h7, i7), mp(e10, d5.$elm$, l6.$elm$), d5 = t5[--c6], h7 = r7[++a5]) : (o5 = up(t5 && t5[a5], n5, a5), h7 = r7[++a5], o5 && mp(l6.$elm$.parentNode, o5, l6.$elm$));
    s4 > c6 ? hp(e10, null == r7[u6 + 1] ? null : r7[u6 + 1].$elm$, n5, r7, a5, u6) : a5 > u6 && fp(t5, s4, c6);
  })(r6, i6, t4, o4, n4) : null !== o4 ? (null !== e9.$text$ && (r6.textContent = ""), hp(r6, null, t4, o4, 0, o4.length - 1)) : !n4 && hf2 && null !== i6 && fp(i6, 0, i6.length - 1), dp && "svg" === s3 && (dp = false)) : e9.$text$ !== a4 && (r6.data = a4);
};
var mp = (e9, t4, n4) => null == e9 ? void 0 : e9.insertBefore(t4, n4);
var yp = (e9, t4, n4 = false) => {
  const r6 = e9.$hostElement$, i6 = e9.$cmpMeta$, o4 = e9.$vnode$ || qf4(null, null), s3 = (a4 = t4) && a4.$tag$ === Wf4 ? t4 : zf4(null, null, t4);
  var a4;
  if (Uf4 = r6.tagName, n4 && s3.$attrs$) for (const e10 of Object.keys(s3.$attrs$)) r6.hasAttribute(e10) && !["key", "ref", "style", "class"].includes(e10) && (s3.$attrs$[e10] = r6[e10]);
  s3.$tag$ = null, s3.$flags$ |= 4, e9.$vnode$ = s3, s3.$elm$ = o4.$elm$ = r6.shadowRoot || r6, jf4 = r6["s-sc"], lp = 0 != (1 & i6.$flags$), gp(o4, s3, n4);
};
var vp = (e9, t4) => {
  t4 && !e9.$onRenderResolve$ && t4["s-p"] && t4["s-p"].push(new Promise(((t5) => e9.$onRenderResolve$ = t5)));
};
var bp = (e9, t4) => {
  if (e9.$flags$ |= 16, 4 & e9.$flags$) return void (e9.$flags$ |= 512);
  vp(e9, e9.$ancestorComponent$);
  return Of4((() => wp(e9, t4)));
};
var wp = (e9, t4) => {
  const n4 = e9.$hostElement$, r6 = (e9.$cmpMeta$.$tagName$, () => {
  }), i6 = e9.$lazyInstance$;
  if (!i6) throw new Error(`Can't render component <${n4.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);
  return r6(), Ep(void 0, (() => _p(e9, i6, t4)));
};
var Ep = (e9, t4) => Sp(e9) ? e9.then(t4).catch(((e10) => {
  console.error(e10), t4();
})) : t4();
var Sp = (e9) => e9 instanceof Promise || e9 && e9.then && "function" == typeof e9.then;
var _p = async (e9, t4, n4) => {
  var r6;
  const i6 = e9.$hostElement$, o4 = (e9.$cmpMeta$.$tagName$, () => {
  }), s3 = i6["s-rc"];
  n4 && ep(e9);
  const a4 = (e9.$cmpMeta$.$tagName$, () => {
  });
  Cp(e9, t4, i6, n4), s3 && (s3.map(((e10) => e10())), i6["s-rc"] = void 0), a4(), o4();
  {
    const t5 = null != (r6 = i6["s-p"]) ? r6 : [], n5 = () => kp(e9);
    0 === t5.length ? n5() : (Promise.all(t5).then(n5), e9.$flags$ |= 4, t5.length = 0);
  }
};
var Cp = (e9, t4, n4, r6) => {
  try {
    t4 = t4.render(), e9.$flags$ &= -17, e9.$flags$ |= 2, yp(e9, t4, r6);
  } catch (t5) {
    vf(t5, e9.$hostElement$);
  }
  return null;
};
var kp = (e9) => {
  e9.$cmpMeta$.$tagName$;
  const t4 = e9.$hostElement$, n4 = () => {
  }, r6 = e9.$lazyInstance$, i6 = e9.$ancestorComponent$;
  64 & e9.$flags$ ? n4() : (e9.$flags$ |= 64, Mp(t4), xp(r6, "componentDidLoad"), n4(), e9.$onReadyResolve$(t4), i6 || Ap()), e9.$onRenderResolve$ && (e9.$onRenderResolve$(), e9.$onRenderResolve$ = void 0), 512 & e9.$flags$ && Pf4((() => bp(e9, false))), e9.$flags$ &= -517;
};
var Ap = (e9) => {
  Mp(_f4.documentElement), Pf4((() => Qf4(Sf4, "appload", { detail: { namespace: "sdk-install-modal-web" } })));
};
var xp = (e9, t4, n4) => {
  if (e9 && e9[t4]) try {
    return e9[t4](n4);
  } catch (e10) {
    vf(e10);
  }
};
var Mp = (e9) => {
  var t4;
  return e9.classList.add(null != (t4 = lf2) ? t4 : "hydrated");
};
var Ip = (e9, t4, n4, r6) => {
  const i6 = gf2(e9);
  if (!i6) throw new Error(`Couldn't find host element for "${r6.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);
  const o4 = i6.$hostElement$, s3 = i6.$instanceValues$.get(t4), a4 = i6.$flags$, c6 = i6.$lazyInstance$;
  var l6, d5;
  l6 = n4, d5 = r6.$members$[t4][0], n4 = null == l6 || Lf4(l6) ? l6 : 4 & d5 ? "false" !== l6 && ("" === l6 || !!l6) : 1 & d5 ? String(l6) : l6;
  const u6 = Number.isNaN(s3) && Number.isNaN(n4);
  if ((!(8 & a4) || void 0 === s3) && (n4 !== s3 && !u6) && (i6.$instanceValues$.set(t4, n4), c6)) {
    if (r6.$watchers$ && 128 & a4) {
      const e10 = r6.$watchers$[t4];
      e10 && e10.map(((e11) => {
        try {
          c6[e11](n4, s3, t4);
        } catch (e12) {
          vf(e12, o4);
        }
      }));
    }
    2 == (18 & a4) && bp(i6, false);
  }
};
var Tp = (e9, t4, n4) => {
  var r6, i6;
  const o4 = e9.prototype;
  if (t4.$members$ || t4.$watchers$ || e9.watchers) {
    e9.watchers && !t4.$watchers$ && (t4.$watchers$ = e9.watchers);
    const s3 = Object.entries(null != (r6 = t4.$members$) ? r6 : {});
    if (s3.map((([e10, [r7]]) => {
      (31 & r7 || 2 & n4 && 32 & r7) && Object.defineProperty(o4, e10, { get() {
        return t5 = e10, gf2(this).$instanceValues$.get(t5);
        var t5;
      }, set(n5) {
        Ip(this, e10, n5, t4);
      }, configurable: true, enumerable: true });
    })), 1 & n4) {
      const n5 = /* @__PURE__ */ new Map();
      o4.attributeChangedCallback = function(e10, r7, i7) {
        Cf4.jmp((() => {
          var s4;
          const a4 = n5.get(e10);
          if (this.hasOwnProperty(a4)) i7 = this[a4], delete this[a4];
          else {
            if (o4.hasOwnProperty(a4) && "number" == typeof this[a4] && this[a4] == i7) return;
            if (null == a4) {
              const n6 = gf2(this), o5 = null == n6 ? void 0 : n6.$flags$;
              if (o5 && !(8 & o5) && 128 & o5 && i7 !== r7) {
                const o6 = n6.$lazyInstance$, a5 = null == (s4 = t4.$watchers$) ? void 0 : s4[e10];
                null == a5 || a5.forEach(((t5) => {
                  null != o6[t5] && o6[t5].call(o6, i7, r7, e10);
                }));
              }
              return;
            }
          }
          this[a4] = (null !== i7 || "boolean" != typeof this[a4]) && i7;
        }));
      }, e9.observedAttributes = Array.from(/* @__PURE__ */ new Set([...Object.keys(null != (i6 = t4.$watchers$) ? i6 : {}), ...s3.filter((([e10, t5]) => 15 & t5[0])).map((([e10, t5]) => {
        const r7 = t5[1] || e10;
        return n5.set(r7, e10), r7;
      }))]));
    }
  }
  return e9;
};
var Rp = async (e9, t4, n4, r6) => {
  let i6;
  if (0 == (32 & t4.$flags$)) {
    t4.$flags$ |= 32;
    if (n4.$lazyBundleId$) {
      const e10 = ((e11, t5, n5) => {
        const r8 = e11.$tagName$.replace(/-/g, "_"), i7 = e11.$lazyBundleId$;
        if (!i7) return;
        const o5 = bf2.get(i7);
        if (o5) return o5[r8];
        {
          const e12 = (e13) => (bf2.set(i7, e13), e13[r8]);
          if ("mm-install-modal_3" === i7) return Promise.resolve().then((function() {
            return wg;
          })).then(e12, vf);
        }
        return /* webpackIgnore: true */ /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ globImport_entry_js(`./${i7}.entry.js`).then(((e12) => (bf2.set(i7, e12), e12[r8])), vf);
      })(n4);
      if (e10 && "then" in e10) {
        const t5 = () => {
        };
        i6 = await e10, t5();
      } else i6 = e10;
      if (!i6) throw new Error(`Constructor for "${n4.$tagName$}#${t4.$modeName$}" was not found`);
      i6.isProxied || (n4.$watchers$ = i6.watchers, Tp(i6, n4, 2), i6.isProxied = true);
      const r7 = (n4.$tagName$, () => {
      });
      t4.$flags$ |= 8;
      try {
        new i6(t4);
      } catch (e11) {
        vf(e11);
      }
      t4.$flags$ &= -9, t4.$flags$ |= 128, r7(), Pp(t4.$lazyInstance$);
    } else {
      i6 = e9.constructor;
      const n5 = e9.localName;
      customElements.whenDefined(n5).then((() => t4.$flags$ |= 128));
    }
    if (i6 && i6.style) {
      let e10;
      "string" == typeof i6.style && (e10 = i6.style);
      const t5 = tp(n4);
      if (!wf.has(t5)) {
        const r7 = (n4.$tagName$, () => {
        });
        ((e11, t6, n5) => {
          let r8 = wf.get(e11);
          kf4 && n5 ? (r8 = r8 || new CSSStyleSheet(), "string" == typeof r8 ? r8 = t6 : r8.replaceSync(t6)) : r8 = t6, wf.set(e11, r8);
        })(t5, e10, !!(1 & n4.$flags$)), r7();
      }
    }
  }
  const o4 = t4.$ancestorComponent$, s3 = () => bp(t4, true);
  o4 && o4["s-rc"] ? o4["s-rc"].push(s3) : s3();
};
var Pp = (e9) => {
  xp(e9, "connectedCallback");
};
var Op = (e9) => {
  xp(e9, "disconnectedCallback");
};
var Np = (e9, t4 = {}) => {
  var n4;
  const r6 = () => {
  }, i6 = [], o4 = t4.exclude || [], s3 = Sf4.customElements, a4 = _f4.head, c6 = a4.querySelector("meta[charset]"), l6 = _f4.createElement("style"), d5 = [];
  let u6, h7 = true;
  Object.assign(Cf4, t4), Cf4.$resourcesUrl$ = new URL(t4.resourcesUrl || "./", _f4.baseURI).href;
  let f12 = false;
  if (e9.map(((e10) => {
    e10[1].map(((t5) => {
      var n5;
      const r7 = { $flags$: t5[0], $tagName$: t5[1], $members$: t5[2], $listeners$: t5[3] };
      4 & r7.$flags$ && (f12 = true), r7.$members$ = t5[2], r7.$watchers$ = null != (n5 = t5[4]) ? n5 : {};
      const a5 = r7.$tagName$, c7 = class extends HTMLElement {
        constructor(e11) {
          if (super(e11), this.hasRegisteredEventListeners = false, ((e12, t6) => {
            const n6 = { $flags$: 0, $hostElement$: e12, $cmpMeta$: t6, $instanceValues$: /* @__PURE__ */ new Map() };
            n6.$onReadyPromise$ = new Promise(((e13) => n6.$onReadyResolve$ = e13)), e12["s-p"] = [], e12["s-rc"] = [], pf2.set(e12, n6);
          })(e11 = this, r7), 1 & r7.$flags$) if (e11.shadowRoot) {
            if ("open" !== e11.shadowRoot.mode) throw new Error(`Unable to re-use existing shadow root for ${r7.$tagName$}! Mode is set to ${e11.shadowRoot.mode} but Stencil only supports open shadow roots.`);
          } else e11.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          gf2(this), this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = true), u6 && (clearTimeout(u6), u6 = null), h7 ? d5.push(this) : Cf4.jmp((() => ((e11) => {
            if (0 == (1 & Cf4.$flags$)) {
              const t6 = gf2(e11), n6 = t6.$cmpMeta$, r8 = (n6.$tagName$, () => {
              });
              if (1 & t6.$flags$) (null == t6 ? void 0 : t6.$lazyInstance$) ? Pp(t6.$lazyInstance$) : (null == t6 ? void 0 : t6.$onReadyPromise$) && t6.$onReadyPromise$.then((() => Pp(t6.$lazyInstance$)));
              else {
                t6.$flags$ |= 1;
                {
                  let n7 = e11;
                  for (; n7 = n7.parentNode || n7.host; ) if (n7["s-p"]) {
                    vp(t6, t6.$ancestorComponent$ = n7);
                    break;
                  }
                }
                n6.$members$ && Object.entries(n6.$members$).map((([t7, [n7]]) => {
                  if (31 & n7 && e11.hasOwnProperty(t7)) {
                    const n8 = e11[t7];
                    delete e11[t7], e11[t7] = n8;
                  }
                })), Rp(e11, t6, n6);
              }
              r8();
            }
          })(this)));
        }
        disconnectedCallback() {
          Cf4.jmp((() => (async (e11) => {
            if (0 == (1 & Cf4.$flags$)) {
              const t6 = gf2(e11);
              (null == t6 ? void 0 : t6.$lazyInstance$) ? Op(t6.$lazyInstance$) : (null == t6 ? void 0 : t6.$onReadyPromise$) && t6.$onReadyPromise$.then((() => Op(t6.$lazyInstance$)));
            }
          })(this)));
        }
        componentOnReady() {
          return gf2(this).$onReadyPromise$;
        }
      };
      r7.$lazyBundleId$ = e10[0], o4.includes(a5) || s3.get(a5) || (i6.push(a5), s3.define(a5, Tp(c7, r7, 1)));
    }));
  })), i6.length > 0 && (f12 && (l6.textContent += Ef2), l6.textContent += i6.sort() + "{visibility:hidden}.hydrated{visibility:inherit}", l6.innerHTML.length)) {
    l6.setAttribute("data-styles", "");
    const e10 = null != (n4 = Cf4.$nonce$) ? n4 : Df4(_f4);
    null != e10 && l6.setAttribute("nonce", e10), a4.insertBefore(l6, c6 ? c6.nextSibling : a4.firstChild);
  }
  h7 = false, d5.length ? d5.map(((e10) => e10.connectedCallback())) : Cf4.jmp((() => u6 = setTimeout(Ap, 30))), r6();
};
!(function() {
  if ("undefined" != typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var e9 = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(e9, [], this.constructor);
    }, HTMLElement.prototype = e9.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, e9);
  }
})();
var Lp = Object.freeze({ __proto__: null, defineCustomElements: async (e9, t4) => {
  if ("undefined" != typeof window) return await void 0, Np([["mm-install-modal_3", [[1, "mm-install-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }], [1, "mm-pending-modal", { displayOTP: [4, "display-o-t-p"], sdkVersion: [1, "sdk-version"], otpCode: [1, "otp-code"], translationsLoaded: [32] }], [1, "mm-select-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }]]]], t4);
}, setNonce: (e9) => Cf4.$nonce$ = e9 });
var Dp = { fontFamily: "Roboto, sans-serif" };
var $p = ({ className: e9 }, t4) => zf4("div", { style: Dp, class: e9 }, t4);
var Bp = ({ Icon: e9, text: t4 }) => zf4("div", { class: "flexContainer", style: { padding: "6", flexDirection: "row" } }, zf4("div", { class: "flexItem1" }, zf4(e9, null)), zf4("div", { class: "flexItem11" }, zf4("span", { style: { lineHeight: "2", color: "black" } }, t4)));
var Kp = () => zf4("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf4("path", { d: "M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z", fill: "#037DD6" }), zf4("path", { d: "M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z", fill: "#037DD6" }));
var jp = () => zf4("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf4("path", { d: "M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z", fill: "#037DD6" }));
var Up = () => zf4("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf4("path", { d: "M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z", fill: "#037DD6" }));
var Hp = () => zf4("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf4("path", { d: "M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf4("path", { d: "M12 2V14.88", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf4("path", { d: "M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }));
function Fp({ version: e9 }) {
  return zf4("div", { style: { textAlign: "center", color: "#BBC0C5", fontSize: "12" } }, "SDK Version ", e9 ? `v${e9}` : "unknown");
}
var zp = () => zf4("svg", { width: "14", height: "14", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf4("rect", { width: "16", height: "16", fill: "white" }), zf4("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z", fill: "#BBC0C5" }));
var qp = () => zf4("svg", { width: "120", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 127 63" }, zf4("path", { fill: "currentColor", d: "M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z" }));
function Wp(e9, t4) {
  return e9.toString(2).padStart(t4, "0");
}
function Vp(e9, t4) {
  const n4 = e9 % t4;
  return n4 >= 0 ? n4 : t4 + n4;
}
function Gp(e9, t4) {
  return new Array(e9).fill(t4);
}
function Yp(...e9) {
  let t4 = 0;
  for (const n5 of e9) t4 = Math.max(t4, n5.length);
  const n4 = [];
  for (let r6 = 0; r6 < t4; r6++) for (const t5 of e9) r6 >= t5.length || n4.push(t5[r6]);
  return new Uint8Array(n4);
}
function Zp(e9, t4, n4) {
  if (n4 < 0 || n4 + t4.length > e9.length) return false;
  for (let r6 = 0; r6 < t4.length; r6++) if (t4[r6] !== e9[n4 + r6]) return false;
  return true;
}
function Jp(e9) {
  return { has: (t4) => e9.includes(t4), decode: (t4) => {
    if (!Array.isArray(t4) || t4.length && "string" != typeof t4[0]) throw new Error("alphabet.decode input should be array of strings");
    return t4.map(((t5) => {
      if ("string" != typeof t5) throw new Error(`alphabet.decode: not string element=${t5}`);
      const n4 = e9.indexOf(t5);
      if (-1 === n4) throw new Error(`Unknown letter: "${t5}". Allowed: ${e9}`);
      return n4;
    }));
  }, encode: (t4) => {
    if (!Array.isArray(t4) || t4.length && "number" != typeof t4[0]) throw new Error("alphabet.encode input should be an array of numbers");
    return t4.map(((t5) => {
      if ((function(e10) {
        if (!Number.isSafeInteger(e10)) throw new Error(`Wrong integer: ${e10}`);
      })(t5), t5 < 0 || t5 >= e9.length) throw new Error(`Digit index outside alphabet: ${t5} (alphabet: ${e9.length})`);
      return e9[t5];
    }));
  } };
}
var Qp = class _Qp {
  static size(e9, t4) {
    if ("number" == typeof e9 && (e9 = { height: e9, width: e9 }), !Number.isSafeInteger(e9.height) && e9.height !== 1 / 0) throw new Error(`Bitmap: wrong height=${e9.height} (${typeof e9.height})`);
    if (!Number.isSafeInteger(e9.width) && e9.width !== 1 / 0) throw new Error(`Bitmap: wrong width=${e9.width} (${typeof e9.width})`);
    return void 0 !== t4 && (e9 = { width: Math.min(e9.width, t4.width), height: Math.min(e9.height, t4.height) }), e9;
  }
  static fromString(e9) {
    const t4 = (e9 = e9.replace(/^\n+/g, "").replace(/\n+$/g, "")).split("\n"), n4 = t4.length, r6 = new Array(n4);
    let i6;
    for (const e10 of t4) {
      const t5 = e10.split("").map(((e11) => {
        if ("X" === e11) return true;
        if (" " === e11) return false;
        if ("?" !== e11) throw new Error(`Bitmap.fromString: unknown symbol=${e11}`);
      }));
      if (i6 && t5.length !== i6) throw new Error(`Bitmap.fromString different row sizes: width=${i6} cur=${t5.length}`);
      i6 = t5.length, r6.push(t5);
    }
    return i6 || (i6 = 0), new _Qp({ height: n4, width: i6 }, r6);
  }
  constructor(e9, t4) {
    const { height: n4, width: r6 } = _Qp.size(e9);
    this.data = t4 || Array.from({ length: n4 }, (() => Gp(r6, void 0))), this.height = n4, this.width = r6;
  }
  point(e9) {
    return this.data[e9.y][e9.x];
  }
  isInside(e9) {
    return 0 <= e9.x && e9.x < this.width && 0 <= e9.y && e9.y < this.height;
  }
  size(e9) {
    if (!e9) return { height: this.height, width: this.width };
    const { x: t4, y: n4 } = this.xy(e9);
    return { height: this.height - n4, width: this.width - t4 };
  }
  xy(e9) {
    if ("number" == typeof e9 && (e9 = { x: e9, y: e9 }), !Number.isSafeInteger(e9.x)) throw new Error(`Bitmap: wrong x=${e9.x}`);
    if (!Number.isSafeInteger(e9.y)) throw new Error(`Bitmap: wrong y=${e9.y}`);
    return e9.x = Vp(e9.x, this.width), e9.y = Vp(e9.y, this.height), e9;
  }
  rect(e9, t4, n4) {
    const { x: r6, y: i6 } = this.xy(e9), { height: o4, width: s3 } = _Qp.size(t4, this.size({ x: r6, y: i6 }));
    for (let e10 = 0; e10 < o4; e10++) for (let t5 = 0; t5 < s3; t5++) this.data[i6 + e10][r6 + t5] = "function" == typeof n4 ? n4({ x: t5, y: e10 }, this.data[i6 + e10][r6 + t5]) : n4;
    return this;
  }
  rectRead(e9, t4, n4) {
    return this.rect(e9, t4, ((e10, t5) => (n4(e10, t5), t5)));
  }
  hLine(e9, t4, n4) {
    return this.rect(e9, { width: t4, height: 1 }, n4);
  }
  vLine(e9, t4, n4) {
    return this.rect(e9, { width: 1, height: t4 }, n4);
  }
  border(e9 = 2, t4) {
    const n4 = this.height + 2 * e9, r6 = this.width + 2 * e9, i6 = Gp(e9, t4), o4 = Array.from({ length: e9 }, (() => Gp(r6, t4)));
    return new _Qp({ height: n4, width: r6 }, [...o4, ...this.data.map(((e10) => [...i6, ...e10, ...i6])), ...o4]);
  }
  embed(e9, t4) {
    return this.rect(e9, t4.size(), (({ x: e10, y: n4 }) => t4.data[n4][e10]));
  }
  rectSlice(e9, t4 = this.size()) {
    const n4 = new _Qp(_Qp.size(t4, this.size(this.xy(e9))));
    return this.rect(e9, t4, (({ x: e10, y: t5 }, r6) => n4.data[t5][e10] = r6)), n4;
  }
  inverse() {
    const { height: e9, width: t4 } = this;
    return new _Qp({ height: t4, width: e9 }).rect({ x: 0, y: 0 }, 1 / 0, (({ x: e10, y: t5 }) => this.data[e10][t5]));
  }
  scale(e9) {
    if (!Number.isSafeInteger(e9) || e9 > 1024) throw new Error(`Wrong scale factor: ${e9}`);
    const { height: t4, width: n4 } = this;
    return new _Qp({ height: e9 * t4, width: e9 * n4 }).rect({ x: 0, y: 0 }, 1 / 0, (({ x: t5, y: n5 }) => this.data[Math.floor(n5 / e9)][Math.floor(t5 / e9)]));
  }
  clone() {
    return new _Qp(this.size()).rect({ x: 0, y: 0 }, this.size(), (({ x: e9, y: t4 }) => this.data[t4][e9]));
  }
  assertDrawn() {
    this.rectRead(0, 1 / 0, ((e9, t4) => {
      if ("boolean" != typeof t4) throw new Error("Invalid color type=" + typeof t4);
    }));
  }
  toString() {
    return this.data.map(((e9) => e9.map(((e10) => void 0 === e10 ? "?" : e10 ? "X" : " ")).join(""))).join("\n");
  }
  toASCII() {
    const { height: e9, width: t4, data: n4 } = this;
    let r6 = "";
    for (let i6 = 0; i6 < e9; i6 += 2) {
      for (let o4 = 0; o4 < t4; o4++) {
        const t5 = n4[i6][o4], s3 = i6 + 1 >= e9 || n4[i6 + 1][o4];
        t5 || s3 ? !t5 && s3 ? r6 += "" : t5 && !s3 ? r6 += "" : t5 && s3 && (r6 += " ") : r6 += "";
      }
      r6 += "\n";
    }
    return r6;
  }
  toTerm() {
    const e9 = "\x1B[0m", t4 = `\x1B[1;47m  ${e9}`, n4 = `\x1B[40m  ${e9}`;
    return this.data.map(((e10) => e10.map(((e11) => e11 ? n4 : t4)).join(""))).join("\n");
  }
  toSVG() {
    let e9 = `<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 ${this.width} ${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">`;
    return this.rectRead(0, 1 / 0, (({ x: t4, y: n4 }, r6) => {
      r6 && (e9 += `<rect x="${t4}" y="${n4}" width="1" height="1" />`);
    })), e9 += "</svg>", e9;
  }
  toGIF() {
    const e9 = (e10) => [255 & e10, e10 >>> 8 & 255], t4 = [...e9(this.width), ...e9(this.height)], n4 = [];
    this.rectRead(0, 1 / 0, ((e10, t5) => n4.push(+(true === t5))));
    const r6 = 126, i6 = [71, 73, 70, 56, 55, 97, ...t4, 246, 0, 0, 255, 255, 255, ...Gp(381, 0), 44, 0, 0, 0, 0, ...t4, 0, 7], o4 = Math.floor(n4.length / r6);
    for (let e10 = 0; e10 < o4; e10++) i6.push(127, 128, ...n4.slice(r6 * e10, r6 * (e10 + 1)).map(((e11) => +e11)));
    return i6.push(n4.length % r6 + 1, 128, ...n4.slice(o4 * r6).map(((e10) => +e10))), i6.push(1, 129, 0, 59), new Uint8Array(i6);
  }
  toImage(e9 = false) {
    const { height: t4, width: n4 } = this.size(), r6 = new Uint8Array(t4 * n4 * (e9 ? 3 : 4));
    let i6 = 0;
    for (let o4 = 0; o4 < t4; o4++) for (let t5 = 0; t5 < n4; t5++) {
      const n5 = this.data[o4][t5] ? 0 : 255;
      r6[i6++] = n5, r6[i6++] = n5, r6[i6++] = n5, e9 || (r6[i6++] = 255);
    }
    return { height: t4, width: n4, data: r6 };
  }
};
var Xp = ["low", "medium", "quartile", "high"];
var eg = ["numeric", "alphanumeric", "byte", "kanji", "eci"];
var tg = [26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
var ng = { low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] };
var rg = { low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] };
var ig = { size: { encode: (e9) => 21 + 4 * (e9 - 1), decode: (e9) => (e9 - 17) / 4 }, sizeType: (e9) => Math.floor((e9 + 7) / 17), alignmentPatterns(e9) {
  if (1 === e9) return [];
  const t4 = ig.size.encode(e9) - 6 - 1, n4 = t4 - 6, r6 = Math.ceil(n4 / 28);
  let i6 = Math.floor(n4 / r6);
  i6 % 2 ? i6 += 1 : n4 % r6 * 2 >= r6 && (i6 += 2);
  const o4 = [6];
  for (let e10 = 1; e10 < r6; e10++) o4.push(t4 - (r6 - e10) * i6);
  return o4.push(t4), o4;
}, ECCode: { low: 1, medium: 0, quartile: 3, high: 2 }, formatMask: 21522, formatBits(e9, t4) {
  const n4 = ig.ECCode[e9] << 3 | t4;
  let r6 = n4;
  for (let e10 = 0; e10 < 10; e10++) r6 = r6 << 1 ^ 1335 * (r6 >> 9);
  return (n4 << 10 | r6) ^ ig.formatMask;
}, versionBits(e9) {
  let t4 = e9;
  for (let e10 = 0; e10 < 12; e10++) t4 = t4 << 1 ^ 7973 * (t4 >> 11);
  return e9 << 12 | t4;
}, alphabet: { numeric: Jp("0123456789"), alphanumerc: Jp("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:") }, lengthBits: (e9, t4) => ({ numeric: [10, 12, 14], alphanumeric: [9, 11, 13], byte: [8, 16, 16], kanji: [8, 10, 12], eci: [0, 0, 0] })[t4][ig.sizeType(e9)], modeBits: { numeric: "0001", alphanumeric: "0010", byte: "0100", kanji: "1000", eci: "0111" }, capacity(e9, t4) {
  const n4 = tg[e9 - 1], r6 = ng[t4][e9 - 1], i6 = rg[t4][e9 - 1], o4 = Math.floor(n4 / i6) - r6, s3 = i6 - n4 % i6;
  return { words: r6, numBlocks: i6, shortBlocks: s3, blockLen: o4, capacity: 8 * (n4 - r6 * i6), total: (r6 + o4) * i6 + i6 - s3 };
} };
var og = [(e9, t4) => (e9 + t4) % 2 == 0, (e9, t4) => t4 % 2 == 0, (e9, t4) => e9 % 3 == 0, (e9, t4) => (e9 + t4) % 3 == 0, (e9, t4) => (Math.floor(t4 / 2) + Math.floor(e9 / 3)) % 2 == 0, (e9, t4) => e9 * t4 % 2 + e9 * t4 % 3 == 0, (e9, t4) => (e9 * t4 % 2 + e9 * t4 % 3) % 2 == 0, (e9, t4) => ((e9 + t4) % 2 + e9 * t4 % 3) % 2 == 0];
var sg = { tables: ((e9) => {
  const t4 = Gp(256, 0), n4 = Gp(256, 0);
  for (let e10 = 0, r6 = 1; e10 < 256; e10++) t4[e10] = r6, n4[r6] = e10, r6 <<= 1, 256 & r6 && (r6 ^= 285);
  return { exp: t4, log: n4 };
})(), exp: (e9) => sg.tables.exp[e9], log(e9) {
  if (0 === e9) throw new Error(`GF.log: wrong arg=${e9}`);
  return sg.tables.log[e9] % 255;
}, mul: (e9, t4) => 0 === e9 || 0 === t4 ? 0 : sg.tables.exp[(sg.tables.log[e9] + sg.tables.log[t4]) % 255], add: (e9, t4) => e9 ^ t4, pow: (e9, t4) => sg.tables.exp[sg.tables.log[e9] * t4 % 255], inv(e9) {
  if (0 === e9) throw new Error(`GF.inverse: wrong arg=${e9}`);
  return sg.tables.exp[255 - sg.tables.log[e9]];
}, polynomial(e9) {
  if (0 == e9.length) throw new Error("GF.polymomial: wrong length");
  if (0 !== e9[0]) return e9;
  let t4 = 0;
  for (; t4 < e9.length - 1 && 0 == e9[t4]; t4++) ;
  return e9.slice(t4);
}, monomial(e9, t4) {
  if (e9 < 0) throw new Error(`GF.monomial: wrong degree=${e9}`);
  if (0 == t4) return [0];
  let n4 = Gp(e9 + 1, 0);
  return n4[0] = t4, sg.polynomial(n4);
}, degree: (e9) => e9.length - 1, coefficient: (e9, t4) => e9[sg.degree(e9) - t4], mulPoly(e9, t4) {
  if (0 === e9[0] || 0 === t4[0]) return [0];
  const n4 = Gp(e9.length + t4.length - 1, 0);
  for (let r6 = 0; r6 < e9.length; r6++) for (let i6 = 0; i6 < t4.length; i6++) n4[r6 + i6] = sg.add(n4[r6 + i6], sg.mul(e9[r6], t4[i6]));
  return sg.polynomial(n4);
}, mulPolyScalar(e9, t4) {
  if (0 == t4) return [0];
  if (1 == t4) return e9;
  const n4 = Gp(e9.length, 0);
  for (let r6 = 0; r6 < e9.length; r6++) n4[r6] = sg.mul(e9[r6], t4);
  return sg.polynomial(n4);
}, mulPolyMonomial(e9, t4, n4) {
  if (t4 < 0) throw new Error("GF.mulPolyMonomial: wrong degree");
  if (0 == n4) return [0];
  const r6 = Gp(e9.length + t4, 0);
  for (let t5 = 0; t5 < e9.length; t5++) r6[t5] = sg.mul(e9[t5], n4);
  return sg.polynomial(r6);
}, addPoly(e9, t4) {
  if (0 === e9[0]) return t4;
  if (0 === t4[0]) return e9;
  let n4 = e9, r6 = t4;
  n4.length > r6.length && ([n4, r6] = [r6, n4]);
  let i6 = Gp(r6.length, 0), o4 = r6.length - n4.length, s3 = r6.slice(0, o4);
  for (let e10 = 0; e10 < s3.length; e10++) i6[e10] = s3[e10];
  for (let e10 = o4; e10 < r6.length; e10++) i6[e10] = sg.add(n4[e10 - o4], r6[e10]);
  return sg.polynomial(i6);
}, remainderPoly(e9, t4) {
  const n4 = Array.from(e9);
  for (let r6 = 0; r6 < e9.length - t4.length + 1; r6++) {
    const e10 = n4[r6];
    if (0 !== e10) for (let i6 = 1; i6 < t4.length; i6++) 0 !== t4[i6] && (n4[r6 + i6] = sg.add(n4[r6 + i6], sg.mul(t4[i6], e10)));
  }
  return n4.slice(e9.length - t4.length + 1, n4.length);
}, divisorPoly(e9) {
  let t4 = [1];
  for (let n4 = 0; n4 < e9; n4++) t4 = sg.mulPoly(t4, [1, sg.pow(2, n4)]);
  return t4;
}, evalPoly(e9, t4) {
  if (0 == t4) return sg.coefficient(e9, 0);
  let n4 = e9[0];
  for (let r6 = 1; r6 < e9.length; r6++) n4 = sg.add(sg.mul(t4, n4), e9[r6]);
  return n4;
}, euclidian(e9, t4, n4) {
  sg.degree(e9) < sg.degree(t4) && ([e9, t4] = [t4, e9]);
  let r6 = e9, i6 = t4, o4 = [0], s3 = [1];
  for (; 2 * sg.degree(i6) >= n4; ) {
    let e10 = r6, t5 = o4;
    if (r6 = i6, o4 = s3, 0 === r6[0]) throw new Error("rLast[0] === 0");
    i6 = e10;
    let n5 = [0];
    const a5 = sg.inv(r6[0]);
    for (; sg.degree(i6) >= sg.degree(r6) && 0 !== i6[0]; ) {
      const e11 = sg.degree(i6) - sg.degree(r6), t6 = sg.mul(i6[0], a5);
      n5 = sg.addPoly(n5, sg.monomial(e11, t6)), i6 = sg.addPoly(i6, sg.mulPolyMonomial(r6, e11, t6));
    }
    if (n5 = sg.mulPoly(n5, o4), s3 = sg.addPoly(n5, t5), sg.degree(i6) >= sg.degree(r6)) throw new Error(`Division failed r: ${i6}, rLast: ${r6}`);
  }
  const a4 = sg.coefficient(s3, 0);
  if (0 == a4) throw new Error("sigmaTilde(0) was zero");
  const c6 = sg.inv(a4);
  return [sg.mulPolyScalar(s3, c6), sg.mulPolyScalar(i6, c6)];
} };
function ag(e9, t4) {
  const { words: n4, shortBlocks: r6, numBlocks: i6, blockLen: o4, total: s3 } = ig.capacity(e9, t4), a4 = (c6 = n4, { encode(e10) {
    const t5 = sg.divisorPoly(c6), n5 = Array.from(e10);
    return n5.push(...t5.slice(0, -1).fill(0)), Uint8Array.from(sg.remainderPoly(n5, t5));
  }, decode(e10) {
    const t5 = e10.slice(), n5 = sg.polynomial(Array.from(e10));
    let r7 = Gp(c6, 0), i7 = false;
    for (let e11 = 0; e11 < c6; e11++) {
      const t6 = sg.evalPoly(n5, sg.exp(e11));
      r7[r7.length - 1 - e11] = t6, 0 !== t6 && (i7 = true);
    }
    if (!i7) return t5;
    r7 = sg.polynomial(r7);
    const o5 = sg.monomial(c6, 1), [s4, a5] = sg.euclidian(o5, r7, c6), l6 = Gp(sg.degree(s4), 0);
    let d5 = 0;
    for (let e11 = 1; e11 < 256 && d5 < l6.length; e11++) 0 === sg.evalPoly(s4, e11) && (l6[d5++] = sg.inv(e11));
    if (d5 !== l6.length) throw new Error("RS.decode: wrong errors number");
    for (let e11 = 0; e11 < l6.length; e11++) {
      const n6 = t5.length - 1 - sg.log(l6[e11]);
      if (n6 < 0) throw new Error("RS.decode: wrong error location");
      const r8 = sg.inv(l6[e11]);
      let i8 = 1;
      for (let t6 = 0; t6 < l6.length; t6++) e11 !== t6 && (i8 = sg.mul(i8, sg.add(1, sg.mul(l6[t6], r8))));
      t5[n6] = sg.add(t5[n6], sg.mul(sg.evalPoly(a5, r8), sg.inv(i8)));
    }
    return t5;
  } });
  var c6;
  return { encode(e10) {
    const t5 = [], n5 = [];
    for (let s5 = 0; s5 < i6; s5++) {
      const i7 = o4 + (s5 < r6 ? 0 : 1);
      t5.push(e10.subarray(0, i7)), n5.push(a4.encode(e10.subarray(0, i7))), e10 = e10.subarray(i7);
    }
    const s4 = Yp(...t5), c7 = Yp(...n5), l6 = new Uint8Array(s4.length + c7.length);
    return l6.set(s4), l6.set(c7, s4.length), l6;
  }, decode(e10) {
    if (e10.length !== s3) throw new Error(`interleave.decode: len(data)=${e10.length}, total=${s3}`);
    const t5 = [];
    for (let e11 = 0; e11 < i6; e11++) {
      const i7 = e11 < r6;
      t5.push(new Uint8Array(n4 + o4 + (i7 ? 0 : 1)));
    }
    let c7 = 0;
    for (let n5 = 0; n5 < o4; n5++) for (let r7 = 0; r7 < i6; r7++) t5[r7][n5] = e10[c7++];
    for (let n5 = r6; n5 < i6; n5++) t5[n5][o4] = e10[c7++];
    for (let s4 = o4; s4 < o4 + n4; s4++) for (let n5 = 0; n5 < i6; n5++) {
      const i7 = n5 < r6;
      t5[n5][s4 + (i7 ? 0 : 1)] = e10[c7++];
    }
    const l6 = [];
    for (const e11 of t5) l6.push(...Array.from(a4.decode(e11)).slice(0, -n4));
    return Uint8Array.from(l6);
  } };
}
function cg(e9, t4, n4, r6) {
  let i6 = "", o4 = n4.length;
  if ("numeric" === r6) {
    const e10 = ig.alphabet.numeric.decode(n4.split("")), t5 = e10.length;
    for (let n5 = 0; n5 < t5 - 2; n5 += 3) i6 += Wp(100 * e10[n5] + 10 * e10[n5 + 1] + e10[n5 + 2], 10);
    t5 % 3 == 1 ? i6 += Wp(e10[t5 - 1], 4) : t5 % 3 == 2 && (i6 += Wp(10 * e10[t5 - 2] + e10[t5 - 1], 7));
  } else if ("alphanumeric" === r6) {
    const e10 = ig.alphabet.alphanumerc.decode(n4.split("")), t5 = e10.length;
    for (let n5 = 0; n5 < t5 - 1; n5 += 2) i6 += Wp(45 * e10[n5] + e10[n5 + 1], 11);
    t5 % 2 == 1 && (i6 += Wp(e10[t5 - 1], 6));
  } else {
    if ("byte" !== r6) throw new Error("encode: unsupported type");
    {
      const e10 = (function(e11) {
        if ("string" != typeof e11) throw new Error("utf8ToBytes expected string, got " + typeof e11);
        return new Uint8Array(new TextEncoder().encode(e11));
      })(n4);
      o4 = e10.length, i6 = Array.from(e10).map(((e11) => Wp(e11, 8))).join("");
    }
  }
  const { capacity: s3 } = ig.capacity(e9, t4), a4 = Wp(o4, ig.lengthBits(e9, r6));
  let c6 = ig.modeBits[r6] + a4 + i6;
  if (c6.length > s3) throw new Error("Capacity overflow");
  c6 += "0".repeat(Math.min(4, Math.max(0, s3 - c6.length))), c6.length % 8 && (c6 += "0".repeat(8 - c6.length % 8));
  const l6 = "1110110000010001";
  for (let e10 = 0; c6.length !== s3; e10++) c6 += l6[e10 % 16];
  const d5 = Uint8Array.from(c6.match(/(.{8})/g).map(((e10) => Number(`0b${e10}`))));
  return ag(e9, t4).encode(d5);
}
function lg(e9, t4, n4, r6, i6 = false) {
  const o4 = (function(e10, t5, n5, r7 = false) {
    const i7 = ig.size.encode(e10);
    let o5 = new Qp(i7 + 2);
    const s4 = new Qp(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);
    o5 = o5.embed(0, s4).embed({ x: -s4.width, y: 0 }, s4).embed({ x: 0, y: -s4.height }, s4), o5 = o5.rectSlice(1, i7);
    const a5 = new Qp(1).rect(0, 1, true).border(1, false).border(1, true), c6 = ig.alignmentPatterns(e10);
    for (const e11 of c6) for (const t6 of c6) void 0 === o5.data[e11][t6] && o5.embed({ x: t6 - 2, y: e11 - 2 }, a5);
    o5 = o5.hLine({ x: 0, y: 6 }, 1 / 0, (({ x: e11 }, t6) => void 0 === t6 ? e11 % 2 == 0 : t6)).vLine({ x: 6, y: 0 }, 1 / 0, (({ y: e11 }, t6) => void 0 === t6 ? e11 % 2 == 0 : t6));
    {
      const e11 = ig.formatBits(t5, n5), s5 = (t6) => !r7 && 1 == (e11 >> t6 & 1);
      for (let e12 = 0; e12 < 6; e12++) o5.data[e12][8] = s5(e12);
      for (let e12 = 6; e12 < 8; e12++) o5.data[e12 + 1][8] = s5(e12);
      for (let e12 = 8; e12 < 15; e12++) o5.data[i7 - 15 + e12][8] = s5(e12);
      for (let e12 = 0; e12 < 8; e12++) o5.data[8][i7 - e12 - 1] = s5(e12);
      for (let e12 = 8; e12 < 9; e12++) o5.data[8][15 - e12 - 1 + 1] = s5(e12);
      for (let e12 = 9; e12 < 15; e12++) o5.data[8][15 - e12 - 1] = s5(e12);
      o5.data[i7 - 8][8] = !r7;
    }
    if (e10 >= 7) {
      const t6 = ig.versionBits(e10);
      for (let e11 = 0; e11 < 18; e11 += 1) {
        const n6 = !r7 && 1 == (t6 >> e11 & 1), s5 = Math.floor(e11 / 3), a6 = e11 % 3 + i7 - 8 - 3;
        o5.data[s5][a6] = n6, o5.data[a6][s5] = n6;
      }
    }
    return o5;
  })(e9, t4, r6, i6);
  let s3 = 0;
  const a4 = 8 * n4.length;
  if ((function(e10, t5, n5) {
    const r7 = e10.height, i7 = og[t5];
    let o5 = -1, s4 = r7 - 1;
    for (let t6 = r7 - 1; t6 > 0; t6 -= 2) {
      for (6 == t6 && (t6 = 5); ; s4 += o5) {
        for (let r8 = 0; r8 < 2; r8 += 1) {
          const o6 = t6 - r8;
          void 0 === e10.data[s4][o6] && n5(o6, s4, i7(o6, s4));
        }
        if (s4 + o5 < 0 || s4 + o5 >= r7) break;
      }
      o5 = -o5;
    }
  })(o4, r6, ((e10, t5, r7) => {
    let i7 = false;
    s3 < a4 && (i7 = 0 != (n4[s3 >>> 3] >> (7 - s3 & 7) & 1), s3++), o4.data[t5][e10] = i7 !== r7;
  })), s3 !== a4) throw new Error("QR: bytes left after draw");
  return o4;
}
function dg(e9) {
  const t4 = e9.inverse(), n4 = (e10) => {
    let t5 = 0;
    for (let n5, r7 = 0, i7 = 1; r7 < e10.length; r7++) n5 === e10[r7] && (i7++, r7 !== e10.length - 1) || (i7 >= 5 && (t5 += i7 - 5 + 3), n5 = e10[r7], i7 = 1);
    return t5;
  };
  let r6 = 0;
  e9.data.forEach(((e10) => r6 += n4(e10))), t4.data.forEach(((e10) => r6 += n4(e10)));
  let i6 = 0, o4 = e9.data;
  const s3 = e9.width - 1, a4 = e9.height - 1;
  for (let e10 = 0; e10 < s3; e10++) for (let t5 = 0; t5 < a4; t5++) {
    const n5 = e10 + 1, r7 = t5 + 1;
    o4[e10][t5] === o4[n5][t5] && o4[n5][t5] === o4[e10][r7] && o4[n5][t5] === o4[n5][r7] && (i6 += 3);
  }
  const c6 = (e10) => {
    const t5 = [true, false, true, true, true, false, true], n5 = [false, false, false, false], r7 = [...t5, ...n5], i7 = [...n5, ...t5];
    let o5 = 0;
    for (let t6 = 0; t6 < e10.length; t6++) Zp(e10, r7, t6) && (o5 += 40), Zp(e10, i7, t6) && (o5 += 40);
    return o5;
  };
  let l6 = 0;
  for (const t5 of e9.data) l6 += c6(t5);
  for (const e10 of t4.data) l6 += c6(e10);
  let d5 = 0;
  e9.rectRead(0, 1 / 0, ((e10, t5) => d5 += t5 ? 1 : 0));
  const u6 = d5 / (e9.height * e9.width) * 100, h7 = 10 * Math.floor(Math.abs(u6 - 50) / 5);
  return r6 + i6 + l6 + h7;
}
function ug(e9, t4 = "raw", n4 = {}) {
  const r6 = void 0 !== n4.ecc ? n4.ecc : "medium";
  !(function(e10) {
    if (!Xp.includes(e10)) throw new Error(`Invalid error correction mode=${e10}. Expected: ${Xp}`);
  })(r6);
  const i6 = void 0 !== n4.encoding ? n4.encoding : (function(e10) {
    let t5 = "numeric";
    for (let n5 of e10) if (!ig.alphabet.numeric.has(n5) && (t5 = "alphanumeric", !ig.alphabet.alphanumerc.has(n5))) return "byte";
    return t5;
  })(e9);
  !(function(e10) {
    if (!eg.includes(e10)) throw new Error(`Encoding: invalid mode=${e10}. Expected: ${eg}`);
    if ("kanji" === e10 || "eci" === e10) throw new Error(`Encoding: ${e10} is not supported (yet?).`);
  })(i6), void 0 !== n4.mask && (function(e10) {
    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(e10) || !og[e10]) throw new Error(`Invalid mask=${e10}. Expected number [0..7]`);
  })(n4.mask);
  let o4, s3 = n4.version, a4 = new Error("Unknown error");
  if (void 0 !== s3) !(function(e10) {
    if (!Number.isSafeInteger(e10) || e10 < 1 || e10 > 40) throw new Error(`Invalid version=${e10}. Expected number [1..40]`);
  })(s3), o4 = cg(s3, r6, e9, i6);
  else for (let t5 = 1; t5 <= 40; t5++) try {
    o4 = cg(t5, r6, e9, i6), s3 = t5;
    break;
  } catch (e10) {
    a4 = e10;
  }
  if (!s3 || !o4) throw a4;
  let c6 = (function(e10, t5, n5, r7) {
    if (void 0 === r7) {
      const i7 = (function() {
        let e11, t6 = 1 / 0;
        return { add(n6, r8) {
          n6 >= t6 || (e11 = r8, t6 = n6);
        }, get: () => e11, score: () => t6 };
      })();
      for (let r8 = 0; r8 < og.length; r8++) i7.add(dg(lg(e10, t5, n5, r8, true)), r8);
      r7 = i7.get();
    }
    if (void 0 === r7) throw new Error("Cannot find mask");
    return lg(e10, t5, n5, r7);
  })(s3, r6, o4, n4.mask);
  c6.assertDrawn();
  const l6 = void 0 === n4.border ? 2 : n4.border;
  if (!Number.isSafeInteger(l6)) throw new Error("Wrong border type=" + typeof l6);
  if (c6 = c6.border(l6, false), void 0 !== n4.scale && (c6 = c6.scale(n4.scale)), "raw" === t4) return c6.data;
  if ("ascii" === t4) return c6.toASCII();
  if ("svg" === t4) return c6.toSVG();
  if ("gif" === t4) return c6.toGIF();
  if ("term" === t4) return c6.toTerm();
  throw new Error(`Unknown output: ${t4}`);
}
var hg = { DESKTOP: "Desktop", MOBILE: "Mobile", META_MASK_MOBILE_APP: "MetaMask mobile app", SCAN_TO_CONNECT: "Scan to connect and sign with", CONNECT_WITH_EXTENSION: "Connect With MetaMask Extension", INSTALL_MODAL: { TRUSTED_BY_USERS: "Trusted by over 30 million users to buy, store, send and swap crypto securely", LEADING_CRYPTO_WALLET: "The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks", CONTROL_DIGITAL_INTERACTIONS: "Puts you in control of your digital interactions by making power of cryptography more accessible", INSTALL_META_MASK_EXTENSION: "Install MetaMask Extension" }, PENDING_MODAL: { OPEN_META_MASK_SELECT_CODE: "Please open the MetaMask wallet app and select the code on the screen OR disconnect", OPEN_META_MASK_CONTINUE: "Open the MetaMask app to continue with your session.", NUMBER_AFTER_OPEN_NOTICE: "If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.", DISCONNECT: "Disconnect" }, SELECT_MODAL: { CRYPTO_TAKE_CONTROL_TEXT: "Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide" }, META_MASK_MODAL: { ADDRESS_COPIED: "Address copied to clipboard!", DISCONNECT: "Disconnect", ACTIVE_NETWORK: "Active Network" } };
var fg = class {
  constructor(e9) {
    var t4;
    this.translations = hg, this.supportedLocales = ["es", "fr", "he", "it", "pt", "tr"], this.baseUrl = null !== (t4 = null == e9 ? void 0 : e9.baseUrl) && void 0 !== t4 ? t4 : "https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales";
  }
  getBrowserLanguage() {
    if ((navigator.languages || [navigator.language]).some(((e10) => e10.toLowerCase().startsWith("en")))) return "en";
    const e9 = navigator.language.toLowerCase().split("-")[0];
    return this.supportedLocales.includes(e9) ? e9 : "en";
  }
  async init(e9) {
    const t4 = this.getBrowserLanguage() || e9.fallbackLng;
    await this.loadTranslations(t4);
  }
  async loadTranslations(e9) {
    const t4 = e9.split("-")[0];
    if ("en" !== t4 && this.supportedLocales.includes(t4)) try {
      const e10 = `${this.baseUrl}/${t4}.json`, n4 = await fetch(e10);
      if (!n4.ok) throw new Error(`HTTP error! status: ${n4.status}`);
      this.translations = await n4.json();
    } catch (e10) {
      console.warn(` Failed to load ${t4} translations, falling back to English:`, e10), this.translations = hg;
    }
    else this.translations = hg;
  }
  t(e9) {
    return this.getNestedTranslation(e9, this.translations) || e9;
  }
  getNestedTranslation(e9, t4) {
    const n4 = e9.split(".");
    let r6 = t4;
    for (const e10 of n4) {
      if ("object" != typeof r6) return "";
      r6 = r6[e10];
    }
    return "string" == typeof r6 ? r6 : "";
  }
};
var pg;
!(function(e9) {
  e9.SDK_MODAL_VIEWED = "sdk_modal_viewed", e9.SDK_MODAL_BUTTON_CLICKED = "sdk_modal_button_clicked", e9.SDK_MODAL_TOGGLE_CHANGED = "sdk_modal_toggle_changed";
})(pg || (pg = {}));
var gg = class {
  constructor(e9) {
    mf(this, e9), this.close = Jf2(this, "close", 7), this.startDesktopOnboarding = Jf2(this, "startDesktopOnboarding", 7), this.trackAnalytics = Jf2(this, "trackAnalytics", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.onClose = this.onClose.bind(this), this.onStartDesktopOnboardingHandler = this.onStartDesktopOnboardingHandler.bind(this), this.setTab = this.setTab.bind(this), this.render = this.render.bind(this), this.setTab(this.preferDesktop ? 1 : 2), this.i18nInstance = new fg();
  }
  componentDidLoad() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_VIEWED, params: { extensionInstalled: false, tab: 1 === this.tab ? "desktop" : "mobile" } });
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  updatePreferDesktop(e9) {
    e9 ? this.setTab(1) : this.setTab(2);
  }
  onClose(e9 = false) {
    this.close.emit({ shouldTerminate: e9 });
  }
  onStartDesktopOnboardingHandler() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_BUTTON_CLICKED, params: { button_type: "install_extension", tab: "desktop" } }), this.startDesktopOnboarding.emit();
  }
  setTab(e9, t4 = false) {
    t4 && this.trackAnalytics.emit({ event: pg.SDK_MODAL_TOGGLE_CHANGED, params: { toggle: 1 === this.tab ? "desktop_to_mobile" : "mobile_to_desktop" } }), this.tab = e9, this.isDefaultTab = false;
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e9 = (e10) => this.i18nInstance.t(e10), t4 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, n4 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf4($p, { className: "install-model" }, zf4("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf4("div", { class: "modal" }, zf4("div", { class: "closeButtonContainer" }, zf4("div", { class: "right" }, zf4("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf4(zp, null)))), zf4("div", { class: "logoContainer" }, zf4(qp, null)), zf4("div", null, zf4("div", { class: "tabcontainer" }, zf4("div", { class: "flexContainer" }, zf4("div", { onClick: () => this.setTab(1, true), class: "tab flexItem " + (1 === t4 ? "tabactive" : "") }, e9("DESKTOP")), zf4("div", { onClick: () => this.setTab(2, true), class: "tab flexItem " + (2 === t4 ? "tabactive" : "") }, e9("MOBILE")))), zf4("div", { style: { display: 1 === t4 ? "none" : "block" } }, zf4("div", { class: "flexContainer" }, zf4("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, n4 && zf4("div", { id: "sdk-mm-qrcode", class: "center", innerHTML: n4 }), zf4("div", { class: "connectMobileText" }, e9("SCAN_TO_CONNECT"), " ", zf4("br", null), zf4("span", { class: "blue" }, zf4("b", null, e9("META_MASK_MOBILE_APP"))))))), zf4("div", { style: { display: 2 === t4 ? "none" : "block" } }, zf4("div", { class: "item" }, zf4(Bp, { Icon: jp, text: e9("INSTALL_MODAL.TRUSTED_BY_USERS") })), zf4("div", { class: "item" }, zf4(Bp, { Icon: Kp, text: e9("INSTALL_MODAL.LEADING_CRYPTO_WALLET") })), zf4("div", { class: "item" }, zf4(Bp, { Icon: Up, text: e9("INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS") })), zf4("button", { class: "button", onClick: () => this.onStartDesktopOnboardingHandler() }, zf4(Hp, null), zf4("span", { class: "installExtensionText" }, e9("INSTALL_MODAL.INSTALL_META_MASK_EXTENSION"))))), zf4(Fp, { version: this.sdkVersion })));
  }
  get el() {
    return Zf4(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
gg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var mg = class {
  constructor(e9) {
    mf(this, e9), this.close = Jf2(this, "close", 7), this.disconnect = Jf2(this, "disconnect", 7), this.updateOTPValue = Jf2(this, "updateOTPValue", 7), this.displayOTP = void 0, this.sdkVersion = void 0, this.otpCode = void 0, this.translationsLoaded = false, this.i18nInstance = new fg();
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose() {
    this.close.emit();
  }
  onDisconnect() {
    this.disconnect.emit();
  }
  onUpdateOTPValueHandler(e9) {
    this.updateOTPValue.emit({ otpValue: e9 });
  }
  disconnectedCallback() {
    this.onClose();
  }
  render() {
    var e9;
    if (!this.translationsLoaded) return null;
    const t4 = null === (e9 = this.displayOTP) || void 0 === e9 || e9, n4 = this.sdkVersion, r6 = (e10) => this.i18nInstance.t(e10);
    return zf4($p, { className: "pending-modal" }, zf4("div", { class: "backdrop", onClick: () => this.onClose() }), zf4("div", { class: "modal" }, zf4("div", { class: "closeButtonContainer" }, zf4("div", { class: "right" }, zf4("span", { class: "closeButton", onClick: () => this.onClose() }, zf4(zp, null)))), zf4("div", { class: "logoContainer" }, zf4(qp, null)), zf4("div", null, zf4("div", { class: "flexContainer", style: { flexDirection: "column", color: "black" } }, zf4("div", { class: "flexItem", style: { textAlign: "center", marginTop: "30px", marginBottom: "30px", fontSize: "16px" } }, r6(t4 ? "PENDING_MODAL.OPEN_META_MASK_SELECT_CODE" : "PENDING_MODAL.OPEN_META_MASK_CONTINUE")), zf4("div", { id: "sdk-mm-otp-value", style: { padding: "10px", fontSize: "32px", display: this.otpCode ? "block" : "none" } }, this.otpCode), t4 && zf4("div", { class: "notice" }, "* ", r6("PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE"))), zf4("div", { style: { marginTop: "20px" } }, zf4("button", { class: "button blue", style: { marginTop: "5px", color: "#0376C9", borderColor: "#0376C9", borderWidth: "1px", borderStyle: "solid", backgroundColor: "white" }, onClick: () => this.onDisconnect() }, r6("PENDING_MODAL.DISCONNECT")))), zf4(Fp, { version: n4 })));
  }
  get el() {
    return Zf4(this);
  }
};
mg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var yg = () => zf4("svg", { width: "21", height: "15", viewBox: "0 0 21 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf4("path", { d: "M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z", fill: "white" }));
var vg = () => zf4("svg", { width: "400", height: "300", viewBox: "0 0 400 300", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf4("rect", { width: "400", height: "300", fill: "white" }), zf4("path", { d: "M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z", fill: "#FF5C16" }), zf4("path", { d: "M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z", fill: "#FF5C16" }), zf4("path", { d: "M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z", fill: "#FF5C16" }), zf4("path", { d: "M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z", fill: "#FF5C16" }), zf4("path", { d: "M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z", fill: "#FF5C16" }), zf4("path", { d: "M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z", fill: "#FF5C16" }), zf4("path", { d: "M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z", fill: "#FF5C16" }), zf4("path", { d: "M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z", fill: "#E34807" }), zf4("path", { d: "M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z", fill: "#E34807" }), zf4("path", { d: "M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z", fill: "#E34807" }), zf4("path", { d: "M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z", fill: "#E34807" }), zf4("path", { d: "M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z", fill: "#FF8D5D" }), zf4("path", { d: "M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z", fill: "#FF8D5D" }), zf4("path", { d: "M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z", fill: "#FF8D5D" }), zf4("path", { d: "M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z", fill: "#661800" }), zf4("path", { d: "M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z", fill: "#661800" }), zf4("path", { d: "M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z", fill: "#661800" }), zf4("path", { d: "M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z", fill: "#661800" }), zf4("path", { d: "M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789", fill: "#661800" }), zf4("path", { d: "M213.047 229.789V250.066H186.944V229.789H213.047Z", fill: "#C0C4CD" }), zf4("path", { d: "M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z", fill: "#E7EBF6" }), zf4("path", { d: "M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z", fill: "#E7EBF6" }));
var bg = class {
  constructor(e9) {
    mf(this, e9), this.close = Jf2(this, "close", 7), this.connectWithExtension = Jf2(this, "connectWithExtension", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.i18nInstance = new fg(), this.setTab(this.preferDesktop ? 1 : 2);
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose(e9 = false) {
    this.close.emit({ shouldTerminate: e9 });
  }
  connectWithExtensionHandler() {
    this.connectWithExtension.emit();
  }
  setTab(e9) {
    this.tab = e9, this.isDefaultTab = false;
  }
  disconnectedCallback() {
    this.onClose();
  }
  updatePreferDesktop(e9) {
    e9 ? this.setTab(1) : this.setTab(2);
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e9 = (e10) => this.i18nInstance.t(e10), t4 = this.sdkVersion, n4 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, r6 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf4($p, { className: "select-modal" }, zf4("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf4("div", { class: "modal" }, zf4("div", { class: "closeButtonContainer" }, zf4("div", { class: "right" }, zf4("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf4(zp, null)))), zf4("div", { class: "logoContainer" }, zf4(qp, null)), zf4("div", null, zf4("div", { class: "tabcontainer" }, zf4("div", { class: "flexContainer" }, zf4("div", { onClick: () => this.setTab(1), class: "tab flexItem " + (1 === n4 ? "tabactive" : "") }, e9("DESKTOP")), zf4("div", { onClick: () => this.setTab(2), class: "tab flexItem " + (2 === n4 ? "tabactive" : "") }, e9("MOBILE")))), zf4("div", { style: { display: 1 === n4 ? "none" : "block" } }, zf4("div", { class: "flexContainer" }, zf4("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, zf4("div", { class: "center", id: "sdk-mm-qrcode", innerHTML: r6 }), zf4("div", { class: "connectMobileText" }, e9("SCAN_TO_CONNECT"), zf4("br", null), zf4("span", { class: "blue" }, zf4("b", null, e9("META_MASK_MOBILE_APP"))))))), zf4("div", { style: { display: 2 === n4 ? "none" : "block" } }, zf4("div", { style: { display: "flex", justifyContent: "center", height: "300", marginTop: "-20" } }, zf4(vg, null)), zf4("div", { class: "extensionLabel" }, e9("SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT")), zf4("button", { class: "button", onClick: () => this.connectWithExtensionHandler() }, zf4(yg, null), zf4("span", { class: "installExtensionText" }, e9("CONNECT_WITH_EXTENSION"))))), zf4(Fp, { version: t4 })));
  }
  get el() {
    return Zf4(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
bg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var wg = Object.freeze({ __proto__: null, mm_install_modal: gg, mm_pending_modal: mg, mm_select_modal: bg });

// node_modules/@dynamic-labs/ethereum/src/metaMask/utils/isPendingWalletRequestPermissionError.js
var isPendingWalletRequestPermissionError = (error) => typeof error === "object" && error !== null && "message" in error && error.message.includes("Request of type 'wallet_requestPermissions' already pending for origin");

// node_modules/@dynamic-labs/ethereum/src/metaMask/utils/waitForConnection.js
var waitForConnection = (provider) => new Promise((resolve) => {
  provider.once("connect", () => resolve());
});

// node_modules/@dynamic-labs/ethereum/src/metaMask/MetaMaskConnector.js
var _metaMaskSDK = null;
var _metaMaskDisplayUri = null;
var _metaMaskConnectUri = null;
var eventTimeline = createEventTimeline();
var setMetaMaskDisplayUri = (displayUri) => {
  _metaMaskDisplayUri = displayUri;
};
var MetaMaskConnector = class extends InjectedWalletBase {
  constructor(props) {
    super(props);
    this.name = "MetaMask";
    this.overrideKey = "metamask";
    this.canConnectViaQrCode = true;
    this.isInAppBrowser = false;
    this.appName = props.appName;
    this.appLogoUrl = props.appLogoUrl;
    this.isInAppBrowser = this.getIsInAppBrowser();
    this.canHandleMultipleConnections = this.isInstalledOnBrowser();
    logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] constructor", {
      hasMetaMaskSDK: Boolean(_metaMaskSDK)
    });
    if (!_metaMaskSDK) {
      this.createMetaMaskSDK();
    }
  }
  isInstalledOnBrowser() {
    var _a4;
    const metaMaskEip6963Provider = (_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.eip6963ProviderLookup(this.rdns);
    const isInstalled = Boolean(metaMaskEip6963Provider);
    return isInstalled;
  }
  getSupportedNetworks() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.evmNetworks.map((network) => network.chainId.toString());
    });
  }
  get metaMaskSDK() {
    if (!_metaMaskSDK)
      throw new Error("MetaMaskSDK not initialized");
    return _metaMaskSDK;
  }
  set metaMaskSDK(metaMaskSDK) {
    _metaMaskSDK = metaMaskSDK;
  }
  createMetaMaskSDK() {
    const dappMetadata = {
      iconUrl: this.appLogoUrl,
      name: this.appName,
      url: PlatformService.getOrigin()
    };
    logger3.debug("[MetaMaskConnector] createMetaMaskSDK - creating sdk", {
      dappMetadata
    });
    _metaMaskSDK = new af2({
      checkInstallationImmediately: true,
      dappMetadata,
      enableAnalytics: false,
      extensionOnly: this.isInstalledOnBrowser(),
      headless: true,
      injectProvider: false,
      openDeeplink: (url2) => {
        if (url2.includes("://connect")) {
          _metaMaskConnectUri = url2;
        } else {
          _metaMaskConnectUri = null;
        }
        PlatformService.openURL(url2);
      },
      preferDesktop: !isMobile(),
      readonlyRPCMap: getReadonlyRPCMap(this.evmNetworkRpcMap()),
      useDeeplink: true
    });
    logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] createMetaMaskSDK - created sdk", { _metaMaskSDK });
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      eventTimeline.postEvent("disconnect");
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] endSession - terminating sdk");
      if (isMobile()) {
        return this.metaMaskSDK.terminate().then(() => {
          _metaMaskSDK = null;
          _metaMaskConnectUri = null;
          return this.createMetaMaskSDK();
        });
      }
      return this.metaMaskSDK.terminate();
    });
  }
  getAddress(opts) {
    return __awaiter(this, void 0, void 0, function* () {
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - waiting for sdk init");
      yield this.metaMaskSDK.sdkInitPromise;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - sdk init promise resolved");
      const handleDisplayUri = (displayUri) => {
        var _a4;
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] handleDisplayUri", { displayUri });
        if (!displayUri)
          return;
        setMetaMaskDisplayUri(displayUri);
        (_a4 = opts === null || opts === void 0 ? void 0 : opts.onDisplayUri) === null || _a4 === void 0 ? void 0 : _a4.call(opts, displayUri);
      };
      if (!isMobile() && Boolean(opts === null || opts === void 0 ? void 0 : opts.onDisplayUri)) {
        this.metaMaskSDK.on("display_uri", handleDisplayUri);
      }
      try {
        if (this.shouldDeepLinkToMetaMaskInAppBrowser() && this.metadata.inAppBrowserUrl) {
          const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
          const { href } = PlatformService.getUrl();
          const deepLink = inAppBrowserCompiledTemplate({
            dappURI: href
          });
          PlatformService.openURL(deepLink);
          return;
        }
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - getting initial connected accounts");
        const initialConnectedAccounts = yield this.getConnectedAccountsSafely();
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - got initial connected accounts", { initialConnectedAccounts });
        if (initialConnectedAccounts.length) {
          return this.parseAddress(initialConnectedAccounts[0]);
        }
        try {
          logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - connecting to metaMask");
          yield this.metaMaskSDK.connect();
          logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - connected to metaMask");
        } catch (error) {
          logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - error connecting to metaMask", { error });
          if (eventTimeline.isEventRecent("disconnect", 1e3)) {
            throw new GetAddressCancelledError();
          }
          const isRequestPendingError = isPendingWalletRequestPermissionError(error);
          if (!isRequestPendingError) {
            throw MetaMaskError.fromError(error);
          } else {
            logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - error connection - waiting for connection");
            yield waitForConnection(this.getProvider());
          }
        }
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - getting connected accounts");
        const accounts = yield this.getConnectedAccounts();
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - got connected accounts", { accounts });
        return accounts[0];
      } finally {
        this.metaMaskSDK.off("display_uri", handleDisplayUri);
      }
    });
  }
  getConnectedAccountsSafely() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const connectedAccounts = yield this.getConnectedAccounts();
        return connectedAccounts;
      } catch (err) {
        logger3.error(err);
        return [];
      }
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.metaMaskSDK.sdkInitPromise;
      const provider = this.getProvider();
      if (!provider) {
        return [];
      }
      const accounts = yield retryableFn(() => provider.request({
        method: "eth_accounts",
        params: []
      }), {
        fallbackValue: [],
        timeoutMs: 1e3
      });
      if (!(accounts === null || accounts === void 0 ? void 0 : accounts.length)) {
        return [];
      }
      return accounts.map(this.parseAddress);
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - waiting for sdk init");
      yield this.metaMaskSDK.sdkInitPromise;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - sdk init promise resolved");
      const windowFocusPromiseForMobile = !this.isInAppBrowser && isMobile() ? waitForFocusWindowEvent() : Promise.resolve();
      const provider = this.getProvider();
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - got provider", { provider });
      if (!provider) {
        return void 0;
      }
      const [selectedAddress] = yield this.getConnectedAccounts();
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - got selected address", { selectedAddress });
      if (!selectedAddress) {
        return void 0;
      }
      const walletClient = this.getWalletClientForAddress(selectedAddress);
      if (!walletClient)
        return void 0;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - will sign", { messageToSign });
      const signature = yield walletClient.signMessage({
        message: messageToSign
      });
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - will wait for window focus");
      yield windowFocusPromiseForMobile;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - signed", { signature });
      return signature;
    });
  }
  chooseAccountsToConnect() {
    return __awaiter(this, void 0, void 0, function* () {
      return [];
    });
  }
  getWalletClient(chainId) {
    const provider = this.getProvider();
    logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getWalletClient - got provider", { provider });
    if (!provider) {
      return void 0;
    }
    const selectedAddress = provider.getSelectedAddress();
    return this.getWalletClientForAddress(selectedAddress || void 0, chainId);
  }
  get rdns() {
    const { rdns } = this.metadata;
    if (!rdns) {
      throw new Error("rdns not found in metadata");
    }
    return rdns;
  }
  setupEventListeners() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.metaMaskSDK.sdkInitPromise;
      const metaMaskProvider = this.getProvider();
      if (!metaMaskProvider) {
        return;
      }
      const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
      const handleAccountsChangedFromMetaMask = (accounts) => {
        if (eventTimeline.isEventRecent("disconnect", 1e3)) {
          return;
        }
        handleAccountChange(accounts);
      };
      metaMaskProvider.on("accountsChanged", handleAccountsChangedFromMetaMask);
      metaMaskProvider.on("chainChanged", handleChainChange);
      metaMaskProvider.on("disconnect", handleDisconnect);
      this.teardownEventListeners = () => {
        metaMaskProvider.off("accountsChanged", handleAccountsChangedFromMetaMask);
        metaMaskProvider.off("chainChanged", handleChainChange);
        metaMaskProvider.off("disconnect", handleDisconnect);
      };
    });
  }
  /**
   * This override is necessary to wait for the MetaMask SDK to initialize
   * before calling the super method. Otherwise, the super method may fail
   * to fetch the provider
   */
  getNetwork() {
    const _super = Object.create(null, {
      getNetwork: { get: () => super.getNetwork }
    });
    return __awaiter(this, void 0, void 0, function* () {
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getNetwork - waiting for sdk init");
      yield this.metaMaskSDK.sdkInitPromise;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getNetwork - sdk init promise resolved");
      const net = yield _super.getNetwork.call(this);
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getNetwork - got network", { network: net });
      return net;
    });
  }
  // Utils
  getProvider() {
    var _a4;
    return (_a4 = this.metaMaskSDK.getProvider()) !== null && _a4 !== void 0 ? _a4 : this.metaMaskSDK.getMobileProvider();
  }
  evmNetworkByChainId(chainId) {
    return this.evmNetworks.find((network) => network.chainId === chainId);
  }
  getWalletClientForAddress(address, chainId) {
    var _a4, _b;
    const provider = this.getProvider();
    if (!provider) {
      return void 0;
    }
    const effectiveChainId = (_b = (_a4 = this.toInt(chainId)) !== null && _a4 !== void 0 ? _a4 : this.getCurrentChainId()) !== null && _b !== void 0 ? _b : "1";
    const network = this.evmNetworkByChainId(effectiveChainId);
    return createWalletClient({
      account: address,
      chain: network ? getOrMapViemChain(network) : this.getActiveChain(),
      transport: custom(provider, this.providersConfig.httpTransportConfig)
    });
  }
  toInt(chainId) {
    if (!chainId)
      return void 0;
    try {
      return parseInt(chainId);
    } catch (err) {
      logger3.debug(err);
      return void 0;
    }
  }
  getCurrentChainId() {
    const provider = this.getProvider();
    if (!provider) {
      return void 0;
    }
    const chainId = provider.getChainId();
    if (isHex(chainId)) {
      return parseInt(chainId);
    }
    return chainId;
  }
  /**
   * Checks if the current environment is the MetaMask in-app browser
   * by checking if the MetaMask provider is installed in the window object
   * on a mobile device
   */
  getIsInAppBrowser() {
    var _a4, _b;
    if (!isMobile())
      return false;
    const provider = ((_a4 = this.ethProviderHelper) === null || _a4 === void 0 ? void 0 : _a4.eip6963ProviderLookup(this.rdns)) || ((_b = this.ethProviderHelper) === null || _b === void 0 ? void 0 : _b.getInjectedProvider());
    return Boolean(provider);
  }
  shouldDeepLinkToMetaMaskInAppBrowser() {
    if (this.isInAppBrowser)
      return false;
    if (!isMobile())
      return false;
    if (this.mobileExperience !== "in-app-browser")
      return false;
    if (!this.metadata.inAppBrowserUrl)
      return false;
    return true;
  }
  getConnectionUri() {
    return _metaMaskDisplayUri !== null && _metaMaskDisplayUri !== void 0 ? _metaMaskDisplayUri : void 0;
  }
  retryDeeplinkConnection() {
    if (_metaMaskConnectUri) {
      PlatformService.openURL(_metaMaskConnectUri);
    }
  }
};
var getReadonlyRPCMap = (evmNetworkRpcMap) => Object.keys(evmNetworkRpcMap).reduce((acc, chainId) => Object.assign(Object.assign({}, acc), { [toHex(parseInt(chainId))]: evmNetworkRpcMap[chainId] }), {});
var waitForFocusWindowEvent = () => new Promise((resolve) => {
  PlatformEventsService.once("appFocused", resolve);
}).then(() => new Promise((resolve) => setTimeout(resolve, 1e3)));

// node_modules/@dynamic-labs/ethereum/src/EthereumWalletConnectors.js
var EthereumWalletConnectors = (props) => {
  const { useMetamaskSdk } = props;
  const walletsWithCustomConnectors = [
    "phantomevm",
    "coinbase",
    "exodusevm",
    "abstract",
    "edenonline",
    "intersend"
  ];
  if (useMetamaskSdk) {
    walletsWithCustomConnectors.push("metamask");
  }
  return [
    ...injectedWalletOverrides,
    ...fetchInjectedWalletConnector(Object.assign(Object.assign({}, props), { walletsWithCustomConnectors })),
    ...fetchWalletConnectWallets(props),
    ...TurnkeyEVMWalletConnectors(props),
    ...DynamicWaasEVMConnectors(),
    ...useMetamaskSdk ? [MetaMaskConnector] : [],
    Coinbase,
    FallbackEvmConnector,
    getWalletConnectConnector()
  ];
};

// node_modules/@dynamic-labs/ethereum/src/EthereumWalletConnectorsWithConfig.js
var EthereumWalletConnectorsWithConfig = (providersConfig) => {
  const classWithConfig = (className) => class extends className {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...args) {
      const [opts] = args;
      const updatedProviderConfig = {
        httpTransportConfig: Object.assign(Object.assign({}, providersConfig.httpTransportConfig), providersConfig.publicClientHttpTransportConfig)
      };
      super(Object.assign(Object.assign({}, opts), { providersConfig: updatedProviderConfig }));
    }
  };
  return (props) => EthereumWalletConnectors(props).map(classWithConfig);
};

// node_modules/@dynamic-labs/ethereum/src/index.js
assertPackageVersion("@dynamic-labs/ethereum", version);
export {
  EthProviderHelper,
  InjectedWalletBase as EthereumInjectedConnector,
  EthereumWalletConnector,
  EthereumWalletConnectors,
  EthereumWalletConnectorsWithConfig,
  ExodusEvm,
  FallbackEvmConnector,
  INFURA_ID,
  PhantomEvm,
  createConnector,
  createInjectedConnector,
  fetchInjectedWalletConnector,
  injectedWalletOverrides,
  isEthereumWallet
};
/*! Bundled license information:

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)

@walletconnect/utils/dist/index.es.js:
@walletconnect/utils/dist/index.es.js:
@walletconnect/utils/dist/index.es.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@dynamic-labs_ethereum.js.map
