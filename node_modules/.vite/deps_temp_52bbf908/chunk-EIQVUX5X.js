import {
  createHash
} from "./chunk-GX5ZUNPE.js";
import {
  stringToBase64urlString
} from "./chunk-N6237SYY.js";
import {
  AuthenticatorTransportProtocol,
  DeferredPromise,
  DynamicError,
  LogLevel,
  Logger,
  PlatformService,
  WalletConnectorBase,
  assertPackageVersion,
  getTLD
} from "./chunk-3OCKXW2Z.js";
import {
  __commonJS,
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@turnkey/http/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/@turnkey/http/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = (function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    })();
    (function(globalThis2) {
      var irrelevant = (function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && (function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          })(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || (function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          })();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init2) {
          return new Promise(function(resolve, reject) {
            var request2 = new Request(input, init2);
            if (request2.signal && request2.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request2.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request2.method, fixUrl(request2.url), true);
            if (request2.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request2.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers || g.Headers && init2.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
              });
              request2.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request2.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request2.signal) {
              request2.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request2.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@dynamic-labs/embedded-wallet/src/types.js
var TurnkeyWalletConnectorInfo = {
  Turnkey: {
    key: "turnkey",
    name: "Turnkey"
  },
  TurnkeyHD: {
    key: "turnkeyhd",
    name: "Turnkey HD"
  }
};

// node_modules/@dynamic-labs/embedded-wallet/package.js
var version = "4.26.0";

// node_modules/@dynamic-labs/embedded-wallet/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

// node_modules/@turnkey/api-key-stamper/dist/index.mjs
var stampHeaderName = "X-Stamp";
var isCryptoEnabledBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var signWithApiKey = async (input) => {
  if (isCryptoEnabledBrowser) {
    const fn = await import("./webcrypto-HHX7M27T.js").then((m) => m.signWithApiKey);
    return fn(input);
  } else if (isNode) {
    const fn = await import("./nodecrypto-D7KNA7BK.js").then((m) => m.signWithApiKey);
    return fn(input);
  } else {
    const fn = await import("./purejs-G4IMHK5R.js").then((m) => m.signWithApiKey);
    return fn(input);
  }
};
var ApiKeyStamper = class {
  constructor(config) {
    this.apiPublicKey = config.apiPublicKey;
    this.apiPrivateKey = config.apiPrivateKey;
  }
  async stamp(payload) {
    const signature = await signWithApiKey({
      publicKey: this.apiPublicKey,
      privateKey: this.apiPrivateKey,
      content: payload
    });
    const stamp = {
      publicKey: this.apiPublicKey,
      scheme: "SIGNATURE_SCHEME_TK_API_P256",
      signature
    };
    return {
      stampHeaderName,
      stampHeaderValue: stringToBase64urlString(JSON.stringify(stamp))
    };
  }
};

// node_modules/@turnkey/http/dist/universal.mjs
var import_cross_fetch = __toESM(require_browser_ponyfill(), 1);
var fetch = import_cross_fetch.fetch;

// node_modules/@turnkey/http/dist/webauthn-json/convert.mjs
var copyValue = "copy";
var convertValue = "convert";
function derived(schema, derive) {
  return {
    required: true,
    schema,
    derive
  };
}
function required(schema) {
  return {
    required: true,
    schema
  };
}
function optional(schema) {
  return {
    required: false,
    schema
  };
}

// node_modules/@turnkey/http/dist/webauthn-json/schema.mjs
var simplifiedClientExtensionResultsSchema = {
  appid: optional(copyValue),
  appidExclude: optional(copyValue),
  credProps: optional(copyValue)
};
var publicKeyCredentialWithAttestation = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    attestationObject: required(convertValue),
    transports: derived(copyValue, (response) => response.getTransports?.() || [])
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
};
var publicKeyCredentialWithAssertion = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    authenticatorData: required(convertValue),
    signature: required(convertValue),
    userHandle: required(convertValue)
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
};

// node_modules/@turnkey/http/dist/webauthn.mjs
var defaultTimeout = 5 * 60 * 1e3;

// node_modules/@turnkey/http/dist/base.mjs
var TurnkeyRequestError = class extends Error {
  constructor(input) {
    let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;
    if (input.details != null) {
      turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;
    }
    super(turnkeyErrorMessage);
    this.name = "TurnkeyRequestError";
    this.details = input.details ?? null;
    this.code = input.code;
  }
};

// node_modules/@turnkey/http/dist/version.mjs
var VERSION = "@turnkey/http@2.15.0";

// node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs
var TurnkeyClient = class {
  constructor(config, stamper) {
    this.getActivity = async (input) => {
      return this.request("/public/v1/query/get_activity", input);
    };
    this.stampGetActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getApiKey = async (input) => {
      return this.request("/public/v1/query/get_api_key", input);
    };
    this.stampGetApiKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getApiKeys = async (input) => {
      return this.request("/public/v1/query/get_api_keys", input);
    };
    this.stampGetApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAttestationDocument = async (input) => {
      return this.request("/public/v1/query/get_attestation", input);
    };
    this.stampGetAttestationDocument = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_attestation";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAuthenticator = async (input) => {
      return this.request("/public/v1/query/get_authenticator", input);
    };
    this.stampGetAuthenticator = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticator";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAuthenticators = async (input) => {
      return this.request("/public/v1/query/get_authenticators", input);
    };
    this.stampGetAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOauthProviders = async (input) => {
      return this.request("/public/v1/query/get_oauth_providers", input);
    };
    this.stampGetOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOrganization = async (input) => {
      return this.request("/public/v1/query/get_organization", input);
    };
    this.stampGetOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOrganizationConfigs = async (input) => {
      return this.request("/public/v1/query/get_organization_configs", input);
    };
    this.stampGetOrganizationConfigs = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization_configs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicy = async (input) => {
      return this.request("/public/v1/query/get_policy", input);
    };
    this.stampGetPolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPrivateKey = async (input) => {
      return this.request("/public/v1/query/get_private_key", input);
    };
    this.stampGetPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getUser = async (input) => {
      return this.request("/public/v1/query/get_user", input);
    };
    this.stampGetUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWallet = async (input) => {
      return this.request("/public/v1/query/get_wallet", input);
    };
    this.stampGetWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getActivities = async (input) => {
      return this.request("/public/v1/query/list_activities", input);
    };
    this.stampGetActivities = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_activities";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicies = async (input) => {
      return this.request("/public/v1/query/list_policies", input);
    };
    this.stampGetPolicies = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_policies";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.listPrivateKeyTags = async (input) => {
      return this.request("/public/v1/query/list_private_key_tags", input);
    };
    this.stampListPrivateKeyTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_key_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPrivateKeys = async (input) => {
      return this.request("/public/v1/query/list_private_keys", input);
    };
    this.stampGetPrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getSubOrgIds = async (input) => {
      return this.request("/public/v1/query/list_suborgs", input);
    };
    this.stampGetSubOrgIds = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_suborgs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.listUserTags = async (input) => {
      return this.request("/public/v1/query/list_user_tags", input);
    };
    this.stampListUserTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_user_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getUsers = async (input) => {
      return this.request("/public/v1/query/list_users", input);
    };
    this.stampGetUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWalletAccounts = async (input) => {
      return this.request("/public/v1/query/list_wallet_accounts", input);
    };
    this.stampGetWalletAccounts = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallet_accounts";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWallets = async (input) => {
      return this.request("/public/v1/query/list_wallets", input);
    };
    this.stampGetWallets = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallets";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWhoami = async (input) => {
      return this.request("/public/v1/query/whoami", input);
    };
    this.stampGetWhoami = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/whoami";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.approveActivity = async (input) => {
      return this.request("/public/v1/submit/approve_activity", input);
    };
    this.stampApproveActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/approve_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createApiKeys = async (input) => {
      return this.request("/public/v1/submit/create_api_keys", input);
    };
    this.stampCreateApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createApiOnlyUsers = async (input) => {
      return this.request("/public/v1/submit/create_api_only_users", input);
    };
    this.stampCreateApiOnlyUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_only_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createAuthenticators = async (input) => {
      return this.request("/public/v1/submit/create_authenticators", input);
    };
    this.stampCreateAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createInvitations = async (input) => {
      return this.request("/public/v1/submit/create_invitations", input);
    };
    this.stampCreateInvitations = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_invitations";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createOauthProviders = async (input) => {
      return this.request("/public/v1/submit/create_oauth_providers", input);
    };
    this.stampCreateOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPolicies = async (input) => {
      return this.request("/public/v1/submit/create_policies", input);
    };
    this.stampCreatePolicies = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policies";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPolicy = async (input) => {
      return this.request("/public/v1/submit/create_policy", input);
    };
    this.stampCreatePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPrivateKeyTag = async (input) => {
      return this.request("/public/v1/submit/create_private_key_tag", input);
    };
    this.stampCreatePrivateKeyTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_key_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPrivateKeys = async (input) => {
      return this.request("/public/v1/submit/create_private_keys", input);
    };
    this.stampCreatePrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createReadOnlySession = async (input) => {
      return this.request("/public/v1/submit/create_read_only_session", input);
    };
    this.stampCreateReadOnlySession = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_only_session";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createReadWriteSession = async (input) => {
      return this.request("/public/v1/submit/create_read_write_session", input);
    };
    this.stampCreateReadWriteSession = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_write_session";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createSubOrganization = async (input) => {
      return this.request("/public/v1/submit/create_sub_organization", input);
    };
    this.stampCreateSubOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_sub_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createUserTag = async (input) => {
      return this.request("/public/v1/submit/create_user_tag", input);
    };
    this.stampCreateUserTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_user_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createUsers = async (input) => {
      return this.request("/public/v1/submit/create_users", input);
    };
    this.stampCreateUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createWallet = async (input) => {
      return this.request("/public/v1/submit/create_wallet", input);
    };
    this.stampCreateWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createWalletAccounts = async (input) => {
      return this.request("/public/v1/submit/create_wallet_accounts", input);
    };
    this.stampCreateWalletAccounts = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet_accounts";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteApiKeys = async (input) => {
      return this.request("/public/v1/submit/delete_api_keys", input);
    };
    this.stampDeleteApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteAuthenticators = async (input) => {
      return this.request("/public/v1/submit/delete_authenticators", input);
    };
    this.stampDeleteAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteInvitation = async (input) => {
      return this.request("/public/v1/submit/delete_invitation", input);
    };
    this.stampDeleteInvitation = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_invitation";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteOauthProviders = async (input) => {
      return this.request("/public/v1/submit/delete_oauth_providers", input);
    };
    this.stampDeleteOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePolicy = async (input) => {
      return this.request("/public/v1/submit/delete_policy", input);
    };
    this.stampDeletePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePrivateKeyTags = async (input) => {
      return this.request("/public/v1/submit/delete_private_key_tags", input);
    };
    this.stampDeletePrivateKeyTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_key_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePrivateKeys = async (input) => {
      return this.request("/public/v1/submit/delete_private_keys", input);
    };
    this.stampDeletePrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteSubOrganization = async (input) => {
      return this.request("/public/v1/submit/delete_sub_organization", input);
    };
    this.stampDeleteSubOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_sub_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteUserTags = async (input) => {
      return this.request("/public/v1/submit/delete_user_tags", input);
    };
    this.stampDeleteUserTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_user_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteUsers = async (input) => {
      return this.request("/public/v1/submit/delete_users", input);
    };
    this.stampDeleteUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteWallets = async (input) => {
      return this.request("/public/v1/submit/delete_wallets", input);
    };
    this.stampDeleteWallets = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_wallets";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.emailAuth = async (input) => {
      return this.request("/public/v1/submit/email_auth", input);
    };
    this.stampEmailAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/email_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportPrivateKey = async (input) => {
      return this.request("/public/v1/submit/export_private_key", input);
    };
    this.stampExportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportWallet = async (input) => {
      return this.request("/public/v1/submit/export_wallet", input);
    };
    this.stampExportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportWalletAccount = async (input) => {
      return this.request("/public/v1/submit/export_wallet_account", input);
    };
    this.stampExportWalletAccount = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet_account";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.importPrivateKey = async (input) => {
      return this.request("/public/v1/submit/import_private_key", input);
    };
    this.stampImportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/import_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.importWallet = async (input) => {
      return this.request("/public/v1/submit/import_wallet", input);
    };
    this.stampImportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/import_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initImportPrivateKey = async (input) => {
      return this.request("/public/v1/submit/init_import_private_key", input);
    };
    this.stampInitImportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initImportWallet = async (input) => {
      return this.request("/public/v1/submit/init_import_wallet", input);
    };
    this.stampInitImportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initOtpAuth = async (input) => {
      return this.request("/public/v1/submit/init_otp_auth", input);
    };
    this.stampInitOtpAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_otp_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initUserEmailRecovery = async (input) => {
      return this.request("/public/v1/submit/init_user_email_recovery", input);
    };
    this.stampInitUserEmailRecovery = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_user_email_recovery";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.oauth = async (input) => {
      return this.request("/public/v1/submit/oauth", input);
    };
    this.stampOauth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/oauth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.otpAuth = async (input) => {
      return this.request("/public/v1/submit/otp_auth", input);
    };
    this.stampOtpAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/otp_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.recoverUser = async (input) => {
      return this.request("/public/v1/submit/recover_user", input);
    };
    this.stampRecoverUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/recover_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.rejectActivity = async (input) => {
      return this.request("/public/v1/submit/reject_activity", input);
    };
    this.stampRejectActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/reject_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.removeOrganizationFeature = async (input) => {
      return this.request("/public/v1/submit/remove_organization_feature", input);
    };
    this.stampRemoveOrganizationFeature = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/remove_organization_feature";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.setOrganizationFeature = async (input) => {
      return this.request("/public/v1/submit/set_organization_feature", input);
    };
    this.stampSetOrganizationFeature = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/set_organization_feature";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signRawPayload = async (input) => {
      return this.request("/public/v1/submit/sign_raw_payload", input);
    };
    this.stampSignRawPayload = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payload";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signRawPayloads = async (input) => {
      return this.request("/public/v1/submit/sign_raw_payloads", input);
    };
    this.stampSignRawPayloads = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payloads";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signTransaction = async (input) => {
      return this.request("/public/v1/submit/sign_transaction", input);
    };
    this.stampSignTransaction = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_transaction";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updatePolicy = async (input) => {
      return this.request("/public/v1/submit/update_policy", input);
    };
    this.stampUpdatePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updatePrivateKeyTag = async (input) => {
      return this.request("/public/v1/submit/update_private_key_tag", input);
    };
    this.stampUpdatePrivateKeyTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_private_key_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateRootQuorum = async (input) => {
      return this.request("/public/v1/submit/update_root_quorum", input);
    };
    this.stampUpdateRootQuorum = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_root_quorum";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUser = async (input) => {
      return this.request("/public/v1/submit/update_user", input);
    };
    this.stampUpdateUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserTag = async (input) => {
      return this.request("/public/v1/submit/update_user_tag", input);
    };
    this.stampUpdateUserTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    if (!config.baseUrl) {
      throw new Error(`Missing base URL. Please verify env vars.`);
    }
    this.config = config;
    this.stamper = stamper;
  }
  async request(url, body) {
    const fullUrl = this.config.baseUrl + url;
    const stringifiedBody = JSON.stringify(body);
    const stamp = await this.stamper.stamp(stringifiedBody);
    const response = await fetch(fullUrl, {
      method: "POST",
      headers: {
        [stamp.stampHeaderName]: stamp.stampHeaderValue,
        "X-Client-Version": VERSION
      },
      body: stringifiedBody,
      redirect: "follow"
    });
    if (!response.ok) {
      let res;
      try {
        res = await response.json();
      } catch (_) {
        throw new Error(`${response.status} ${response.statusText}`);
      }
      throw new TurnkeyRequestError(res);
    }
    const data = await response.json();
    return data;
  }
};

// node_modules/@turnkey/http/dist/shared.mjs
var TurnkeyActivityError = class extends Error {
  constructor(input) {
    const { message, cause, activityId, activityStatus, activityType } = input;
    super(message);
    this.name = "TurnkeyActivityError";
    this.activityId = activityId ?? void 0;
    this.activityStatus = activityStatus ?? void 0;
    this.activityType = activityType ?? void 0;
    this.cause = cause ?? void 0;
  }
};
var TurnkeyActivityConsensusNeededError = class extends Error {
  constructor(input) {
    const { message, cause, activityId, activityStatus, activityType } = input;
    super(message);
    this.name = "TurnkeyActivityConsensusNeededError";
    this.activityId = activityId ?? void 0;
    this.activityStatus = activityStatus ?? void 0;
    this.activityType = activityType ?? void 0;
    this.cause = cause ?? void 0;
  }
};
function assertActivityCompleted(activity) {
  const { id: activityId, status: activityStatus } = activity;
  if (activityStatus === "ACTIVITY_STATUS_CONSENSUS_NEEDED") {
    throw new TurnkeyActivityConsensusNeededError({
      message: "Activity requires consensus",
      activityId,
      activityStatus
    });
  }
  if (activityStatus !== "ACTIVITY_STATUS_COMPLETED") {
    throw new TurnkeyActivityError({
      message: `Expected COMPLETED status, got ${activityStatus}`,
      activityId,
      activityStatus
    });
  }
  return true;
}
function assertNonNull(input) {
  if (input == null) {
    throw new Error(`Got unexpected ${JSON.stringify(input)}`);
  }
  return input;
}

// node_modules/@turnkey/iframe-stamper/dist/index.mjs
var stampHeaderName2 = "X-Stamp";
var IframeEventType;
(function(IframeEventType2) {
  IframeEventType2["PublicKeyReady"] = "PUBLIC_KEY_READY";
  IframeEventType2["InjectCredentialBundle"] = "INJECT_CREDENTIAL_BUNDLE";
  IframeEventType2["InjectKeyExportBundle"] = "INJECT_KEY_EXPORT_BUNDLE";
  IframeEventType2["InjectWalletExportBundle"] = "INJECT_WALLET_EXPORT_BUNDLE";
  IframeEventType2["InjectImportBundle"] = "INJECT_IMPORT_BUNDLE";
  IframeEventType2["ExtractWalletEncryptedBundle"] = "EXTRACT_WALLET_ENCRYPTED_BUNDLE";
  IframeEventType2["ExtractKeyEncryptedBundle"] = "EXTRACT_KEY_ENCRYPTED_BUNDLE";
  IframeEventType2["ApplySettings"] = "APPLY_SETTINGS";
  IframeEventType2["BundleInjected"] = "BUNDLE_INJECTED";
  IframeEventType2["EncryptedBundleExtracted"] = "ENCRYPTED_BUNDLE_EXTRACTED";
  IframeEventType2["SettingsApplied"] = "SETTINGS_APPLIED";
  IframeEventType2["StampRequest"] = "STAMP_REQUEST";
  IframeEventType2["Stamp"] = "STAMP";
  IframeEventType2["Error"] = "ERROR";
})(IframeEventType || (IframeEventType = {}));
var KeyFormat;
(function(KeyFormat2) {
  KeyFormat2["Hexadecimal"] = "HEXADECIMAL";
  KeyFormat2["Solana"] = "SOLANA";
})(KeyFormat || (KeyFormat = {}));
var IframeStamper = class {
  /**
   * Creates a new iframe stamper. This function _does not_ insert the iframe in the DOM.
   * Call `.init()` to insert the iframe element in the DOM.
   */
  constructor(config) {
    if (typeof window === "undefined") {
      throw new Error("Cannot initialize iframe in non-browser environment");
    }
    if (!config.iframeContainer) {
      throw new Error("Iframe container cannot be found");
    }
    this.container = config.iframeContainer;
    if (this.container.querySelector(`#${config.iframeElementId}`)) {
      throw new Error(`Iframe element with ID ${config.iframeElementId} already exists`);
    }
    let iframe = window.document.createElement("iframe");
    iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
    iframe.id = config.iframeElementId;
    iframe.src = config.iframeUrl;
    this.iframe = iframe;
    const iframeUrl = new URL(config.iframeUrl);
    this.iframeOrigin = iframeUrl.origin;
    this.iframePublicKey = null;
  }
  /**
   * Inserts the iframe on the page and returns a promise resolving to the iframe's public key
   */
  async init() {
    this.container.appendChild(this.iframe);
    return new Promise((resolve, _reject) => {
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.PublicKeyReady) {
          this.iframePublicKey = event.data["value"];
          resolve(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Removes the iframe from the DOM
   */
  clear() {
    this.iframe.remove();
  }
  /**
   * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
   */
  publicKey() {
    return this.iframePublicKey;
  }
  /**
   * Function to inject a new credential into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during recovery and auth flows.
   */
  async injectCredentialBundle(bundle) {
    return new Promise((resolve, reject) => {
      this.iframe.contentWindow?.postMessage({
        type: IframeEventType.InjectCredentialBundle,
        value: bundle
      }, "*");
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.BundleInjected) {
          resolve(event.data["value"]);
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Function to inject an export bundle into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * The key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
   * This is used during the private key export flow.
   */
  async injectKeyExportBundle(bundle, organizationId, keyFormat) {
    this.iframe.contentWindow?.postMessage({
      type: IframeEventType.InjectKeyExportBundle,
      value: bundle,
      keyFormat,
      organizationId
    }, "*");
    return new Promise((resolve, reject) => {
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.BundleInjected) {
          resolve(event.data["value"]);
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Function to inject an export bundle into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during the wallet export flow.
   */
  async injectWalletExportBundle(bundle, organizationId) {
    this.iframe.contentWindow?.postMessage({
      type: IframeEventType.InjectWalletExportBundle,
      value: bundle,
      organizationId
    }, "*");
    return new Promise((resolve, reject) => {
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.BundleInjected) {
          resolve(event.data["value"]);
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Function to inject an import bundle into the iframe
   * This is used to initiate either the wallet import flow or the private key import flow.
   */
  async injectImportBundle(bundle, organizationId, userId) {
    this.iframe.contentWindow?.postMessage({
      type: IframeEventType.InjectImportBundle,
      value: bundle,
      organizationId,
      userId
    }, "*");
    return new Promise((resolve, reject) => {
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.BundleInjected) {
          resolve(event.data["value"]);
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Function to extract an encrypted bundle from the iframe
   * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during the wallet import flow.
   */
  async extractWalletEncryptedBundle() {
    this.iframe.contentWindow?.postMessage({
      type: IframeEventType.ExtractWalletEncryptedBundle
    }, "*");
    return new Promise((resolve, reject) => {
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.EncryptedBundleExtracted) {
          resolve(event.data["value"]);
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Function to extract an encrypted bundle from the iframe
   * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * The key format to encode the private key in before it's encrypted and imported: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
   * This is used during the private key import flow.
   */
  async extractKeyEncryptedBundle(keyFormat) {
    this.iframe.contentWindow?.postMessage({
      type: IframeEventType.ExtractKeyEncryptedBundle,
      keyFormat
    }, "*");
    return new Promise((resolve, reject) => {
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.EncryptedBundleExtracted) {
          resolve(event.data["value"]);
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Function to apply settings on allowed parameters in the iframe
   * This is used to style the HTML element used for plaintext in wallet and private key import.
   */
  async applySettings(settings) {
    const settingsStr = JSON.stringify(settings);
    this.iframe.contentWindow?.postMessage({
      type: IframeEventType.ApplySettings,
      value: settingsStr
    }, "*");
    return new Promise((resolve, reject) => {
      window.addEventListener("message", (event) => {
        if (event.origin !== this.iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.SettingsApplied) {
          resolve(event.data["value"]);
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
  /**
   * Function to sign a payload with the underlying iframe
   */
  async stamp(payload) {
    if (this.iframePublicKey === null) {
      throw new Error("null iframe public key. Have you called/awaited .init()?");
    }
    const iframeOrigin = this.iframeOrigin;
    this.iframe.contentWindow?.postMessage({
      type: IframeEventType.StampRequest,
      value: payload
    }, "*");
    return new Promise(function(resolve, reject) {
      window.addEventListener("message", (event) => {
        if (event.origin !== iframeOrigin) {
          return;
        }
        if (event.data?.type === IframeEventType.Stamp) {
          resolve({
            stampHeaderName: stampHeaderName2,
            stampHeaderValue: event.data["value"]
          });
        }
        if (event.data?.type === IframeEventType.Error) {
          reject(event.data["value"]);
        }
      }, false);
    });
  }
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/BaseTurnkeyHandler.js
var BaseTurnkeyHandler = class {
  get client() {
    return this.__turnkeyClient;
  }
  get publicKey() {
    return this.__publicKey;
  }
  clear() {
    var _a2;
    (_a2 = this.__iframeStamper) === null || _a2 === void 0 ? void 0 : _a2.clear();
    this.__iframeStamper = void 0;
    this.__publicKey = void 0;
    this.__turnkeyClient = void 0;
  }
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/constants.js
var TURNKEY_API_BASE_URL = "https://api.turnkey.com";
var TURNKEY_API_KEY_EXPIRY_MESSAGE = "Turnkey error 16: expired api key";
var TURNKEY_API_KEY_NOT_FOUND_MESSAGE = "Turnkey error 16: could not find public key";
var WEBAUTHN_NOT_SUPPORTED_OR_CANCELLED_ERROR_MESSAGE = "The operation either timed out or was not allowed";
var WEBAUTHN_NOT_SUPPORTED_OR_DISABLED_ERROR_MESSAGE = "The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.";
var INVALID_PASSKEY_SELECTED_ERROR_MESSAGE = "Turnkey error 5: webauthn authenticator not found in organization or parent organization";
var USER_CANCELLED_REQUEST_ERROR_MESSAGE = "The user cancelled the request";
var TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS = [
  TURNKEY_API_KEY_EXPIRY_MESSAGE,
  TURNKEY_API_KEY_NOT_FOUND_MESSAGE
];
var TURNKEY_SDK_BENIGN_ERRORS = [
  WEBAUTHN_NOT_SUPPORTED_OR_CANCELLED_ERROR_MESSAGE,
  WEBAUTHN_NOT_SUPPORTED_OR_DISABLED_ERROR_MESSAGE,
  INVALID_PASSKEY_SELECTED_ERROR_MESSAGE,
  USER_CANCELLED_REQUEST_ERROR_MESSAGE
];

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/convertAttestationTransports/convertAttestationTransports.js
var transportMap = {
  AUTHENTICATOR_TRANSPORT_BLE: AuthenticatorTransportProtocol.Ble,
  AUTHENTICATOR_TRANSPORT_HYBRID: AuthenticatorTransportProtocol.Hybrid,
  AUTHENTICATOR_TRANSPORT_INTERNAL: AuthenticatorTransportProtocol.Internal,
  AUTHENTICATOR_TRANSPORT_NFC: AuthenticatorTransportProtocol.Nfc,
  AUTHENTICATOR_TRANSPORT_USB: AuthenticatorTransportProtocol.Usb
};
var convertAttestationTransports = (attestationTransports) => attestationTransports.map((transport) => transportMap[transport]);

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/logger/logger.js
var DynamicEmbeddedWalletsLogger = class extends Logger {
  constructor(name, level) {
    super(name, level);
  }
  error(message, ...args) {
    const [err] = args;
    if (!(err === null || err === void 0 ? void 0 : err.message) || !TURNKEY_SDK_BENIGN_ERRORS.some((errorMsg) => err.message.includes(errorMsg))) {
      this.log(LogLevel.ERROR, message, ...args);
    } else {
      this.warn(message, ...args);
    }
  }
};
var logger = new DynamicEmbeddedWalletsLogger("Dynamic embedded wallets", LogLevel.INFO);

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs
function bufferToBase64url2(buffer) {
  const byteView = new Uint8Array(buffer);
  let str = "";
  for (const charCode of byteView) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  const base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return base64urlString;
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs
var copyValue2 = "copy";
var convertValue2 = "convert";
function convert2(conversionFn, schema, input) {
  if (schema === copyValue2) {
    return input;
  }
  if (schema === convertValue2) {
    return conversionFn(input);
  }
  if (schema instanceof Array) {
    return input.map((v) => convert2(conversionFn, schema[0], v));
  }
  if (schema instanceof Object) {
    const output = {};
    for (const [key, schemaField] of Object.entries(schema)) {
      if (schemaField.derive) {
        const v = schemaField.derive(input);
        if (v !== void 0) {
          input[key] = v;
        }
      }
      if (!(key in input)) {
        if (schemaField.required) {
          throw new Error(`Missing key: ${key}`);
        }
        continue;
      }
      if (input[key] == null) {
        output[key] = null;
        continue;
      }
      output[key] = convert2(conversionFn, schemaField.schema, input[key]);
    }
    return output;
  }
}
function derived2(schema, derive) {
  return {
    required: true,
    schema,
    derive
  };
}
function required2(schema) {
  return {
    required: true,
    schema
  };
}
function optional2(schema) {
  return {
    required: false,
    schema
  };
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs
var simplifiedClientExtensionResultsSchema2 = {
  appid: optional2(copyValue2),
  appidExclude: optional2(copyValue2),
  credProps: optional2(copyValue2)
};
var publicKeyCredentialWithAssertion2 = {
  type: required2(copyValue2),
  id: required2(copyValue2),
  rawId: required2(convertValue2),
  authenticatorAttachment: optional2(copyValue2),
  response: required2({
    clientDataJSON: required2(convertValue2),
    authenticatorData: required2(convertValue2),
    signature: required2(convertValue2),
    userHandle: required2(convertValue2)
  }),
  clientExtensionResults: derived2(simplifiedClientExtensionResultsSchema2, (pkc) => pkc.getClientExtensionResults())
};

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs
function getResponseToJSON2(credential) {
  return convert2(bufferToBase64url2, publicKeyCredentialWithAssertion2, credential);
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs
async function get2(options) {
  const response = await navigator.credentials.get(options);
  response.toJSON = () => getResponseToJSON2(response);
  return response;
}

// node_modules/@turnkey/webauthn-stamper/dist/index.mjs
var stampHeaderName3 = "X-Stamp-Webauthn";
var defaultTimeout2 = 5 * 60 * 1e3;
var defaultUserVerification = "preferred";
var WebauthnStamper = class {
  constructor(config) {
    this.rpId = config.rpId;
    this.timeout = config.timeout || defaultTimeout2;
    this.userVerification = config.userVerification || defaultUserVerification;
    this.allowCredentials = config.allowCredentials || [];
  }
  async stamp(payload) {
    const challenge = getChallengeFromPayload(payload);
    const signingOptions = {
      publicKey: {
        rpId: this.rpId,
        challenge,
        allowCredentials: this.allowCredentials,
        timeout: this.timeout,
        userVerification: this.userVerification
      }
    };
    const clientGetResult = await get2(signingOptions);
    const assertion = clientGetResult.toJSON();
    const stamp = {
      authenticatorData: assertion.response.authenticatorData,
      clientDataJson: assertion.response.clientDataJSON,
      credentialId: assertion.id,
      signature: assertion.response.signature
    };
    return {
      stampHeaderName: stampHeaderName3,
      stampHeaderValue: JSON.stringify(stamp)
    };
  }
};
function getChallengeFromPayload(payload) {
  const hexString = createHash().update(payload).digest("hex");
  return new TextEncoder().encode(hexString);
}

// node_modules/@dynamic-labs/webauthn/package.js
var version2 = "4.26.0";

// node_modules/@dynamic-labs/webauthn/src/lib/errors/WebauthnNotSupportedError.js
var WebauthnNotSupportedError = class extends Error {
  constructor() {
    super("Webauthn is not supported on this device");
  }
};

// node_modules/@dynamic-labs/webauthn/_virtual/_tslib.js
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js
function bufferToBase64URLString(buffer) {
  const bytes = new Uint8Array(buffer);
  let str = "";
  for (const charCode of bytes) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js
function base64URLStringToBuffer(base64URLString) {
  const base64 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
  const padLength = (4 - base64.length % 4) % 4;
  const padded = base64.padEnd(base64.length + padLength, "=");
  const binary = atob(padded);
  const buffer = new ArrayBuffer(binary.length);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return buffer;
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js
function browserSupportsWebAuthn() {
  return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== void 0 && typeof globalThis.PublicKeyCredential === "function");
}
var _browserSupportsWebAuthnInternals = {
  stubThis: (value) => value
};

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js
function toPublicKeyCredentialDescriptor(descriptor) {
  const { id } = descriptor;
  return {
    ...descriptor,
    id: base64URLStringToBuffer(id),
    /**
     * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer
     * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports
     * are fine to pass to WebAuthn since browsers will recognize the new value.
     */
    transports: descriptor.transports
  };
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js
var WebAuthnError = class extends Error {
  constructor({ message, code, cause, name }) {
    super(message, { cause });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name ?? cause.name;
    this.code = code;
  }
};

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js
function identifyRegistrationError({ error, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "ConstraintError") {
    if (publicKey.authenticatorSelection?.requireResidentKey === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && publicKey.authenticatorSelection?.userVerification === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error
      });
    } else if (publicKey.authenticatorSelection?.userVerification === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error
      });
    }
  } else if (error.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error
    });
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = globalThis.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${globalThis.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return error;
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js
var BaseWebAuthnAbortService = class {
  constructor() {
    Object.defineProperty(this, "controller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
};
var WebAuthnAbortService = new BaseWebAuthnAbortService();

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js
var attachments = ["cross-platform", "platform"];
function toAuthenticatorAttachment(attachment) {
  if (!attachment) {
    return;
  }
  if (attachments.indexOf(attachment) < 0) {
    return;
  }
  return attachment;
}

// node_modules/@dynamic-labs/webauthn/node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js
async function startRegistration(options) {
  if (!options.optionsJSON && options.challenge) {
    console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
    options = { optionsJSON: options };
  }
  const { optionsJSON, useAutoRegister = false } = options;
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  const publicKey = {
    ...optionsJSON,
    challenge: base64URLStringToBuffer(optionsJSON.challenge),
    user: {
      ...optionsJSON.user,
      id: base64URLStringToBuffer(optionsJSON.user.id)
    },
    excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor)
  };
  const createOptions = {};
  if (useAutoRegister) {
    createOptions.mediation = "conditional";
  }
  createOptions.publicKey = publicKey;
  createOptions.signal = WebAuthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.create(createOptions);
  } catch (err) {
    throw identifyRegistrationError({ error: err, options: createOptions });
  }
  if (!credential) {
    throw new Error("Registration was not completed");
  }
  const { id, rawId, response, type } = credential;
  let transports = void 0;
  if (typeof response.getTransports === "function") {
    transports = response.getTransports();
  }
  let responsePublicKeyAlgorithm = void 0;
  if (typeof response.getPublicKeyAlgorithm === "function") {
    try {
      responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();
    } catch (error) {
      warnOnBrokenImplementation("getPublicKeyAlgorithm()", error);
    }
  }
  let responsePublicKey = void 0;
  if (typeof response.getPublicKey === "function") {
    try {
      const _publicKey = response.getPublicKey();
      if (_publicKey !== null) {
        responsePublicKey = bufferToBase64URLString(_publicKey);
      }
    } catch (error) {
      warnOnBrokenImplementation("getPublicKey()", error);
    }
  }
  let responseAuthenticatorData;
  if (typeof response.getAuthenticatorData === "function") {
    try {
      responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());
    } catch (error) {
      warnOnBrokenImplementation("getAuthenticatorData()", error);
    }
  }
  return {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      attestationObject: bufferToBase64URLString(response.attestationObject),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
      transports,
      publicKeyAlgorithm: responsePublicKeyAlgorithm,
      publicKey: responsePublicKey,
      authenticatorData: responseAuthenticatorData
    },
    type,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
  };
}
function warnOnBrokenImplementation(methodName, cause) {
  console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.
`, cause);
}

// node_modules/@dynamic-labs/webauthn/src/lib/logger.js
var logger2 = new Logger("Webauthn");

// node_modules/@dynamic-labs/webauthn/src/lib/createWebauthnCredential.js
var createWebauthnCredential = (options) => __awaiter2(void 0, void 0, void 0, function* () {
  if (!browserSupportsWebAuthn()) {
    throw new WebauthnNotSupportedError();
  }
  let attestationResp;
  try {
    attestationResp = yield startRegistration({
      optionsJSON: options
    });
  } catch (error) {
    logger2.debug("Failed to create webauthn credential", error);
    throw error;
  }
  return attestationResp;
});

// node_modules/@dynamic-labs/webauthn/src/lib/adapters/convertTransportEnumToTurnkeyEnum.js
var convertTransportEnumToTurnkeyEnum = (transportEnum) => {
  switch (transportEnum) {
    case "internal": {
      return "AUTHENTICATOR_TRANSPORT_INTERNAL";
    }
    case "usb": {
      return "AUTHENTICATOR_TRANSPORT_USB";
    }
    case "nfc": {
      return "AUTHENTICATOR_TRANSPORT_NFC";
    }
    case "ble": {
      return "AUTHENTICATOR_TRANSPORT_BLE";
    }
    case "hybrid": {
      return "AUTHENTICATOR_TRANSPORT_HYBRID";
    }
    default: {
      throw new Error("unsupported transport format " + transportEnum);
    }
  }
};

// node_modules/@dynamic-labs/webauthn/src/lib/adapters/getWebAuthnAttestationTurnkeyAdapter.js
var getWebAuthnAttestationTurnkeyAdapter = (options) => __awaiter2(void 0, void 0, void 0, function* () {
  if (!options.publicKey) {
    throw new Error("Invalid options. Public key attribute must be defined");
  }
  const attestation = yield createWebauthnCredential(convertPublicKeyToWebauthn(options.publicKey));
  return convertAttestationResultToTurnkey(attestation);
});
var convertAttestationResultToTurnkey = (attestation) => {
  var _a2;
  return {
    attestationObject: attestation.response.attestationObject,
    clientDataJson: attestation.response.clientDataJSON,
    credentialId: attestation.rawId,
    transports: ((_a2 = attestation.response.transports) === null || _a2 === void 0 ? void 0 : _a2.map(convertTransportEnumToTurnkeyEnum)) || []
  };
};
var convertPublicKeyToWebauthn = (publicKey) => {
  var _a2;
  return Object.assign(Object.assign({}, publicKey), { challenge: bufferSourceToString(publicKey.challenge), excludeCredentials: (_a2 = publicKey.excludeCredentials) === null || _a2 === void 0 ? void 0 : _a2.map((cred) => Object.assign(Object.assign({}, cred), { id: bufferSourceToString(cred.id) })), user: Object.assign(Object.assign({}, publicKey.user), { id: bufferSourceToString(publicKey.user.id) }) });
};
var bufferSourceToString = (buf) => {
  if (buf instanceof ArrayBuffer) {
    return bufferToBase64URLString(buf);
  } else {
    const arr = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    return bufferToBase64URLString(arr);
  }
};

// node_modules/@dynamic-labs/webauthn/src/index.js
assertPackageVersion("@dynamic-labs/webauthn", version2);

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/TurnkeyPasskeyService/utils/createTurnkeyPasskeyService/createTurnkeyPasskeyService.js
var createTurnkeyPasskeyService = () => ({
  createWebauthnStamper: (config) => new WebauthnStamper(config),
  getWebAuthnAttestation: getWebAuthnAttestationTurnkeyAdapter
});

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/TurnkeyPasskeyService/TurnkeyPasskeyService.js
var _a;
var _TurnkeyPasskeyService_implementation;
var TurnkeyPasskeyService = class {
  /**
   * Gets the current passkey service implementation.
   * If no implementation is set, it will create a new turnkey passkey service.
   * @returns {ITurnkeyPasskeyService} The passkey service implementation.
   */
  static get implementation() {
    if (!__classPrivateFieldGet(_a, _a, "f", _TurnkeyPasskeyService_implementation)) {
      return createTurnkeyPasskeyService();
    }
    return __classPrivateFieldGet(_a, _a, "f", _TurnkeyPasskeyService_implementation);
  }
  /**
   * Sets the passkey service implementation.
   * @param {ITurnkeyPasskeyService} implementation The passkey service implementation to set.
   */
  static set implementation(implementation) {
    __classPrivateFieldSet(_a, _a, implementation, "f", _TurnkeyPasskeyService_implementation);
  }
  /**
   * Gets the WebAuthn attestation method from the current implementation.
   */
  static get getWebAuthnAttestation() {
    return _a.implementation.getWebAuthnAttestation;
  }
  /**
   * Gets the createWebauthnStamper method from the current implementation.
   */
  static get createWebauthnStamper() {
    return _a.implementation.createWebauthnStamper;
  }
};
_a = TurnkeyPasskeyService;
_TurnkeyPasskeyService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/embedded-wallet/src/lib/AuthenticatorHandler/TurnkeyAuthenticatorRecoveryHandler.js
var turnkeyPasskeyRecoveryUrl = "https://recovery.turnkey.com";
var turnkeyEmailRecoveryUrl = "https://auth.turnkey.com";
var TURNKEY_RECOVERY_CREDENTIAL_EXPIRATION_SECONDS = 900;
var TURNKEY_SESSION_EXPIRATION_SECONDS = 1800;
var EMAIL_AUTH_CREDENTIAL_TYPE = "CREDENTIAL_TYPE_API_KEY_P256";
var PASSKEY_RECOVERY_CREDENTIAL_TYPE = "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256";
var TurnkeyAuthenticatorRecoveryHandler = class extends BaseTurnkeyHandler {
  constructor() {
    super(...arguments);
    this.isSessionActive = () => {
      if (!this.__createdAt || this.__recoveryType !== "email") {
        return false;
      }
      const isExpired = this.isExpired(this.__createdAt, this.__sessionExpiration || TURNKEY_SESSION_EXPIRATION_SECONDS);
      if (isExpired) {
        this.clear();
        return false;
      }
      return true;
    };
    this.isValidCode = (organizationId) => __awaiter(this, void 0, void 0, function* () {
      var _a2, _b, _c, _d;
      if (!organizationId || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      const userResponse = yield (_a2 = this.__turnkeyClient) === null || _a2 === void 0 ? void 0 : _a2.getUser({
        organizationId,
        userId: this.__turnkeyRecoveryUserId
      });
      const credentialTypeMap = {
        email: EMAIL_AUTH_CREDENTIAL_TYPE,
        passkey: PASSKEY_RECOVERY_CREDENTIAL_TYPE
      };
      const recoveryCredential = (_d = (_c = (_b = userResponse === null || userResponse === void 0 ? void 0 : userResponse.user) === null || _b === void 0 ? void 0 : _b.apiKeys) === null || _c === void 0 ? void 0 : _c.filter((k) => k.credential.type === credentialTypeMap[this.__recoveryType])) === null || _d === void 0 ? void 0 : _d.pop();
      if (!recoveryCredential) {
        return false;
      }
      const isExpired = this.isExpired(parseInt(recoveryCredential.createdAt.seconds, 10), TURNKEY_RECOVERY_CREDENTIAL_EXPIRATION_SECONDS);
      if (isExpired) {
        return false;
      }
      this.__createdAt = parseInt(recoveryCredential.createdAt.seconds, 10);
      return true;
    });
    this.isExpired = (createdAtSeconds, expirationTimeSeconds) => {
      const recoveryExpirationSeconds = createdAtSeconds + expirationTimeSeconds;
      const expirationTime = new Date(recoveryExpirationSeconds * 1e3);
      if (/* @__PURE__ */ new Date() >= expirationTime) {
        return true;
      }
      return false;
    };
  }
  get recoveryType() {
    return this.__recoveryType;
  }
  get recoveryUserId() {
    return this.__turnkeyRecoveryUserId || "";
  }
  set recoveryUserId(turnkeyRecoveryUserId) {
    this.__turnkeyRecoveryUserId = turnkeyRecoveryUserId;
  }
  clear() {
    super.clear();
    this.__recoveryType = void 0;
    this.__turnkeyRecoveryUserId = void 0;
    this.__createdAt = void 0;
  }
  initRecovery(authType, iframeContainer, iframeElementId, sessionExpiration) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.__recoveryType) {
        this.clear();
      }
      this.__sessionExpiration = sessionExpiration;
      this.__recoveryType = authType;
      const iframeUrl = authType === "passkey" ? turnkeyPasskeyRecoveryUrl : turnkeyEmailRecoveryUrl;
      this.__iframeStamper = new IframeStamper({
        iframeContainer,
        iframeElementId,
        iframeUrl
      });
      yield this.__iframeStamper.init();
      this.__publicKey = this.__iframeStamper.publicKey();
      return this.__publicKey;
    });
  }
  verifyRecoveryCode(recoveryBundle, organizationId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        yield this.__iframeStamper.injectCredentialBundle(recoveryBundle);
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, this.__iframeStamper);
        if (!organizationId || !this.__turnkeyRecoveryUserId) {
          throw new DynamicError("Cannot proceed with your request");
        }
        if (!(yield this.isValidCode(organizationId))) {
          throw new DynamicError("The code is invalid or expired.");
        }
      } catch (err) {
        logger.error("Error while verifying recovery code", err);
        if (err instanceof DynamicError) {
          throw err;
        }
        throw new DynamicError("The code is invalid or expired.");
      }
    });
  }
  completeRecovery(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ attestation, challenge, turnkeySubOrganizationId }) {
      if (!this.__turnkeyClient || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return this.__turnkeyClient.recoverUser({
          organizationId: turnkeySubOrganizationId,
          parameters: {
            authenticator: {
              attestation,
              authenticatorName: "Passkey",
              challenge
            },
            userId: this.__turnkeyRecoveryUserId
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_RECOVER_USER"
        });
      } catch (err) {
        logger.error("[TK] Error while completing recovery process", err);
        throw err;
      }
    });
  }
  addPasskeyAuthenticator(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ attestation, challenge, turnkeySubOrganizationId }) {
      if (!this.__turnkeyClient || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return this.__turnkeyClient.createAuthenticators({
          organizationId: turnkeySubOrganizationId,
          parameters: {
            authenticators: [
              {
                attestation,
                authenticatorName: "Passkey",
                challenge
              }
            ],
            userId: this.__turnkeyRecoveryUserId
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
        });
      } catch (err) {
        logger.error("[TK] Error while creating new authenticator", err);
        throw err;
      }
    });
  }
  addEmailRecovery(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ organizationId, email, turnkeyUserId }) {
      let rpId = getTLD();
      if (!rpId) {
        rpId = PlatformService.getHostname();
      }
      const stamper = TurnkeyPasskeyService.createWebauthnStamper({
        rpId
      });
      const client = new TurnkeyClient({
        baseUrl: TURNKEY_API_BASE_URL
      }, stamper);
      try {
        const signedRequest2 = yield client.stampUpdateUser({
          organizationId,
          parameters: {
            userEmail: email,
            userId: turnkeyUserId,
            userTagIds: []
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_UPDATE_USER"
        });
        return { signedRequest: signedRequest2, userId: turnkeyUserId };
      } catch (err) {
        logger.error("Error while adding email recovery", err);
        throw err;
      }
    });
  }
};
var turnkeyAuthenticatorRecoveryHandler = new TurnkeyAuthenticatorRecoveryHandler();

// node_modules/@dynamic-labs/embedded-wallet/src/lib/ExportHandler/TurnkeyExportHandler.js
var turnkeyExportUrl = "https://export.turnkey.com";
var TurnkeyExportHandler = class _TurnkeyExportHandler extends BaseTurnkeyHandler {
  initExport(iframeContainer, iframeElementId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.__iframeStamper = new IframeStamper({
        iframeContainer,
        iframeElementId,
        iframeUrl: turnkeyExportUrl
      });
      yield this.__iframeStamper.init();
      this.__publicKey = this.__iframeStamper.publicKey();
      if (turnkeyAuthenticatorRecoveryHandler.isSessionActive()) {
        this.__turnkeyClient = turnkeyAuthenticatorRecoveryHandler.client;
      } else {
        let rpId = getTLD();
        if (!rpId) {
          rpId = PlatformService.getHostname();
        }
        const passkeyStamper = TurnkeyPasskeyService.createWebauthnStamper({
          rpId
        });
        const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
        const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, stamper);
      }
      return this.__publicKey;
    });
  }
  verifyExportWallet(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ exportBundle, organizationId }) {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return yield this.__iframeStamper.injectWalletExportBundle(exportBundle, organizationId);
      } catch (err) {
        logger.error("Error while verifying export wallet", err);
        throw err;
      }
    });
  }
  verifyExportPrivateKey(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ exportBundle, organizationId, chain }) {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      const keyFormat = chain === "solana" || chain === "SOL" ? KeyFormat.Solana : KeyFormat.Hexadecimal;
      try {
        return yield this.__iframeStamper.injectKeyExportBundle(exportBundle, organizationId, keyFormat);
      } catch (err) {
        logger.error("Error while verifying export private key", err);
        throw err;
      }
    });
  }
  exportPrivateKey(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ privateKeyId, organizationId }) {
      const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
      if (apiKeyStamper) {
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, apiKeyStamper);
      }
      if (!this.__iframeStamper || !this.__publicKey || !this.__turnkeyClient || !privateKeyId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        const newActivity = yield this.__turnkeyClient.exportPrivateKey({
          organizationId,
          parameters: { privateKeyId, targetPublicKey: this.__publicKey },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
        });
        return newActivity.activity;
      } catch (err) {
        logger.error("[TK] Error while completing export private key process", err);
        throw err;
      }
    });
  }
  exportWallet(_a2) {
    return __awaiter(this, arguments, void 0, function* ({ walletId, organizationId, address }) {
      const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
      if (apiKeyStamper) {
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, apiKeyStamper);
      }
      if (!this.__iframeStamper || !this.__publicKey || !this.__turnkeyClient || !walletId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        if (address) {
          const newActivity2 = yield this.__turnkeyClient.exportWalletAccount({
            organizationId,
            parameters: { address, targetPublicKey: this.__publicKey },
            timestampMs: String(Date.now()),
            type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
          });
          return newActivity2.activity;
        }
        const newActivity = yield this.__turnkeyClient.exportWallet({
          organizationId,
          parameters: { targetPublicKey: this.__publicKey, walletId },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_EXPORT_WALLET"
        });
        return newActivity.activity;
      } catch (err) {
        logger.error("[TK] Error while completing export wallet process", err);
        throw err;
      }
    });
  }
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/base64UrlEncode/base64UrlEncode.js
var base64UrlEncode = (challenge) => Buffer.from(challenge).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/generateRandomBuffer/generateRandomBuffer.js
var generateRandomBuffer = () => {
  const arr = new Uint8Array(32);
  crypto.getRandomValues(arr);
  return arr.buffer;
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/TurnkeyWalletConnectorBase/TurnkeyWalletConnectorBase.js
var TurnkeyWalletConnectorBase = class _TurnkeyWalletConnectorBase extends WalletConnectorBase {
  constructor(nameAndKey, props) {
    super(props);
    this.requiresNonDynamicEmailOtp = false;
    this.isEmbeddedWallet = true;
    this.removeSessionKeys = () => __awaiter(this, void 0, void 0, function* () {
      _TurnkeyWalletConnectorBase.sessionKeys = void 0;
      _TurnkeyWalletConnectorBase.apiKeyStamper = void 0;
      TurnkeyExportHandler.apiKeyStamper = void 0;
    });
    this.stampCreateWalletAccountRequest = (_a2) => __awaiter(this, [_a2], void 0, function* ({ request: request2 }) {
      yield this.createOrRestoreSession();
      const turnkeyClient = yield this.getTurnkeyClient();
      return turnkeyClient.stampCreateWalletAccounts(request2);
    });
    this.stampDeleteSubOrganizationRequest = (_b) => __awaiter(this, [_b], void 0, function* ({ request: request2 }) {
      yield this.createOrRestoreSession();
      const turnkeyClient = yield this.getTurnkeyClient();
      return turnkeyClient.stampDeleteSubOrganization(request2);
    });
    if (!props.appName) {
      throw new Error("appName not set");
    }
    this.name = nameAndKey.name;
    this.overrideKey = nameAndKey.key;
    this.appName = props.appName;
    this.__authenticatorMethodHandler = turnkeyAuthenticatorRecoveryHandler;
  }
  getWebAuthnAttestation() {
    return __awaiter(this, void 0, void 0, function* () {
      const challenge = generateRandomBuffer();
      const authenticatorUserId = generateRandomBuffer();
      const { email, passkeyIdentifier } = this;
      if (!email && !passkeyIdentifier) {
        throw new Error("Email or passkeyIdentifier must be set to register a webauthn credential.");
      }
      const displayName = email || `${this.appName} - ${passkeyIdentifier}`;
      const webAuthnCreateParams = {
        publicKey: {
          authenticatorSelection: {
            authenticatorAttachment: void 0,
            requireResidentKey: false,
            residentKey: "preferred",
            userVerification: "discouraged"
          },
          challenge,
          pubKeyCredParams: [
            {
              alg: -7,
              type: "public-key"
            }
          ],
          rp: {
            id: getTLD(),
            name: this.appName
          },
          user: {
            displayName,
            id: authenticatorUserId,
            name: email || `${this.appName} - ${passkeyIdentifier}`
          }
        }
      };
      let attestation;
      try {
        attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
      } catch (error) {
        logger.warn(`Unable to register webauthn credential on the current page's TLD ${getTLD()}. Falling back to using hostname. ${PlatformService.getHostname()}`, error);
        webAuthnCreateParams.publicKey.rp.id = PlatformService.getHostname();
        attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
      }
      return {
        attestation: {
          attestationObject: attestation.attestationObject,
          clientDataJson: attestation.clientDataJson,
          credentialId: attestation.credentialId,
          transports: convertAttestationTransports(attestation.transports)
        },
        challenge: base64UrlEncode(challenge),
        displayName
      };
    });
  }
  getAuthenticatorHandler() {
    return this.__authenticatorMethodHandler;
  }
  getExportHandler() {
    if (!_TurnkeyWalletConnectorBase.__exportHandler) {
      _TurnkeyWalletConnectorBase.__exportHandler = new TurnkeyExportHandler();
    }
    return _TurnkeyWalletConnectorBase.__exportHandler;
  }
  // Public methods
  get email() {
    return this._email;
  }
  setEmail(email) {
    this._email = email;
  }
  get phone() {
    return this._phone;
  }
  setPhone(phone) {
    this._phone = phone;
  }
  get passkeyIdentifier() {
    return this._passkeyIdentifier;
  }
  setPasskeyIdentifier(passkeyIdentifier) {
    this._passkeyIdentifier = passkeyIdentifier;
  }
  clearEmail() {
    this._email = null;
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      return (_a2 = this.verifiedCredential) === null || _a2 === void 0 ? void 0 : _a2.address;
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const verifiedCredentials = this.verifiedCredentials || [];
      const addresses = verifiedCredentials.map((vc) => vc === null || vc === void 0 ? void 0 : vc.address).filter((a) => typeof a === "string");
      return addresses;
    });
  }
  get turnkeyAddress() {
    var _a2;
    const { address } = (_a2 = this.verifiedCredential) !== null && _a2 !== void 0 ? _a2 : {};
    return address;
  }
  get walletProperties() {
    const { walletProperties } = this.verifiedCredential || {};
    return walletProperties;
  }
  // Private methods
  set verifiedCredentials(verifiedCredentials) {
    this._verifiedCredentials = verifiedCredentials;
  }
  get verifiedCredentials() {
    return this._verifiedCredentials;
  }
  set verifiedCredential(verifiedCredential) {
    this._verifiedCredential = verifiedCredential;
  }
  get verifiedCredential() {
    return this._verifiedCredential;
  }
  setSessionKeyFetcher(func) {
    this.createOrRestoreSessionFetcherFunction = func;
  }
  setSessionKeyRemoveFunction(func) {
    this.removeSessionKeysFunction = func;
  }
  createOrRestoreSession() {
    return __awaiter(this, arguments, void 0, function* ({ ignoreRestore } = {}) {
      var _a2;
      if (!this.isSessionKeyCompatible() || _TurnkeyWalletConnectorBase.isLoadingSession) {
        return;
      }
      if (!this.createOrRestoreSessionFetcherFunction) {
        throw new DynamicError("Cannot register session key to init provider");
      }
      const { sessionKeys } = _TurnkeyWalletConnectorBase;
      if (sessionKeys === null || sessionKeys === void 0 ? void 0 : sessionKeys.publicKey) {
        const isExpired = /* @__PURE__ */ new Date() >= new Date(sessionKeys.expirationDate);
        if (!isExpired)
          return sessionKeys.publicKey;
      }
      try {
        _TurnkeyWalletConnectorBase.isLoadingSession = true;
        this.isLoadingSessionDeferredPromise = new DeferredPromise();
        const sessionKeys2 = yield this.createOrRestoreSessionFetcherFunction({
          ignoreRestore
        });
        _TurnkeyWalletConnectorBase.sessionKeys = sessionKeys2;
        _TurnkeyWalletConnectorBase.apiKeyStamper = new ApiKeyStamper({
          apiPrivateKey: sessionKeys2.privateKey,
          apiPublicKey: sessionKeys2.publicKey
        });
        TurnkeyExportHandler.apiKeyStamper = _TurnkeyWalletConnectorBase.apiKeyStamper;
        logger.metaData.set("sessionApiPublicKey", sessionKeys2.publicKey);
        return sessionKeys2.publicKey;
      } catch (error) {
        logger.error(error);
        throw new DynamicError("Failed to create or restore session");
      } finally {
        _TurnkeyWalletConnectorBase.isLoadingSession = false;
        (_a2 = this.isLoadingSessionDeferredPromise) === null || _a2 === void 0 ? void 0 : _a2.resolve();
      }
    });
  }
  isSessionKeyCompatible() {
    var _a2;
    const walletProperties = (_a2 = this.verifiedCredential) === null || _a2 === void 0 ? void 0 : _a2.walletProperties;
    const isSessionKeyCompatible = walletProperties === null || walletProperties === void 0 ? void 0 : walletProperties.isSessionKeyCompatible;
    return Boolean(isSessionKeyCompatible);
  }
  isSessionActive() {
    return __awaiter(this, void 0, void 0, function* () {
      const hasWallet = yield this.getAddress();
      return Boolean(hasWallet && _TurnkeyWalletConnectorBase.sessionKeys && _TurnkeyWalletConnectorBase.apiKeyStamper);
    });
  }
  get sessionKeys() {
    return _TurnkeyWalletConnectorBase.sessionKeys;
  }
  getTurnkeyClient() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2, _b;
      if (_TurnkeyWalletConnectorBase.isLoadingSession) {
        yield (_a2 = this.isLoadingSessionDeferredPromise) === null || _a2 === void 0 ? void 0 : _a2.promise;
      }
      let rpId = getTLD();
      if (!rpId) {
        rpId = PlatformService.getHostname();
      }
      const passkeyStamper = TurnkeyPasskeyService.createWebauthnStamper({
        rpId
      });
      const apiKeyStamper = _TurnkeyWalletConnectorBase === null || _TurnkeyWalletConnectorBase === void 0 ? void 0 : _TurnkeyWalletConnectorBase.apiKeyStamper;
      const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
      this.__turnkeyClient = (_b = this.getAuthenticatorHandler().client) !== null && _b !== void 0 ? _b : new TurnkeyClient({
        baseUrl: TURNKEY_API_BASE_URL
      }, stamper);
      return this.__turnkeyClient;
    });
  }
  setLoggerMetadata() {
    var _a2, _b, _c;
    logger.metaData.set("turnkeySubOrganizationId", (_b = (_a2 = this._verifiedCredential) === null || _a2 === void 0 ? void 0 : _a2.walletProperties) === null || _b === void 0 ? void 0 : _b.turnkeySubOrganizationId);
    logger.metaData.set("walletId", (_c = this._verifiedCredential) === null || _c === void 0 ? void 0 : _c.id);
    let authMethod = "Unknown";
    if (this.isSessionKeyCompatible()) {
      authMethod = "SessionKeys";
    } else if (this.__authenticatorMethodHandler.recoveryType === "passkey") {
      authMethod = "Passkey";
    } else if (this.__authenticatorMethodHandler.recoveryType === "email") {
      authMethod = "EmailAuth";
    }
    logger.metaData.set("authMethod", authMethod);
  }
};
TurnkeyWalletConnectorBase.isLoadingSession = false;

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/findTurnkeyVerifiedCredentials/findTurnkeyVerifiedCredentials.js
var findTurnkeyVerifiedCredentials = (verifiedCredentials, chain) => verifiedCredentials === null || verifiedCredentials === void 0 ? void 0 : verifiedCredentials.filter(({ walletName, chain: vcChain }) => (walletName === null || walletName === void 0 ? void 0 : walletName.startsWith("turnkey")) && chain === vcChain);
var findTurnkeyVerifiedCredentialsWithSmartWalletRef = (verifiedCredentials, chain) => verifiedCredentials === null || verifiedCredentials === void 0 ? void 0 : verifiedCredentials.reduce((acc, vc) => {
  var _a2;
  if (((_a2 = vc.walletName) === null || _a2 === void 0 ? void 0 : _a2.startsWith("turnkey")) && chain === vc.chain) {
    const smartWallet = verifiedCredentials.find((v) => v.signerRefId === vc.id);
    const smartWalletRefId = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.id;
    const smartWalletRefAddress = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.address;
    acc.push(Object.assign(Object.assign({}, vc), { smartWalletRefAddress, smartWalletRefId }));
  }
  return acc;
}, []);

// node_modules/@dynamic-labs/embedded-wallet/src/index.js
assertPackageVersion("@dynamic-labs/embedded-wallet", version);

export {
  ApiKeyStamper,
  TurnkeyClient,
  TurnkeyActivityError,
  TurnkeyActivityConsensusNeededError,
  assertActivityCompleted,
  assertNonNull,
  IframeStamper,
  TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS,
  logger,
  WebauthnStamper,
  TurnkeyWalletConnectorBase,
  findTurnkeyVerifiedCredentials,
  findTurnkeyVerifiedCredentialsWithSmartWalletRef,
  TurnkeyWalletConnectorInfo
};
//# sourceMappingURL=chunk-EIQVUX5X.js.map
