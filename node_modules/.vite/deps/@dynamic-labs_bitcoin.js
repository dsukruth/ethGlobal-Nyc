"use client";
import {
  require_u64,
  require_utils
} from "./chunk-YMTSYZVI.js";
import {
  getWallets,
  require_safe_buffer
} from "./chunk-QZGQY7RV.js";
import {
  require_bs58
} from "./chunk-LR3WEES7.js";
import {
  require_crypto
} from "./chunk-VDEFIFDG.js";
import {
  DynamicError,
  PlatformService,
  Wallet,
  WalletAddressType,
  WalletConnectorBase,
  assertPackageVersion,
  eventListenerHandlers,
  getItemAsync,
  getProvidersFromWindow,
  getWalletBookWallet,
  handleMobileWalletRedirect,
  isConnectorMethodSupported,
  isLedgerAddressViaVerifiedCredentials,
  isMobile,
  logger,
  removeItemAsync,
  require_base64_js,
  require_buffer,
  setItemAsync,
  template
} from "./chunk-3OCKXW2Z.js";
import "./chunk-7KMCIXGS.js";
import "./chunk-ASWLBWKD.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/jsontokens/lib/base64Url.js
var require_base64Url = __commonJS({
  "node_modules/jsontokens/lib/base64Url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = exports.unescape = exports.escape = exports.pad = void 0;
    var base64_js_1 = require_base64_js();
    function pad(base64) {
      return `${base64}${"=".repeat(4 - (base64.length % 4 || 4))}`;
    }
    exports.pad = pad;
    function escape(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    exports.escape = escape;
    function unescape2(base64Url) {
      return pad(base64Url).replace(/-/g, "+").replace(/_/g, "/");
    }
    exports.unescape = unescape2;
    function encode3(base64) {
      return escape((0, base64_js_1.fromByteArray)(new TextEncoder().encode(base64)));
    }
    exports.encode = encode3;
    function decode(base64Url) {
      return new TextDecoder().decode((0, base64_js_1.toByteArray)(pad(unescape2(base64Url))));
    }
    exports.decode = decode;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var utils_ts_1 = require_utils();
    var HMAC = class extends utils_ts_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
    exports.setBigUint64 = setBigUint64;
    exports.Chi = Chi;
    exports.Maj = Maj;
    var utils_ts_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h2 = isLE ? 4 : 0;
      const l2 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h2, wh, isLE);
      view.setUint32(byteOffset + l2, wl, isLE);
    }
    function Chi(a2, b3, c2) {
      return a2 & b3 ^ ~a2 & c2;
    }
    function Maj(a2, b3, c2) {
      return a2 & b3 ^ a2 & c2 ^ b3 & c2;
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports.HashMD = HashMD;
    exports.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K = Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A: A3, B, C: C4, D: D2, E: E2, F: F2, G: G2, H } = this;
        return [A3, B, C4, D2, E2, F2, G2, H];
      }
      // prettier-ignore
      set(A3, B, C4, D2, E2, F2, G2, H) {
        this.A = A3 | 0;
        this.B = B | 0;
        this.C = C4 | 0;
        this.D = D2 | 0;
        this.E = E2 | 0;
        this.F = F2 | 0;
        this.G = G2 | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W[i2 - 15];
          const W2 = SHA256_W[i2 - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
        }
        let { A: A3, B, C: C4, D: D2, E: E2, F: F2, G: G2, H } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = (0, utils_ts_1.rotr)(E2, 6) ^ (0, utils_ts_1.rotr)(E2, 11) ^ (0, utils_ts_1.rotr)(E2, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E2, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A3, 2) ^ (0, utils_ts_1.rotr)(A3, 13) ^ (0, utils_ts_1.rotr)(A3, 22);
          const T22 = sigma0 + (0, _md_ts_1.Maj)(A3, B, C4) | 0;
          H = G2;
          G2 = F2;
          F2 = E2;
          E2 = D2 + T1 | 0;
          D2 = C4;
          C4 = B;
          B = A3;
          A3 = T1 + T22 | 0;
        }
        A3 = A3 + this.A | 0;
        B = B + this.B | 0;
        C4 = C4 + this.C | 0;
        D2 = D2 + this.D | 0;
        E2 = E2 + this.E | 0;
        F2 = F2 + this.F | 0;
        G2 = G2 + this.G | 0;
        H = H + this.H | 0;
        this.set(A3, B, C4, D2, E2, F2, G2, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports.SHA224 = SHA224;
    var K512 = (() => u64.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n2) => BigInt(n2))))();
    var SHA512_Kh = (() => K512[0])();
    var SHA512_Kl = (() => K512[1])();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4) {
          SHA512_W_H[i2] = view.getUint32(offset);
          SHA512_W_L[i2] = view.getUint32(offset += 4);
        }
        for (let i2 = 16; i2 < 80; i2++) {
          const W15h = SHA512_W_H[i2 - 15] | 0;
          const W15l = SHA512_W_L[i2 - 15] | 0;
          const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
          const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i2 - 2] | 0;
          const W2l = SHA512_W_L[i2 - 2] | 0;
          const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
          const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
          const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
          SHA512_W_H[i2] = SUMh | 0;
          SHA512_W_L[i2] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i2 = 0; i2 < 80; i2++) {
          const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
          const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
          const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
          const T1l = T1ll | 0;
          const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
          const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports.SHA384 = SHA384;
    var T224_IV = Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports.SHA512_256 = SHA512_256;
    exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
    exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
    exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
    var sha2_ts_1 = require_sha2();
    exports.SHA256 = sha2_ts_1.SHA256;
    exports.sha256 = sha2_ts_1.sha256;
    exports.SHA224 = sha2_ts_1.SHA224;
    exports.sha224 = sha2_ts_1.sha224;
  }
});

// node_modules/@noble/secp256k1/lib/index.js
var require_lib = __commonJS({
  "node_modules/@noble/secp256k1/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.hexToBytes = exports.bytesToHex = exports.Signature = exports.Point = exports.CURVE = void 0;
    var nodeCrypto = require_crypto();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _8n = BigInt(8);
    var CURVE = Object.freeze({
      a: _0n,
      b: BigInt(7),
      P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: _1n,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    exports.CURVE = CURVE;
    var divNearest = (a2, b3) => (a2 + b3 / _2n) / b3;
    var endo = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar(k2) {
        const { n: n2 } = CURVE;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b22 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b22 * k2, n2);
        const c2 = divNearest(-b1 * k2, n2);
        let k1 = mod(k2 - c1 * a1 - c2 * a2, n2);
        let k22 = mod(-c1 * b1 - c2 * b22, n2);
        const k1neg = k1 > POW_2_128;
        const k2neg = k22 > POW_2_128;
        if (k1neg)
          k1 = n2 - k1;
        if (k2neg)
          k22 = n2 - k22;
        if (k1 > POW_2_128 || k22 > POW_2_128) {
          throw new Error("splitScalarEndo: Endomorphism failed, k=" + k2);
        }
        return { k1neg, k1, k2neg, k2: k22 };
      }
    };
    var fieldLen = 32;
    var groupLen = 32;
    var hashLen = 32;
    var compressedLen = fieldLen + 1;
    var uncompressedLen = 2 * fieldLen + 1;
    function weierstrass(x2) {
      const { a: a2, b: b3 } = CURVE;
      const x22 = mod(x2 * x2);
      const x3 = mod(x22 * x2);
      return mod(x3 + a2 * x2 + b3);
    }
    var USE_ENDOMORPHISM = CURVE.a === _0n;
    var ShaError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    function assertJacPoint(other) {
      if (!(other instanceof JacobianPoint))
        throw new TypeError("JacobianPoint expected");
    }
    var JacobianPoint = class _JacobianPoint {
      constructor(x2, y2, z2) {
        this.x = x2;
        this.y = y2;
        this.z = z2;
      }
      static fromAffine(p2) {
        if (!(p2 instanceof Point)) {
          throw new TypeError("JacobianPoint#fromAffine: expected Point");
        }
        if (p2.equals(Point.ZERO))
          return _JacobianPoint.ZERO;
        return new _JacobianPoint(p2.x, p2.y, _1n);
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p2) => p2.z));
        return points.map((p2, i2) => p2.toAffine(toInv[i2]));
      }
      static normalizeZ(points) {
        return _JacobianPoint.toAffineBatch(points).map(_JacobianPoint.fromAffine);
      }
      equals(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
      }
      negate() {
        return new _JacobianPoint(this.x, mod(-this.y), this.z);
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A3 = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C4 = mod(B * B);
        const x1b = X1 + B;
        const D2 = mod(_2n * (mod(x1b * x1b) - A3 - C4));
        const E2 = mod(_3n * A3);
        const F2 = mod(E2 * E2);
        const X3 = mod(F2 - _2n * D2);
        const Y3 = mod(E2 * (D2 - X3) - _8n * C4);
        const Z3 = mod(_2n * Y1 * Z1);
        return new _JacobianPoint(X3, Y3, Z3);
      }
      add(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
          return this;
        if (X1 === _0n || Y1 === _0n)
          return other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r2 = mod(S2 - S1);
        if (H === _0n) {
          if (r2 === _0n) {
            return this.double();
          } else {
            return _JacobianPoint.ZERO;
          }
        }
        const HH = mod(H * H);
        const HHH = mod(H * HH);
        const V2 = mod(U1 * HH);
        const X3 = mod(r2 * r2 - HHH - _2n * V2);
        const Y3 = mod(r2 * (V2 - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new _JacobianPoint(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiplyUnsafe(scalar) {
        const P0 = _JacobianPoint.ZERO;
        if (typeof scalar === "bigint" && scalar === _0n)
          return P0;
        let n2 = normalizeScalar(scalar);
        if (n2 === _1n)
          return this;
        if (!USE_ENDOMORPHISM) {
          let p2 = P0;
          let d3 = this;
          while (n2 > _0n) {
            if (n2 & _1n)
              p2 = p2.add(d3);
            d3 = d3.double();
            n2 >>= _1n;
          }
          return p2;
        }
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let k1p = P0;
        let k2p = P0;
        let d2 = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            k1p = k1p.add(d2);
          if (k2 & _1n)
            k2p = k2p.add(d2);
          d2 = d2.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new _JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
      }
      precomputeWindow(W2) {
        const windows = USE_ENDOMORPHISM ? 128 / W2 + 1 : 256 / W2 + 1;
        const points = [];
        let p2 = this;
        let base = p2;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p2;
          points.push(base);
          for (let i2 = 1; i2 < 2 ** (W2 - 1); i2++) {
            base = base.add(p2);
            points.push(base);
          }
          p2 = base.double();
        }
        return points;
      }
      wNAF(n2, affinePoint) {
        if (!affinePoint && this.equals(_JacobianPoint.BASE))
          affinePoint = Point.BASE;
        const W2 = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W2) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W2);
          if (affinePoint && W2 !== 1) {
            precomputes = _JacobianPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p2 = _JacobianPoint.ZERO;
        let f2 = _JacobianPoint.BASE;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W2 : 256 / W2);
        const windowSize = 2 ** (W2 - 1);
        const mask = BigInt(2 ** W2 - 1);
        const maxNumber = 2 ** W2;
        const shiftBy = BigInt(W2);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n2 & mask);
          n2 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n2 += _1n;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p: p2, f: f2 };
      }
      multiply(scalar, affinePoint) {
        let n2 = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
          let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
          let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
          k1p = constTimeNegate(k1neg, k1p);
          k2p = constTimeNegate(k2neg, k2p);
          k2p = new _JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p: p2, f: f2 } = this.wNAF(n2, affinePoint);
          point = p2;
          fake = f2;
        }
        return _JacobianPoint.normalizeZ([point, fake])[0];
      }
      toAffine(invZ) {
        const { x: x2, y: y2, z: z2 } = this;
        const is0 = this.equals(_JacobianPoint.ZERO);
        if (invZ == null)
          invZ = is0 ? _8n : invert(z2);
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x2 * iz2);
        const ay = mod(y2 * iz3);
        const zz = mod(z2 * iz1);
        if (is0)
          return Point.ZERO;
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
    };
    JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
    JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
    function constTimeNegate(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var Point = class _Point {
      constructor(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      hasEvenY() {
        return this.y % _2n === _0n;
      }
      static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x2 = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrass(x2);
        let y3 = sqrtMod(y2);
        const isYOdd = (y3 & _1n) === _1n;
        if (isShort) {
          if (isYOdd)
            y3 = mod(-y3);
        } else {
          const isFirstByteOdd = (bytes[0] & 1) === 1;
          if (isFirstByteOdd !== isYOdd)
            y3 = mod(-y3);
        }
        const point = new _Point(x2, y3);
        point.assertValidity();
        return point;
      }
      static fromUncompressedHex(bytes) {
        const x2 = bytesToNumber(bytes.subarray(1, fieldLen + 1));
        const y2 = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
        const point = new _Point(x2, y2);
        point.assertValidity();
        return point;
      }
      static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === fieldLen)
          return this.fromCompressedHex(bytes);
        if (len === compressedLen && (header === 2 || header === 3)) {
          return this.fromCompressedHex(bytes);
        }
        if (len === uncompressedLen && header === 4)
          return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
      }
      static fromPrivateKey(privateKey) {
        return _Point.BASE.multiply(normalizePrivateKey(privateKey));
      }
      static fromSignature(msgHash, signature, recovery) {
        const { r: r2, s: s2 } = normalizeSignature(signature);
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("Cannot recover: invalid recovery bit");
        const h2 = truncateHash(ensureBytes(msgHash));
        const { n: n2 } = CURVE;
        const radj = recovery === 2 || recovery === 3 ? r2 + n2 : r2;
        const rinv = invert(radj, n2);
        const u1 = mod(-h2 * rinv, n2);
        const u2 = mod(s2 * rinv, n2);
        const prefix = recovery & 1 ? "03" : "02";
        const R = _Point.fromHex(prefix + numTo32bStr(radj));
        const Q2 = _Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q2)
          throw new Error("Cannot recover signature: point at infinify");
        Q2.assertValidity();
        return Q2;
      }
      toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
      }
      toHex(isCompressed = false) {
        const x2 = numTo32bStr(this.x);
        if (isCompressed) {
          const prefix = this.hasEvenY() ? "02" : "03";
          return `${prefix}${x2}`;
        } else {
          return `04${x2}${numTo32bStr(this.y)}`;
        }
      }
      toHexX() {
        return this.toHex(true).slice(2);
      }
      toRawX() {
        return this.toRawBytes(true).slice(1);
      }
      assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x: x2, y: y2 } = this;
        if (!isValidFieldElement(x2) || !isValidFieldElement(y2))
          throw new Error(msg);
        const left = mod(y2 * y2);
        const right = weierstrass(x2);
        if (mod(left - right) !== _0n)
          throw new Error(msg);
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new _Point(this.x, mod(-this.y));
      }
      double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
      }
      add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
      multiplyAndAddUnsafe(Q2, a2, b3) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a2 === _0n || a2 === _1n || this !== _Point.BASE ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const bQ = JacobianPoint.fromAffine(Q2).multiplyUnsafe(b3);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
      }
    };
    exports.Point = Point;
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _0n);
    function sliceDER(s2) {
      return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
    }
    function parseDERInt(data) {
      if (data.length < 2 || data[0] !== 2) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
      }
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
      }
      if (res[0] === 0 && res[1] <= 127) {
        throw new Error("Invalid signature integer: trailing length");
      }
      return { data: bytesToNumber(res), left: data.subarray(len + 2) };
    }
    function parseDERSignature(data) {
      if (data.length < 2 || data[0] != 48) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
      }
      if (data[1] !== data.length - 2) {
        throw new Error("Invalid signature: incorrect length");
      }
      const { data: r2, left: sBytes } = parseDERInt(data.subarray(2));
      const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
      if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
      }
      return { r: r2, s: s2 };
    }
    var Signature = class _Signature {
      constructor(r2, s2) {
        this.r = r2;
        this.s = s2;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const arr = isBytes(hex);
        const name = "Signature.fromCompact";
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
          throw new Error(`${name}: Expected 64-byte hex`);
        return new _Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
      }
      static fromDER(hex) {
        const arr = isBytes(hex);
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r: r2, s: s2 } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new _Signature(r2, s2);
      }
      static fromHex(hex) {
        return this.fromDER(hex);
      }
      assertValidity() {
        const { r: r2, s: s2 } = this;
        if (!isWithinCurveOrder(r2))
          throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s2))
          throw new Error("Invalid Signature: s must be 0 < s < n");
      }
      hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
      }
      normalizeS() {
        return this.hasHighS() ? new _Signature(this.r, mod(-this.s, CURVE.n)) : this;
      }
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const sHexL = sHex.length / 2;
        const rHexL = rHex.length / 2;
        const sLen = numberToHexUnpadded(sHexL);
        const rLen = numberToHexUnpadded(rHexL);
        const length = numberToHexUnpadded(rHexL + sHexL + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
      }
      toRawBytes() {
        return this.toDERRawBytes();
      }
      toHex() {
        return this.toDERHex();
      }
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
    };
    exports.Signature = Signature;
    function isBytes(a2) {
      return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes(item))
        throw new Error("Uint8Array expected");
    }
    function concatBytes(...arrays) {
      arrays.every(abytes);
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a2, arr) => a2 + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
        const arr = arrays[i2];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    var hexes = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex += hexes[bytes[i2]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n2;
      }
      return array2;
    }
    exports.hexToBytes = hexToBytes;
    var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    function numTo32bStr(num) {
      if (typeof num !== "bigint")
        throw new Error("Expected bigint");
      if (!(_0n <= num && num < POW_2_256))
        throw new Error("Expected number 0 <= n < 2^256");
      return num.toString(16).padStart(64, "0");
    }
    function numTo32b(num) {
      const b3 = hexToBytes(numTo32bStr(num));
      if (b3.length !== 32)
        throw new Error("Error: expected 32 bytes");
      return b3;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToNumber: expected string, got " + typeof hex);
      }
      return BigInt(`0x${hex}`);
    }
    function bytesToNumber(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function ensureBytes(hex) {
      return isBytes(hex) ? Uint8Array.from(hex) : hexToBytes(hex);
    }
    function normalizeScalar(num) {
      if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
      if (typeof num === "bigint" && isWithinCurveOrder(num))
        return num;
      throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
    }
    function mod(a2, b3 = CURVE.P) {
      const result = a2 % b3;
      return result >= _0n ? result : b3 + result;
    }
    function pow2(x2, power) {
      const { P } = CURVE;
      let res = x2;
      while (power-- > _0n) {
        res *= res;
        res %= P;
      }
      return res;
    }
    function sqrtMod(x2) {
      const { P } = CURVE;
      const _6n = BigInt(6);
      const _11n = BigInt(11);
      const _22n = BigInt(22);
      const _23n = BigInt(23);
      const _44n = BigInt(44);
      const _88n = BigInt(88);
      const b22 = x2 * x2 * x2 % P;
      const b3 = b22 * b22 * x2 % P;
      const b6 = pow2(b3, _3n) * b3 % P;
      const b9 = pow2(b6, _3n) * b3 % P;
      const b11 = pow2(b9, _2n) * b22 % P;
      const b222 = pow2(b11, _11n) * b11 % P;
      const b44 = pow2(b222, _22n) * b222 % P;
      const b88 = pow2(b44, _44n) * b44 % P;
      const b176 = pow2(b88, _88n) * b88 % P;
      const b220 = pow2(b176, _44n) * b44 % P;
      const b223 = pow2(b220, _3n) * b3 % P;
      const t1 = pow2(b223, _23n) * b222 % P;
      const t2 = pow2(t1, _6n) * b22 % P;
      const rt = pow2(t2, _2n);
      const xc = rt * rt % P;
      if (xc !== x2)
        throw new Error("Cannot find square root");
      return rt;
    }
    function invert(number2, modulo = CURVE.P) {
      if (number2 === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
      }
      let a2 = mod(number2, modulo);
      let b3 = modulo;
      let x2 = _0n, y2 = _1n, u2 = _1n, v2 = _0n;
      while (a2 !== _0n) {
        const q2 = b3 / a2;
        const r2 = b3 % a2;
        const m4 = x2 - u2 * q2;
        const n2 = y2 - v2 * q2;
        b3 = a2, a2 = r2, x2 = u2, y2 = v2, u2 = m4, v2 = n2;
      }
      const gcd = b3;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x2, modulo);
    }
    function invertBatch(nums, p2 = CURVE.P) {
      const scratch = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i2) => {
        if (num === _0n)
          return acc;
        scratch[i2] = acc;
        return mod(acc * num, p2);
      }, _1n);
      const inverted = invert(lastMultiplied, p2);
      nums.reduceRight((acc, num, i2) => {
        if (num === _0n)
          return acc;
        scratch[i2] = mod(acc * scratch[i2], p2);
        return mod(acc * num, p2);
      }, inverted);
      return scratch;
    }
    function bits2int_2(bytes) {
      const delta = bytes.length * 8 - groupLen * 8;
      const num = bytesToNumber(bytes);
      return delta > 0 ? num >> BigInt(delta) : num;
    }
    function truncateHash(hash, truncateOnly = false) {
      const h2 = bits2int_2(hash);
      if (truncateOnly)
        return h2;
      const { n: n2 } = CURVE;
      return h2 >= n2 ? h2 - n2 : h2;
    }
    var _sha256Sync;
    var _hmacSha256Sync;
    var HmacDrbg = class {
      constructor(hashLen2, qByteLen) {
        this.hashLen = hashLen2;
        this.qByteLen = qByteLen;
        if (typeof hashLen2 !== "number" || hashLen2 < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        this.v = new Uint8Array(hashLen2).fill(1);
        this.k = new Uint8Array(hashLen2).fill(0);
        this.counter = 0;
      }
      hmac(...values) {
        return exports.utils.hmacSha256(this.k, ...values);
      }
      hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
      }
      checkSync() {
        if (typeof _hmacSha256Sync !== "function")
          throw new ShaError("hmacSha256Sync needs to be set");
      }
      incr() {
        if (this.counter >= 1e3)
          throw new Error("Tried 1,000 k values for sign(), all were invalid");
        this.counter += 1;
      }
      async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
          return;
        this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
        this.v = await this.hmac(this.v);
      }
      reseedSync(seed = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
          return;
        this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
        this.v = this.hmacSync(this.v);
      }
      async generate() {
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = await this.hmac(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes(...out);
      }
      generateSync() {
        this.checkSync();
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = this.hmacSync(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes(...out);
      }
    };
    function isWithinCurveOrder(num) {
      return _0n < num && num < CURVE.n;
    }
    function isValidFieldElement(num) {
      return _0n < num && num < CURVE.P;
    }
    function kmdToSig(kBytes, m4, d2, lowS = true) {
      const { n: n2 } = CURVE;
      const k2 = truncateHash(kBytes, true);
      if (!isWithinCurveOrder(k2))
        return;
      const kinv = invert(k2, n2);
      const q2 = Point.BASE.multiply(k2);
      const r2 = mod(q2.x, n2);
      if (r2 === _0n)
        return;
      const s2 = mod(kinv * mod(m4 + d2 * r2, n2), n2);
      if (s2 === _0n)
        return;
      let sig = new Signature(r2, s2);
      let recovery = (q2.x === sig.r ? 0 : 2) | Number(q2.y & _1n);
      if (lowS && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
      }
      return { sig, recovery };
    }
    function normalizePrivateKey(key) {
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
      } else if (typeof key === "string") {
        if (key.length !== 2 * groupLen)
          throw new Error("Expected 32 bytes of private key");
        num = hexToNumber(key);
      } else if (isBytes(key)) {
        if (key.length !== groupLen)
          throw new Error("Expected 32 bytes of private key");
        num = bytesToNumber(key);
      } else {
        throw new TypeError("Expected valid private key");
      }
      if (!isWithinCurveOrder(num))
        throw new Error("Expected private key: 0 < key < n");
      return num;
    }
    function normalizePublicKey(publicKey) {
      if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
      } else {
        return Point.fromHex(publicKey);
      }
    }
    function normalizeSignature(signature) {
      if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
      }
      try {
        return Signature.fromDER(signature);
      } catch (error) {
        return Signature.fromCompact(signature);
      }
    }
    function getPublicKey(privateKey, isCompressed = false) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    exports.getPublicKey = getPublicKey;
    function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
      return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function isProbPub(item) {
      const arr = isBytes(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === compressedLen * 2 || len === uncompressedLen * 2;
      if (item instanceof Point)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = false) {
      if (isProbPub(privateA))
        throw new TypeError("getSharedSecret: first arg must be private key");
      if (!isProbPub(publicB))
        throw new TypeError("getSharedSecret: second arg must be public key");
      const b3 = normalizePublicKey(publicB);
      b3.assertValidity();
      return b3.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
    }
    exports.getSharedSecret = getSharedSecret;
    function bits2int(bytes) {
      const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
      return bytesToNumber(slice);
    }
    function bits2octets(bytes) {
      const z1 = bits2int(bytes);
      const z2 = mod(z1, CURVE.n);
      return int2octets(z2 < _0n ? z1 : z2);
    }
    function int2octets(num) {
      return numTo32b(num);
    }
    function initSigArgs(msgHash, privateKey, extraEntropy) {
      if (msgHash == null)
        throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
      const h1 = ensureBytes(msgHash);
      const d2 = normalizePrivateKey(privateKey);
      const seedArgs = [int2octets(d2), bits2octets(h1)];
      if (extraEntropy != null) {
        if (extraEntropy === true)
          extraEntropy = exports.utils.randomBytes(fieldLen);
        const e2 = ensureBytes(extraEntropy);
        if (e2.length !== fieldLen)
          throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
        seedArgs.push(e2);
      }
      const seed = concatBytes(...seedArgs);
      const m4 = bits2int(h1);
      return { seed, m: m4, d: d2 };
    }
    function finalizeSig(recSig, opts) {
      const { sig, recovery } = recSig;
      const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
      const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
      return recovered ? [hashed, recovery] : hashed;
    }
    async function sign(msgHash, privKey, opts = {}) {
      const { seed, m: m4, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      const drbg = new HmacDrbg(hashLen, groupLen);
      await drbg.reseed(seed);
      let sig;
      while (!(sig = kmdToSig(await drbg.generate(), m4, d2, opts.canonical)))
        await drbg.reseed();
      return finalizeSig(sig, opts);
    }
    exports.sign = sign;
    function signSync(msgHash, privKey, opts = {}) {
      const { seed, m: m4, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      const drbg = new HmacDrbg(hashLen, groupLen);
      drbg.reseedSync(seed);
      let sig;
      while (!(sig = kmdToSig(drbg.generateSync(), m4, d2, opts.canonical)))
        drbg.reseedSync();
      return finalizeSig(sig, opts);
    }
    exports.signSync = signSync;
    var vopts = { strict: true };
    function verify(signature, msgHash, publicKey, opts = vopts) {
      let sig;
      try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
      } catch (error) {
        return false;
      }
      const { r: r2, s: s2 } = sig;
      if (opts.strict && sig.hasHighS())
        return false;
      const h2 = truncateHash(msgHash);
      let P;
      try {
        P = normalizePublicKey(publicKey);
      } catch (error) {
        return false;
      }
      const { n: n2 } = CURVE;
      const sinv = invert(s2, n2);
      const u1 = mod(h2 * sinv, n2);
      const u2 = mod(r2 * sinv, n2);
      const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
      if (!R)
        return false;
      const v2 = mod(R.x, n2);
      return v2 === r2;
    }
    exports.verify = verify;
    function schnorrChallengeFinalize(ch) {
      return mod(bytesToNumber(ch), CURVE.n);
    }
    var SchnorrSignature = class _SchnorrSignature {
      constructor(r2, s2) {
        this.r = r2;
        this.s = s2;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64)
          throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r2 = bytesToNumber(bytes.subarray(0, 32));
        const s2 = bytesToNumber(bytes.subarray(32, 64));
        return new _SchnorrSignature(r2, s2);
      }
      assertValidity() {
        const { r: r2, s: s2 } = this;
        if (!isValidFieldElement(r2) || !isWithinCurveOrder(s2))
          throw new Error("Invalid signature");
      }
      toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
      toRawBytes() {
        return hexToBytes(this.toHex());
      }
    };
    function schnorrGetPublicKey(privateKey) {
      return Point.fromPrivateKey(privateKey).toRawX();
    }
    var InternalSchnorrSignature = class {
      constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {
        if (message == null)
          throw new TypeError(`sign: Expected valid message, not "${message}"`);
        this.m = ensureBytes(message);
        const { x: x2, scalar } = this.getScalar(normalizePrivateKey(privateKey));
        this.px = x2;
        this.d = scalar;
        this.rand = ensureBytes(auxRand);
        if (this.rand.length !== 32)
          throw new TypeError("sign: Expected 32 bytes of aux randomness");
      }
      getScalar(priv) {
        const point = Point.fromPrivateKey(priv);
        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
        return { point, scalar, x: point.toRawX() };
      }
      initNonce(d2, t0h) {
        return numTo32b(d2 ^ bytesToNumber(t0h));
      }
      finalizeNonce(k0h) {
        const k0 = mod(bytesToNumber(k0h), CURVE.n);
        if (k0 === _0n)
          throw new Error("sign: Creation of signature failed. k is zero");
        const { point: R, x: rx, scalar: k2 } = this.getScalar(k0);
        return { R, rx, k: k2 };
      }
      finalizeSig(R, k2, e2, d2) {
        return new SchnorrSignature(R.x, mod(k2 + e2 * d2, CURVE.n)).toRawBytes();
      }
      error() {
        throw new Error("sign: Invalid signature produced");
      }
      async calc() {
        const { m: m4, d: d2, px, rand } = this;
        const tag = exports.utils.taggedHash;
        const t2 = this.initNonce(d2, await tag(TAGS.aux, rand));
        const { R, rx, k: k2 } = this.finalizeNonce(await tag(TAGS.nonce, t2, px, m4));
        const e2 = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m4));
        const sig = this.finalizeSig(R, k2, e2, d2);
        if (!await schnorrVerify(sig, m4, px))
          this.error();
        return sig;
      }
      calcSync() {
        const { m: m4, d: d2, px, rand } = this;
        const tag = exports.utils.taggedHashSync;
        const t2 = this.initNonce(d2, tag(TAGS.aux, rand));
        const { R, rx, k: k2 } = this.finalizeNonce(tag(TAGS.nonce, t2, px, m4));
        const e2 = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m4));
        const sig = this.finalizeSig(R, k2, e2, d2);
        if (!schnorrVerifySync(sig, m4, px))
          this.error();
        return sig;
      }
    };
    async function schnorrSign(msg, privKey, auxRand) {
      return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
    }
    function schnorrSignSync(msg, privKey, auxRand) {
      return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
    }
    function initSchnorrVerify(signature, message, publicKey) {
      const raw = signature instanceof SchnorrSignature;
      const sig = raw ? signature : SchnorrSignature.fromHex(signature);
      if (raw)
        sig.assertValidity();
      return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey)
      };
    }
    function finalizeSchnorrVerify(r2, P, s2, e2) {
      const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s2), mod(-e2, CURVE.n));
      if (!R || !R.hasEvenY() || R.x !== r2)
        return false;
      return true;
    }
    async function schnorrVerify(signature, message, publicKey) {
      try {
        const { r: r2, s: s2, m: m4, P } = initSchnorrVerify(signature, message, publicKey);
        const e2 = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r2), P.toRawX(), m4));
        return finalizeSchnorrVerify(r2, P, s2, e2);
      } catch (error) {
        return false;
      }
    }
    function schnorrVerifySync(signature, message, publicKey) {
      try {
        const { r: r2, s: s2, m: m4, P } = initSchnorrVerify(signature, message, publicKey);
        const e2 = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r2), P.toRawX(), m4));
        return finalizeSchnorrVerify(r2, P, s2, e2);
      } catch (error) {
        if (error instanceof ShaError)
          throw error;
        return false;
      }
    }
    exports.schnorr = {
      Signature: SchnorrSignature,
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      signSync: schnorrSignSync,
      verifySync: schnorrVerifySync
    };
    Point.BASE._setWindowSize(8);
    var crypto2 = {
      node: nodeCrypto,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    var TAGS = {
      challenge: "BIP0340/challenge",
      aux: "BIP0340/aux",
      nonce: "BIP0340/nonce"
    };
    var TAGGED_HASH_PREFIXES = {};
    exports.utils = {
      bytesToHex,
      hexToBytes,
      concatBytes,
      mod,
      invert,
      isValidPrivateKey(privateKey) {
        try {
          normalizePrivateKey(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      _bigintTo32Bytes: numTo32b,
      _normalizePrivateKey: normalizePrivateKey,
      hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        const minLen = groupLen + 8;
        if (hash.length < minLen || hash.length > 1024) {
          throw new Error(`Expected valid bytes of private key as per FIPS 186`);
        }
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto2.web) {
          return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto2.node) {
          const { randomBytes } = crypto2.node;
          return Uint8Array.from(randomBytes(bytesLength));
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
      },
      sha256: async (...messages) => {
        if (crypto2.web) {
          const buffer = await crypto2.web.subtle.digest("SHA-256", concatBytes(...messages));
          return new Uint8Array(buffer);
        } else if (crypto2.node) {
          const { createHash } = crypto2.node;
          const hash = createHash("sha256");
          messages.forEach((m4) => hash.update(m4));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have sha256 function");
        }
      },
      hmacSha256: async (key, ...messages) => {
        if (crypto2.web) {
          const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
          const message = concatBytes(...messages);
          const buffer = await crypto2.web.subtle.sign("HMAC", ckey, message);
          return new Uint8Array(buffer);
        } else if (crypto2.node) {
          const { createHmac } = crypto2.node;
          const hash = createHmac("sha256", key);
          messages.forEach((m4) => hash.update(m4));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have hmac-sha256 function");
        }
      },
      sha256Sync: void 0,
      hmacSha256Sync: void 0,
      taggedHash: async (tag, ...messages) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
          tagP = concatBytes(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return exports.utils.sha256(tagP, ...messages);
      },
      taggedHashSync: (tag, ...messages) => {
        if (typeof _sha256Sync !== "function")
          throw new ShaError("sha256Sync is undefined, you need to set it");
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = _sha256Sync(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
          tagP = concatBytes(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages);
      },
      _JacobianPoint: JacobianPoint
    };
    Object.defineProperties(exports.utils, {
      sha256Sync: {
        configurable: false,
        get() {
          return _sha256Sync;
        },
        set(val) {
          if (!_sha256Sync)
            _sha256Sync = val;
        }
      },
      hmacSha256Sync: {
        configurable: false,
        get() {
          return _hmacSha256Sync;
        },
        set(val) {
          if (!_hmacSha256Sync)
            _hmacSha256Sync = val;
        }
      }
    });
  }
});

// node_modules/jsontokens/lib/ecdsaSigFormatter.js
var require_ecdsaSigFormatter = __commonJS({
  "node_modules/jsontokens/lib/ecdsaSigFormatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joseToDer = exports.derToJose = void 0;
    var base64_js_1 = require_base64_js();
    var base64Url_1 = require_base64Url();
    function getParamSize(keySize) {
      return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      const paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error(`Unknown algorithm "${alg}"`);
    }
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function signatureAsBytes(signature) {
      if (signature instanceof Uint8Array) {
        return signature;
      } else if ("string" === typeof signature) {
        return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
    }
    function derToJose(signature, alg) {
      const signatureBytes = signatureAsBytes(signature);
      const paramBytes = getParamBytesForAlg(alg);
      const maxEncodedParamLength = paramBytes + 1;
      const inputLength = signatureBytes.length;
      let offset = 0;
      if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      let seqLength = signatureBytes[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signatureBytes[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error(`"seq" specified length of "${seqLength}", only "${inputLength - offset}" remaining`);
      }
      if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      const rLength = signatureBytes[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error(`"r" specified length of "${rLength}", only "${inputLength - offset - 2}" available`);
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error(`"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`);
      }
      const rOffset = offset;
      offset += rLength;
      if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      const sLength = signatureBytes[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error(`"s" specified length of "${sLength}", expected "${inputLength - offset}"`);
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error(`"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`);
      }
      const sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error(`Expected to consume entire array, but "${inputLength - offset}" bytes remain`);
      }
      const rPadding = paramBytes - rLength;
      const sPadding = paramBytes - sLength;
      const dst = new Uint8Array(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);
      offset = paramBytes;
      for (const o2 = offset; offset < o2 + sPadding; ++offset) {
        dst[offset] = 0;
      }
      dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);
      return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));
    }
    exports.derToJose = derToJose;
    function countPadding(buf, start, stop) {
      let padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      const needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBytes(signature);
      const paramBytes = getParamBytesForAlg(alg);
      const signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError(`"${alg}" signatures must be "${paramBytes * 2}" bytes, saw "${signatureBytes}"`);
      }
      const rPadding = countPadding(signature, 0, paramBytes);
      const sPadding = countPadding(signature, paramBytes, signature.length);
      const rLength = paramBytes - rPadding;
      const sLength = paramBytes - sPadding;
      const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      const shortLength = rsBytes < MAX_OCTET;
      const dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);
      let offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(0, paramBytes), offset);
        offset += paramBytes;
      } else {
        dst.set(signature.subarray(rPadding, paramBytes), offset);
        offset += paramBytes - rPadding;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(paramBytes), offset);
      } else {
        dst.set(signature.subarray(paramBytes + sPadding), offset);
      }
      return dst;
    }
    exports.joseToDer = joseToDer;
  }
});

// node_modules/jsontokens/lib/errors.js
var require_errors = __commonJS({
  "node_modules/jsontokens/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidTokenError = exports.MissingParametersError = void 0;
    var MissingParametersError = class extends Error {
      constructor(message) {
        super();
        this.name = "MissingParametersError";
        this.message = message || "";
      }
    };
    exports.MissingParametersError = MissingParametersError;
    var InvalidTokenError = class extends Error {
      constructor(message) {
        super();
        this.name = "InvalidTokenError";
        this.message = message || "";
      }
    };
    exports.InvalidTokenError = InvalidTokenError;
  }
});

// node_modules/jsontokens/lib/cryptoClients/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SECP256K1Client = void 0;
    var hmac_1 = require_hmac();
    var sha256_1 = require_sha256();
    var secp = require_lib();
    var ecdsaSigFormatter_1 = require_ecdsaSigFormatter();
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    secp.utils.hmacSha256Sync = (key, ...msgs) => {
      const h2 = hmac_1.hmac.create(sha256_1.sha256, key);
      msgs.forEach((msg) => h2.update(msg));
      return h2.digest();
    };
    var SECP256K1Client = class {
      static derivePublicKey(privateKey, compressed = true) {
        if (privateKey.length === 66) {
          privateKey = privateKey.slice(0, 64);
        }
        if (privateKey.length < 64) {
          privateKey = privateKey.padStart(64, "0");
        }
        return (0, utils_1.bytesToHex)(secp.getPublicKey(privateKey, compressed));
      }
      static signHash(signingInputHash, privateKey, format = "jose") {
        if (!signingInputHash || !privateKey) {
          throw new errors_1.MissingParametersError("a signing input hash and private key are all required");
        }
        const derSignature = secp.signSync(signingInputHash, privateKey.slice(0, 64), {
          der: true,
          canonical: false
        });
        if (format === "der")
          return (0, utils_1.bytesToHex)(derSignature);
        if (format === "jose")
          return (0, ecdsaSigFormatter_1.derToJose)(derSignature, "ES256");
        throw Error("Invalid signature format");
      }
      static loadSignature(joseSignature) {
        return (0, ecdsaSigFormatter_1.joseToDer)(joseSignature, "ES256");
      }
      static verifyHash(signingInputHash, derSignatureBytes, publicKey) {
        if (!signingInputHash || !derSignatureBytes || !publicKey) {
          throw new errors_1.MissingParametersError("a signing input hash, der signature, and public key are all required");
        }
        return secp.verify(derSignatureBytes, signingInputHash, publicKey, { strict: false });
      }
    };
    exports.SECP256K1Client = SECP256K1Client;
    SECP256K1Client.algorithmName = "ES256K";
  }
});

// node_modules/jsontokens/lib/cryptoClients/index.js
var require_cryptoClients = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cryptoClients = exports.SECP256K1Client = void 0;
    var secp256k1_1 = require_secp256k1();
    Object.defineProperty(exports, "SECP256K1Client", { enumerable: true, get: function() {
      return secp256k1_1.SECP256K1Client;
    } });
    var cryptoClients = {
      ES256K: secp256k1_1.SECP256K1Client
    };
    exports.cryptoClients = cryptoClients;
  }
});

// node_modules/jsontokens/lib/cryptoClients/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/sha256.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashSha256Async = exports.hashSha256 = void 0;
    var sha256_1 = require_sha256();
    function hashSha256(input) {
      return (0, sha256_1.sha256)(input);
    }
    exports.hashSha256 = hashSha256;
    function hashSha256Async(input) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const isSubtleCryptoAvailable = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
          if (isSubtleCryptoAvailable) {
            const bytes = typeof input === "string" ? new TextEncoder().encode(input) : input;
            const hash = yield crypto.subtle.digest("SHA-256", bytes);
            return new Uint8Array(hash);
          } else {
            const nodeCrypto = require_crypto();
            if (!nodeCrypto.createHash) {
              throw new Error("`crypto` module does not contain `createHash`");
            }
            return Promise.resolve(nodeCrypto.createHash("sha256").update(input).digest());
          }
        } catch (error) {
          console.log(error);
          console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.');
          return Promise.resolve(hashSha256(input));
        }
      });
    }
    exports.hashSha256Async = hashSha256Async;
  }
});

// node_modules/jsontokens/lib/signer.js
var require_signer = __commonJS({
  "node_modules/jsontokens/lib/signer.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenSigner = exports.createUnsecuredToken = void 0;
    var base64url = require_base64Url();
    var cryptoClients_1 = require_cryptoClients();
    var errors_1 = require_errors();
    var sha256_1 = require_sha2562();
    function createSigningInput(payload, header) {
      const tokenParts = [];
      const encodedHeader = base64url.encode(JSON.stringify(header));
      tokenParts.push(encodedHeader);
      const encodedPayload = base64url.encode(JSON.stringify(payload));
      tokenParts.push(encodedPayload);
      const signingInput = tokenParts.join(".");
      return signingInput;
    }
    function createUnsecuredToken10(payload) {
      const header = { typ: "JWT", alg: "none" };
      return createSigningInput(payload, header) + ".";
    }
    exports.createUnsecuredToken = createUnsecuredToken10;
    var TokenSigner = class {
      constructor(signingAlgorithm, rawPrivateKey) {
        if (!(signingAlgorithm && rawPrivateKey)) {
          throw new errors_1.MissingParametersError("a signing algorithm and private key are required");
        }
        if (typeof signingAlgorithm !== "string") {
          throw new Error("signing algorithm parameter must be a string");
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
          throw new Error("invalid signing algorithm");
        }
        this.tokenType = "JWT";
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPrivateKey = rawPrivateKey;
      }
      header(header = {}) {
        const defaultHeader = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
        return Object.assign({}, defaultHeader, header);
      }
      sign(payload, expanded = false, customHeader = {}) {
        const header = this.header(customHeader);
        const signingInput = createSigningInput(payload, header);
        const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
        return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
      }
      signAsync(payload, expanded = false, customHeader = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          const header = this.header(customHeader);
          const signingInput = createSigningInput(payload, header);
          const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);
          return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
        });
      }
      createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {
        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);
        if (expanded) {
          const signedToken = {
            header: [base64url.encode(JSON.stringify(header))],
            payload: JSON.stringify(payload),
            signature: [signature]
          };
          return signedToken;
        } else {
          return [signingInput, signature].join(".");
        }
      }
    };
    exports.TokenSigner = TokenSigner;
  }
});

// node_modules/jsontokens/lib/verifier.js
var require_verifier = __commonJS({
  "node_modules/jsontokens/lib/verifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenVerifier = void 0;
    var base64url = require_base64Url();
    var cryptoClients_1 = require_cryptoClients();
    var errors_1 = require_errors();
    var sha256_1 = require_sha2562();
    var TokenVerifier = class {
      constructor(signingAlgorithm, rawPublicKey) {
        if (!(signingAlgorithm && rawPublicKey)) {
          throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
        }
        if (typeof signingAlgorithm !== "string") {
          throw "signing algorithm parameter must be a string";
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
          throw "invalid signing algorithm";
        }
        this.tokenType = "JWT";
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPublicKey = rawPublicKey;
      }
      verify(token) {
        if (typeof token === "string") {
          return this.verifyCompact(token, false);
        } else if (typeof token === "object") {
          return this.verifyExpanded(token, false);
        } else {
          return false;
        }
      }
      verifyAsync(token) {
        if (typeof token === "string") {
          return this.verifyCompact(token, true);
        } else if (typeof token === "object") {
          return this.verifyExpanded(token, true);
        } else {
          return Promise.resolve(false);
        }
      }
      verifyCompact(token, async) {
        const tokenParts = token.split(".");
        const signingInput = tokenParts[0] + "." + tokenParts[1];
        const performVerify = (signingInputHash) => {
          const derSignatureBytes = this.cryptoClient.loadSignature(tokenParts[2]);
          return this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
        };
        if (async) {
          return (0, sha256_1.hashSha256Async)(signingInput).then((signingInputHash) => performVerify(signingInputHash));
        } else {
          const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
          return performVerify(signingInputHash);
        }
      }
      verifyExpanded(token, async) {
        const signingInput = [token["header"].join("."), base64url.encode(token["payload"])].join(".");
        let verified = true;
        const performVerify = (signingInputHash) => {
          token["signature"].map((signature) => {
            const derSignatureBytes = this.cryptoClient.loadSignature(signature);
            const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
            if (!signatureVerified) {
              verified = false;
            }
          });
          return verified;
        };
        if (async) {
          return (0, sha256_1.hashSha256Async)(signingInput).then((signingInputHash) => performVerify(signingInputHash));
        } else {
          const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
          return performVerify(signingInputHash);
        }
      }
    };
    exports.TokenVerifier = TokenVerifier;
  }
});

// node_modules/jsontokens/lib/decode.js
var require_decode = __commonJS({
  "node_modules/jsontokens/lib/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeToken = void 0;
    var base64url = require_base64Url();
    function decodeToken(token) {
      if (typeof token === "string") {
        const tokenParts = token.split(".");
        const header = JSON.parse(base64url.decode(tokenParts[0]));
        const payload = JSON.parse(base64url.decode(tokenParts[1]));
        const signature = tokenParts[2];
        return {
          header,
          payload,
          signature
        };
      } else if (typeof token === "object") {
        if (typeof token.payload !== "string") {
          throw new Error("Expected token payload to be a base64 or json string");
        }
        let payload = token.payload;
        if (token.payload[0] !== "{") {
          payload = base64url.decode(payload);
        }
        const allHeaders = [];
        token.header.map((headerValue) => {
          const header = JSON.parse(base64url.decode(headerValue));
          allHeaders.push(header);
        });
        return {
          header: allHeaders,
          payload: JSON.parse(payload),
          signature: token.signature
        };
      }
    }
    exports.decodeToken = decodeToken;
  }
});

// node_modules/jsontokens/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/jsontokens/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m4, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m4, k2);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    }) : (function(o2, m4, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m4[k2];
    }));
    var __exportStar = exports && exports.__exportStar || function(m4, exports2) {
      for (var p2 in m4) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m4, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_signer(), exports);
    __exportStar(require_verifier(), exports);
    __exportStar(require_decode(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_cryptoClients(), exports);
  }
});

// node_modules/bitcoinjs-lib/src/networks.js
var require_networks = __commonJS({
  "node_modules/bitcoinjs-lib/src/networks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testnet = exports.regtest = exports.bitcoin = void 0;
    exports.bitcoin = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bc",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128
    };
    exports.regtest = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bcrt",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
    exports.testnet = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "tb",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
  }
});

// node_modules/bitcoinjs-lib/src/bip66.js
var require_bip66 = __commonJS({
  "node_modules/bitcoinjs-lib/src/bip66.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = exports.check = void 0;
    function check2(buffer) {
      if (buffer.length < 8) return false;
      if (buffer.length > 72) return false;
      if (buffer[0] !== 48) return false;
      if (buffer[1] !== buffer.length - 2) return false;
      if (buffer[2] !== 2) return false;
      const lenR = buffer[3];
      if (lenR === 0) return false;
      if (5 + lenR >= buffer.length) return false;
      if (buffer[4 + lenR] !== 2) return false;
      const lenS = buffer[5 + lenR];
      if (lenS === 0) return false;
      if (6 + lenR + lenS !== buffer.length) return false;
      if (buffer[4] & 128) return false;
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) return false;
      if (buffer[lenR + 6] & 128) return false;
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
        return false;
      return true;
    }
    exports.check = check2;
    function decode(buffer) {
      if (buffer.length < 8) throw new Error("DER sequence length is too short");
      if (buffer.length > 72) throw new Error("DER sequence length is too long");
      if (buffer[0] !== 48) throw new Error("Expected DER sequence");
      if (buffer[1] !== buffer.length - 2)
        throw new Error("DER sequence length is invalid");
      if (buffer[2] !== 2) throw new Error("Expected DER integer");
      const lenR = buffer[3];
      if (lenR === 0) throw new Error("R length is zero");
      if (5 + lenR >= buffer.length) throw new Error("R length is too long");
      if (buffer[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
      const lenS = buffer[5 + lenR];
      if (lenS === 0) throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
      if (buffer[4] & 128) throw new Error("R value is negative");
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128))
        throw new Error("R value excessively padded");
      if (buffer[lenR + 6] & 128) throw new Error("S value is negative");
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
        throw new Error("S value excessively padded");
      return {
        r: buffer.slice(4, 4 + lenR),
        s: buffer.slice(6 + lenR)
      };
    }
    exports.decode = decode;
    function encode3(r2, s2) {
      const lenR = r2.length;
      const lenS = s2.length;
      if (lenR === 0) throw new Error("R length is zero");
      if (lenS === 0) throw new Error("S length is zero");
      if (lenR > 33) throw new Error("R length is too long");
      if (lenS > 33) throw new Error("S length is too long");
      if (r2[0] & 128) throw new Error("R value is negative");
      if (s2[0] & 128) throw new Error("S value is negative");
      if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
        throw new Error("R value excessively padded");
      if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128))
        throw new Error("S value excessively padded");
      const signature = Buffer.allocUnsafe(6 + lenR + lenS);
      signature[0] = 48;
      signature[1] = signature.length - 2;
      signature[2] = 2;
      signature[3] = r2.length;
      r2.copy(signature, 4);
      signature[4 + lenR] = 2;
      signature[5 + lenR] = s2.length;
      s2.copy(signature, 6 + lenR);
      return signature;
    }
    exports.encode = encode3;
  }
});

// node_modules/bitcoinjs-lib/src/ops.js
var require_ops = __commonJS({
  "node_modules/bitcoinjs-lib/src/ops.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.REVERSE_OPS = exports.OPS = void 0;
    var OPS = {
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      OP_CAT: 126,
      OP_SUBSTR: 127,
      OP_LEFT: 128,
      OP_RIGHT: 129,
      OP_SIZE: 130,
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      OP_NOP1: 176,
      OP_NOP2: 177,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_NOP3: 178,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      OP_CHECKSIGADD: 186,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255
    };
    exports.OPS = OPS;
    var REVERSE_OPS = {};
    exports.REVERSE_OPS = REVERSE_OPS;
    for (const op of Object.keys(OPS)) {
      const code = OPS[op];
      REVERSE_OPS[code] = op;
    }
  }
});

// node_modules/bitcoinjs-lib/src/push_data.js
var require_push_data = __commonJS({
  "node_modules/bitcoinjs-lib/src/push_data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = exports.encodingLength = void 0;
    var ops_1 = require_ops();
    function encodingLength(i2) {
      return i2 < ops_1.OPS.OP_PUSHDATA1 ? 1 : i2 <= 255 ? 2 : i2 <= 65535 ? 3 : 5;
    }
    exports.encodingLength = encodingLength;
    function encode3(buffer, num, offset) {
      const size = encodingLength(num);
      if (size === 1) {
        buffer.writeUInt8(num, offset);
      } else if (size === 2) {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
        buffer.writeUInt8(num, offset + 1);
      } else if (size === 3) {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
        buffer.writeUInt16LE(num, offset + 1);
      } else {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
        buffer.writeUInt32LE(num, offset + 1);
      }
      return size;
    }
    exports.encode = encode3;
    function decode(buffer, offset) {
      const opcode = buffer.readUInt8(offset);
      let num;
      let size;
      if (opcode < ops_1.OPS.OP_PUSHDATA1) {
        num = opcode;
        size = 1;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
        if (offset + 2 > buffer.length) return null;
        num = buffer.readUInt8(offset + 1);
        size = 2;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
        if (offset + 3 > buffer.length) return null;
        num = buffer.readUInt16LE(offset + 1);
        size = 3;
      } else {
        if (offset + 5 > buffer.length) return null;
        if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        num = buffer.readUInt32LE(offset + 1);
        size = 5;
      }
      return {
        opcode,
        number: num,
        size
      };
    }
    exports.decode = decode;
  }
});

// node_modules/bitcoinjs-lib/src/script_number.js
var require_script_number = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    function decode(buffer, maxLength2, minimal) {
      maxLength2 = maxLength2 || 4;
      minimal = minimal === void 0 ? true : minimal;
      const length = buffer.length;
      if (length === 0) return 0;
      if (length > maxLength2) throw new TypeError("Script number overflow");
      if (minimal) {
        if ((buffer[length - 1] & 127) === 0) {
          if (length <= 1 || (buffer[length - 2] & 128) === 0)
            throw new Error("Non-minimally encoded script number");
        }
      }
      if (length === 5) {
        const a2 = buffer.readUInt32LE(0);
        const b3 = buffer.readUInt8(4);
        if (b3 & 128) return -((b3 & ~128) * 4294967296 + a2);
        return b3 * 4294967296 + a2;
      }
      let result = 0;
      for (let i2 = 0; i2 < length; ++i2) {
        result |= buffer[i2] << 8 * i2;
      }
      if (buffer[length - 1] & 128)
        return -(result & ~(128 << 8 * (length - 1)));
      return result;
    }
    exports.decode = decode;
    function scriptNumSize(i2) {
      return i2 > 2147483647 ? 5 : i2 > 8388607 ? 4 : i2 > 32767 ? 3 : i2 > 127 ? 2 : i2 > 0 ? 1 : 0;
    }
    function encode3(_number) {
      let value = Math.abs(_number);
      const size = scriptNumSize(value);
      const buffer = Buffer.allocUnsafe(size);
      const negative = _number < 0;
      for (let i2 = 0; i2 < size; ++i2) {
        buffer.writeUInt8(value & 255, i2);
        value >>= 8;
      }
      if (buffer[size - 1] & 128) {
        buffer.writeUInt8(negative ? 128 : 0, size - 1);
      } else if (negative) {
        buffer[size - 1] |= 128;
      }
      return buffer;
    }
    exports.encode = encode3;
  }
});

// node_modules/typeforce/native.js
var require_native = __commonJS({
  "node_modules/typeforce/native.js"(exports, module) {
    var types = {
      Array: function(value) {
        return value !== null && value !== void 0 && value.constructor === Array;
      },
      Boolean: function(value) {
        return typeof value === "boolean";
      },
      Function: function(value) {
        return typeof value === "function";
      },
      Nil: function(value) {
        return value === void 0 || value === null;
      },
      Number: function(value) {
        return typeof value === "number";
      },
      Object: function(value) {
        return typeof value === "object";
      },
      String: function(value) {
        return typeof value === "string";
      },
      "": function() {
        return true;
      }
    };
    types.Null = types.Nil;
    for (typeName in types) {
      types[typeName].toJSON = (function(t2) {
        return t2;
      }).bind(null, typeName);
    }
    var typeName;
    module.exports = types;
  }
});

// node_modules/typeforce/errors.js
var require_errors2 = __commonJS({
  "node_modules/typeforce/errors.js"(exports, module) {
    var native = require_native();
    function getTypeName(fn3) {
      return fn3.name || fn3.toString().match(/function (.*?)\s*\(/)[1];
    }
    function getValueTypeName(value) {
      return native.Nil(value) ? "" : getTypeName(value.constructor);
    }
    function getValue(value) {
      if (native.Function(value)) return "";
      if (native.String(value)) return JSON.stringify(value);
      if (value && native.Object(value)) return "";
      return value;
    }
    function captureStackTrace(e2, t2) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(e2, t2);
      }
    }
    function tfJSON(type) {
      if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
      if (native.Array(type)) return "Array";
      if (type && native.Object(type)) return "Object";
      return type !== void 0 ? type : "";
    }
    function tfErrorString(type, value, valueTypeName) {
      var valueJson = getValue(value);
      return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
    }
    function TfTypeError(type, value, valueTypeName) {
      valueTypeName = valueTypeName || getValueTypeName(value);
      this.message = tfErrorString(type, value, valueTypeName);
      captureStackTrace(this, TfTypeError);
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfTypeError.prototype = Object.create(Error.prototype);
    TfTypeError.prototype.constructor = TfTypeError;
    function tfPropertyErrorString(type, label, name, value, valueTypeName) {
      var description = '" of type ';
      if (label === "key") description = '" with key type ';
      return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName);
    }
    function TfPropertyTypeError(type, property, label, value, valueTypeName) {
      if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
      } else {
        this.message = 'Unexpected property "' + property + '"';
      }
      captureStackTrace(this, TfTypeError);
      this.__label = label;
      this.__property = property;
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfPropertyTypeError.prototype = Object.create(Error.prototype);
    TfPropertyTypeError.prototype.constructor = TfTypeError;
    function tfCustomError(expected, actual) {
      return new TfTypeError(expected, {}, actual);
    }
    function tfSubError(e2, property, label) {
      if (e2 instanceof TfPropertyTypeError) {
        property = property + "." + e2.__property;
        e2 = new TfPropertyTypeError(
          e2.__type,
          property,
          e2.__label,
          e2.__value,
          e2.__valueTypeName
        );
      } else if (e2 instanceof TfTypeError) {
        e2 = new TfPropertyTypeError(
          e2.__type,
          property,
          label,
          e2.__value,
          e2.__valueTypeName
        );
      }
      captureStackTrace(e2);
      return e2;
    }
    module.exports = {
      TfTypeError,
      TfPropertyTypeError,
      tfCustomError,
      tfSubError,
      tfJSON,
      getValueTypeName
    };
  }
});

// node_modules/typeforce/extra.js
var require_extra = __commonJS({
  "node_modules/typeforce/extra.js"(exports, module) {
    var NATIVE = require_native();
    var ERRORS = require_errors2();
    function _Buffer(value) {
      return Buffer.isBuffer(value);
    }
    function Hex(value) {
      return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
    }
    function _LengthN(type, length) {
      var name = type.toJSON();
      function Length(value) {
        if (!type(value)) return false;
        if (value.length === length) return true;
        throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")");
      }
      Length.toJSON = function() {
        return name;
      };
      return Length;
    }
    var _ArrayN = _LengthN.bind(null, NATIVE.Array);
    var _BufferN = _LengthN.bind(null, _Buffer);
    var _HexN = _LengthN.bind(null, Hex);
    var _StringN = _LengthN.bind(null, NATIVE.String);
    function Range(a2, b3, f2) {
      f2 = f2 || NATIVE.Number;
      function _range(value, strict) {
        return f2(value, strict) && value > a2 && value < b3;
      }
      _range.toJSON = function() {
        return `${f2.toJSON()} between [${a2}, ${b3}]`;
      };
      return _range;
    }
    var INT53_MAX = Math.pow(2, 53) - 1;
    function Finite(value) {
      return typeof value === "number" && isFinite(value);
    }
    function Int8(value) {
      return value << 24 >> 24 === value;
    }
    function Int16(value) {
      return value << 16 >> 16 === value;
    }
    function Int32(value) {
      return (value | 0) === value;
    }
    function Int53(value) {
      return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
    }
    function UInt8(value) {
      return (value & 255) === value;
    }
    function UInt16(value) {
      return (value & 65535) === value;
    }
    function UInt32(value) {
      return value >>> 0 === value;
    }
    function UInt53(value) {
      return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
    }
    var types = {
      ArrayN: _ArrayN,
      Buffer: _Buffer,
      BufferN: _BufferN,
      Finite,
      Hex,
      HexN: _HexN,
      Int8,
      Int16,
      Int32,
      Int53,
      Range,
      StringN: _StringN,
      UInt8,
      UInt16,
      UInt32,
      UInt53
    };
    for (typeName in types) {
      types[typeName].toJSON = (function(t2) {
        return t2;
      }).bind(null, typeName);
    }
    var typeName;
    module.exports = types;
  }
});

// node_modules/typeforce/index.js
var require_typeforce = __commonJS({
  "node_modules/typeforce/index.js"(exports, module) {
    var ERRORS = require_errors2();
    var NATIVE = require_native();
    var tfJSON = ERRORS.tfJSON;
    var TfTypeError = ERRORS.TfTypeError;
    var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
    var tfSubError = ERRORS.tfSubError;
    var getValueTypeName = ERRORS.getValueTypeName;
    var TYPES = {
      arrayOf: function arrayOf(type, options) {
        type = compile(type);
        options = options || {};
        function _arrayOf(array2, strict) {
          if (!NATIVE.Array(array2)) return false;
          if (NATIVE.Nil(array2)) return false;
          if (options.minLength !== void 0 && array2.length < options.minLength) return false;
          if (options.maxLength !== void 0 && array2.length > options.maxLength) return false;
          if (options.length !== void 0 && array2.length !== options.length) return false;
          return array2.every(function(value, i2) {
            try {
              return typeforce(type, value, strict);
            } catch (e2) {
              throw tfSubError(e2, i2);
            }
          });
        }
        _arrayOf.toJSON = function() {
          var str = "[" + tfJSON(type) + "]";
          if (options.length !== void 0) {
            str += "{" + options.length + "}";
          } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
            str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
          }
          return str;
        };
        return _arrayOf;
      },
      maybe: function maybe(type) {
        type = compile(type);
        function _maybe(value, strict) {
          return NATIVE.Nil(value) || type(value, strict, maybe);
        }
        _maybe.toJSON = function() {
          return "?" + tfJSON(type);
        };
        return _maybe;
      },
      map: function map(propertyType, propertyKeyType) {
        propertyType = compile(propertyType);
        if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
        function _map(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          for (var propertyName in value) {
            try {
              if (propertyKeyType) {
                typeforce(propertyKeyType, propertyName, strict);
              }
            } catch (e2) {
              throw tfSubError(e2, propertyName, "key");
            }
            try {
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            } catch (e2) {
              throw tfSubError(e2, propertyName);
            }
          }
          return true;
        }
        if (propertyKeyType) {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
          };
        } else {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
          };
        }
        return _map;
      },
      object: function object2(uncompiled) {
        var type = {};
        for (var typePropertyName in uncompiled) {
          type[typePropertyName] = compile(uncompiled[typePropertyName]);
        }
        function _object(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          var propertyName;
          try {
            for (propertyName in type) {
              var propertyType = type[propertyName];
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            }
          } catch (e2) {
            throw tfSubError(e2, propertyName);
          }
          if (strict) {
            for (propertyName in value) {
              if (type[propertyName]) continue;
              throw new TfPropertyTypeError(void 0, propertyName);
            }
          }
          return true;
        }
        _object.toJSON = function() {
          return tfJSON(type);
        };
        return _object;
      },
      anyOf: function anyOf() {
        var types = [].slice.call(arguments).map(compile);
        function _anyOf(value, strict) {
          return types.some(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e2) {
              return false;
            }
          });
        }
        _anyOf.toJSON = function() {
          return types.map(tfJSON).join("|");
        };
        return _anyOf;
      },
      allOf: function allOf() {
        var types = [].slice.call(arguments).map(compile);
        function _allOf(value, strict) {
          return types.every(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e2) {
              return false;
            }
          });
        }
        _allOf.toJSON = function() {
          return types.map(tfJSON).join(" & ");
        };
        return _allOf;
      },
      quacksLike: function quacksLike(type) {
        function _quacksLike(value) {
          return type === getValueTypeName(value);
        }
        _quacksLike.toJSON = function() {
          return type;
        };
        return _quacksLike;
      },
      tuple: function tuple() {
        var types = [].slice.call(arguments).map(compile);
        function _tuple(values, strict) {
          if (NATIVE.Nil(values)) return false;
          if (NATIVE.Nil(values.length)) return false;
          if (strict && values.length !== types.length) return false;
          return types.every(function(type, i2) {
            try {
              return typeforce(type, values[i2], strict);
            } catch (e2) {
              throw tfSubError(e2, i2);
            }
          });
        }
        _tuple.toJSON = function() {
          return "(" + types.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
      },
      value: function value(expected) {
        function _value(actual) {
          return actual === expected;
        }
        _value.toJSON = function() {
          return expected;
        };
        return _value;
      }
    };
    TYPES.oneOf = TYPES.anyOf;
    function compile(type) {
      if (NATIVE.String(type)) {
        if (type[0] === "?") return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
      } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
          if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
          return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
      } else if (NATIVE.Function(type)) {
        return type;
      }
      return TYPES.value(type);
    }
    function typeforce(type, value, strict, surrogate) {
      if (NATIVE.Function(type)) {
        if (type(value, strict)) return true;
        throw new TfTypeError(surrogate || type, value);
      }
      return typeforce(compile(type), value, strict);
    }
    for (typeName in NATIVE) {
      typeforce[typeName] = NATIVE[typeName];
    }
    var typeName;
    for (typeName in TYPES) {
      typeforce[typeName] = TYPES[typeName];
    }
    var EXTRA = require_extra();
    for (typeName in EXTRA) {
      typeforce[typeName] = EXTRA[typeName];
    }
    typeforce.compile = compile;
    typeforce.TfTypeError = TfTypeError;
    typeforce.TfPropertyTypeError = TfPropertyTypeError;
    module.exports = typeforce;
  }
});

// node_modules/bitcoinjs-lib/src/types.js
var require_types = __commonJS({
  "node_modules/bitcoinjs-lib/src/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oneOf = exports.Null = exports.BufferN = exports.Function = exports.UInt32 = exports.UInt8 = exports.tuple = exports.maybe = exports.Hex = exports.Buffer = exports.String = exports.Boolean = exports.Array = exports.Number = exports.Hash256bit = exports.Hash160bit = exports.Buffer256bit = exports.isTaptree = exports.isTapleaf = exports.TAPLEAF_VERSION_MASK = exports.Network = exports.ECPoint = exports.Satoshi = exports.Signer = exports.BIP32Path = exports.UInt31 = exports.isPoint = exports.typeforce = void 0;
    var buffer_1 = require_buffer();
    exports.typeforce = require_typeforce();
    var ZERO32 = buffer_1.Buffer.alloc(32, 0);
    var EC_P = buffer_1.Buffer.from(
      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
      "hex"
    );
    function isPoint(p2) {
      if (!buffer_1.Buffer.isBuffer(p2)) return false;
      if (p2.length < 33) return false;
      const t2 = p2[0];
      const x2 = p2.slice(1, 33);
      if (x2.compare(ZERO32) === 0) return false;
      if (x2.compare(EC_P) >= 0) return false;
      if ((t2 === 2 || t2 === 3) && p2.length === 33) {
        return true;
      }
      const y2 = p2.slice(33);
      if (y2.compare(ZERO32) === 0) return false;
      if (y2.compare(EC_P) >= 0) return false;
      if (t2 === 4 && p2.length === 65) return true;
      return false;
    }
    exports.isPoint = isPoint;
    var UINT31_MAX = Math.pow(2, 31) - 1;
    function UInt31(value) {
      return exports.typeforce.UInt32(value) && value <= UINT31_MAX;
    }
    exports.UInt31 = UInt31;
    function BIP32Path(value) {
      return exports.typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
    }
    exports.BIP32Path = BIP32Path;
    BIP32Path.toJSON = () => {
      return "BIP32 derivation path";
    };
    function Signer(obj) {
      return (exports.typeforce.Buffer(obj.publicKey) || typeof obj.getPublicKey === "function") && typeof obj.sign === "function";
    }
    exports.Signer = Signer;
    var SATOSHI_MAX = 21 * 1e14;
    function Satoshi(value) {
      return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;
    }
    exports.Satoshi = Satoshi;
    exports.ECPoint = exports.typeforce.quacksLike("Point");
    exports.Network = exports.typeforce.compile({
      messagePrefix: exports.typeforce.oneOf(
        exports.typeforce.Buffer,
        exports.typeforce.String
      ),
      bip32: {
        public: exports.typeforce.UInt32,
        private: exports.typeforce.UInt32
      },
      pubKeyHash: exports.typeforce.UInt8,
      scriptHash: exports.typeforce.UInt8,
      wif: exports.typeforce.UInt8
    });
    exports.TAPLEAF_VERSION_MASK = 254;
    function isTapleaf(o2) {
      if (!o2 || !("output" in o2)) return false;
      if (!buffer_1.Buffer.isBuffer(o2.output)) return false;
      if (o2.version !== void 0)
        return (o2.version & exports.TAPLEAF_VERSION_MASK) === o2.version;
      return true;
    }
    exports.isTapleaf = isTapleaf;
    function isTaptree(scriptTree) {
      if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);
      if (scriptTree.length !== 2) return false;
      return scriptTree.every((t2) => isTaptree(t2));
    }
    exports.isTaptree = isTaptree;
    exports.Buffer256bit = exports.typeforce.BufferN(32);
    exports.Hash160bit = exports.typeforce.BufferN(20);
    exports.Hash256bit = exports.typeforce.BufferN(32);
    exports.Number = exports.typeforce.Number;
    exports.Array = exports.typeforce.Array;
    exports.Boolean = exports.typeforce.Boolean;
    exports.String = exports.typeforce.String;
    exports.Buffer = exports.typeforce.Buffer;
    exports.Hex = exports.typeforce.Hex;
    exports.maybe = exports.typeforce.maybe;
    exports.tuple = exports.typeforce.tuple;
    exports.UInt8 = exports.typeforce.UInt8;
    exports.UInt32 = exports.typeforce.UInt32;
    exports.Function = exports.typeforce.Function;
    exports.BufferN = exports.typeforce.BufferN;
    exports.Null = exports.typeforce.Null;
    exports.oneOf = exports.typeforce.oneOf;
  }
});

// node_modules/bitcoinjs-lib/src/script_signature.js
var require_script_signature = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var bip66 = require_bip66();
    var types = require_types();
    var { typeforce } = types;
    var ZERO = Buffer.alloc(1, 0);
    function toDER(x2) {
      let i2 = 0;
      while (x2[i2] === 0) ++i2;
      if (i2 === x2.length) return ZERO;
      x2 = x2.slice(i2);
      if (x2[0] & 128) return Buffer.concat([ZERO, x2], 1 + x2.length);
      return x2;
    }
    function fromDER(x2) {
      if (x2[0] === 0) x2 = x2.slice(1);
      const buffer = Buffer.alloc(32, 0);
      const bstart = Math.max(0, 32 - x2.length);
      x2.copy(buffer, bstart);
      return buffer;
    }
    function decode(buffer) {
      const hashType = buffer.readUInt8(buffer.length - 1);
      const hashTypeMod = hashType & ~128;
      if (hashTypeMod <= 0 || hashTypeMod >= 4)
        throw new Error("Invalid hashType " + hashType);
      const decoded = bip66.decode(buffer.slice(0, -1));
      const r2 = fromDER(decoded.r);
      const s2 = fromDER(decoded.s);
      const signature = Buffer.concat([r2, s2], 64);
      return { signature, hashType };
    }
    exports.decode = decode;
    function encode3(signature, hashType) {
      typeforce(
        {
          signature: types.BufferN(64),
          hashType: types.UInt8
        },
        { signature, hashType }
      );
      const hashTypeMod = hashType & ~128;
      if (hashTypeMod <= 0 || hashTypeMod >= 4)
        throw new Error("Invalid hashType " + hashType);
      const hashTypeBuffer = Buffer.allocUnsafe(1);
      hashTypeBuffer.writeUInt8(hashType, 0);
      const r2 = toDER(signature.slice(0, 32));
      const s2 = toDER(signature.slice(32, 64));
      return Buffer.concat([bip66.encode(r2, s2), hashTypeBuffer]);
    }
    exports.encode = encode3;
  }
});

// node_modules/bitcoinjs-lib/src/script.js
var require_script = __commonJS({
  "node_modules/bitcoinjs-lib/src/script.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signature = exports.number = exports.isCanonicalScriptSignature = exports.isDefinedHashType = exports.isCanonicalPubKey = exports.toStack = exports.fromASM = exports.toASM = exports.decompile = exports.compile = exports.countNonPushOnlyOPs = exports.isPushOnly = exports.OPS = void 0;
    var bip66 = require_bip66();
    var ops_1 = require_ops();
    Object.defineProperty(exports, "OPS", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var pushdata = require_push_data();
    var scriptNumber = require_script_number();
    var scriptSignature = require_script_signature();
    var types = require_types();
    var { typeforce } = types;
    var OP_INT_BASE = ops_1.OPS.OP_RESERVED;
    function isOPInt(value) {
      return types.Number(value) && (value === ops_1.OPS.OP_0 || value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16 || value === ops_1.OPS.OP_1NEGATE);
    }
    function isPushOnlyChunk(value) {
      return types.Buffer(value) || isOPInt(value);
    }
    function isPushOnly(value) {
      return types.Array(value) && value.every(isPushOnlyChunk);
    }
    exports.isPushOnly = isPushOnly;
    function countNonPushOnlyOPs(value) {
      return value.length - value.filter(isPushOnlyChunk).length;
    }
    exports.countNonPushOnlyOPs = countNonPushOnlyOPs;
    function asMinimalOP(buffer) {
      if (buffer.length === 0) return ops_1.OPS.OP_0;
      if (buffer.length !== 1) return;
      if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
      if (buffer[0] === 129) return ops_1.OPS.OP_1NEGATE;
    }
    function chunksIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function chunksIsArray(buf) {
      return types.Array(buf);
    }
    function singleChunkIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function compile(chunks) {
      if (chunksIsBuffer(chunks)) return chunks;
      typeforce(types.Array, chunks);
      const bufferSize = chunks.reduce((accum, chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          if (chunk.length === 1 && asMinimalOP(chunk) !== void 0) {
            return accum + 1;
          }
          return accum + pushdata.encodingLength(chunk.length) + chunk.length;
        }
        return accum + 1;
      }, 0);
      const buffer = Buffer.allocUnsafe(bufferSize);
      let offset = 0;
      chunks.forEach((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const opcode = asMinimalOP(chunk);
          if (opcode !== void 0) {
            buffer.writeUInt8(opcode, offset);
            offset += 1;
            return;
          }
          offset += pushdata.encode(buffer, chunk.length, offset);
          chunk.copy(buffer, offset);
          offset += chunk.length;
        } else {
          buffer.writeUInt8(chunk, offset);
          offset += 1;
        }
      });
      if (offset !== buffer.length) throw new Error("Could not decode chunks");
      return buffer;
    }
    exports.compile = compile;
    function decompile(buffer) {
      if (chunksIsArray(buffer)) return buffer;
      typeforce(types.Buffer, buffer);
      const chunks = [];
      let i2 = 0;
      while (i2 < buffer.length) {
        const opcode = buffer[i2];
        if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
          const d2 = pushdata.decode(buffer, i2);
          if (d2 === null) return null;
          i2 += d2.size;
          if (i2 + d2.number > buffer.length) return null;
          const data = buffer.slice(i2, i2 + d2.number);
          i2 += d2.number;
          const op = asMinimalOP(data);
          if (op !== void 0) {
            chunks.push(op);
          } else {
            chunks.push(data);
          }
        } else {
          chunks.push(opcode);
          i2 += 1;
        }
      }
      return chunks;
    }
    exports.decompile = decompile;
    function toASM(chunks) {
      if (chunksIsBuffer(chunks)) {
        chunks = decompile(chunks);
      }
      return chunks.map((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const op = asMinimalOP(chunk);
          if (op === void 0) return chunk.toString("hex");
          chunk = op;
        }
        return ops_1.REVERSE_OPS[chunk];
      }).join(" ");
    }
    exports.toASM = toASM;
    function fromASM(asm) {
      typeforce(types.String, asm);
      return compile(
        asm.split(" ").map((chunkStr) => {
          if (ops_1.OPS[chunkStr] !== void 0) return ops_1.OPS[chunkStr];
          typeforce(types.Hex, chunkStr);
          return Buffer.from(chunkStr, "hex");
        })
      );
    }
    exports.fromASM = fromASM;
    function toStack(chunks) {
      chunks = decompile(chunks);
      typeforce(isPushOnly, chunks);
      return chunks.map((op) => {
        if (singleChunkIsBuffer(op)) return op;
        if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);
        return scriptNumber.encode(op - OP_INT_BASE);
      });
    }
    exports.toStack = toStack;
    function isCanonicalPubKey(buffer) {
      return types.isPoint(buffer);
    }
    exports.isCanonicalPubKey = isCanonicalPubKey;
    function isDefinedHashType(hashType) {
      const hashTypeMod = hashType & ~128;
      return hashTypeMod > 0 && hashTypeMod < 4;
    }
    exports.isDefinedHashType = isDefinedHashType;
    function isCanonicalScriptSignature(buffer) {
      if (!Buffer.isBuffer(buffer)) return false;
      if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
      return bip66.check(buffer.slice(0, -1));
    }
    exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
    exports.number = scriptNumber;
    exports.signature = scriptSignature;
  }
});

// node_modules/bitcoinjs-lib/src/payments/lazy.js
var require_lazy = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/lazy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.value = exports.prop = void 0;
    function prop(object2, name, f2) {
      Object.defineProperty(object2, name, {
        configurable: true,
        enumerable: true,
        get() {
          const _value = f2.call(this);
          this[name] = _value;
          return _value;
        },
        set(_value) {
          Object.defineProperty(this, name, {
            configurable: true,
            enumerable: true,
            value: _value,
            writable: true
          });
        }
      });
    }
    exports.prop = prop;
    function value(f2) {
      let _value;
      return () => {
        if (_value !== void 0) return _value;
        _value = f2();
        return _value;
      };
    }
    exports.value = value;
  }
});

// node_modules/bitcoinjs-lib/src/payments/embed.js
var require_embed = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/embed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2data = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    function stacksEqual(a2, b3) {
      if (a2.length !== b3.length) return false;
      return a2.every((x2, i2) => {
        return x2.equals(b3[i2]);
      });
    }
    function p2data(a2, opts) {
      if (!a2.data && !a2.output) throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          data: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a2
      );
      const network = a2.network || networks_1.bitcoin;
      const o2 = { name: "embed", network };
      lazy.prop(o2, "output", () => {
        if (!a2.data) return;
        return bscript.compile([OPS.OP_RETURN].concat(a2.data));
      });
      lazy.prop(o2, "data", () => {
        if (!a2.output) return;
        return bscript.decompile(a2.output).slice(1);
      });
      if (opts.validate) {
        if (a2.output) {
          const chunks = bscript.decompile(a2.output);
          if (chunks[0] !== OPS.OP_RETURN) throw new TypeError("Output is invalid");
          if (!chunks.slice(1).every(types_1.typeforce.Buffer))
            throw new TypeError("Output is invalid");
          if (a2.data && !stacksEqual(a2.data, o2.data))
            throw new TypeError("Data mismatch");
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2data = p2data;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2ms.js
var require_p2ms = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2ms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2ms = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    var OP_INT_BASE = OPS.OP_RESERVED;
    function stacksEqual(a2, b3) {
      if (a2.length !== b3.length) return false;
      return a2.every((x2, i2) => {
        return x2.equals(b3[i2]);
      });
    }
    function p2ms(a2, opts) {
      if (!a2.input && !a2.output && !(a2.pubkeys && a2.m !== void 0) && !a2.signatures)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      function isAcceptableSignature(x2) {
        return bscript.isCanonicalScriptSignature(x2) || (opts.allowIncomplete && x2 === OPS.OP_0) !== void 0;
      }
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          m: types_1.typeforce.maybe(types_1.typeforce.Number),
          n: types_1.typeforce.maybe(types_1.typeforce.Number),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkeys: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.isPoint)
          ),
          signatures: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(isAcceptableSignature)
          ),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a2
      );
      const network = a2.network || networks_1.bitcoin;
      const o2 = { network };
      let chunks = [];
      let decoded = false;
      function decode(output) {
        if (decoded) return;
        decoded = true;
        chunks = bscript.decompile(output);
        o2.m = chunks[0] - OP_INT_BASE;
        o2.n = chunks[chunks.length - 2] - OP_INT_BASE;
        o2.pubkeys = chunks.slice(1, -2);
      }
      lazy.prop(o2, "output", () => {
        if (!a2.m) return;
        if (!o2.n) return;
        if (!a2.pubkeys) return;
        return bscript.compile(
          [].concat(
            OP_INT_BASE + a2.m,
            a2.pubkeys,
            OP_INT_BASE + o2.n,
            OPS.OP_CHECKMULTISIG
          )
        );
      });
      lazy.prop(o2, "m", () => {
        if (!o2.output) return;
        decode(o2.output);
        return o2.m;
      });
      lazy.prop(o2, "n", () => {
        if (!o2.pubkeys) return;
        return o2.pubkeys.length;
      });
      lazy.prop(o2, "pubkeys", () => {
        if (!a2.output) return;
        decode(a2.output);
        return o2.pubkeys;
      });
      lazy.prop(o2, "signatures", () => {
        if (!a2.input) return;
        return bscript.decompile(a2.input).slice(1);
      });
      lazy.prop(o2, "input", () => {
        if (!a2.signatures) return;
        return bscript.compile([OPS.OP_0].concat(a2.signatures));
      });
      lazy.prop(o2, "witness", () => {
        if (!o2.input) return;
        return [];
      });
      lazy.prop(o2, "name", () => {
        if (!o2.m || !o2.n) return;
        return `p2ms(${o2.m} of ${o2.n})`;
      });
      if (opts.validate) {
        if (a2.output) {
          decode(a2.output);
          if (!types_1.typeforce.Number(chunks[0]))
            throw new TypeError("Output is invalid");
          if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
            throw new TypeError("Output is invalid");
          if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
            throw new TypeError("Output is invalid");
          if (o2.m <= 0 || o2.n > 16 || o2.m > o2.n || o2.n !== chunks.length - 3)
            throw new TypeError("Output is invalid");
          if (!o2.pubkeys.every((x2) => (0, types_1.isPoint)(x2)))
            throw new TypeError("Output is invalid");
          if (a2.m !== void 0 && a2.m !== o2.m) throw new TypeError("m mismatch");
          if (a2.n !== void 0 && a2.n !== o2.n) throw new TypeError("n mismatch");
          if (a2.pubkeys && !stacksEqual(a2.pubkeys, o2.pubkeys))
            throw new TypeError("Pubkeys mismatch");
        }
        if (a2.pubkeys) {
          if (a2.n !== void 0 && a2.n !== a2.pubkeys.length)
            throw new TypeError("Pubkey count mismatch");
          o2.n = a2.pubkeys.length;
          if (o2.n < o2.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (a2.signatures) {
          if (a2.signatures.length < o2.m)
            throw new TypeError("Not enough signatures provided");
          if (a2.signatures.length > o2.m)
            throw new TypeError("Too many signatures provided");
        }
        if (a2.input) {
          if (a2.input[0] !== OPS.OP_0) throw new TypeError("Input is invalid");
          if (o2.signatures.length === 0 || !o2.signatures.every(isAcceptableSignature))
            throw new TypeError("Input has invalid signature(s)");
          if (a2.signatures && !stacksEqual(a2.signatures, o2.signatures))
            throw new TypeError("Signature mismatch");
          if (a2.m !== void 0 && a2.m !== a2.signatures.length)
            throw new TypeError("Signature count mismatch");
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2ms = p2ms;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pk.js
var require_p2pk = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2pk = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    function p2pk(a2, opts) {
      if (!a2.input && !a2.output && !a2.pubkey && !a2.input && !a2.signature)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a2
      );
      const _chunks = lazy.value(() => {
        return bscript.decompile(a2.input);
      });
      const network = a2.network || networks_1.bitcoin;
      const o2 = { name: "p2pk", network };
      lazy.prop(o2, "output", () => {
        if (!a2.pubkey) return;
        return bscript.compile([a2.pubkey, OPS.OP_CHECKSIG]);
      });
      lazy.prop(o2, "pubkey", () => {
        if (!a2.output) return;
        return a2.output.slice(1, -1);
      });
      lazy.prop(o2, "signature", () => {
        if (!a2.input) return;
        return _chunks()[0];
      });
      lazy.prop(o2, "input", () => {
        if (!a2.signature) return;
        return bscript.compile([a2.signature]);
      });
      lazy.prop(o2, "witness", () => {
        if (!o2.input) return;
        return [];
      });
      if (opts.validate) {
        if (a2.output) {
          if (a2.output[a2.output.length - 1] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          if (!(0, types_1.isPoint)(o2.pubkey))
            throw new TypeError("Output pubkey is invalid");
          if (a2.pubkey && !a2.pubkey.equals(o2.pubkey))
            throw new TypeError("Pubkey mismatch");
        }
        if (a2.signature) {
          if (a2.input && !a2.input.equals(o2.input))
            throw new TypeError("Signature mismatch");
        }
        if (a2.input) {
          if (_chunks().length !== 1) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(o2.signature))
            throw new TypeError("Input has invalid signature");
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2pk = p2pk;
  }
});

// node_modules/@noble/hashes/legacy.js
var require_legacy = __commonJS({
  "node_modules/@noble/hashes/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
    var _md_ts_1 = require_md();
    var utils_ts_1 = require_utils();
    var SHA1_IV = Uint32Array.from([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = new Uint32Array(80);
    var SHA1 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A: A3, B, C: C4, D: D2, E: E2 } = this;
        return [A3, B, C4, D2, E2];
      }
      set(A3, B, C4, D2, E2) {
        this.A = A3 | 0;
        this.B = B | 0;
        this.C = C4 | 0;
        this.D = D2 | 0;
        this.E = E2 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA1_W[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 80; i2++)
          SHA1_W[i2] = (0, utils_ts_1.rotl)(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
        let { A: A3, B, C: C4, D: D2, E: E2 } = this;
        for (let i2 = 0; i2 < 80; i2++) {
          let F2, K2;
          if (i2 < 20) {
            F2 = (0, _md_ts_1.Chi)(B, C4, D2);
            K2 = 1518500249;
          } else if (i2 < 40) {
            F2 = B ^ C4 ^ D2;
            K2 = 1859775393;
          } else if (i2 < 60) {
            F2 = (0, _md_ts_1.Maj)(B, C4, D2);
            K2 = 2400959708;
          } else {
            F2 = B ^ C4 ^ D2;
            K2 = 3395469782;
          }
          const T3 = (0, utils_ts_1.rotl)(A3, 5) + F2 + E2 + K2 + SHA1_W[i2] | 0;
          E2 = D2;
          D2 = C4;
          C4 = (0, utils_ts_1.rotl)(B, 30);
          B = A3;
          A3 = T3;
        }
        A3 = A3 + this.A | 0;
        B = B + this.B | 0;
        C4 = C4 + this.C | 0;
        D2 = D2 + this.D | 0;
        E2 = E2 + this.E | 0;
        this.set(A3, B, C4, D2, E2);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA1 = SHA1;
    exports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
    var p32 = Math.pow(2, 32);
    var K = Array.from({ length: 64 }, (_2, i2) => Math.floor(p32 * Math.abs(Math.sin(i2 + 1))));
    var MD5_IV = SHA1_IV.slice(0, 4);
    var MD5_W = new Uint32Array(16);
    var MD5 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
      }
      get() {
        const { A: A3, B, C: C4, D: D2 } = this;
        return [A3, B, C4, D2];
      }
      set(A3, B, C4, D2) {
        this.A = A3 | 0;
        this.B = B | 0;
        this.C = C4 | 0;
        this.D = D2 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          MD5_W[i2] = view.getUint32(offset, true);
        let { A: A3, B, C: C4, D: D2 } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          let F2, g3, s2;
          if (i2 < 16) {
            F2 = (0, _md_ts_1.Chi)(B, C4, D2);
            g3 = i2;
            s2 = [7, 12, 17, 22];
          } else if (i2 < 32) {
            F2 = (0, _md_ts_1.Chi)(D2, B, C4);
            g3 = (5 * i2 + 1) % 16;
            s2 = [5, 9, 14, 20];
          } else if (i2 < 48) {
            F2 = B ^ C4 ^ D2;
            g3 = (3 * i2 + 5) % 16;
            s2 = [4, 11, 16, 23];
          } else {
            F2 = C4 ^ (B | ~D2);
            g3 = 7 * i2 % 16;
            s2 = [6, 10, 15, 21];
          }
          F2 = F2 + A3 + K[i2] + MD5_W[g3];
          A3 = D2;
          D2 = C4;
          C4 = B;
          B = B + (0, utils_ts_1.rotl)(F2, s2[i2 % 4]);
        }
        A3 = A3 + this.A | 0;
        B = B + this.B | 0;
        C4 = C4 + this.C | 0;
        D2 = D2 + this.D | 0;
        this.set(A3, B, C4, D2);
      }
      roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
      }
      destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.MD5 = MD5;
    exports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
    var Rho160 = Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_2, i2) => i2)))();
    var Pi160 = (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
    var idxLR = (() => {
      const L2 = [Id160];
      const R = [Pi160];
      const res = [L2, R];
      for (let i2 = 0; i2 < 4; i2++)
        for (let j2 of res)
          j2.push(j2[i2].map((k2) => Rho160[k2]));
      return res;
    })();
    var idxL = (() => idxLR[0])();
    var idxR = (() => idxLR[1])();
    var shifts160 = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i2) => Uint8Array.from(i2));
    var shiftsL160 = idxL.map((idx, i2) => idx.map((j2) => shifts160[i2][j2]));
    var shiftsR160 = idxR.map((idx, i2) => idx.map((j2) => shifts160[i2][j2]));
    var Kl160 = Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr160 = Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function ripemd_f(group, x2, y2, z2) {
      if (group === 0)
        return x2 ^ y2 ^ z2;
      if (group === 1)
        return x2 & y2 | ~x2 & z2;
      if (group === 2)
        return (x2 | ~y2) ^ z2;
      if (group === 3)
        return x2 & z2 | y2 & ~z2;
      return x2 ^ (y2 | ~z2);
    }
    var BUF_160 = new Uint32Array(16);
    var RIPEMD160 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          BUF_160[i2] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group], hbr = Kr160[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL160[group], sr = shiftsR160[group];
          for (let i2 = 0; i2 < 16; i2++) {
            const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
            al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i2 = 0; i2 < 16; i2++) {
            const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i2]] + hbr, sr[i2]) + er | 0;
            ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
  }
});

// node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var legacy_ts_1 = require_legacy();
    exports.RIPEMD160 = legacy_ts_1.RIPEMD160;
    exports.ripemd160 = legacy_ts_1.ripemd160;
  }
});

// node_modules/@noble/hashes/sha1.js
var require_sha1 = __commonJS({
  "node_modules/@noble/hashes/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha1 = exports.SHA1 = void 0;
    var legacy_ts_1 = require_legacy();
    exports.SHA1 = legacy_ts_1.SHA1;
    exports.sha1 = legacy_ts_1.sha1;
  }
});

// node_modules/bitcoinjs-lib/src/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taggedHash = exports.TAGGED_HASH_PREFIXES = exports.TAGS = exports.hash256 = exports.hash160 = exports.sha256 = exports.sha1 = exports.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var sha1_1 = require_sha1();
    var sha256_1 = require_sha256();
    function ripemd160(buffer) {
      return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));
    }
    exports.ripemd160 = ripemd160;
    function sha1(buffer) {
      return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));
    }
    exports.sha1 = sha1;
    function sha256(buffer) {
      return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));
    }
    exports.sha256 = sha256;
    function hash160(buffer) {
      return Buffer.from(
        (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
      );
    }
    exports.hash160 = hash160;
    function hash256(buffer) {
      return Buffer.from(
        (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
      );
    }
    exports.hash256 = hash256;
    exports.TAGS = [
      "BIP0340/challenge",
      "BIP0340/aux",
      "BIP0340/nonce",
      "TapLeaf",
      "TapBranch",
      "TapSighash",
      "TapTweak",
      "KeyAgg list",
      "KeyAgg coefficient"
    ];
    exports.TAGGED_HASH_PREFIXES = {
      "BIP0340/challenge": Buffer.from([
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124,
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124
      ]),
      "BIP0340/aux": Buffer.from([
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144,
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144
      ]),
      "BIP0340/nonce": Buffer.from([
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47,
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47
      ]),
      TapLeaf: Buffer.from([
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238,
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238
      ]),
      TapBranch: Buffer.from([
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21,
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21
      ]),
      TapSighash: Buffer.from([
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49,
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49
      ]),
      TapTweak: Buffer.from([
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233,
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233
      ]),
      "KeyAgg list": Buffer.from([
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240,
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240
      ]),
      "KeyAgg coefficient": Buffer.from([
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129,
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129
      ])
    };
    function taggedHash(prefix, data) {
      return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));
    }
    exports.taggedHash = taggedHash;
  }
});

// node_modules/bs58check/base.js
var require_base = __commonJS({
  "node_modules/bs58check/base.js"(exports, module) {
    "use strict";
    var base58 = require_bs58();
    module.exports = function(checksumFn) {
      function encode3(payload) {
        var payloadU8 = Uint8Array.from(payload);
        var checksum = checksumFn(payloadU8);
        var length = payloadU8.length + 4;
        var both = new Uint8Array(length);
        both.set(payloadU8, 0);
        both.set(checksum.subarray(0, 4), payloadU8.length);
        return base58.encode(both, length);
      }
      function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string2) {
        var buffer = base58.decodeUnsafe(string2);
        if (!buffer) return;
        return decodeRaw(buffer);
      }
      function decode(string2) {
        var buffer = base58.decode(string2);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode: encode3,
        decode,
        decodeUnsafe
      };
    };
  }
});

// node_modules/bs58check/index.js
var require_bs58check = __commonJS({
  "node_modules/bs58check/index.js"(exports, module) {
    "use strict";
    var { sha256 } = require_sha256();
    var bs58checkBase = require_base();
    function sha256x2(buffer) {
      return sha256(sha256(buffer));
    }
    module.exports = bs58checkBase(sha256x2);
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pkh.js
var require_p2pkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pkh.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2pkh = void 0;
    var bcrypto = require_crypto2();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bs58check = require_bs58check();
    var OPS = bscript.OPS;
    function p2pkh(a2, opts) {
      if (!a2.address && !a2.hash && !a2.output && !a2.pubkey && !a2.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a2
      );
      const _address = lazy.value(() => {
        const payload = Buffer.from(bs58check.decode(a2.address));
        const version2 = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version: version2, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a2.input);
      });
      const network = a2.network || networks_1.bitcoin;
      const o2 = { name: "p2pkh", network };
      lazy.prop(o2, "address", () => {
        if (!o2.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o2.hash.copy(payload, 1);
        return bs58check.encode(payload);
      });
      lazy.prop(o2, "hash", () => {
        if (a2.output) return a2.output.slice(3, 23);
        if (a2.address) return _address().hash;
        if (a2.pubkey || o2.pubkey) return bcrypto.hash160(a2.pubkey || o2.pubkey);
      });
      lazy.prop(o2, "output", () => {
        if (!o2.hash) return;
        return bscript.compile([
          OPS.OP_DUP,
          OPS.OP_HASH160,
          o2.hash,
          OPS.OP_EQUALVERIFY,
          OPS.OP_CHECKSIG
        ]);
      });
      lazy.prop(o2, "pubkey", () => {
        if (!a2.input) return;
        return _chunks()[1];
      });
      lazy.prop(o2, "signature", () => {
        if (!a2.input) return;
        return _chunks()[0];
      });
      lazy.prop(o2, "input", () => {
        if (!a2.pubkey) return;
        if (!a2.signature) return;
        return bscript.compile([a2.signature, a2.pubkey]);
      });
      lazy.prop(o2, "witness", () => {
        if (!o2.input) return;
        return [];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a2.address) {
          if (_address().version !== network.pubKeyHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a2.hash) {
          if (hash.length > 0 && !hash.equals(a2.hash))
            throw new TypeError("Hash mismatch");
          else hash = a2.hash;
        }
        if (a2.output) {
          if (a2.output.length !== 25 || a2.output[0] !== OPS.OP_DUP || a2.output[1] !== OPS.OP_HASH160 || a2.output[2] !== 20 || a2.output[23] !== OPS.OP_EQUALVERIFY || a2.output[24] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          const hash2 = a2.output.slice(3, 23);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a2.pubkey) {
          const pkh = bcrypto.hash160(a2.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
        }
        if (a2.input) {
          const chunks = _chunks();
          if (chunks.length !== 2) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(chunks[0]))
            throw new TypeError("Input has invalid signature");
          if (!(0, types_1.isPoint)(chunks[1]))
            throw new TypeError("Input has invalid pubkey");
          if (a2.signature && !a2.signature.equals(chunks[0]))
            throw new TypeError("Signature mismatch");
          if (a2.pubkey && !a2.pubkey.equals(chunks[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(chunks[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2pkh = p2pkh;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2sh.js
var require_p2sh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2sh.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2sh = void 0;
    var bcrypto = require_crypto2();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bs58check = require_bs58check();
    var OPS = bscript.OPS;
    function stacksEqual(a2, b3) {
      if (a2.length !== b3.length) return false;
      return a2.every((x2, i2) => {
        return x2.equals(b3[i2]);
      });
    }
    function p2sh(a2, opts) {
      if (!a2.address && !a2.hash && !a2.output && !a2.redeem && !a2.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
          redeem: types_1.typeforce.maybe({
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a2
      );
      let network = a2.network;
      if (!network) {
        network = a2.redeem && a2.redeem.network || networks_1.bitcoin;
      }
      const o2 = { network };
      const _address = lazy.value(() => {
        const payload = Buffer.from(bs58check.decode(a2.address));
        const version2 = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version: version2, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a2.input);
      });
      const _redeem = lazy.value(() => {
        const chunks = _chunks();
        const lastChunk = chunks[chunks.length - 1];
        return {
          network,
          output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,
          input: bscript.compile(chunks.slice(0, -1)),
          witness: a2.witness || []
        };
      });
      lazy.prop(o2, "address", () => {
        if (!o2.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(o2.network.scriptHash, 0);
        o2.hash.copy(payload, 1);
        return bs58check.encode(payload);
      });
      lazy.prop(o2, "hash", () => {
        if (a2.output) return a2.output.slice(2, 22);
        if (a2.address) return _address().hash;
        if (o2.redeem && o2.redeem.output) return bcrypto.hash160(o2.redeem.output);
      });
      lazy.prop(o2, "output", () => {
        if (!o2.hash) return;
        return bscript.compile([OPS.OP_HASH160, o2.hash, OPS.OP_EQUAL]);
      });
      lazy.prop(o2, "redeem", () => {
        if (!a2.input) return;
        return _redeem();
      });
      lazy.prop(o2, "input", () => {
        if (!a2.redeem || !a2.redeem.input || !a2.redeem.output) return;
        return bscript.compile(
          [].concat(bscript.decompile(a2.redeem.input), a2.redeem.output)
        );
      });
      lazy.prop(o2, "witness", () => {
        if (o2.redeem && o2.redeem.witness) return o2.redeem.witness;
        if (o2.input) return [];
      });
      lazy.prop(o2, "name", () => {
        const nameParts = ["p2sh"];
        if (o2.redeem !== void 0 && o2.redeem.name !== void 0)
          nameParts.push(o2.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a2.address) {
          if (_address().version !== network.scriptHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a2.hash) {
          if (hash.length > 0 && !hash.equals(a2.hash))
            throw new TypeError("Hash mismatch");
          else hash = a2.hash;
        }
        if (a2.output) {
          if (a2.output.length !== 23 || a2.output[0] !== OPS.OP_HASH160 || a2.output[1] !== 20 || a2.output[22] !== OPS.OP_EQUAL)
            throw new TypeError("Output is invalid");
          const hash2 = a2.output.slice(2, 22);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        const checkRedeem = (redeem) => {
          if (redeem.output) {
            const decompile = bscript.decompile(redeem.output);
            if (!decompile || decompile.length < 1)
              throw new TypeError("Redeem.output too short");
            if (redeem.output.byteLength > 520)
              throw new TypeError(
                "Redeem.output unspendable if larger than 520 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.hash160(redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (redeem.input) {
            const hasInput = redeem.input.length > 0;
            const hasWitness = redeem.witness && redeem.witness.length > 0;
            if (!hasInput && !hasWitness) throw new TypeError("Empty input");
            if (hasInput && hasWitness)
              throw new TypeError("Input and witness provided");
            if (hasInput) {
              const richunks = bscript.decompile(redeem.input);
              if (!bscript.isPushOnly(richunks))
                throw new TypeError("Non push-only scriptSig");
            }
          }
        };
        if (a2.input) {
          const chunks = _chunks();
          if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
          if (!Buffer.isBuffer(_redeem().output))
            throw new TypeError("Input is invalid");
          checkRedeem(_redeem());
        }
        if (a2.redeem) {
          if (a2.redeem.network && a2.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a2.input) {
            const redeem = _redeem();
            if (a2.redeem.output && !a2.redeem.output.equals(redeem.output))
              throw new TypeError("Redeem.output mismatch");
            if (a2.redeem.input && !a2.redeem.input.equals(redeem.input))
              throw new TypeError("Redeem.input mismatch");
          }
          checkRedeem(a2.redeem);
        }
        if (a2.witness) {
          if (a2.redeem && a2.redeem.witness && !stacksEqual(a2.redeem.witness, a2.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2sh = p2sh;
  }
});

// node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/bech32/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bech32m = exports.bech32 = void 0;
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z2 = 0; z2 < ALPHABET.length; z2++) {
      const x2 = ALPHABET.charAt(z2);
      ALPHABET_MAP[x2] = z2;
    }
    function polymodStep(pre) {
      const b3 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b3 >> 0 & 1) & 996825010 ^ -(b3 >> 1 & 1) & 642813549 ^ -(b3 >> 2 & 1) & 513874426 ^ -(b3 >> 3 & 1) & 1027748829 ^ -(b3 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const c2 = prefix.charCodeAt(i2);
        if (c2 < 33 || c2 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c2 >> 5;
      }
      chk = polymodStep(chk);
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const v2 = prefix.charCodeAt(i2);
        chk = polymodStep(chk) ^ v2 & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad) {
      let value = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i2 = 0; i2 < data.length; ++i2) {
        value = value << inBits | data[i2];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes) {
      return convert(bytes, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode3(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i2 = 0; i2 < words.length; ++i2) {
          const x2 = words[i2];
          if (x2 >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x2;
          result += ALPHABET.charAt(x2);
        }
        for (let i2 = 0; i2 < 6; ++i2) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i2 = 0; i2 < 6; ++i2) {
          const v2 = chk >> (5 - i2) * 5 & 31;
          result += ALPHABET.charAt(v2);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split = str.lastIndexOf("1");
        if (split === -1)
          return "No separator character for " + str;
        if (split === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i2 = 0; i2 < wordChars.length; ++i2) {
          const c2 = wordChars.charAt(i2);
          const v2 = ALPHABET_MAP[c2];
          if (v2 === void 0)
            return "Unknown character " + c2;
          chk = polymodStep(chk) ^ v2;
          if (i2 + 6 >= wordChars.length)
            continue;
          words.push(v2);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode,
        encode: encode3,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports.bech32 = getLibraryFromEncoding("bech32");
    exports.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wpkh.js
var require_p2wpkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wpkh.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2wpkh = void 0;
    var bcrypto = require_crypto2();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bech32_1 = require_dist();
    var OPS = bscript.OPS;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function p2wpkh(a2, opts) {
      if (!a2.address && !a2.hash && !a2.output && !a2.pubkey && !a2.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a2
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a2.address);
        const version2 = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version: version2,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const network = a2.network || networks_1.bitcoin;
      const o2 = { name: "p2wpkh", network };
      lazy.prop(o2, "address", () => {
        if (!o2.hash) return;
        const words = bech32_1.bech32.toWords(o2.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o2, "hash", () => {
        if (a2.output) return a2.output.slice(2, 22);
        if (a2.address) return _address().data;
        if (a2.pubkey || o2.pubkey) return bcrypto.hash160(a2.pubkey || o2.pubkey);
      });
      lazy.prop(o2, "output", () => {
        if (!o2.hash) return;
        return bscript.compile([OPS.OP_0, o2.hash]);
      });
      lazy.prop(o2, "pubkey", () => {
        if (a2.pubkey) return a2.pubkey;
        if (!a2.witness) return;
        return a2.witness[1];
      });
      lazy.prop(o2, "signature", () => {
        if (!a2.witness) return;
        return a2.witness[0];
      });
      lazy.prop(o2, "input", () => {
        if (!o2.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o2, "witness", () => {
        if (!a2.pubkey) return;
        if (!a2.signature) return;
        return [a2.signature, a2.pubkey];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a2.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 20)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a2.hash) {
          if (hash.length > 0 && !hash.equals(a2.hash))
            throw new TypeError("Hash mismatch");
          else hash = a2.hash;
        }
        if (a2.output) {
          if (a2.output.length !== 22 || a2.output[0] !== OPS.OP_0 || a2.output[1] !== 20)
            throw new TypeError("Output is invalid");
          if (hash.length > 0 && !hash.equals(a2.output.slice(2)))
            throw new TypeError("Hash mismatch");
          else hash = a2.output.slice(2);
        }
        if (a2.pubkey) {
          const pkh = bcrypto.hash160(a2.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
          if (!(0, types_1.isPoint)(a2.pubkey) || a2.pubkey.length !== 33)
            throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (a2.witness) {
          if (a2.witness.length !== 2) throw new TypeError("Witness is invalid");
          if (!bscript.isCanonicalScriptSignature(a2.witness[0]))
            throw new TypeError("Witness has invalid signature");
          if (!(0, types_1.isPoint)(a2.witness[1]) || a2.witness[1].length !== 33)
            throw new TypeError("Witness has invalid pubkey");
          if (a2.signature && !a2.signature.equals(a2.witness[0]))
            throw new TypeError("Signature mismatch");
          if (a2.pubkey && !a2.pubkey.equals(a2.witness[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(a2.witness[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2wpkh = p2wpkh;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wsh.js
var require_p2wsh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wsh.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2wsh = void 0;
    var bcrypto = require_crypto2();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bech32_1 = require_dist();
    var OPS = bscript.OPS;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function stacksEqual(a2, b3) {
      if (a2.length !== b3.length) return false;
      return a2.every((x2, i2) => {
        return x2.equals(b3[i2]);
      });
    }
    function chunkHasUncompressedPubkey(chunk) {
      if (Buffer.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 4 && (0, types_1.isPoint)(chunk)) {
        return true;
      } else {
        return false;
      }
    }
    function p2wsh(a2, opts) {
      if (!a2.address && !a2.hash && !a2.output && !a2.redeem && !a2.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          redeem: types_1.typeforce.maybe({
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a2
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a2.address);
        const version2 = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version: version2,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const _rchunks = lazy.value(() => {
        return bscript.decompile(a2.redeem.input);
      });
      let network = a2.network;
      if (!network) {
        network = a2.redeem && a2.redeem.network || networks_1.bitcoin;
      }
      const o2 = { network };
      lazy.prop(o2, "address", () => {
        if (!o2.hash) return;
        const words = bech32_1.bech32.toWords(o2.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o2, "hash", () => {
        if (a2.output) return a2.output.slice(2);
        if (a2.address) return _address().data;
        if (o2.redeem && o2.redeem.output) return bcrypto.sha256(o2.redeem.output);
      });
      lazy.prop(o2, "output", () => {
        if (!o2.hash) return;
        return bscript.compile([OPS.OP_0, o2.hash]);
      });
      lazy.prop(o2, "redeem", () => {
        if (!a2.witness) return;
        return {
          output: a2.witness[a2.witness.length - 1],
          input: EMPTY_BUFFER,
          witness: a2.witness.slice(0, -1)
        };
      });
      lazy.prop(o2, "input", () => {
        if (!o2.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o2, "witness", () => {
        if (a2.redeem && a2.redeem.input && a2.redeem.input.length > 0 && a2.redeem.output && a2.redeem.output.length > 0) {
          const stack = bscript.toStack(_rchunks());
          o2.redeem = Object.assign({ witness: stack }, a2.redeem);
          o2.redeem.input = EMPTY_BUFFER;
          return [].concat(stack, a2.redeem.output);
        }
        if (!a2.redeem) return;
        if (!a2.redeem.output) return;
        if (!a2.redeem.witness) return;
        return [].concat(a2.redeem.witness, a2.redeem.output);
      });
      lazy.prop(o2, "name", () => {
        const nameParts = ["p2wsh"];
        if (o2.redeem !== void 0 && o2.redeem.name !== void 0)
          nameParts.push(o2.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a2.address) {
          if (_address().prefix !== network.bech32)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a2.hash) {
          if (hash.length > 0 && !hash.equals(a2.hash))
            throw new TypeError("Hash mismatch");
          else hash = a2.hash;
        }
        if (a2.output) {
          if (a2.output.length !== 34 || a2.output[0] !== OPS.OP_0 || a2.output[1] !== 32)
            throw new TypeError("Output is invalid");
          const hash2 = a2.output.slice(2);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a2.redeem) {
          if (a2.redeem.network && a2.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a2.redeem.input && a2.redeem.input.length > 0 && a2.redeem.witness && a2.redeem.witness.length > 0)
            throw new TypeError("Ambiguous witness source");
          if (a2.redeem.output) {
            const decompile = bscript.decompile(a2.redeem.output);
            if (!decompile || decompile.length < 1)
              throw new TypeError("Redeem.output is invalid");
            if (a2.redeem.output.byteLength > 3600)
              throw new TypeError(
                "Redeem.output unspendable if larger than 3600 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.sha256(a2.redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a2.redeem.input && !bscript.isPushOnly(_rchunks()))
            throw new TypeError("Non push-only scriptSig");
          if (a2.witness && a2.redeem.witness && !stacksEqual(a2.witness, a2.redeem.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
          if (a2.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a2.redeem.output && (bscript.decompile(a2.redeem.output) || []).some(
            chunkHasUncompressedPubkey
          )) {
            throw new TypeError(
              "redeem.input or redeem.output contains uncompressed pubkey"
            );
          }
        }
        if (a2.witness && a2.witness.length > 0) {
          const wScript = a2.witness[a2.witness.length - 1];
          if (a2.redeem && a2.redeem.output && !a2.redeem.output.equals(wScript))
            throw new TypeError("Witness and redeem.output mismatch");
          if (a2.witness.some(chunkHasUncompressedPubkey) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey))
            throw new TypeError("Witness contains uncompressed pubkey");
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2wsh = p2wsh;
  }
});

// node_modules/bitcoinjs-lib/src/ecc_lib.js
var require_ecc_lib = __commonJS({
  "node_modules/bitcoinjs-lib/src/ecc_lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEccLib = exports.initEccLib = void 0;
    var _ECCLIB_CACHE = {};
    function initEccLib(eccLib) {
      if (!eccLib) {
        _ECCLIB_CACHE.eccLib = eccLib;
      } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
        verifyEcc(eccLib);
        _ECCLIB_CACHE.eccLib = eccLib;
      }
    }
    exports.initEccLib = initEccLib;
    function getEccLib() {
      if (!_ECCLIB_CACHE.eccLib)
        throw new Error(
          "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
        );
      return _ECCLIB_CACHE.eccLib;
    }
    exports.getEccLib = getEccLib;
    var h2 = (hex) => Buffer.from(hex, "hex");
    function verifyEcc(ecc) {
      assert(typeof ecc.isXOnlyPoint === "function");
      assert(
        ecc.isXOnlyPoint(
          h2("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h2("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h2("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h2("0000000000000000000000000000000000000000000000000000000000000001")
        )
      );
      assert(
        !ecc.isXOnlyPoint(
          h2("0000000000000000000000000000000000000000000000000000000000000000")
        )
      );
      assert(
        !ecc.isXOnlyPoint(
          h2("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
        )
      );
      assert(typeof ecc.xOnlyPointAddTweak === "function");
      tweakAddVectors.forEach((t2) => {
        const r2 = ecc.xOnlyPointAddTweak(h2(t2.pubkey), h2(t2.tweak));
        if (t2.result === null) {
          assert(r2 === null);
        } else {
          assert(r2 !== null);
          assert(r2.parity === t2.parity);
          assert(Buffer.from(r2.xOnlyPubkey).equals(h2(t2.result)));
        }
      });
    }
    function assert(bool) {
      if (!bool) throw new Error("ecc library invalid");
    }
    var tweakAddVectors = [
      {
        pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
        parity: -1,
        result: null
      },
      {
        pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
        tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
        parity: 1,
        result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
      },
      {
        pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
        tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
        parity: 0,
        result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
      }
    ];
  }
});

// node_modules/varuint-bitcoin/index.js
var require_varuint_bitcoin = __commonJS({
  "node_modules/varuint-bitcoin/index.js"(exports, module) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n2) {
      if (n2 < 0 || n2 > MAX_SAFE_INTEGER || n2 % 1 !== 0) throw new RangeError("value out of range");
    }
    function encode3(number2, buffer, offset) {
      checkUInt53(number2);
      if (!buffer) buffer = Buffer3.allocUnsafe(encodingLength(number2));
      if (!Buffer3.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (number2 < 253) {
        buffer.writeUInt8(number2, offset);
        encode3.bytes = 1;
      } else if (number2 <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(number2, offset + 1);
        encode3.bytes = 3;
      } else if (number2 <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(number2, offset + 1);
        encode3.bytes = 5;
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(number2 >>> 0, offset + 1);
        buffer.writeUInt32LE(number2 / 4294967296 | 0, offset + 5);
        encode3.bytes = 9;
      }
      return buffer;
    }
    function decode(buffer, offset) {
      if (!Buffer3.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      var first = buffer.readUInt8(offset);
      if (first < 253) {
        decode.bytes = 1;
        return first;
      } else if (first === 253) {
        decode.bytes = 3;
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        decode.bytes = 5;
        return buffer.readUInt32LE(offset + 1);
      } else {
        decode.bytes = 9;
        var lo = buffer.readUInt32LE(offset + 1);
        var hi = buffer.readUInt32LE(offset + 5);
        var number2 = hi * 4294967296 + lo;
        checkUInt53(number2);
        return number2;
      }
    }
    function encodingLength(number2) {
      checkUInt53(number2);
      return number2 < 253 ? 1 : number2 <= 65535 ? 3 : number2 <= 4294967295 ? 5 : 9;
    }
    module.exports = { encode: encode3, decode, encodingLength };
  }
});

// node_modules/bitcoinjs-lib/src/bufferutils.js
var require_bufferutils = __commonJS({
  "node_modules/bitcoinjs-lib/src/bufferutils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferReader = exports.BufferWriter = exports.cloneBuffer = exports.reverseBuffer = exports.writeUInt64LE = exports.readUInt64LE = exports.varuint = void 0;
    var types = require_types();
    var { typeforce } = types;
    var varuint = require_varuint_bitcoin();
    exports.varuint = varuint;
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a2 = buffer.readUInt32LE(offset);
      let b3 = buffer.readUInt32LE(offset + 4);
      b3 *= 4294967296;
      verifuint(b3 + a2, 9007199254740991);
      return b3 + a2;
    }
    exports.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports.writeUInt64LE = writeUInt64LE;
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j2 = buffer.length - 1;
      let tmp = 0;
      for (let i2 = 0; i2 < buffer.length / 2; i2++) {
        tmp = buffer[i2];
        buffer[i2] = buffer[j2];
        buffer[j2] = tmp;
        j2--;
      }
      return buffer;
    }
    exports.reverseBuffer = reverseBuffer;
    function cloneBuffer(buffer) {
      const clone = Buffer.allocUnsafe(buffer.length);
      buffer.copy(clone);
      return clone;
    }
    exports.cloneBuffer = cloneBuffer;
    var BufferWriter = class _BufferWriter {
      static withCapacity(size) {
        return new _BufferWriter(Buffer.alloc(size));
      }
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      writeUInt8(i2) {
        this.offset = this.buffer.writeUInt8(i2, this.offset);
      }
      writeInt32(i2) {
        this.offset = this.buffer.writeInt32LE(i2, this.offset);
      }
      writeUInt32(i2) {
        this.offset = this.buffer.writeUInt32LE(i2, this.offset);
      }
      writeUInt64(i2) {
        this.offset = writeUInt64LE(this.buffer, i2, this.offset);
      }
      writeVarInt(i2) {
        varuint.encode(i2, this.buffer, this.offset);
        this.offset += varuint.encode.bytes;
      }
      writeSlice(slice) {
        if (this.buffer.length < this.offset + slice.length) {
          throw new Error("Cannot write slice out of bounds");
        }
        this.offset += slice.copy(this.buffer, this.offset);
      }
      writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
      }
      writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf) => this.writeVarSlice(buf));
      }
      end() {
        if (this.buffer.length === this.offset) {
          return this.buffer;
        }
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
      }
    };
    exports.BufferWriter = BufferWriter;
    var BufferReader = class {
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
      }
      readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
      }
      readVarInt() {
        const vi = varuint.decode(this.buffer, this.offset);
        this.offset += varuint.decode.bytes;
        return vi;
      }
      readSlice(n2) {
        if (this.buffer.length < this.offset + n2) {
          throw new Error("Cannot read slice out of bounds");
        }
        const result = this.buffer.slice(this.offset, this.offset + n2);
        this.offset += n2;
        return result;
      }
      readVarSlice() {
        return this.readSlice(this.readVarInt());
      }
      readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i2 = 0; i2 < count; i2++) vector.push(this.readVarSlice());
        return vector;
      }
    };
    exports.BufferReader = BufferReader;
  }
});

// node_modules/bitcoinjs-lib/src/payments/bip341.js
var require_bip341 = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/bip341.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tweakKey = exports.tapTweakHash = exports.tapleafHash = exports.findScriptPath = exports.toHashTree = exports.rootHashFromPath = exports.MAX_TAPTREE_DEPTH = exports.LEAF_VERSION_TAPSCRIPT = void 0;
    var buffer_1 = require_buffer();
    var ecc_lib_1 = require_ecc_lib();
    var bcrypto = require_crypto2();
    var bufferutils_1 = require_bufferutils();
    var types_1 = require_types();
    exports.LEAF_VERSION_TAPSCRIPT = 192;
    exports.MAX_TAPTREE_DEPTH = 128;
    var isHashBranch = (ht2) => "left" in ht2 && "right" in ht2;
    function rootHashFromPath(controlBlock, leafHash) {
      if (controlBlock.length < 33)
        throw new TypeError(
          `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
        );
      const m4 = (controlBlock.length - 33) / 32;
      let kj = leafHash;
      for (let j2 = 0; j2 < m4; j2++) {
        const ej = controlBlock.slice(33 + 32 * j2, 65 + 32 * j2);
        if (kj.compare(ej) < 0) {
          kj = tapBranchHash(kj, ej);
        } else {
          kj = tapBranchHash(ej, kj);
        }
      }
      return kj;
    }
    exports.rootHashFromPath = rootHashFromPath;
    function toHashTree(scriptTree) {
      if ((0, types_1.isTapleaf)(scriptTree))
        return { hash: tapleafHash(scriptTree) };
      const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
      hashes.sort((a2, b3) => a2.hash.compare(b3.hash));
      const [left, right] = hashes;
      return {
        hash: tapBranchHash(left.hash, right.hash),
        left,
        right
      };
    }
    exports.toHashTree = toHashTree;
    function findScriptPath(node, hash) {
      if (isHashBranch(node)) {
        const leftPath = findScriptPath(node.left, hash);
        if (leftPath !== void 0) return [...leftPath, node.right.hash];
        const rightPath = findScriptPath(node.right, hash);
        if (rightPath !== void 0) return [...rightPath, node.left.hash];
      } else if (node.hash.equals(hash)) {
        return [];
      }
      return void 0;
    }
    exports.findScriptPath = findScriptPath;
    function tapleafHash(leaf) {
      const version2 = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;
      return bcrypto.taggedHash(
        "TapLeaf",
        buffer_1.Buffer.concat([
          buffer_1.Buffer.from([version2]),
          serializeScript(leaf.output)
        ])
      );
    }
    exports.tapleafHash = tapleafHash;
    function tapTweakHash(pubKey, h2) {
      return bcrypto.taggedHash(
        "TapTweak",
        buffer_1.Buffer.concat(h2 ? [pubKey, h2] : [pubKey])
      );
    }
    exports.tapTweakHash = tapTweakHash;
    function tweakKey(pubKey, h2) {
      if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
      if (pubKey.length !== 32) return null;
      if (h2 && h2.length !== 32) return null;
      const tweakHash = tapTweakHash(pubKey, h2);
      const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
      if (!res || res.xOnlyPubkey === null) return null;
      return {
        parity: res.parity,
        x: buffer_1.Buffer.from(res.xOnlyPubkey)
      };
    }
    exports.tweakKey = tweakKey;
    function tapBranchHash(a2, b3) {
      return bcrypto.taggedHash("TapBranch", buffer_1.Buffer.concat([a2, b3]));
    }
    function serializeScript(s2) {
      const varintLen = bufferutils_1.varuint.encodingLength(s2.length);
      const buffer = buffer_1.Buffer.allocUnsafe(varintLen);
      bufferutils_1.varuint.encode(s2.length, buffer);
      return buffer_1.Buffer.concat([buffer, s2]);
    }
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2tr.js
var require_p2tr = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2tr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2tr = void 0;
    var buffer_1 = require_buffer();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var ecc_lib_1 = require_ecc_lib();
    var bip341_1 = require_bip341();
    var lazy = require_lazy();
    var bech32_1 = require_dist();
    var OPS = bscript.OPS;
    var TAPROOT_WITNESS_VERSION = 1;
    var ANNEX_PREFIX = 80;
    function p2tr(a2, opts) {
      if (!a2.address && !a2.output && !a2.pubkey && !a2.internalPubkey && !(a2.witness && a2.witness.length > 1))
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          signature: types_1.typeforce.maybe(
            types_1.typeforce.anyOf(
              types_1.typeforce.BufferN(64),
              types_1.typeforce.BufferN(65)
            )
          ),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          ),
          scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
          redeem: types_1.typeforce.maybe({
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number)
        },
        a2
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32m.decode(a2.address);
        const version2 = result.words.shift();
        const data = bech32_1.bech32m.fromWords(result.words);
        return {
          version: version2,
          prefix: result.prefix,
          data: buffer_1.Buffer.from(data)
        };
      });
      const _witness = lazy.value(() => {
        if (!a2.witness || !a2.witness.length) return;
        if (a2.witness.length >= 2 && a2.witness[a2.witness.length - 1][0] === ANNEX_PREFIX) {
          return a2.witness.slice(0, -1);
        }
        return a2.witness.slice();
      });
      const _hashTree = lazy.value(() => {
        if (a2.scriptTree) return (0, bip341_1.toHashTree)(a2.scriptTree);
        if (a2.hash) return { hash: a2.hash };
        return;
      });
      const network = a2.network || networks_1.bitcoin;
      const o2 = { name: "p2tr", network };
      lazy.prop(o2, "address", () => {
        if (!o2.pubkey) return;
        const words = bech32_1.bech32m.toWords(o2.pubkey);
        words.unshift(TAPROOT_WITNESS_VERSION);
        return bech32_1.bech32m.encode(network.bech32, words);
      });
      lazy.prop(o2, "hash", () => {
        const hashTree = _hashTree();
        if (hashTree) return hashTree.hash;
        const w3 = _witness();
        if (w3 && w3.length > 1) {
          const controlBlock = w3[w3.length - 1];
          const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
          const script = w3[w3.length - 2];
          const leafHash = (0, bip341_1.tapleafHash)({
            output: script,
            version: leafVersion
          });
          return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
        }
        return null;
      });
      lazy.prop(o2, "output", () => {
        if (!o2.pubkey) return;
        return bscript.compile([OPS.OP_1, o2.pubkey]);
      });
      lazy.prop(o2, "redeemVersion", () => {
        if (a2.redeemVersion) return a2.redeemVersion;
        if (a2.redeem && a2.redeem.redeemVersion !== void 0 && a2.redeem.redeemVersion !== null) {
          return a2.redeem.redeemVersion;
        }
        return bip341_1.LEAF_VERSION_TAPSCRIPT;
      });
      lazy.prop(o2, "redeem", () => {
        const witness = _witness();
        if (!witness || witness.length < 2) return;
        return {
          output: witness[witness.length - 2],
          witness: witness.slice(0, -2),
          redeemVersion: witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK
        };
      });
      lazy.prop(o2, "pubkey", () => {
        if (a2.pubkey) return a2.pubkey;
        if (a2.output) return a2.output.slice(2);
        if (a2.address) return _address().data;
        if (o2.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(o2.internalPubkey, o2.hash);
          if (tweakedKey) return tweakedKey.x;
        }
      });
      lazy.prop(o2, "internalPubkey", () => {
        if (a2.internalPubkey) return a2.internalPubkey;
        const witness = _witness();
        if (witness && witness.length > 1)
          return witness[witness.length - 1].slice(1, 33);
      });
      lazy.prop(o2, "signature", () => {
        if (a2.signature) return a2.signature;
        const witness = _witness();
        if (!witness || witness.length !== 1) return;
        return witness[0];
      });
      lazy.prop(o2, "witness", () => {
        if (a2.witness) return a2.witness;
        const hashTree = _hashTree();
        if (hashTree && a2.redeem && a2.redeem.output && a2.internalPubkey) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a2.redeem.output,
            version: o2.redeemVersion
          });
          const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
          if (!path) return;
          const outputKey = (0, bip341_1.tweakKey)(a2.internalPubkey, hashTree.hash);
          if (!outputKey) return;
          const controlBock = buffer_1.Buffer.concat(
            [
              buffer_1.Buffer.from([o2.redeemVersion | outputKey.parity]),
              a2.internalPubkey
            ].concat(path)
          );
          return [a2.redeem.output, controlBock];
        }
        if (a2.signature) return [a2.signature];
      });
      if (opts.validate) {
        let pubkey = buffer_1.Buffer.from([]);
        if (a2.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== TAPROOT_WITNESS_VERSION)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          pubkey = _address().data;
        }
        if (a2.pubkey) {
          if (pubkey.length > 0 && !pubkey.equals(a2.pubkey))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a2.pubkey;
        }
        if (a2.output) {
          if (a2.output.length !== 34 || a2.output[0] !== OPS.OP_1 || a2.output[1] !== 32)
            throw new TypeError("Output is invalid");
          if (pubkey.length > 0 && !pubkey.equals(a2.output.slice(2)))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a2.output.slice(2);
        }
        if (a2.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(a2.internalPubkey, o2.hash);
          if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
            throw new TypeError("Pubkey mismatch");
          else pubkey = tweakedKey.x;
        }
        if (pubkey && pubkey.length) {
          if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
            throw new TypeError("Invalid pubkey for p2tr");
        }
        const hashTree = _hashTree();
        if (a2.hash && hashTree) {
          if (!a2.hash.equals(hashTree.hash)) throw new TypeError("Hash mismatch");
        }
        if (a2.redeem && a2.redeem.output && hashTree) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a2.redeem.output,
            version: o2.redeemVersion
          });
          if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
            throw new TypeError("Redeem script not in tree");
        }
        const witness = _witness();
        if (a2.redeem && o2.redeem) {
          if (a2.redeem.redeemVersion) {
            if (a2.redeem.redeemVersion !== o2.redeem.redeemVersion)
              throw new TypeError("Redeem.redeemVersion and witness mismatch");
          }
          if (a2.redeem.output) {
            if (bscript.decompile(a2.redeem.output).length === 0)
              throw new TypeError("Redeem.output is invalid");
            if (o2.redeem.output && !a2.redeem.output.equals(o2.redeem.output))
              throw new TypeError("Redeem.output and witness mismatch");
          }
          if (a2.redeem.witness) {
            if (o2.redeem.witness && !stacksEqual(a2.redeem.witness, o2.redeem.witness))
              throw new TypeError("Redeem.witness and witness mismatch");
          }
        }
        if (witness && witness.length) {
          if (witness.length === 1) {
            if (a2.signature && !a2.signature.equals(witness[0]))
              throw new TypeError("Signature mismatch");
          } else {
            const controlBlock = witness[witness.length - 1];
            if (controlBlock.length < 33)
              throw new TypeError(
                `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
              );
            if ((controlBlock.length - 33) % 32 !== 0)
              throw new TypeError(
                `The control-block length of ${controlBlock.length} is incorrect!`
              );
            const m4 = (controlBlock.length - 33) / 32;
            if (m4 > 128)
              throw new TypeError(
                `The script path is too long. Got ${m4}, expected max 128.`
              );
            const internalPubkey = controlBlock.slice(1, 33);
            if (a2.internalPubkey && !a2.internalPubkey.equals(internalPubkey))
              throw new TypeError("Internal pubkey mismatch");
            if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
              throw new TypeError("Invalid internalPubkey for p2tr witness");
            const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
            const script = witness[witness.length - 2];
            const leafHash = (0, bip341_1.tapleafHash)({
              output: script,
              version: leafVersion
            });
            const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
            const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
            if (!outputKey)
              throw new TypeError("Invalid outputKey for p2tr witness");
            if (pubkey.length && !pubkey.equals(outputKey.x))
              throw new TypeError("Pubkey mismatch for p2tr witness");
            if (outputKey.parity !== (controlBlock[0] & 1))
              throw new Error("Incorrect parity");
          }
        }
      }
      return Object.assign(o2, a2);
    }
    exports.p2tr = p2tr;
    function stacksEqual(a2, b3) {
      if (a2.length !== b3.length) return false;
      return a2.every((x2, i2) => {
        return x2.equals(b3[i2]);
      });
    }
  }
});

// node_modules/bitcoinjs-lib/src/payments/index.js
var require_payments = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2tr = exports.p2wsh = exports.p2wpkh = exports.p2sh = exports.p2pkh = exports.p2pk = exports.p2ms = exports.embed = void 0;
    var embed_1 = require_embed();
    Object.defineProperty(exports, "embed", {
      enumerable: true,
      get: function() {
        return embed_1.p2data;
      }
    });
    var p2ms_1 = require_p2ms();
    Object.defineProperty(exports, "p2ms", {
      enumerable: true,
      get: function() {
        return p2ms_1.p2ms;
      }
    });
    var p2pk_1 = require_p2pk();
    Object.defineProperty(exports, "p2pk", {
      enumerable: true,
      get: function() {
        return p2pk_1.p2pk;
      }
    });
    var p2pkh_1 = require_p2pkh();
    Object.defineProperty(exports, "p2pkh", {
      enumerable: true,
      get: function() {
        return p2pkh_1.p2pkh;
      }
    });
    var p2sh_1 = require_p2sh();
    Object.defineProperty(exports, "p2sh", {
      enumerable: true,
      get: function() {
        return p2sh_1.p2sh;
      }
    });
    var p2wpkh_1 = require_p2wpkh();
    Object.defineProperty(exports, "p2wpkh", {
      enumerable: true,
      get: function() {
        return p2wpkh_1.p2wpkh;
      }
    });
    var p2wsh_1 = require_p2wsh();
    Object.defineProperty(exports, "p2wsh", {
      enumerable: true,
      get: function() {
        return p2wsh_1.p2wsh;
      }
    });
    var p2tr_1 = require_p2tr();
    Object.defineProperty(exports, "p2tr", {
      enumerable: true,
      get: function() {
        return p2tr_1.p2tr;
      }
    });
  }
});

// node_modules/bitcoinjs-lib/src/address.js
var require_address = __commonJS({
  "node_modules/bitcoinjs-lib/src/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toOutputScript = exports.fromOutputScript = exports.toBech32 = exports.toBase58Check = exports.fromBech32 = exports.fromBase58Check = void 0;
    var networks2 = require_networks();
    var payments2 = require_payments();
    var bscript = require_script();
    var types_1 = require_types();
    var bech32_1 = require_dist();
    var bs58check = require_bs58check();
    var FUTURE_SEGWIT_MAX_SIZE = 40;
    var FUTURE_SEGWIT_MIN_SIZE = 2;
    var FUTURE_SEGWIT_MAX_VERSION = 16;
    var FUTURE_SEGWIT_MIN_VERSION = 2;
    var FUTURE_SEGWIT_VERSION_DIFF = 80;
    var FUTURE_SEGWIT_VERSION_WARNING = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
    function _toFutureSegwitAddress(output, network) {
      const data = output.slice(2);
      if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE)
        throw new TypeError("Invalid program length for segwit address");
      const version2 = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
      if (version2 < FUTURE_SEGWIT_MIN_VERSION || version2 > FUTURE_SEGWIT_MAX_VERSION)
        throw new TypeError("Invalid version for segwit address");
      if (output[1] !== data.length)
        throw new TypeError("Invalid script for segwit address");
      console.warn(FUTURE_SEGWIT_VERSION_WARNING);
      return toBech32(data, version2, network.bech32);
    }
    function fromBase58Check(address2) {
      const payload = Buffer.from(bs58check.decode(address2));
      if (payload.length < 21) throw new TypeError(address2 + " is too short");
      if (payload.length > 21) throw new TypeError(address2 + " is too long");
      const version2 = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version: version2, hash };
    }
    exports.fromBase58Check = fromBase58Check;
    function fromBech32(address2) {
      let result;
      let version2;
      try {
        result = bech32_1.bech32.decode(address2);
      } catch (e2) {
      }
      if (result) {
        version2 = result.words[0];
        if (version2 !== 0) throw new TypeError(address2 + " uses wrong encoding");
      } else {
        result = bech32_1.bech32m.decode(address2);
        version2 = result.words[0];
        if (version2 === 0) throw new TypeError(address2 + " uses wrong encoding");
      }
      const data = bech32_1.bech32.fromWords(result.words.slice(1));
      return {
        version: version2,
        prefix: result.prefix,
        data: Buffer.from(data)
      };
    }
    exports.fromBech32 = fromBech32;
    function toBase58Check(hash, version2) {
      (0, types_1.typeforce)(
        (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
        arguments
      );
      const payload = Buffer.allocUnsafe(21);
      payload.writeUInt8(version2, 0);
      hash.copy(payload, 1);
      return bs58check.encode(payload);
    }
    exports.toBase58Check = toBase58Check;
    function toBech32(data, version2, prefix) {
      const words = bech32_1.bech32.toWords(data);
      words.unshift(version2);
      return version2 === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);
    }
    exports.toBech32 = toBech32;
    function fromOutputScript(output, network) {
      network = network || networks2.bitcoin;
      try {
        return payments2.p2pkh({ output, network }).address;
      } catch (e2) {
      }
      try {
        return payments2.p2sh({ output, network }).address;
      } catch (e2) {
      }
      try {
        return payments2.p2wpkh({ output, network }).address;
      } catch (e2) {
      }
      try {
        return payments2.p2wsh({ output, network }).address;
      } catch (e2) {
      }
      try {
        return payments2.p2tr({ output, network }).address;
      } catch (e2) {
      }
      try {
        return _toFutureSegwitAddress(output, network);
      } catch (e2) {
      }
      throw new Error(bscript.toASM(output) + " has no matching Address");
    }
    exports.fromOutputScript = fromOutputScript;
    function toOutputScript(address2, network) {
      network = network || networks2.bitcoin;
      let decodeBase58;
      let decodeBech32;
      try {
        decodeBase58 = fromBase58Check(address2);
      } catch (e2) {
      }
      if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash)
          return payments2.p2pkh({ hash: decodeBase58.hash }).output;
        if (decodeBase58.version === network.scriptHash)
          return payments2.p2sh({ hash: decodeBase58.hash }).output;
      } else {
        try {
          decodeBech32 = fromBech32(address2);
        } catch (e2) {
        }
        if (decodeBech32) {
          if (decodeBech32.prefix !== network.bech32)
            throw new Error(address2 + " has an invalid prefix");
          if (decodeBech32.version === 0) {
            if (decodeBech32.data.length === 20)
              return payments2.p2wpkh({ hash: decodeBech32.data }).output;
            if (decodeBech32.data.length === 32)
              return payments2.p2wsh({ hash: decodeBech32.data }).output;
          } else if (decodeBech32.version === 1) {
            if (decodeBech32.data.length === 32)
              return payments2.p2tr({ pubkey: decodeBech32.data }).output;
          } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
            console.warn(FUTURE_SEGWIT_VERSION_WARNING);
            return bscript.compile([
              decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
              decodeBech32.data
            ]);
          }
        }
      }
      throw new Error(address2 + " has no matching Script");
    }
    exports.toOutputScript = toOutputScript;
  }
});

// node_modules/bitcoinjs-lib/src/merkle.js
var require_merkle = __commonJS({
  "node_modules/bitcoinjs-lib/src/merkle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fastMerkleRoot = void 0;
    function fastMerkleRoot(values, digestFn) {
      if (!Array.isArray(values)) throw TypeError("Expected values Array");
      if (typeof digestFn !== "function")
        throw TypeError("Expected digest Function");
      let length = values.length;
      const results = values.concat();
      while (length > 1) {
        let j2 = 0;
        for (let i2 = 0; i2 < length; i2 += 2, ++j2) {
          const left = results[i2];
          const right = i2 + 1 === length ? left : results[i2 + 1];
          const data = Buffer.concat([left, right]);
          results[j2] = digestFn(data);
        }
        length = j2;
      }
      return results[0];
    }
    exports.fastMerkleRoot = fastMerkleRoot;
  }
});

// node_modules/bitcoinjs-lib/src/transaction.js
var require_transaction = __commonJS({
  "node_modules/bitcoinjs-lib/src/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto2();
    var bscript = require_script();
    var script_1 = require_script();
    var types = require_types();
    var { typeforce } = types;
    function varSliceSize(someScript) {
      const length = someScript.length;
      return bufferutils_1.varuint.encodingLength(length) + length;
    }
    function vectorSize(someVector) {
      const length = someVector.length;
      return bufferutils_1.varuint.encodingLength(length) + someVector.reduce((sum, witness) => {
        return sum + varSliceSize(witness);
      }, 0);
    }
    var EMPTY_BUFFER = Buffer.allocUnsafe(0);
    var EMPTY_WITNESS = [];
    var ZERO = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000000",
      "hex"
    );
    var ONE = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000001",
      "hex"
    );
    var VALUE_UINT64_MAX = Buffer.from("ffffffffffffffff", "hex");
    var BLANK_OUTPUT = {
      script: EMPTY_BUFFER,
      valueBuffer: VALUE_UINT64_MAX
    };
    function isOutput(out) {
      return out.value !== void 0;
    }
    var Transaction4 = class _Transaction {
      constructor() {
        this.version = 1;
        this.locktime = 0;
        this.ins = [];
        this.outs = [];
      }
      static fromBuffer(buffer, _NO_STRICT) {
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const tx = new _Transaction();
        tx.version = bufferReader.readInt32();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === _Transaction.ADVANCED_TRANSACTION_MARKER && flag === _Transaction.ADVANCED_TRANSACTION_FLAG) {
          hasWitnesses = true;
        } else {
          bufferReader.offset -= 2;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i2 = 0; i2 < vinLen; ++i2) {
          tx.ins.push({
            hash: bufferReader.readSlice(32),
            index: bufferReader.readUInt32(),
            script: bufferReader.readVarSlice(),
            sequence: bufferReader.readUInt32(),
            witness: EMPTY_WITNESS
          });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i2 = 0; i2 < voutLen; ++i2) {
          tx.outs.push({
            value: bufferReader.readUInt64(),
            script: bufferReader.readVarSlice()
          });
        }
        if (hasWitnesses) {
          for (let i2 = 0; i2 < vinLen; ++i2) {
            tx.ins[i2].witness = bufferReader.readVector();
          }
          if (!tx.hasWitnesses())
            throw new Error("Transaction has superfluous witness data");
        }
        tx.locktime = bufferReader.readUInt32();
        if (_NO_STRICT) return tx;
        if (bufferReader.offset !== buffer.length)
          throw new Error("Transaction has unexpected data");
        return tx;
      }
      static fromHex(hex) {
        return _Transaction.fromBuffer(Buffer.from(hex, "hex"), false);
      }
      static isCoinbaseHash(buffer) {
        typeforce(types.Hash256bit, buffer);
        for (let i2 = 0; i2 < 32; ++i2) {
          if (buffer[i2] !== 0) return false;
        }
        return true;
      }
      isCoinbase() {
        return this.ins.length === 1 && _Transaction.isCoinbaseHash(this.ins[0].hash);
      }
      addInput(hash, index, sequence, scriptSig) {
        typeforce(
          types.tuple(
            types.Hash256bit,
            types.UInt32,
            types.maybe(types.UInt32),
            types.maybe(types.Buffer)
          ),
          arguments
        );
        if (types.Null(sequence)) {
          sequence = _Transaction.DEFAULT_SEQUENCE;
        }
        return this.ins.push({
          hash,
          index,
          script: scriptSig || EMPTY_BUFFER,
          sequence,
          witness: EMPTY_WITNESS
        }) - 1;
      }
      addOutput(scriptPubKey, value) {
        typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
        return this.outs.push({
          script: scriptPubKey,
          value
        }) - 1;
      }
      hasWitnesses() {
        return this.ins.some((x2) => {
          return x2.witness.length !== 0;
        });
      }
      weight() {
        const base = this.byteLength(false);
        const total = this.byteLength(true);
        return base * 3 + total;
      }
      virtualSize() {
        return Math.ceil(this.weight() / 4);
      }
      byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return (hasWitnesses ? 10 : 8) + bufferutils_1.varuint.encodingLength(this.ins.length) + bufferutils_1.varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {
          return sum + 40 + varSliceSize(input.script);
        }, 0) + this.outs.reduce((sum, output) => {
          return sum + 8 + varSliceSize(output.script);
        }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {
          return sum + vectorSize(input.witness);
        }, 0) : 0);
      }
      clone() {
        const newTx = new _Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn) => {
          return {
            hash: txIn.hash,
            index: txIn.index,
            script: txIn.script,
            sequence: txIn.sequence,
            witness: txIn.witness
          };
        });
        newTx.outs = this.outs.map((txOut) => {
          return {
            script: txOut.script,
            value: txOut.value
          };
        });
        return newTx;
      }
      /**
       * Hash transaction for signing a specific input.
       *
       * Bitcoin uses a different hash for each signed transaction input.
       * This method copies the transaction, makes the necessary changes based on the
       * hashType, and then hashes the result.
       * This hash can then be used to sign the provided transaction input.
       */
      hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(
          types.tuple(
            types.UInt32,
            types.Buffer,
            /* types.UInt8 */
            types.Number
          ),
          arguments
        );
        if (inIndex >= this.ins.length) return ONE;
        const ourScript = bscript.compile(
          bscript.decompile(prevOutScript).filter((x2) => {
            return x2 !== script_1.OPS.OP_CODESEPARATOR;
          })
        );
        const txTmp = this.clone();
        if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
          txTmp.outs = [];
          txTmp.ins.forEach((input, i2) => {
            if (i2 === inIndex) return;
            input.sequence = 0;
          });
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
          if (inIndex >= this.outs.length) return ONE;
          txTmp.outs.length = inIndex + 1;
          for (let i2 = 0; i2 < inIndex; i2++) {
            txTmp.outs[i2] = BLANK_OUTPUT;
          }
          txTmp.ins.forEach((input, y2) => {
            if (y2 === inIndex) return;
            input.sequence = 0;
          });
        }
        if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
          txTmp.ins = [txTmp.ins[inIndex]];
          txTmp.ins[0].script = ourScript;
        } else {
          txTmp.ins.forEach((input) => {
            input.script = EMPTY_BUFFER;
          });
          txTmp.ins[inIndex].script = ourScript;
        }
        const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
        buffer.writeInt32LE(hashType, buffer.length - 4);
        txTmp.__toBuffer(buffer, 0, false);
        return bcrypto.hash256(buffer);
      }
      hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
        typeforce(
          types.tuple(
            types.UInt32,
            typeforce.arrayOf(types.Buffer),
            typeforce.arrayOf(types.Satoshi),
            types.UInt32
          ),
          arguments
        );
        if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
          throw new Error("Must supply prevout script and value for all inputs");
        }
        const outputType = hashType === _Transaction.SIGHASH_DEFAULT ? _Transaction.SIGHASH_ALL : hashType & _Transaction.SIGHASH_OUTPUT_MASK;
        const inputType = hashType & _Transaction.SIGHASH_INPUT_MASK;
        const isAnyoneCanPay = inputType === _Transaction.SIGHASH_ANYONECANPAY;
        const isNone = outputType === _Transaction.SIGHASH_NONE;
        const isSingle = outputType === _Transaction.SIGHASH_SINGLE;
        let hashPrevouts = EMPTY_BUFFER;
        let hashAmounts = EMPTY_BUFFER;
        let hashScriptPubKeys = EMPTY_BUFFER;
        let hashSequences = EMPTY_BUFFER;
        let hashOutputs = EMPTY_BUFFER;
        if (!isAnyoneCanPay) {
          let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            36 * this.ins.length
          );
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 * this.ins.length
          );
          values.forEach((value) => bufferWriter.writeUInt64(value));
          hashAmounts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            prevOutScripts.map(varSliceSize).reduce((a2, b3) => a2 + b3)
          );
          prevOutScripts.forEach(
            (prevOutScript) => bufferWriter.writeVarSlice(prevOutScript)
          );
          hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            4 * this.ins.length
          );
          this.ins.forEach((txIn) => bufferWriter.writeUInt32(txIn.sequence));
          hashSequences = bcrypto.sha256(bufferWriter.end());
        }
        if (!(isNone || isSingle)) {
          const txOutsSize = this.outs.map((output) => 8 + varSliceSize(output.script)).reduce((a2, b3) => a2 + b3);
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        } else if (isSingle && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 + varSliceSize(output.script)
          );
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        }
        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
        const sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
        const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
        sigMsgWriter.writeUInt8(hashType);
        sigMsgWriter.writeInt32(this.version);
        sigMsgWriter.writeUInt32(this.locktime);
        sigMsgWriter.writeSlice(hashPrevouts);
        sigMsgWriter.writeSlice(hashAmounts);
        sigMsgWriter.writeSlice(hashScriptPubKeys);
        sigMsgWriter.writeSlice(hashSequences);
        if (!(isNone || isSingle)) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        sigMsgWriter.writeUInt8(spendType);
        if (isAnyoneCanPay) {
          const input = this.ins[inIndex];
          sigMsgWriter.writeSlice(input.hash);
          sigMsgWriter.writeUInt32(input.index);
          sigMsgWriter.writeUInt64(values[inIndex]);
          sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
          sigMsgWriter.writeUInt32(input.sequence);
        } else {
          sigMsgWriter.writeUInt32(inIndex);
        }
        if (annex) {
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            varSliceSize(annex)
          );
          bufferWriter.writeVarSlice(annex);
          sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
        }
        if (isSingle) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        if (leafHash) {
          sigMsgWriter.writeSlice(leafHash);
          sigMsgWriter.writeUInt8(0);
          sigMsgWriter.writeUInt32(4294967295);
        }
        return bcrypto.taggedHash(
          "TapSighash",
          Buffer.concat([Buffer.from([0]), sigMsgWriter.end()])
        );
      }
      hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
        typeforce(
          types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
          arguments
        );
        let tbuffer = Buffer.from([]);
        let bufferWriter;
        let hashOutputs = ZERO;
        let hashPrevouts = ZERO;
        let hashSequence = ZERO;
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
          tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.hash256(tbuffer);
        }
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeUInt32(txIn.sequence);
          });
          hashSequence = bcrypto.hash256(tbuffer);
        }
        if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          const txOutsSize = this.outs.reduce((sum, output) => {
            return sum + 8 + varSliceSize(output.script);
          }, 0);
          tbuffer = Buffer.allocUnsafe(txOutsSize);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.hash256(tbuffer);
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.hash256(tbuffer);
        }
        tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(hashPrevouts);
        bufferWriter.writeSlice(hashSequence);
        bufferWriter.writeSlice(input.hash);
        bufferWriter.writeUInt32(input.index);
        bufferWriter.writeVarSlice(prevOutScript);
        bufferWriter.writeUInt64(value);
        bufferWriter.writeUInt32(input.sequence);
        bufferWriter.writeSlice(hashOutputs);
        bufferWriter.writeUInt32(this.locktime);
        bufferWriter.writeUInt32(hashType);
        return bcrypto.hash256(tbuffer);
      }
      getHash(forWitness) {
        if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
        return bcrypto.hash256(this.__toBuffer(void 0, void 0, forWitness));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
          "hex"
        );
      }
      toBuffer(buffer, initialOffset) {
        return this.__toBuffer(buffer, initialOffset, true);
      }
      toHex() {
        return this.toBuffer(void 0, void 0).toString("hex");
      }
      setInputScript(index, scriptSig) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.ins[index].script = scriptSig;
      }
      setWitness(index, witness) {
        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
        this.ins[index].witness = witness;
      }
      __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new bufferutils_1.BufferWriter(
          buffer,
          initialOffset || 0
        );
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_MARKER);
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
          bufferWriter.writeVarSlice(txIn.script);
          bufferWriter.writeUInt32(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
          if (isOutput(txOut)) {
            bufferWriter.writeUInt64(txOut.value);
          } else {
            bufferWriter.writeSlice(txOut.valueBuffer);
          }
          bufferWriter.writeVarSlice(txOut.script);
        });
        if (hasWitnesses) {
          this.ins.forEach((input) => {
            bufferWriter.writeVector(input.witness);
          });
        }
        bufferWriter.writeUInt32(this.locktime);
        if (initialOffset !== void 0)
          return buffer.slice(initialOffset, bufferWriter.offset);
        return buffer;
      }
    };
    exports.Transaction = Transaction4;
    Transaction4.DEFAULT_SEQUENCE = 4294967295;
    Transaction4.SIGHASH_DEFAULT = 0;
    Transaction4.SIGHASH_ALL = 1;
    Transaction4.SIGHASH_NONE = 2;
    Transaction4.SIGHASH_SINGLE = 3;
    Transaction4.SIGHASH_ANYONECANPAY = 128;
    Transaction4.SIGHASH_OUTPUT_MASK = 3;
    Transaction4.SIGHASH_INPUT_MASK = 128;
    Transaction4.ADVANCED_TRANSACTION_MARKER = 0;
    Transaction4.ADVANCED_TRANSACTION_FLAG = 1;
  }
});

// node_modules/bitcoinjs-lib/src/block.js
var require_block = __commonJS({
  "node_modules/bitcoinjs-lib/src/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Block = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto2();
    var merkle_1 = require_merkle();
    var transaction_1 = require_transaction();
    var types = require_types();
    var { typeforce } = types;
    var errorMerkleNoTxes = new TypeError(
      "Cannot compute merkle root for zero transactions"
    );
    var errorWitnessNotSegwit = new TypeError(
      "Cannot compute witness commit for non-segwit block"
    );
    var Block = class _Block {
      constructor() {
        this.version = 1;
        this.prevHash = void 0;
        this.merkleRoot = void 0;
        this.timestamp = 0;
        this.witnessCommit = void 0;
        this.bits = 0;
        this.nonce = 0;
        this.transactions = void 0;
      }
      static fromBuffer(buffer) {
        if (buffer.length < 80) throw new Error("Buffer too small (< 80 bytes)");
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const block = new _Block();
        block.version = bufferReader.readInt32();
        block.prevHash = bufferReader.readSlice(32);
        block.merkleRoot = bufferReader.readSlice(32);
        block.timestamp = bufferReader.readUInt32();
        block.bits = bufferReader.readUInt32();
        block.nonce = bufferReader.readUInt32();
        if (buffer.length === 80) return block;
        const readTransaction = () => {
          const tx = transaction_1.Transaction.fromBuffer(
            bufferReader.buffer.slice(bufferReader.offset),
            true
          );
          bufferReader.offset += tx.byteLength();
          return tx;
        };
        const nTransactions = bufferReader.readVarInt();
        block.transactions = [];
        for (let i2 = 0; i2 < nTransactions; ++i2) {
          const tx = readTransaction();
          block.transactions.push(tx);
        }
        const witnessCommit = block.getWitnessCommit();
        if (witnessCommit) block.witnessCommit = witnessCommit;
        return block;
      }
      static fromHex(hex) {
        return _Block.fromBuffer(Buffer.from(hex, "hex"));
      }
      static calculateTarget(bits) {
        const exponent = ((bits & 4278190080) >> 24) - 3;
        const mantissa = bits & 8388607;
        const target = Buffer.alloc(32, 0);
        target.writeUIntBE(mantissa, 29 - exponent, 3);
        return target;
      }
      static calculateMerkleRoot(transactions, forWitness) {
        typeforce([{ getHash: types.Function }], transactions);
        if (transactions.length === 0) throw errorMerkleNoTxes;
        if (forWitness && !txesHaveWitnessCommit(transactions))
          throw errorWitnessNotSegwit;
        const hashes = transactions.map(
          (transaction) => transaction.getHash(forWitness)
        );
        const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);
        return forWitness ? bcrypto.hash256(
          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])
        ) : rootHash;
      }
      getWitnessCommit() {
        if (!txesHaveWitnessCommit(this.transactions)) return null;
        const witnessCommits = this.transactions[0].outs.filter(
          (out) => out.script.slice(0, 6).equals(Buffer.from("6a24aa21a9ed", "hex"))
        ).map((out) => out.script.slice(6, 38));
        if (witnessCommits.length === 0) return null;
        const result = witnessCommits[witnessCommits.length - 1];
        if (!(result instanceof Buffer && result.length === 32)) return null;
        return result;
      }
      hasWitnessCommit() {
        if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32)
          return true;
        if (this.getWitnessCommit() !== null) return true;
        return false;
      }
      hasWitness() {
        return anyTxHasWitness(this.transactions);
      }
      weight() {
        const base = this.byteLength(false, false);
        const total = this.byteLength(false, true);
        return base * 3 + total;
      }
      byteLength(headersOnly, allowWitness = true) {
        if (headersOnly || !this.transactions) return 80;
        return 80 + bufferutils_1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a2, x2) => a2 + x2.byteLength(allowWitness), 0);
      }
      getHash() {
        return bcrypto.hash256(this.toBuffer(true));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString("hex");
      }
      getUTCDate() {
        const date = /* @__PURE__ */ new Date(0);
        date.setUTCSeconds(this.timestamp);
        return date;
      }
      // TODO: buffer, offset compatibility
      toBuffer(headersOnly) {
        const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
        const bufferWriter = new bufferutils_1.BufferWriter(buffer);
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(this.prevHash);
        bufferWriter.writeSlice(this.merkleRoot);
        bufferWriter.writeUInt32(this.timestamp);
        bufferWriter.writeUInt32(this.bits);
        bufferWriter.writeUInt32(this.nonce);
        if (headersOnly || !this.transactions) return buffer;
        bufferutils_1.varuint.encode(
          this.transactions.length,
          buffer,
          bufferWriter.offset
        );
        bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
        this.transactions.forEach((tx) => {
          const txSize = tx.byteLength();
          tx.toBuffer(buffer, bufferWriter.offset);
          bufferWriter.offset += txSize;
        });
        return buffer;
      }
      toHex(headersOnly) {
        return this.toBuffer(headersOnly).toString("hex");
      }
      checkTxRoots() {
        const hasWitnessCommit = this.hasWitnessCommit();
        if (!hasWitnessCommit && this.hasWitness()) return false;
        return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
      }
      checkProofOfWork() {
        const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
        const target = _Block.calculateTarget(this.bits);
        return hash.compare(target) <= 0;
      }
      __checkMerkleRoot() {
        if (!this.transactions) throw errorMerkleNoTxes;
        const actualMerkleRoot = _Block.calculateMerkleRoot(this.transactions);
        return this.merkleRoot.compare(actualMerkleRoot) === 0;
      }
      __checkWitnessCommit() {
        if (!this.transactions) throw errorMerkleNoTxes;
        if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
        const actualWitnessCommit = _Block.calculateMerkleRoot(
          this.transactions,
          true
        );
        return this.witnessCommit.compare(actualWitnessCommit) === 0;
      }
    };
    exports.Block = Block;
    function txesHaveWitnessCommit(transactions) {
      return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
    }
    function anyTxHasWitness(transactions) {
      return transactions instanceof Array && transactions.some(
        (tx) => typeof tx === "object" && tx.ins instanceof Array && tx.ins.some(
          (input) => typeof input === "object" && input.witness instanceof Array && input.witness.length > 0
        )
      );
    }
  }
});

// node_modules/bip174/src/lib/typeFields.js
var require_typeFields = __commonJS({
  "node_modules/bip174/src/lib/typeFields.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GlobalTypes;
    (function(GlobalTypes2) {
      GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
      GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
    })(GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {}));
    exports.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"];
    var InputTypes;
    (function(InputTypes2) {
      InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
      InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
      InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
      InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
      InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
      InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
      InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
      InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
      InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
      InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
      InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
      InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
      InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
      InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
      InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
      InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
    })(InputTypes = exports.InputTypes || (exports.InputTypes = {}));
    exports.INPUT_TYPE_NAMES = [
      "nonWitnessUtxo",
      "witnessUtxo",
      "partialSig",
      "sighashType",
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "finalScriptSig",
      "finalScriptWitness",
      "porCommitment",
      "tapKeySig",
      "tapScriptSig",
      "tapLeafScript",
      "tapBip32Derivation",
      "tapInternalKey",
      "tapMerkleRoot"
    ];
    var OutputTypes;
    (function(OutputTypes2) {
      OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
      OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
      OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
      OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
      OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
      OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
    })(OutputTypes = exports.OutputTypes || (exports.OutputTypes = {}));
    exports.OUTPUT_TYPE_NAMES = [
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "tapInternalKey",
      "tapTree",
      "tapBip32Derivation"
    ];
  }
});

// node_modules/bip174/src/lib/converter/global/globalXpub.js
var require_globalXpub = __commonJS({
  "node_modules/bip174/src/lib/converter/global/globalXpub.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var range = (n2) => [...Array(n2).keys()];
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
        throw new Error(
          "Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
        throw new Error(
          "Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length / 4 % 1 !== 0) {
        throw new Error(
          "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
        );
      }
      const extendedPubkey = keyVal.key.slice(1);
      const data = {
        masterFingerprint: keyVal.value.slice(0, 4),
        extendedPubkey,
        path: "m"
      };
      for (const i2 of range(keyVal.value.length / 4 - 1)) {
        const val = keyVal.value.readUInt32LE(i2 * 4 + 4);
        const isHard = !!(val & 2147483648);
        const idx = val & 2147483647;
        data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
      }
      return data;
    }
    exports.decode = decode;
    function encode3(data) {
      const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
      const key = Buffer.concat([head, data.extendedPubkey]);
      const splitPath = data.path.split("/");
      const value = Buffer.allocUnsafe(splitPath.length * 4);
      data.masterFingerprint.copy(value, 0);
      let offset = 4;
      splitPath.slice(1).forEach((level) => {
        const isHard = level.slice(-1) === "'";
        let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
        if (isHard) num += 2147483648;
        value.writeUInt32LE(num, offset);
        offset += 4;
      });
      return {
        key,
        value
      };
    }
    exports.encode = encode3;
    exports.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
    function check2(data) {
      const epk = data.extendedPubkey;
      const mfp = data.masterFingerprint;
      const p2 = data.path;
      return Buffer.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && Buffer.isBuffer(mfp) && mfp.length === 4 && typeof p2 === "string" && !!p2.match(/^m(\/\d+'?)*$/);
    }
    exports.check = check2;
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.extendedPubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v2) => v2.extendedPubkey.equals(item.extendedPubkey)).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/global/unsignedTx.js
var require_unsignedTx = __commonJS({
  "node_modules/bip174/src/lib/converter/global/unsignedTx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function encode3(data) {
      return {
        key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
        value: data.toBuffer()
      };
    }
    exports.encode = encode3;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptSig.js
var require_finalScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptSig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
        throw new Error(
          "Decode Error: could not decode finalScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode3(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
      return {
        key,
        value: data
      };
    }
    exports.encode = encode3;
    exports.expected = "Buffer";
    function check2(data) {
      return Buffer.isBuffer(data);
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptSig === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptWitness.js
var require_finalScriptWitness = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptWitness.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
        throw new Error(
          "Decode Error: could not decode finalScriptWitness with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode3(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
      return {
        key,
        value: data
      };
    }
    exports.encode = encode3;
    exports.expected = "Buffer";
    function check2(data) {
      return Buffer.isBuffer(data);
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js
var require_nonWitnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode nonWitnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode3(data) {
      return {
        key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
        value: data
      };
    }
    exports.encode = encode3;
    exports.expected = "Buffer";
    function check2(data) {
      return Buffer.isBuffer(data);
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/partialSig.js
var require_partialSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/partialSig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
        throw new Error(
          "Decode Error: could not decode partialSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
        throw new Error(
          "Decode Error: partialSig has invalid pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1);
      return {
        pubkey,
        signature: keyVal.value
      };
    }
    exports.decode = decode;
    function encode3(pSig) {
      const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
      return {
        key: Buffer.concat([head, pSig.pubkey]),
        value: pSig.signature
      };
    }
    exports.encode = encode3;
    exports.expected = "{ pubkey: Buffer; signature: Buffer; }";
    function check2(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.signature) && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
    }
    exports.check = check2;
    function isDerSigWithSighash(buf) {
      if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
      if (buf[0] !== 48) return false;
      if (buf.length !== buf[1] + 3) return false;
      if (buf[2] !== 2) return false;
      const rLen = buf[3];
      if (rLen > 33 || rLen < 1) return false;
      if (buf[3 + rLen + 1] !== 2) return false;
      const sLen = buf[3 + rLen + 2];
      if (sLen > 33 || sLen < 1) return false;
      if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
      return true;
    }
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v2) => v2.pubkey.equals(item.pubkey)).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/porCommitment.js
var require_porCommitment = __commonJS({
  "node_modules/bip174/src/lib/converter/input/porCommitment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
        throw new Error(
          "Decode Error: could not decode porCommitment with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.toString("utf8");
    }
    exports.decode = decode;
    function encode3(data) {
      const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
      return {
        key,
        value: Buffer.from(data, "utf8")
      };
    }
    exports.encode = encode3;
    exports.expected = "string";
    function check2(data) {
      return typeof data === "string";
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.porCommitment === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/sighashType.js
var require_sighashType = __commonJS({
  "node_modules/bip174/src/lib/converter/input/sighashType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
        throw new Error(
          "Decode Error: could not decode sighashType with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.readUInt32LE(0);
    }
    exports.decode = decode;
    function encode3(data) {
      const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
      const value = Buffer.allocUnsafe(4);
      value.writeUInt32LE(data, 0);
      return {
        key,
        value
      };
    }
    exports.encode = encode3;
    exports.expected = "number";
    function check2(data) {
      return typeof data === "number";
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.sighashType === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapKeySig.js
var require_tapKeySig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapKeySig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapKeySig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check2(keyVal.value)) {
        throw new Error(
          "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode3(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
      return { key, value };
    }
    exports.encode = encode3;
    exports.expected = "Buffer";
    function check2(data) {
      return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapKeySig === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapLeafScript.js
var require_tapLeafScript = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapLeafScript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
        throw new Error(
          "Decode Error: could not decode tapLeafScript with key 0x" + keyVal.key.toString("hex")
        );
      }
      if ((keyVal.key.length - 2) % 32 !== 0) {
        throw new Error(
          "Decode Error: tapLeafScript has invalid control block in key 0x" + keyVal.key.toString("hex")
        );
      }
      const leafVersion = keyVal.value[keyVal.value.length - 1];
      if ((keyVal.key[1] & 254) !== leafVersion) {
        throw new Error(
          "Decode Error: tapLeafScript bad leaf version in key 0x" + keyVal.key.toString("hex")
        );
      }
      const script = keyVal.value.slice(0, -1);
      const controlBlock = keyVal.key.slice(1);
      return { controlBlock, script, leafVersion };
    }
    exports.decode = decode;
    function encode3(tScript) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
      const verBuf = Buffer.from([tScript.leafVersion]);
      return {
        key: Buffer.concat([head, tScript.controlBlock]),
        value: Buffer.concat([tScript.script, verBuf])
      };
    }
    exports.encode = encode3;
    exports.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
    function check2(data) {
      return Buffer.isBuffer(data.controlBlock) && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && Buffer.isBuffer(data.script);
    }
    exports.check = check2;
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.controlBlock.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v2) => v2.controlBlock.equals(item.controlBlock)).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js
var require_tapMerkleRoot = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapMerkleRoot with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check2(keyVal.value)) {
        throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode3(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
      return { key, value };
    }
    exports.encode = encode3;
    exports.expected = "Buffer";
    function check2(data) {
      return Buffer.isBuffer(data) && data.length === 32;
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapScriptSig.js
var require_tapScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapScriptSig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
        throw new Error(
          "Decode Error: could not decode tapScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid signature in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1, 33);
      const leafHash = keyVal.key.slice(33);
      return {
        pubkey,
        leafHash,
        signature: keyVal.value
      };
    }
    exports.decode = decode;
    function encode3(tSig) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
      return {
        key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
        value: tSig.signature
      };
    }
    exports.encode = encode3;
    exports.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
    function check2(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.leafHash) && Buffer.isBuffer(data.signature) && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
    }
    exports.check = check2;
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex") + item.leafHash.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter(
        (v2) => v2.pubkey.equals(item.pubkey) && v2.leafHash.equals(item.leafHash)
      ).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/varint.js
var require_varint = __commonJS({
  "node_modules/bip174/src/lib/converter/varint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n2) {
      if (n2 < 0 || n2 > MAX_SAFE_INTEGER || n2 % 1 !== 0)
        throw new RangeError("value out of range");
    }
    function encode3(_number, buffer, offset) {
      checkUInt53(_number);
      if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (_number < 253) {
        buffer.writeUInt8(_number, offset);
        Object.assign(encode3, { bytes: 1 });
      } else if (_number <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(_number, offset + 1);
        Object.assign(encode3, { bytes: 3 });
      } else if (_number <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(_number, offset + 1);
        Object.assign(encode3, { bytes: 5 });
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(_number >>> 0, offset + 1);
        buffer.writeUInt32LE(_number / 4294967296 | 0, offset + 5);
        Object.assign(encode3, { bytes: 9 });
      }
      return buffer;
    }
    exports.encode = encode3;
    function decode(buffer, offset) {
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      const first = buffer.readUInt8(offset);
      if (first < 253) {
        Object.assign(decode, { bytes: 1 });
        return first;
      } else if (first === 253) {
        Object.assign(decode, { bytes: 3 });
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        Object.assign(decode, { bytes: 5 });
        return buffer.readUInt32LE(offset + 1);
      } else {
        Object.assign(decode, { bytes: 9 });
        const lo = buffer.readUInt32LE(offset + 1);
        const hi = buffer.readUInt32LE(offset + 5);
        const _number = hi * 4294967296 + lo;
        checkUInt53(_number);
        return _number;
      }
    }
    exports.decode = decode;
    function encodingLength(_number) {
      checkUInt53(_number);
      return _number < 253 ? 1 : _number <= 65535 ? 3 : _number <= 4294967295 ? 5 : 9;
    }
    exports.encodingLength = encodingLength;
  }
});

// node_modules/bip174/src/lib/converter/tools.js
var require_tools = __commonJS({
  "node_modules/bip174/src/lib/converter/tools.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var varuint = require_varint();
    exports.range = (n2) => [...Array(n2).keys()];
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j2 = buffer.length - 1;
      let tmp = 0;
      for (let i2 = 0; i2 < buffer.length / 2; i2++) {
        tmp = buffer[i2];
        buffer[i2] = buffer[j2];
        buffer[j2] = tmp;
        j2--;
      }
      return buffer;
    }
    exports.reverseBuffer = reverseBuffer;
    function keyValsToBuffer(keyVals) {
      const buffers = keyVals.map(keyValToBuffer);
      buffers.push(Buffer.from([0]));
      return Buffer.concat(buffers);
    }
    exports.keyValsToBuffer = keyValsToBuffer;
    function keyValToBuffer(keyVal) {
      const keyLen = keyVal.key.length;
      const valLen = keyVal.value.length;
      const keyVarIntLen = varuint.encodingLength(keyLen);
      const valVarIntLen = varuint.encodingLength(valLen);
      const buffer = Buffer.allocUnsafe(
        keyVarIntLen + keyLen + valVarIntLen + valLen
      );
      varuint.encode(keyLen, buffer, 0);
      keyVal.key.copy(buffer, keyVarIntLen);
      varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
      keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
      return buffer;
    }
    exports.keyValToBuffer = keyValToBuffer;
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a2 = buffer.readUInt32LE(offset);
      let b3 = buffer.readUInt32LE(offset + 4);
      b3 *= 4294967296;
      verifuint(b3 + a2, 9007199254740991);
      return b3 + a2;
    }
    exports.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports.writeUInt64LE = writeUInt64LE;
  }
});

// node_modules/bip174/src/lib/converter/input/witnessUtxo.js
var require_witnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/witnessUtxo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var tools_1 = require_tools();
    var varuint = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode witnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      const value = tools_1.readUInt64LE(keyVal.value, 0);
      let _offset = 8;
      const scriptLen = varuint.decode(keyVal.value, _offset);
      _offset += varuint.encodingLength(scriptLen);
      const script = keyVal.value.slice(_offset);
      if (script.length !== scriptLen) {
        throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
      }
      return {
        script,
        value
      };
    }
    exports.decode = decode;
    function encode3(data) {
      const { script, value } = data;
      const varintLen = varuint.encodingLength(script.length);
      const result = Buffer.allocUnsafe(8 + varintLen + script.length);
      tools_1.writeUInt64LE(result, value, 0);
      varuint.encode(script.length, result, 8);
      script.copy(result, 8 + varintLen);
      return {
        key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
        value: result
      };
    }
    exports.encode = encode3;
    exports.expected = "{ script: Buffer; value: number; }";
    function check2(data) {
      return Buffer.isBuffer(data.script) && typeof data.value === "number";
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.witnessUtxo === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/output/tapTree.js
var require_tapTree = __commonJS({
  "node_modules/bip174/src/lib/converter/output/tapTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var varuint = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapTree with key 0x" + keyVal.key.toString("hex")
        );
      }
      let _offset = 0;
      const data = [];
      while (_offset < keyVal.value.length) {
        const depth = keyVal.value[_offset++];
        const leafVersion = keyVal.value[_offset++];
        const scriptLen = varuint.decode(keyVal.value, _offset);
        _offset += varuint.encodingLength(scriptLen);
        data.push({
          depth,
          leafVersion,
          script: keyVal.value.slice(_offset, _offset + scriptLen)
        });
        _offset += scriptLen;
      }
      return { leaves: data };
    }
    exports.decode = decode;
    function encode3(tree) {
      const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
      const bufs = [].concat(
        ...tree.leaves.map((tapLeaf) => [
          Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
          varuint.encode(tapLeaf.script.length),
          tapLeaf.script
        ])
      );
      return {
        key,
        value: Buffer.concat(bufs)
      };
    }
    exports.encode = encode3;
    exports.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
    function check2(data) {
      return Array.isArray(data.leaves) && data.leaves.every(
        (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && Buffer.isBuffer(tapLeaf.script)
      );
    }
    exports.check = check2;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapTree === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/shared/bip32Derivation.js
var require_bip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var range = (n2) => [...Array(n2).keys()];
    var isValidDERKey = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
    function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode bip32Derivation with key 0x" + keyVal.key.toString("hex")
          );
        }
        const pubkey = keyVal.key.slice(1);
        if (!isValidPubkey(pubkey)) {
          throw new Error(
            "Decode Error: bip32Derivation has invalid pubkey in key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length / 4 % 1 !== 0) {
          throw new Error(
            "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
          );
        }
        const data = {
          masterFingerprint: keyVal.value.slice(0, 4),
          pubkey,
          path: "m"
        };
        for (const i2 of range(keyVal.value.length / 4 - 1)) {
          const val = keyVal.value.readUInt32LE(i2 * 4 + 4);
          const isHard = !!(val & 2147483648);
          const idx = val & 2147483647;
          data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
        }
        return data;
      }
      function encode3(data) {
        const head = Buffer.from([TYPE_BYTE]);
        const key = Buffer.concat([head, data.pubkey]);
        const splitPath = data.path.split("/");
        const value = Buffer.allocUnsafe(splitPath.length * 4);
        data.masterFingerprint.copy(value, 0);
        let offset = 4;
        splitPath.slice(1).forEach((level) => {
          const isHard = level.slice(-1) === "'";
          let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
          if (isHard) num += 2147483648;
          value.writeUInt32LE(num, offset);
          offset += 4;
        });
        return {
          key,
          value
        };
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
      function check2(data) {
        return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
      }
      function canAddToArray(array2, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array2.filter((v2) => v2.pubkey.equals(item.pubkey)).length === 0;
      }
      return {
        decode,
        encode: encode3,
        check: check2,
        expected,
        canAddToArray
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/checkPubkey.js
var require_checkPubkey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/checkPubkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeChecker(pubkeyTypes) {
      return checkPubkey;
      function checkPubkey(keyVal) {
        let pubkey;
        if (pubkeyTypes.includes(keyVal.key[0])) {
          pubkey = keyVal.key.slice(1);
          if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
            throw new Error(
              "Format Error: invalid pubkey in key 0x" + keyVal.key.toString("hex")
            );
          }
        }
        return pubkey;
      }
    }
    exports.makeChecker = makeChecker;
  }
});

// node_modules/bip174/src/lib/converter/shared/redeemScript.js
var require_redeemScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/redeemScript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode redeemScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode3(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check2(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.redeemScript === void 0;
      }
      return {
        decode,
        encode: encode3,
        check: check2,
        expected,
        canAdd
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js
var require_tapBip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var varuint = require_varint();
    var bip32Derivation = require_bip32Derivation();
    var isValidBIP340Key = (pubkey) => pubkey.length === 32;
    function makeConverter(TYPE_BYTE) {
      const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
      function decode(keyVal) {
        const nHashes = varuint.decode(keyVal.value);
        const nHashesLen = varuint.encodingLength(nHashes);
        const base = parent.decode({
          key: keyVal.key,
          value: keyVal.value.slice(nHashesLen + nHashes * 32)
        });
        const leafHashes = new Array(nHashes);
        for (let i2 = 0, _offset = nHashesLen; i2 < nHashes; i2++, _offset += 32) {
          leafHashes[i2] = keyVal.value.slice(_offset, _offset + 32);
        }
        return Object.assign({}, base, { leafHashes });
      }
      function encode3(data) {
        const base = parent.encode(data);
        const nHashesLen = varuint.encodingLength(data.leafHashes.length);
        const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
        varuint.encode(data.leafHashes.length, nHashesBuf);
        const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);
        return Object.assign({}, base, { value });
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
      function check2(data) {
        return Array.isArray(data.leafHashes) && data.leafHashes.every(
          (leafHash) => Buffer.isBuffer(leafHash) && leafHash.length === 32
        ) && parent.check(data);
      }
      return {
        decode,
        encode: encode3,
        check: check2,
        expected,
        canAddToArray: parent.canAddToArray
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapInternalKey.js
var require_tapInternalKey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapInternalKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapInternalKey with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length !== 32) {
          throw new Error(
            "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
          );
        }
        return keyVal.value;
      }
      function encode3(value) {
        const key = Buffer.from([TYPE_BYTE]);
        return { key, value };
      }
      const expected = "Buffer";
      function check2(data) {
        return Buffer.isBuffer(data) && data.length === 32;
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapInternalKey === void 0;
      }
      return {
        decode,
        encode: encode3,
        check: check2,
        expected,
        canAdd
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/witnessScript.js
var require_witnessScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/witnessScript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode witnessScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode3(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check2(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.witnessScript === void 0;
      }
      return {
        decode,
        encode: encode3,
        check: check2,
        expected,
        canAdd
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/index.js
var require_converter = __commonJS({
  "node_modules/bip174/src/lib/converter/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var globalXpub = require_globalXpub();
    var unsignedTx = require_unsignedTx();
    var finalScriptSig = require_finalScriptSig();
    var finalScriptWitness = require_finalScriptWitness();
    var nonWitnessUtxo = require_nonWitnessUtxo();
    var partialSig = require_partialSig();
    var porCommitment = require_porCommitment();
    var sighashType = require_sighashType();
    var tapKeySig = require_tapKeySig();
    var tapLeafScript = require_tapLeafScript();
    var tapMerkleRoot = require_tapMerkleRoot();
    var tapScriptSig = require_tapScriptSig();
    var witnessUtxo = require_witnessUtxo();
    var tapTree = require_tapTree();
    var bip32Derivation = require_bip32Derivation();
    var checkPubkey = require_checkPubkey();
    var redeemScript = require_redeemScript();
    var tapBip32Derivation = require_tapBip32Derivation();
    var tapInternalKey = require_tapInternalKey();
    var witnessScript = require_witnessScript();
    var globals = {
      unsignedTx,
      globalXpub,
      // pass an Array of key bytes that require pubkey beside the key
      checkPubkey: checkPubkey.makeChecker([])
    };
    exports.globals = globals;
    var inputs = {
      nonWitnessUtxo,
      partialSig,
      sighashType,
      finalScriptSig,
      finalScriptWitness,
      porCommitment,
      witnessUtxo,
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.InputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.InputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.InputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.InputTypes.PARTIAL_SIG,
        typeFields_1.InputTypes.BIP32_DERIVATION
      ]),
      tapKeySig,
      tapScriptSig,
      tapLeafScript,
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.InputTypes.TAP_BIP32_DERIVATION
      ),
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.InputTypes.TAP_INTERNAL_KEY
      ),
      tapMerkleRoot
    };
    exports.inputs = inputs;
    var outputs = {
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.OutputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.OutputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ]),
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.OutputTypes.TAP_BIP32_DERIVATION
      ),
      tapTree,
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.OutputTypes.TAP_INTERNAL_KEY
      )
    };
    exports.outputs = outputs;
  }
});

// node_modules/bip174/src/lib/parser/fromBuffer.js
var require_fromBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/fromBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    var varuint = require_varint();
    var typeFields_1 = require_typeFields();
    function psbtFromBuffer(buffer, txGetter) {
      let offset = 0;
      function varSlice() {
        const keyLen = varuint.decode(buffer, offset);
        offset += varuint.encodingLength(keyLen);
        const key = buffer.slice(offset, offset + keyLen);
        offset += keyLen;
        return key;
      }
      function readUInt32BE() {
        const num = buffer.readUInt32BE(offset);
        offset += 4;
        return num;
      }
      function readUInt8() {
        const num = buffer.readUInt8(offset);
        offset += 1;
        return num;
      }
      function getKeyValue() {
        const key = varSlice();
        const value = varSlice();
        return {
          key,
          value
        };
      }
      function checkEndOfKeyValPairs() {
        if (offset >= buffer.length) {
          throw new Error("Format Error: Unexpected End of PSBT");
        }
        const isEnd = buffer.readUInt8(offset) === 0;
        if (isEnd) {
          offset++;
        }
        return isEnd;
      }
      if (readUInt32BE() !== 1886610036) {
        throw new Error("Format Error: Invalid Magic Number");
      }
      if (readUInt8() !== 255) {
        throw new Error(
          "Format Error: Magic Number must be followed by 0xff separator"
        );
      }
      const globalMapKeyVals = [];
      const globalKeyIndex = {};
      while (!checkEndOfKeyValPairs()) {
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString("hex");
        if (globalKeyIndex[hexKey]) {
          throw new Error(
            "Format Error: Keys must be unique for global keymap: key " + hexKey
          );
        }
        globalKeyIndex[hexKey] = 1;
        globalMapKeyVals.push(keyVal);
      }
      const unsignedTxMaps = globalMapKeyVals.filter(
        (keyVal) => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX
      );
      if (unsignedTxMaps.length !== 1) {
        throw new Error("Format Error: Only one UNSIGNED_TX allowed");
      }
      const unsignedTx = txGetter(unsignedTxMaps[0].value);
      const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
      const inputKeyVals = [];
      const outputKeyVals = [];
      for (const index of tools_1.range(inputCount)) {
        const inputKeyIndex = {};
        const input = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (inputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
            );
          }
          inputKeyIndex[hexKey] = 1;
          input.push(keyVal);
        }
        inputKeyVals.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const outputKeyIndex = {};
        const output = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (outputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
            );
          }
          outputKeyIndex[hexKey] = 1;
          output.push(keyVal);
        }
        outputKeyVals.push(output);
      }
      return psbtFromKeyVals(unsignedTx, {
        globalMapKeyVals,
        inputKeyVals,
        outputKeyVals
      });
    }
    exports.psbtFromBuffer = psbtFromBuffer;
    function checkKeyBuffer(type, keyBuf, keyNum) {
      if (!keyBuf.equals(Buffer.from([keyNum]))) {
        throw new Error(
          `Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`
        );
      }
    }
    exports.checkKeyBuffer = checkKeyBuffer;
    function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
      const globalMap = {
        unsignedTx
      };
      let txCount = 0;
      for (const keyVal of globalMapKeyVals) {
        switch (keyVal.key[0]) {
          case typeFields_1.GlobalTypes.UNSIGNED_TX:
            checkKeyBuffer(
              "global",
              keyVal.key,
              typeFields_1.GlobalTypes.UNSIGNED_TX
            );
            if (txCount > 0) {
              throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            }
            txCount++;
            break;
          case typeFields_1.GlobalTypes.GLOBAL_XPUB:
            if (globalMap.globalXpub === void 0) {
              globalMap.globalXpub = [];
            }
            globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
            break;
          default:
            if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
            globalMap.unknownKeyVals.push(keyVal);
        }
      }
      const inputCount = inputKeyVals.length;
      const outputCount = outputKeyVals.length;
      const inputs = [];
      const outputs = [];
      for (const index of tools_1.range(inputCount)) {
        const input = {};
        for (const keyVal of inputKeyVals[index]) {
          convert.inputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.InputTypes.NON_WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.NON_WITNESS_UTXO
              );
              if (input.nonWitnessUtxo !== void 0) {
                throw new Error(
                  "Format Error: Input has multiple NON_WITNESS_UTXO"
                );
              }
              input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_UTXO
              );
              if (input.witnessUtxo !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_UTXO");
              }
              input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.PARTIAL_SIG:
              if (input.partialSig === void 0) {
                input.partialSig = [];
              }
              input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.SIGHASH_TYPE:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.SIGHASH_TYPE
              );
              if (input.sighashType !== void 0) {
                throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
              }
              input.sighashType = convert.inputs.sighashType.decode(keyVal);
              break;
            case typeFields_1.InputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.REDEEM_SCRIPT
              );
              if (input.redeemScript !== void 0) {
                throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
              }
              input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_SCRIPT
              );
              if (input.witnessScript !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
              }
              input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.BIP32_DERIVATION:
              if (input.bip32Derivation === void 0) {
                input.bip32Derivation = [];
              }
              input.bip32Derivation.push(
                convert.inputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTSIG
              );
              input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
              );
              input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
                keyVal
              );
              break;
            case typeFields_1.InputTypes.POR_COMMITMENT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.POR_COMMITMENT
              );
              input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_KEY_SIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_KEY_SIG
              );
              input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
              if (input.tapScriptSig === void 0) {
                input.tapScriptSig = [];
              }
              input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
              if (input.tapLeafScript === void 0) {
                input.tapLeafScript = [];
              }
              input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
              if (input.tapBip32Derivation === void 0) {
                input.tapBip32Derivation = [];
              }
              input.tapBip32Derivation.push(
                convert.inputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_INTERNAL_KEY
              );
              input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_MERKLE_ROOT
              );
              input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
              break;
            default:
              if (!input.unknownKeyVals) input.unknownKeyVals = [];
              input.unknownKeyVals.push(keyVal);
          }
        }
        inputs.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const output = {};
        for (const keyVal of outputKeyVals[index]) {
          convert.outputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.OutputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.REDEEM_SCRIPT
              );
              if (output.redeemScript !== void 0) {
                throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
              }
              output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.WITNESS_SCRIPT
              );
              if (output.witnessScript !== void 0) {
                throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
              }
              output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.BIP32_DERIVATION:
              if (output.bip32Derivation === void 0) {
                output.bip32Derivation = [];
              }
              output.bip32Derivation.push(
                convert.outputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_INTERNAL_KEY
              );
              output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_TREE:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_TREE
              );
              output.tapTree = convert.outputs.tapTree.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
              if (output.tapBip32Derivation === void 0) {
                output.tapBip32Derivation = [];
              }
              output.tapBip32Derivation.push(
                convert.outputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            default:
              if (!output.unknownKeyVals) output.unknownKeyVals = [];
              output.unknownKeyVals.push(keyVal);
          }
        }
        outputs.push(output);
      }
      return { globalMap, inputs, outputs };
    }
    exports.psbtFromKeyVals = psbtFromKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/toBuffer.js
var require_toBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/toBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    function psbtToBuffer({ globalMap, inputs, outputs }) {
      const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
        globalMap,
        inputs,
        outputs
      });
      const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
      const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);
      const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
      const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
      const header = Buffer.allocUnsafe(5);
      header.writeUIntBE(482972169471, 0, 5);
      return Buffer.concat(
        [header, globalBuffer].concat(inputBuffers, outputBuffers)
      );
    }
    exports.psbtToBuffer = psbtToBuffer;
    var sortKeyVals = (a2, b3) => {
      return a2.key.compare(b3.key);
    };
    function keyValsFromMap(keyValMap, converterFactory) {
      const keyHexSet = /* @__PURE__ */ new Set();
      const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
        if (key === "unknownKeyVals") return result;
        const converter = converterFactory[key];
        if (converter === void 0) return result;
        const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
          converter.encode
        );
        const keyHexes = encodedKeyVals.map((kv) => kv.key.toString("hex"));
        keyHexes.forEach((hex) => {
          if (keyHexSet.has(hex))
            throw new Error("Serialize Error: Duplicate key: " + hex);
          keyHexSet.add(hex);
        });
        return result.concat(encodedKeyVals);
      }, []);
      const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
        return !keyHexSet.has(keyVal.key.toString("hex"));
      }) : [];
      return keyVals.concat(otherKeyVals).sort(sortKeyVals);
    }
    function psbtToKeyVals({ globalMap, inputs, outputs }) {
      return {
        globalKeyVals: keyValsFromMap(globalMap, convert.globals),
        inputKeyVals: inputs.map((i2) => keyValsFromMap(i2, convert.inputs)),
        outputKeyVals: outputs.map((o2) => keyValsFromMap(o2, convert.outputs))
      };
    }
    exports.psbtToKeyVals = psbtToKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/index.js
var require_parser = __commonJS({
  "node_modules/bip174/src/lib/parser/index.js"(exports) {
    "use strict";
    function __export2(m4) {
      for (var p2 in m4) if (!exports.hasOwnProperty(p2)) exports[p2] = m4[p2];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_fromBuffer());
    __export2(require_toBuffer());
  }
});

// node_modules/bip174/src/lib/combiner/index.js
var require_combiner = __commonJS({
  "node_modules/bip174/src/lib/combiner/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var parser_1 = require_parser();
    function combine(psbts) {
      const self2 = psbts[0];
      const selfKeyVals = parser_1.psbtToKeyVals(self2);
      const others = psbts.slice(1);
      if (others.length === 0) throw new Error("Combine: Nothing to combine");
      const selfTx = getTx(self2);
      if (selfTx === void 0) {
        throw new Error("Combine: Self missing transaction");
      }
      const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
      const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
      const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
      for (const other of others) {
        const otherTx = getTx(other);
        if (otherTx === void 0 || !otherTx.toBuffer().equals(selfTx.toBuffer())) {
          throw new Error(
            "Combine: One of the Psbts does not have the same transaction."
          );
        }
        const otherKeyVals = parser_1.psbtToKeyVals(other);
        const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
        otherGlobalSet.forEach(
          keyPusher(
            selfGlobalSet,
            selfKeyVals.globalKeyVals,
            otherKeyVals.globalKeyVals
          )
        );
        const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
        otherInputSets.forEach(
          (inputSet, idx) => inputSet.forEach(
            keyPusher(
              selfInputSets[idx],
              selfKeyVals.inputKeyVals[idx],
              otherKeyVals.inputKeyVals[idx]
            )
          )
        );
        const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
        otherOutputSets.forEach(
          (outputSet, idx) => outputSet.forEach(
            keyPusher(
              selfOutputSets[idx],
              selfKeyVals.outputKeyVals[idx],
              otherKeyVals.outputKeyVals[idx]
            )
          )
        );
      }
      return parser_1.psbtFromKeyVals(selfTx, {
        globalMapKeyVals: selfKeyVals.globalKeyVals,
        inputKeyVals: selfKeyVals.inputKeyVals,
        outputKeyVals: selfKeyVals.outputKeyVals
      });
    }
    exports.combine = combine;
    function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
      return (key) => {
        if (selfSet.has(key)) return;
        const newKv = otherKeyVals.filter((kv) => kv.key.toString("hex") === key)[0];
        selfKeyVals.push(newKv);
        selfSet.add(key);
      };
    }
    function getTx(psbt) {
      return psbt.globalMap.unsignedTx;
    }
    function getKeySet(keyVals) {
      const set = /* @__PURE__ */ new Set();
      keyVals.forEach((keyVal) => {
        const hex = keyVal.key.toString("hex");
        if (set.has(hex))
          throw new Error("Combine: KeyValue Map keys should be unique");
        set.add(hex);
      });
      return set;
    }
  }
});

// node_modules/bip174/src/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/bip174/src/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var converter = require_converter();
    function checkForInput(inputs, inputIndex) {
      const input = inputs[inputIndex];
      if (input === void 0) throw new Error(`No input #${inputIndex}`);
      return input;
    }
    exports.checkForInput = checkForInput;
    function checkForOutput(outputs, outputIndex) {
      const output = outputs[outputIndex];
      if (output === void 0) throw new Error(`No output #${outputIndex}`);
      return output;
    }
    exports.checkForOutput = checkForOutput;
    function checkHasKey(checkKeyVal, keyVals, enumLength) {
      if (checkKeyVal.key[0] < enumLength) {
        throw new Error(
          `Use the method for your specific key instead of addUnknownKeyVal*`
        );
      }
      if (keyVals && keyVals.filter((kv) => kv.key.equals(checkKeyVal.key)).length !== 0) {
        throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
      }
    }
    exports.checkHasKey = checkHasKey;
    function getEnumLength(myenum) {
      let count = 0;
      Object.keys(myenum).forEach((val) => {
        if (Number(isNaN(Number(val)))) {
          count++;
        }
      });
      return count;
    }
    exports.getEnumLength = getEnumLength;
    function inputCheckUncleanFinalized(inputIndex, input) {
      let result = false;
      if (input.nonWitnessUtxo || input.witnessUtxo) {
        const needScriptSig = !!input.redeemScript;
        const needWitnessScript = !!input.witnessScript;
        const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
        const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
        const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
        result = scriptSigOK && witnessScriptOK && hasOneFinal;
      }
      if (result === false) {
        throw new Error(
          `Input #${inputIndex} has too much or too little data to clean`
        );
      }
    }
    exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
    function throwForUpdateMaker(typeName, name, expected, data) {
      throw new Error(
        `Data for ${typeName} key ${name} is incorrect: Expected ${expected} and got ${JSON.stringify(data)}`
      );
    }
    function updateMaker(typeName) {
      return (updateData, mainData) => {
        for (const name of Object.keys(updateData)) {
          const data = updateData[name];
          const { canAdd, canAddToArray, check: check2, expected } = (
            // @ts-ignore
            converter[typeName + "s"][name] || {}
          );
          const isArray2 = !!canAddToArray;
          if (check2) {
            if (isArray2) {
              if (!Array.isArray(data) || // @ts-ignore
              mainData[name] && !Array.isArray(mainData[name])) {
                throw new Error(`Key type ${name} must be an array`);
              }
              if (!data.every(check2)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              const arr = mainData[name] || [];
              const dupeCheckSet = /* @__PURE__ */ new Set();
              if (!data.every((v2) => canAddToArray(arr, v2, dupeCheckSet))) {
                throw new Error("Can not add duplicate data to array");
              }
              mainData[name] = arr.concat(data);
            } else {
              if (!check2(data)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              if (!canAdd(mainData, data)) {
                throw new Error(`Can not add duplicate data to ${typeName}`);
              }
              mainData[name] = data;
            }
          }
        }
      };
    }
    exports.updateGlobal = updateMaker("global");
    exports.updateInput = updateMaker("input");
    exports.updateOutput = updateMaker("output");
    function addInputAttributes(inputs, data) {
      const index = inputs.length - 1;
      const input = checkForInput(inputs, index);
      exports.updateInput(data, input);
    }
    exports.addInputAttributes = addInputAttributes;
    function addOutputAttributes(outputs, data) {
      const index = outputs.length - 1;
      const output = checkForOutput(outputs, index);
      exports.updateOutput(data, output);
    }
    exports.addOutputAttributes = addOutputAttributes;
    function defaultVersionSetter(version2, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Version: Invalid Transaction");
      }
      txBuf.writeUInt32LE(version2, 0);
      return txBuf;
    }
    exports.defaultVersionSetter = defaultVersionSetter;
    function defaultLocktimeSetter(locktime, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Locktime: Invalid Transaction");
      }
      txBuf.writeUInt32LE(locktime, txBuf.length - 4);
      return txBuf;
    }
    exports.defaultLocktimeSetter = defaultLocktimeSetter;
  }
});

// node_modules/bip174/src/lib/psbt.js
var require_psbt = __commonJS({
  "node_modules/bip174/src/lib/psbt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var combiner_1 = require_combiner();
    var parser_1 = require_parser();
    var typeFields_1 = require_typeFields();
    var utils_1 = require_utils2();
    var Psbt9 = class {
      constructor(tx) {
        this.inputs = [];
        this.outputs = [];
        this.globalMap = {
          unsignedTx: tx
        };
      }
      static fromBase64(data, txFromBuffer) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromHex(data, txFromBuffer) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromBuffer(buffer, txFromBuffer) {
        const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
        const psbt = new this(results.globalMap.unsignedTx);
        Object.assign(psbt, results);
        return psbt;
      }
      toBase64() {
        const buffer = this.toBuffer();
        return buffer.toString("base64");
      }
      toHex() {
        const buffer = this.toBuffer();
        return buffer.toString("hex");
      }
      toBuffer() {
        return parser_1.psbtToBuffer(this);
      }
      updateGlobal(updateData) {
        utils_1.updateGlobal(updateData, this.globalMap);
        return this;
      }
      updateInput(inputIndex, updateData) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.updateInput(updateData, input);
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.updateOutput(updateData, output);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        utils_1.checkHasKey(
          keyVal,
          this.globalMap.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.GlobalTypes)
        );
        if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
        this.globalMap.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.checkHasKey(
          keyVal,
          input.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.InputTypes)
        );
        if (!input.unknownKeyVals) input.unknownKeyVals = [];
        input.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.checkHasKey(
          keyVal,
          output.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.OutputTypes)
        );
        if (!output.unknownKeyVals) output.unknownKeyVals = [];
        output.unknownKeyVals.push(keyVal);
        return this;
      }
      addInput(inputData) {
        this.globalMap.unsignedTx.addInput(inputData);
        this.inputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = inputData.unknownKeyVals || [];
        const inputIndex = this.inputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
        );
        utils_1.addInputAttributes(this.inputs, inputData);
        return this;
      }
      addOutput(outputData) {
        this.globalMap.unsignedTx.addOutput(outputData);
        this.outputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = outputData.unknownKeyVals || [];
        const outputIndex = this.outputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
        );
        utils_1.addOutputAttributes(this.outputs, outputData);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.inputCheckUncleanFinalized(inputIndex, input);
        for (const key of Object.keys(input)) {
          if (![
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
          ].includes(key)) {
            delete input[key];
          }
        }
        return this;
      }
      combine(...those) {
        const result = combiner_1.combine([this].concat(those));
        Object.assign(this, result);
        return this;
      }
      getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
      }
    };
    exports.Psbt = Psbt9;
  }
});

// node_modules/bitcoinjs-lib/src/psbt/psbtutils.js
var require_psbtutils = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt/psbtutils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureBlocksAction = exports.checkInputForSig = exports.pubkeyInScript = exports.pubkeyPositionInScript = exports.witnessStackToScriptWitness = exports.isP2TR = exports.isP2SHScript = exports.isP2WSHScript = exports.isP2WPKH = exports.isP2PKH = exports.isP2PK = exports.isP2MS = void 0;
    var varuint = require_varint();
    var bscript = require_script();
    var transaction_1 = require_transaction();
    var crypto_1 = require_crypto2();
    var payments2 = require_payments();
    function isPaymentFactory(payment) {
      return (script) => {
        try {
          payment({ output: script });
          return true;
        } catch (err) {
          return false;
        }
      };
    }
    exports.isP2MS = isPaymentFactory(payments2.p2ms);
    exports.isP2PK = isPaymentFactory(payments2.p2pk);
    exports.isP2PKH = isPaymentFactory(payments2.p2pkh);
    exports.isP2WPKH = isPaymentFactory(payments2.p2wpkh);
    exports.isP2WSHScript = isPaymentFactory(payments2.p2wsh);
    exports.isP2SHScript = isPaymentFactory(payments2.p2sh);
    exports.isP2TR = isPaymentFactory(payments2.p2tr);
    function witnessStackToScriptWitness(witness) {
      let buffer = Buffer.allocUnsafe(0);
      function writeSlice(slice) {
        buffer = Buffer.concat([buffer, Buffer.from(slice)]);
      }
      function writeVarInt(i2) {
        const currentLen = buffer.length;
        const varintLen = varuint.encodingLength(i2);
        buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
        varuint.encode(i2, buffer, currentLen);
      }
      function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
      }
      function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
      }
      writeVector(witness);
      return buffer;
    }
    exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
    function pubkeyPositionInScript(pubkey, script) {
      const pubkeyHash = (0, crypto_1.hash160)(pubkey);
      const pubkeyXOnly = pubkey.slice(1, 33);
      const decompiled = bscript.decompile(script);
      if (decompiled === null) throw new Error("Unknown script error");
      return decompiled.findIndex((element) => {
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash) || element.equals(pubkeyXOnly);
      });
    }
    exports.pubkeyPositionInScript = pubkeyPositionInScript;
    function pubkeyInScript(pubkey, script) {
      return pubkeyPositionInScript(pubkey, script) !== -1;
    }
    exports.pubkeyInScript = pubkeyInScript;
    function checkInputForSig(input, action) {
      const pSigs = extractPartialSigs(input);
      return pSigs.some(
        (pSig) => signatureBlocksAction(pSig, bscript.signature.decode, action)
      );
    }
    exports.checkInputForSig = checkInputForSig;
    function signatureBlocksAction(signature, signatureDecodeFn, action) {
      const { hashType } = signatureDecodeFn(signature);
      const whitelist = [];
      const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
      if (isAnyoneCanPay) whitelist.push("addInput");
      const hashMod = hashType & 31;
      switch (hashMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
        case transaction_1.Transaction.SIGHASH_NONE:
          whitelist.push("addOutput");
          whitelist.push("setInputSequence");
          break;
      }
      if (whitelist.indexOf(action) === -1) {
        return true;
      }
      return false;
    }
    exports.signatureBlocksAction = signatureBlocksAction;
    function extractPartialSigs(input) {
      let pSigs = [];
      if ((input.partialSig || []).length === 0) {
        if (!input.finalScriptSig && !input.finalScriptWitness) return [];
        pSigs = getPsigsFromInputFinalScripts(input);
      } else {
        pSigs = input.partialSig;
      }
      return pSigs.map((p2) => p2.signature);
    }
    function getPsigsFromInputFinalScripts(input) {
      const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
      const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
      return scriptItems.concat(witnessItems).filter((item) => {
        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
      }).map((sig) => ({ signature: sig }));
    }
  }
});

// node_modules/bitcoinjs-lib/src/psbt/bip371.js
var require_bip371 = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt/bip371.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkTaprootInputForSigs = exports.tapTreeFromList = exports.tapTreeToList = exports.tweakInternalPubKey = exports.checkTaprootOutputFields = exports.checkTaprootInputFields = exports.isTaprootOutput = exports.isTaprootInput = exports.serializeTaprootSignature = exports.tapScriptFinalizer = exports.toXOnly = void 0;
    var types_1 = require_types();
    var transaction_1 = require_transaction();
    var psbtutils_1 = require_psbtutils();
    var bip341_1 = require_bip341();
    var payments_1 = require_payments();
    var psbtutils_2 = require_psbtutils();
    var toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    exports.toXOnly = toXOnly;
    function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
      const tapLeaf = findTapLeafToFinalize(
        input,
        inputIndex,
        tapLeafHashToFinalize
      );
      try {
        const sigs = sortSignatures(input, tapLeaf);
        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return {
          finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness)
        };
      } catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
      }
    }
    exports.tapScriptFinalizer = tapScriptFinalizer;
    function serializeTaprootSignature(sig, sighashType) {
      const sighashTypeByte = sighashType ? Buffer.from([sighashType]) : Buffer.from([]);
      return Buffer.concat([sig, sighashTypeByte]);
    }
    exports.serializeTaprootSignature = serializeTaprootSignature;
    function isTaprootInput(input) {
      return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script));
    }
    exports.isTaprootInput = isTaprootInput;
    function isTaprootOutput(output, script) {
      return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, psbtutils_1.isP2TR)(script));
    }
    exports.isTaprootOutput = isTaprootOutput;
    function checkTaprootInputFields(inputData, newInputData, action) {
      checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
      checkIfTapLeafInTree(inputData, newInputData, action);
    }
    exports.checkTaprootInputFields = checkTaprootInputFields;
    function checkTaprootOutputFields(outputData, newOutputData, action) {
      checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
      checkTaprootScriptPubkey(outputData, newOutputData);
    }
    exports.checkTaprootOutputFields = checkTaprootOutputFields;
    function checkTaprootScriptPubkey(outputData, newOutputData) {
      if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
      const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
      const tapTree = newOutputData.tapTree || outputData.tapTree;
      if (tapInternalKey) {
        const { script: scriptPubkey } = outputData;
        const script = getTaprootScripPubkey(tapInternalKey, tapTree);
        if (scriptPubkey && !scriptPubkey.equals(script))
          throw new Error("Error adding output. Script or address missmatch.");
      }
    }
    function getTaprootScripPubkey(tapInternalKey, tapTree) {
      const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
      const { output } = (0, payments_1.p2tr)({
        internalPubkey: tapInternalKey,
        scriptTree
      });
      return output;
    }
    function tweakInternalPubKey(inputIndex, input) {
      const tapInternalKey = input.tapInternalKey;
      const outputKey = tapInternalKey && (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
      if (!outputKey)
        throw new Error(
          `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${tapInternalKey && tapInternalKey.toString("hex")}`
        );
      return outputKey.x;
    }
    exports.tweakInternalPubKey = tweakInternalPubKey;
    function tapTreeToList(tree) {
      if (!(0, types_1.isTaptree)(tree))
        throw new Error(
          "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
        );
      return _tapTreeToList(tree);
    }
    exports.tapTreeToList = tapTreeToList;
    function tapTreeFromList(leaves = []) {
      if (leaves.length === 1 && leaves[0].depth === 0)
        return {
          output: leaves[0].script,
          version: leaves[0].leafVersion
        };
      return instertLeavesInTree(leaves);
    }
    exports.tapTreeFromList = tapTreeFromList;
    function checkTaprootInputForSigs(input, action) {
      const sigs = extractTaprootSigs(input);
      return sigs.some(
        (sig) => (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action)
      );
    }
    exports.checkTaprootInputForSigs = checkTaprootInputForSigs;
    function decodeSchnorrSignature(signature) {
      return {
        signature: signature.slice(0, 64),
        hashType: signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT
      };
    }
    function extractTaprootSigs(input) {
      const sigs = [];
      if (input.tapKeySig) sigs.push(input.tapKeySig);
      if (input.tapScriptSig)
        sigs.push(...input.tapScriptSig.map((s2) => s2.signature));
      if (!sigs.length) {
        const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
        if (finalTapKeySig) sigs.push(finalTapKeySig);
      }
      return sigs;
    }
    function getTapKeySigFromWithness(finalScriptWitness) {
      if (!finalScriptWitness) return;
      const witness = finalScriptWitness.slice(2);
      if (witness.length === 64 || witness.length === 65) return witness;
    }
    function _tapTreeToList(tree, leaves = [], depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (!tree) return [];
      if ((0, types_1.isTapleaf)(tree)) {
        leaves.push({
          depth,
          leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
          script: tree.output
        });
        return leaves;
      }
      if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
      if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
      return leaves;
    }
    function instertLeavesInTree(leaves) {
      let tree;
      for (const leaf of leaves) {
        tree = instertLeafInTree(leaf, tree);
        if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
      }
      return tree;
    }
    function instertLeafInTree(leaf, tree, depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (leaf.depth === depth) {
        if (!tree)
          return {
            output: leaf.script,
            version: leaf.leafVersion
          };
        return;
      }
      if ((0, types_1.isTapleaf)(tree)) return;
      const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
      if (leftSide) return [leftSide, tree && tree[1]];
      const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
      if (rightSide) return [tree && tree[0], rightSide];
    }
    function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootInput(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkIfTapLeafInTree(inputData, newInputData, action) {
      if (newInputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l2) => isTapLeafInTree(l2, newInputData.tapMerkleRoot)
        );
        const oldLeafsInTree = (inputData.tapLeafScript || []).every(
          (l2) => isTapLeafInTree(l2, newInputData.tapMerkleRoot)
        );
        if (!newLeafsInTree || !oldLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      } else if (inputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l2) => isTapLeafInTree(l2, inputData.tapMerkleRoot)
        );
        if (!newLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      }
    }
    function isTapLeafInTree(tapLeaf, merkleRoot) {
      if (!merkleRoot) return true;
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      const rootHash = (0, bip341_1.rootHashFromPath)(
        tapLeaf.controlBlock,
        leafHash
      );
      return rootHash.equals(merkleRoot);
    }
    function sortSignatures(input, tapLeaf) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      return (input.tapScriptSig || []).filter((tss) => tss.leafHash.equals(leafHash)).map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss)).sort((t1, t2) => t2.positionInScript - t1.positionInScript).map((t2) => t2.signature);
    }
    function addPubkeyPositionInScript(script, tss) {
      return Object.assign(
        {
          positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
            tss.pubkey,
            script
          )
        },
        tss
      );
    }
    function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
      if (!input.tapScriptSig || !input.tapScriptSig.length)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`
        );
      const tapLeaf = (input.tapLeafScript || []).sort((a2, b3) => a2.controlBlock.length - b3.controlBlock.length).find(
        (leaf) => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize)
      );
      if (!tapLeaf)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`
        );
      return tapLeaf;
    }
    function canFinalizeLeaf(leaf, tapScriptSig, hash) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: leaf.script,
        version: leaf.leafVersion
      });
      const whiteListedHash = !hash || hash.equals(leafHash);
      return whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== void 0;
    }
    function hasNonTaprootFields(io) {
      return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
    }
  }
});

// node_modules/bitcoinjs-lib/src/psbt.js
var require_psbt2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Psbt = void 0;
    var bip174_1 = require_psbt();
    var varuint = require_varint();
    var utils_1 = require_utils2();
    var address_1 = require_address();
    var bufferutils_1 = require_bufferutils();
    var networks_1 = require_networks();
    var payments2 = require_payments();
    var bip341_1 = require_bip341();
    var bscript = require_script();
    var transaction_1 = require_transaction();
    var bip371_1 = require_bip371();
    var psbtutils_1 = require_psbtutils();
    var DEFAULT_OPTS = {
      /**
       * A bitcoinjs Network object. This is only used if you pass an `address`
       * parameter to addOutput. Otherwise it is not needed and can be left default.
       */
      network: networks_1.bitcoin,
      /**
       * When extractTransaction is called, the fee rate is checked.
       * THIS IS NOT TO BE RELIED ON.
       * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
       */
      maximumFeeRate: 5e3
      // satoshi per byte
    };
    var Psbt9 = class _Psbt {
      static fromBase64(data, opts = {}) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, opts);
      }
      static fromHex(data, opts = {}) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, opts);
      }
      static fromBuffer(buffer, opts = {}) {
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
        const psbt = new _Psbt(opts, psbtBase);
        checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
        return psbt;
      }
      constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
        this.data = data;
        this.opts = Object.assign({}, DEFAULT_OPTS, opts);
        this.__CACHE = {
          __NON_WITNESS_UTXO_TX_CACHE: [],
          __NON_WITNESS_UTXO_BUF_CACHE: [],
          __TX_IN_CACHE: {},
          __TX: this.data.globalMap.unsignedTx.tx,
          // Psbt's predecesor (TransactionBuilder - now removed) behavior
          // was to not confirm input values  before signing.
          // Even though we highly encourage people to get
          // the full parent transaction to verify values, the ability to
          // sign non-segwit inputs without the full transaction was often
          // requested. So the only way to activate is to use @ts-ignore.
          // We will disable exporting the Psbt when unsafe sign is active.
          // because it is not BIP174 compliant.
          __UNSAFE_SIGN_NONSEGWIT: false
        };
        if (this.data.inputs.length === 0) this.setVersion(2);
        const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {
          enumerable,
          writable
        });
        dpew(this, "__CACHE", false, true);
        dpew(this, "opts", false, true);
      }
      get inputCount() {
        return this.data.inputs.length;
      }
      get version() {
        return this.__CACHE.__TX.version;
      }
      set version(version2) {
        this.setVersion(version2);
      }
      get locktime() {
        return this.__CACHE.__TX.locktime;
      }
      set locktime(locktime) {
        this.setLocktime(locktime);
      }
      get txInputs() {
        return this.__CACHE.__TX.ins.map((input) => ({
          hash: (0, bufferutils_1.cloneBuffer)(input.hash),
          index: input.index,
          sequence: input.sequence
        }));
      }
      get txOutputs() {
        return this.__CACHE.__TX.outs.map((output) => {
          let address2;
          try {
            address2 = (0, address_1.fromOutputScript)(
              output.script,
              this.opts.network
            );
          } catch (_2) {
          }
          return {
            script: (0, bufferutils_1.cloneBuffer)(output.script),
            value: output.value,
            address: address2
          };
        });
      }
      combine(...those) {
        this.data.combine(...those.map((o2) => o2.data));
        return this;
      }
      clone() {
        const res = _Psbt.fromBuffer(this.data.toBuffer());
        res.opts = JSON.parse(JSON.stringify(this.opts));
        return res;
      }
      setMaximumFeeRate(satoshiPerByte) {
        check32Bit(satoshiPerByte);
        this.opts.maximumFeeRate = satoshiPerByte;
      }
      setVersion(version2) {
        check32Bit(version2);
        checkInputsForPartialSig(this.data.inputs, "setVersion");
        const c2 = this.__CACHE;
        c2.__TX.version = version2;
        c2.__EXTRACTED_TX = void 0;
        return this;
      }
      setLocktime(locktime) {
        check32Bit(locktime);
        checkInputsForPartialSig(this.data.inputs, "setLocktime");
        const c2 = this.__CACHE;
        c2.__TX.locktime = locktime;
        c2.__EXTRACTED_TX = void 0;
        return this;
      }
      setInputSequence(inputIndex, sequence) {
        check32Bit(sequence);
        checkInputsForPartialSig(this.data.inputs, "setInputSequence");
        const c2 = this.__CACHE;
        if (c2.__TX.ins.length <= inputIndex) {
          throw new Error("Input index too high");
        }
        c2.__TX.ins[inputIndex].sequence = sequence;
        c2.__EXTRACTED_TX = void 0;
        return this;
      }
      addInputs(inputDatas) {
        inputDatas.forEach((inputData) => this.addInput(inputData));
        return this;
      }
      addInput(inputData) {
        if (arguments.length > 1 || !inputData || inputData.hash === void 0 || inputData.index === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`
          );
        }
        (0, bip371_1.checkTaprootInputFields)(inputData, inputData, "addInput");
        checkInputsForPartialSig(this.data.inputs, "addInput");
        if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
        const c2 = this.__CACHE;
        this.data.addInput(inputData);
        const txIn = c2.__TX.ins[c2.__TX.ins.length - 1];
        checkTxInputCache(c2, txIn);
        const inputIndex = this.data.inputs.length - 1;
        const input = this.data.inputs[inputIndex];
        if (input.nonWitnessUtxo) {
          addNonWitnessTxCache(this.__CACHE, input, inputIndex);
        }
        c2.__FEE = void 0;
        c2.__FEE_RATE = void 0;
        c2.__EXTRACTED_TX = void 0;
        return this;
      }
      addOutputs(outputDatas) {
        outputDatas.forEach((outputData) => this.addOutput(outputData));
        return this;
      }
      addOutput(outputData) {
        if (arguments.length > 1 || !outputData || outputData.value === void 0 || outputData.address === void 0 && outputData.script === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`
          );
        }
        checkInputsForPartialSig(this.data.inputs, "addOutput");
        const { address: address2 } = outputData;
        if (typeof address2 === "string") {
          const { network } = this.opts;
          const script = (0, address_1.toOutputScript)(address2, network);
          outputData = Object.assign(outputData, { script });
        }
        (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, "addOutput");
        const c2 = this.__CACHE;
        this.data.addOutput(outputData);
        c2.__FEE = void 0;
        c2.__FEE_RATE = void 0;
        c2.__EXTRACTED_TX = void 0;
        return this;
      }
      extractTransaction(disableFeeCheck) {
        if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
        const c2 = this.__CACHE;
        if (!disableFeeCheck) {
          checkFees(this, c2, this.opts);
        }
        if (c2.__EXTRACTED_TX) return c2.__EXTRACTED_TX;
        const tx = c2.__TX.clone();
        inputFinalizeGetAmts(this.data.inputs, tx, c2, true);
        return tx;
      }
      getFeeRate() {
        return getTxCacheValue(
          "__FEE_RATE",
          "fee rate",
          this.data.inputs,
          this.__CACHE
        );
      }
      getFee() {
        return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
      }
      finalizeAllInputs() {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        range(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
        return this;
      }
      finalizeInput(inputIndex, finalScriptsFunc) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            void 0,
            finalScriptsFunc
          );
        return this._finalizeInput(inputIndex, input, finalScriptsFunc);
      }
      finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            tapLeafHashToFinalize,
            finalScriptsFunc
          );
        throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
      }
      _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
        const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
          inputIndex,
          input,
          this.__CACHE
        );
        if (!script) throw new Error(`No script found for input #${inputIndex}`);
        checkPartialSigSighashes(input);
        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
          inputIndex,
          input,
          script,
          isSegwit,
          isP2SH,
          isP2WSH
        );
        if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
        if (finalScriptWitness)
          this.data.updateInput(inputIndex, { finalScriptWitness });
        if (!finalScriptSig && !finalScriptWitness)
          throw new Error(`Unknown error finalizing input #${inputIndex}`);
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        if (!input.witnessUtxo)
          throw new Error(
            `Cannot finalize input #${inputIndex}. Missing withness utxo.`
          );
        if (input.tapKeySig) {
          const payment = payments2.p2tr({
            output: input.witnessUtxo.script,
            signature: input.tapKeySig
          });
          const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        } else {
          const { finalScriptWitness } = finalScriptsFunc(
            inputIndex,
            input,
            tapLeafHashToFinalize
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        }
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      getInputType(inputIndex) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
        const result = getMeaningfulScript(
          script,
          inputIndex,
          "input",
          input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
          input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness)
        );
        const type = result.type === "raw" ? "" : result.type + "-";
        const mainType = classifyScript(result.meaningfulScript);
        return type + mainType;
      }
      inputHasPubkey(inputIndex, pubkey) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
      }
      inputHasHDKey(inputIndex, root) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
      }
      outputHasPubkey(outputIndex, pubkey) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
      }
      outputHasHDKey(outputIndex, root) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
      }
      validateSignaturesOfAllInputs(validator) {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        const results = range(this.data.inputs.length).map(
          (idx) => this.validateSignaturesOfInput(idx, validator)
        );
        return results.reduce((final, res) => res === true && final, true);
      }
      validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        if ((0, bip371_1.isTaprootInput)(input))
          return this.validateSignaturesOfTaprootInput(
            inputIndex,
            validator,
            pubkey
          );
        return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
      }
      _validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const partialSig = (input || {}).partialSig;
        if (!input || !partialSig || partialSig.length < 1)
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        const mySigs = pubkey ? partialSig.filter((sig) => sig.pubkey.equals(pubkey)) : partialSig;
        if (mySigs.length < 1) throw new Error("No signatures for this pubkey");
        const results = [];
        let hashCache;
        let scriptCache;
        let sighashCache;
        for (const pSig of mySigs) {
          const sig = bscript.signature.decode(pSig.signature);
          const { hash, script } = sighashCache !== sig.hashType ? getHashForSig(
            inputIndex,
            Object.assign({}, input, { sighashType: sig.hashType }),
            this.__CACHE,
            true
          ) : { hash: hashCache, script: scriptCache };
          sighashCache = sig.hashType;
          hashCache = hash;
          scriptCache = script;
          checkScriptForPubkey(pSig.pubkey, script, "verify");
          results.push(validator(pSig.pubkey, hash, sig.signature));
        }
        return results.every((res) => res === true);
      }
      validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const tapKeySig = (input || {}).tapKeySig;
        const tapScriptSig = (input || {}).tapScriptSig;
        if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
        const allHashses = pubkey ? getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          pubkey,
          this.__CACHE
        ) : getAllTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          this.__CACHE
        );
        if (!allHashses.length) throw new Error("No signatures for this pubkey");
        const tapKeyHash = allHashses.find((h2) => !h2.leafHash);
        let validationResultCount = 0;
        if (tapKeySig && tapKeyHash) {
          const isValidTapkeySig = validator(
            tapKeyHash.pubkey,
            tapKeyHash.hash,
            trimTaprootSig(tapKeySig)
          );
          if (!isValidTapkeySig) return false;
          validationResultCount++;
        }
        if (tapScriptSig) {
          for (const tapSig of tapScriptSig) {
            const tapSigHash = allHashses.find((h2) => tapSig.pubkey.equals(h2.pubkey));
            if (tapSigHash) {
              const isValidTapScriptSig = validator(
                tapSig.pubkey,
                tapSigHash.hash,
                trimTaprootSig(tapSig.signature)
              );
              if (!isValidTapScriptSig) return false;
              validationResultCount++;
            }
          }
        }
        return validationResultCount > 0;
      }
      signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const results = [];
        for (const i2 of range(this.data.inputs.length)) {
          try {
            this.signInputHD(i2, hdKeyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v2) => v2 === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const results = [];
          const promises = [];
          for (const i2 of range(this.data.inputs.length)) {
            promises.push(
              this.signInputHDAsync(i2, hdKeyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v2) => v2 === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
        return this;
      }
      signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
          const promises = signers.map(
            (signer) => this.signInputAsync(inputIndex, signer, sighashTypes)
          );
          return Promise.all(promises).then(() => {
            resolve();
          }).catch(reject);
        });
      }
      signAllInputs(keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const results = [];
        for (const i2 of range(this.data.inputs.length)) {
          try {
            this.signInput(i2, keyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v2) => v2 === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsAsync(keyPair, sighashTypes) {
        return new Promise((resolve, reject) => {
          if (!keyPair || !keyPair.publicKey)
            return reject(new Error("Need Signer to sign input"));
          const results = [];
          const promises = [];
          for (const [i2] of this.data.inputs.entries()) {
            promises.push(
              this.signInputAsync(i2, keyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v2) => v2 === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInput(inputIndex, keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input)) {
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            void 0,
            sighashTypes
          );
        }
        return this._signInput(inputIndex, keyPair, sighashTypes);
      }
      signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            tapLeafHashToSign,
            sighashTypes
          );
        throw new Error(`Input #${inputIndex} is not of type Taproot.`);
      }
      _signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        const partialSig = [
          {
            pubkey: keyPair.publicKey,
            signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
          }
        ];
        this.data.updateInput(inputIndex, { partialSig });
        return this;
      }
      _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        const tapKeySig = hashesForSig.filter((h2) => !h2.leafHash).map(
          (h2) => (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h2.hash),
            input.sighashType
          )
        )[0];
        const tapScriptSig = hashesForSig.filter((h2) => !!h2.leafHash).map((h2) => ({
          pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
          signature: (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h2.hash),
            input.sighashType
          ),
          leafHash: h2.leafHash
        }));
        if (tapKeySig) {
          this.data.updateInput(inputIndex, { tapKeySig });
        }
        if (tapScriptSig.length) {
          this.data.updateInput(inputIndex, { tapScriptSig });
        }
        return this;
      }
      signInputAsync(inputIndex, keyPair, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              void 0,
              sighashTypes
            );
          return this._signInputAsync(inputIndex, keyPair, sighashTypes);
        });
      }
      signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              tapLeafHash,
              sighashTypes
            );
          throw new Error(`Input #${inputIndex} is not of type Taproot.`);
        });
      }
      _signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        return Promise.resolve(keyPair.sign(hash)).then((signature) => {
          const partialSig = [
            {
              pubkey: keyPair.publicKey,
              signature: bscript.signature.encode(signature, sighashType)
            }
          ];
          this.data.updateInput(inputIndex, { partialSig });
        });
      }
      async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHash,
          sighashTypes
        );
        const signaturePromises = [];
        const tapKeyHash = hashesForSig.filter((h2) => !h2.leafHash)[0];
        if (tapKeyHash) {
          const tapKeySigPromise = Promise.resolve(
            keyPair.signSchnorr(tapKeyHash.hash)
          ).then((sig) => {
            return {
              tapKeySig: (0, bip371_1.serializeTaprootSignature)(
                sig,
                input.sighashType
              )
            };
          });
          signaturePromises.push(tapKeySigPromise);
        }
        const tapScriptHashes = hashesForSig.filter((h2) => !!h2.leafHash);
        if (tapScriptHashes.length) {
          const tapScriptSigPromises = tapScriptHashes.map((tsh) => {
            return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
              (signature) => {
                const tapScriptSig = [
                  {
                    pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                    signature: (0, bip371_1.serializeTaprootSignature)(
                      signature,
                      input.sighashType
                    ),
                    leafHash: tsh.leafHash
                  }
                ];
                return { tapScriptSig };
              }
            );
          });
          signaturePromises.push(...tapScriptSigPromises);
        }
        return Promise.all(signaturePromises).then((results) => {
          results.forEach((v2) => this.data.updateInput(inputIndex, v2));
        });
      }
      checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
        if (typeof keyPair.signSchnorr !== "function")
          throw new Error(
            `Need Schnorr Signer to sign taproot input #${inputIndex}.`
          );
        const hashesForSig = getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          keyPair.publicKey,
          this.__CACHE,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        if (!hashesForSig || !hashesForSig.length)
          throw new Error(
            `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
              "hex"
            )}`
          );
        return hashesForSig;
      }
      toBuffer() {
        checkCache(this.__CACHE);
        return this.data.toBuffer();
      }
      toHex() {
        checkCache(this.__CACHE);
        return this.data.toHex();
      }
      toBase64() {
        checkCache(this.__CACHE);
        return this.data.toBase64();
      }
      updateGlobal(updateData) {
        this.data.updateGlobal(updateData);
        return this;
      }
      updateInput(inputIndex, updateData) {
        if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
        (0, bip371_1.checkTaprootInputFields)(
          this.data.inputs[inputIndex],
          updateData,
          "updateInput"
        );
        this.data.updateInput(inputIndex, updateData);
        if (updateData.nonWitnessUtxo) {
          addNonWitnessTxCache(
            this.__CACHE,
            this.data.inputs[inputIndex],
            inputIndex
          );
        }
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const outputData = this.data.outputs[outputIndex];
        (0, bip371_1.checkTaprootOutputFields)(
          outputData,
          updateData,
          "updateOutput"
        );
        this.data.updateOutput(outputIndex, updateData);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        this.data.addUnknownKeyValToGlobal(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        this.data.addUnknownKeyValToInput(inputIndex, keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
    };
    exports.Psbt = Psbt9;
    var transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);
    var PsbtTransaction = class {
      constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
        this.tx = transaction_1.Transaction.fromBuffer(buffer);
        checkTxEmpty(this.tx);
        Object.defineProperty(this, "tx", {
          enumerable: false,
          writable: true
        });
      }
      getInputOutputCounts() {
        return {
          inputCount: this.tx.ins.length,
          outputCount: this.tx.outs.length
        };
      }
      addInput(input) {
        if (input.hash === void 0 || input.index === void 0 || !Buffer.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") {
          throw new Error("Error adding input.");
        }
        const hash = typeof input.hash === "string" ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, "hex")) : input.hash;
        this.tx.addInput(hash, input.index, input.sequence);
      }
      addOutput(output) {
        if (output.script === void 0 || output.value === void 0 || !Buffer.isBuffer(output.script) || typeof output.value !== "number") {
          throw new Error("Error adding output.");
        }
        this.tx.addOutput(output.script, output.value);
      }
      toBuffer() {
        return this.tx.toBuffer();
      }
    };
    function canFinalize(input, script, scriptType) {
      switch (scriptType) {
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
          return hasSigs(1, input.partialSig);
        case "multisig":
          const p2ms = payments2.p2ms({ output: script });
          return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
        default:
          return false;
      }
    }
    function checkCache(cache) {
      if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
        throw new Error("Not BIP174 compliant, can not export");
      }
    }
    function hasSigs(neededSigs, partialSig, pubkeys) {
      if (!partialSig) return false;
      let sigs;
      if (pubkeys) {
        sigs = pubkeys.map((pkey) => {
          const pubkey = compressPubkey(pkey);
          return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
        }).filter((v2) => !!v2);
      } else {
        sigs = partialSig;
      }
      if (sigs.length > neededSigs) throw new Error("Too many signatures");
      return sigs.length === neededSigs;
    }
    function isFinalized(input) {
      return !!input.finalScriptSig || !!input.finalScriptWitness;
    }
    function bip32DerivationIsMine(root) {
      return (d2) => {
        if (!d2.masterFingerprint.equals(root.fingerprint)) return false;
        if (!root.derivePath(d2.path).publicKey.equals(d2.pubkey)) return false;
        return true;
      };
    }
    function check32Bit(num) {
      if (typeof num !== "number" || num !== Math.floor(num) || num > 4294967295 || num < 0) {
        throw new Error("Invalid 32 bit integer");
      }
    }
    function checkFees(psbt, cache, opts) {
      const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
      const vsize = cache.__EXTRACTED_TX.virtualSize();
      const satoshis = feeRate * vsize;
      if (feeRate >= opts.maximumFeeRate) {
        throw new Error(
          `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
        );
      }
    }
    function checkInputsForPartialSig(inputs, action) {
      inputs.forEach((input) => {
        const throws = (0, bip371_1.isTaprootInput)(input) ? (0, bip371_1.checkTaprootInputForSigs)(input, action) : (0, psbtutils_1.checkInputForSig)(input, action);
        if (throws)
          throw new Error("Can not modify transaction, signatures exist.");
      });
    }
    function checkPartialSigSighashes(input) {
      if (!input.sighashType || !input.partialSig) return;
      const { partialSig, sighashType } = input;
      partialSig.forEach((pSig) => {
        const { hashType } = bscript.signature.decode(pSig.signature);
        if (sighashType !== hashType) {
          throw new Error("Signature sighash does not match input sighash type");
        }
      });
    }
    function checkScriptForPubkey(pubkey, script, action) {
      if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
        throw new Error(
          `Can not ${action} for this input with the key ${pubkey.toString("hex")}`
        );
      }
    }
    function checkTxEmpty(tx) {
      const isEmpty = tx.ins.every(
        (input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0
      );
      if (!isEmpty) {
        throw new Error("Format Error: Transaction ScriptSigs are not empty");
      }
    }
    function checkTxForDupeIns(tx, cache) {
      tx.ins.forEach((input) => {
        checkTxInputCache(cache, input);
      });
    }
    function checkTxInputCache(cache, input) {
      const key = (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString("hex") + ":" + input.index;
      if (cache.__TX_IN_CACHE[key]) throw new Error("Duplicate input detected.");
      cache.__TX_IN_CACHE[key] = 1;
    }
    function scriptCheckerFactory(payment, paymentScriptName) {
      return (inputIndex, scriptPubKey, redeemScript, ioType) => {
        const redeemScriptOutput = payment({
          redeem: { output: redeemScript }
        }).output;
        if (!scriptPubKey.equals(redeemScriptOutput)) {
          throw new Error(
            `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`
          );
        }
      };
    }
    var checkRedeemScript = scriptCheckerFactory(payments2.p2sh, "Redeem script");
    var checkWitnessScript = scriptCheckerFactory(
      payments2.p2wsh,
      "Witness script"
    );
    function getTxCacheValue(key, name, inputs, c2) {
      if (!inputs.every(isFinalized))
        throw new Error(`PSBT must be finalized to calculate ${name}`);
      if (key === "__FEE_RATE" && c2.__FEE_RATE) return c2.__FEE_RATE;
      if (key === "__FEE" && c2.__FEE) return c2.__FEE;
      let tx;
      let mustFinalize = true;
      if (c2.__EXTRACTED_TX) {
        tx = c2.__EXTRACTED_TX;
        mustFinalize = false;
      } else {
        tx = c2.__TX.clone();
      }
      inputFinalizeGetAmts(inputs, tx, c2, mustFinalize);
      if (key === "__FEE_RATE") return c2.__FEE_RATE;
      else if (key === "__FEE") return c2.__FEE;
    }
    function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
      const scriptType = classifyScript(script);
      if (!canFinalize(input, script, scriptType))
        throw new Error(`Can not finalize input #${inputIndex}`);
      return prepareFinalScripts(
        script,
        scriptType,
        input.partialSig,
        isSegwit,
        isP2SH,
        isP2WSH
      );
    }
    function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
      let finalScriptSig;
      let finalScriptWitness;
      const payment = getPayment(script, scriptType, partialSig);
      const p2wsh = !isP2WSH ? null : payments2.p2wsh({ redeem: payment });
      const p2sh = !isP2SH ? null : payments2.p2sh({ redeem: p2wsh || payment });
      if (isSegwit) {
        if (p2wsh) {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            p2wsh.witness
          );
        } else {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
        }
        if (p2sh) {
          finalScriptSig = p2sh.input;
        }
      } else {
        if (p2sh) {
          finalScriptSig = p2sh.input;
        } else {
          finalScriptSig = payment.input;
        }
      }
      return {
        finalScriptSig,
        finalScriptWitness
      };
    }
    function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
      const input = (0, utils_1.checkForInput)(inputs, inputIndex);
      const { hash, sighashType, script } = getHashForSig(
        inputIndex,
        input,
        cache,
        false,
        sighashTypes
      );
      checkScriptForPubkey(pubkey, script, "sign");
      return {
        hash,
        sighashType
      };
    }
    function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
      const unsignedTx = cache.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
      checkSighashTypeAllowed(sighashType, sighashTypes);
      let hash;
      let prevout;
      if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        const prevoutHash = unsignedTx.ins[inputIndex].hash;
        const utxoHash = nonWitnessUtxoTx.getHash();
        if (!prevoutHash.equals(utxoHash)) {
          throw new Error(
            `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`
          );
        }
        const prevoutIndex = unsignedTx.ins[inputIndex].index;
        prevout = nonWitnessUtxoTx.outs[prevoutIndex];
      } else if (input.witnessUtxo) {
        prevout = input.witnessUtxo;
      } else {
        throw new Error("Need a Utxo input item for signing");
      }
      const { meaningfulScript, type } = getMeaningfulScript(
        prevout.script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      if (["p2sh-p2wsh", "p2wsh"].indexOf(type) >= 0) {
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          meaningfulScript,
          prevout.value,
          sighashType
        );
      } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
        const signingScript = payments2.p2pkh({
          hash: meaningfulScript.slice(2)
        }).output;
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          signingScript,
          prevout.value,
          sighashType
        );
      } else {
        if (input.nonWitnessUtxo === void 0 && cache.__UNSAFE_SIGN_NONSEGWIT === false)
          throw new Error(
            `Input #${inputIndex} has witnessUtxo but non-segwit script: ${meaningfulScript.toString("hex")}`
          );
        if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
          console.warn(
            "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecesor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************"
          );
        hash = unsignedTx.hashForSignature(
          inputIndex,
          meaningfulScript,
          sighashType
        );
      }
      return {
        script: meaningfulScript,
        sighashType,
        hash
      };
    }
    function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
      const allPublicKeys = [];
      if (input.tapInternalKey) {
        const key = getPrevoutTaprootKey(inputIndex, input, cache);
        if (key) {
          allPublicKeys.push(key);
        }
      }
      if (input.tapScriptSig) {
        const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
        allPublicKeys.push(...tapScriptPubkeys);
      }
      const allHashes = allPublicKeys.map(
        (pubicKey) => getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache)
      );
      return allHashes.flat();
    }
    function getPrevoutTaprootKey(inputIndex, input, cache) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
      return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
    }
    function trimTaprootSig(signature) {
      return signature.length === 64 ? signature : signature.subarray(0, 64);
    }
    function getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {
      const unsignedTx = cache.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
      checkSighashTypeAllowed(sighashType, allowedSighashTypes);
      const prevOuts = inputs.map(
        (i2, index) => getScriptAndAmountFromUtxo(index, i2, cache)
      );
      const signingScripts = prevOuts.map((o2) => o2.script);
      const values = prevOuts.map((o2) => o2.value);
      const hashes = [];
      if (input.tapInternalKey && !tapLeafHashToSign) {
        const outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);
        if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
          const tapKeyHash = unsignedTx.hashForWitnessV1(
            inputIndex,
            signingScripts,
            values,
            sighashType
          );
          hashes.push({ pubkey, hash: tapKeyHash });
        }
      }
      const tapLeafHashes = (input.tapLeafScript || []).filter((tapLeaf) => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script)).map((tapLeaf) => {
        const hash = (0, bip341_1.tapleafHash)({
          output: tapLeaf.script,
          version: tapLeaf.leafVersion
        });
        return Object.assign({ hash }, tapLeaf);
      }).filter(
        (tapLeaf) => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash)
      ).map((tapLeaf) => {
        const tapScriptHash = unsignedTx.hashForWitnessV1(
          inputIndex,
          signingScripts,
          values,
          transaction_1.Transaction.SIGHASH_DEFAULT,
          tapLeaf.hash
        );
        return {
          pubkey,
          hash: tapScriptHash,
          leafHash: tapLeaf.hash
        };
      });
      return hashes.concat(tapLeafHashes);
    }
    function checkSighashTypeAllowed(sighashType, sighashTypes) {
      if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
        const str = sighashTypeToString(sighashType);
        throw new Error(
          `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`
        );
      }
    }
    function getPayment(script, scriptType, partialSig) {
      let payment;
      switch (scriptType) {
        case "multisig":
          const sigs = getSortedSigs(script, partialSig);
          payment = payments2.p2ms({
            output: script,
            signatures: sigs
          });
          break;
        case "pubkey":
          payment = payments2.p2pk({
            output: script,
            signature: partialSig[0].signature
          });
          break;
        case "pubkeyhash":
          payment = payments2.p2pkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
        case "witnesspubkeyhash":
          payment = payments2.p2wpkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
      }
      return payment;
    }
    function getScriptFromInput(inputIndex, input, cache) {
      const unsignedTx = cache.__TX;
      const res = {
        script: null,
        isSegwit: false,
        isP2SH: false,
        isP2WSH: false
      };
      res.isP2SH = !!input.redeemScript;
      res.isP2WSH = !!input.witnessScript;
      if (input.witnessScript) {
        res.script = input.witnessScript;
      } else if (input.redeemScript) {
        res.script = input.redeemScript;
      } else {
        if (input.nonWitnessUtxo) {
          const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
            cache,
            input,
            inputIndex
          );
          const prevoutIndex = unsignedTx.ins[inputIndex].index;
          res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
        } else if (input.witnessUtxo) {
          res.script = input.witnessUtxo.script;
        }
      }
      if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
        res.isSegwit = true;
      }
      return res;
    }
    function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
      const input = (0, utils_1.checkForInput)(inputs, inputIndex);
      if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
        throw new Error("Need bip32Derivation to sign with HD");
      }
      const myDerivations = input.bip32Derivation.map((bipDv) => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
          return bipDv;
        } else {
          return;
        }
      }).filter((v2) => !!v2);
      if (myDerivations.length === 0) {
        throw new Error(
          "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
        );
      }
      const signers = myDerivations.map((bipDv) => {
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(node.publicKey)) {
          throw new Error("pubkey did not match bip32Derivation");
        }
        return node;
      });
      return signers;
    }
    function getSortedSigs(script, partialSig) {
      const p2ms = payments2.p2ms({ output: script });
      return p2ms.pubkeys.map((pk) => {
        return (partialSig.filter((ps) => {
          return ps.pubkey.equals(pk);
        })[0] || {}).signature;
      }).filter((v2) => !!v2);
    }
    function scriptWitnessToWitnessStack(buffer) {
      let offset = 0;
      function readSlice(n2) {
        offset += n2;
        return buffer.slice(offset - n2, offset);
      }
      function readVarInt() {
        const vi = varuint.decode(buffer, offset);
        offset += varuint.decode.bytes;
        return vi;
      }
      function readVarSlice() {
        return readSlice(readVarInt());
      }
      function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i2 = 0; i2 < count; i2++) vector.push(readVarSlice());
        return vector;
      }
      return readVector();
    }
    function sighashTypeToString(sighashType) {
      let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
      const sigMod = sighashType & 31;
      switch (sigMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          text += "SIGHASH_ALL";
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
          text += "SIGHASH_SINGLE";
          break;
        case transaction_1.Transaction.SIGHASH_NONE:
          text += "SIGHASH_NONE";
          break;
      }
      return text;
    }
    function addNonWitnessTxCache(cache, input, inputIndex) {
      cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
      const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
      cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
      const self2 = cache;
      const selfIndex = inputIndex;
      delete input.nonWitnessUtxo;
      Object.defineProperty(input, "nonWitnessUtxo", {
        enumerable: true,
        get() {
          const buf = self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
          const txCache = self2.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
          if (buf !== void 0) {
            return buf;
          } else {
            const newBuf = txCache.toBuffer();
            self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
            return newBuf;
          }
        },
        set(data) {
          self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
        }
      });
    }
    function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
      let inputAmount = 0;
      inputs.forEach((input, idx) => {
        if (mustFinalize && input.finalScriptSig)
          tx.ins[idx].script = input.finalScriptSig;
        if (mustFinalize && input.finalScriptWitness) {
          tx.ins[idx].witness = scriptWitnessToWitnessStack(
            input.finalScriptWitness
          );
        }
        if (input.witnessUtxo) {
          inputAmount += input.witnessUtxo.value;
        } else if (input.nonWitnessUtxo) {
          const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
          const vout = tx.ins[idx].index;
          const out = nwTx.outs[vout];
          inputAmount += out.value;
        }
      });
      const outputAmount = tx.outs.reduce((total, o2) => total + o2.value, 0);
      const fee = inputAmount - outputAmount;
      if (fee < 0) {
        throw new Error("Outputs are spending more than Inputs");
      }
      const bytes = tx.virtualSize();
      cache.__FEE = fee;
      cache.__EXTRACTED_TX = tx;
      cache.__FEE_RATE = Math.floor(fee / bytes);
    }
    function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
      const c2 = cache.__NON_WITNESS_UTXO_TX_CACHE;
      if (!c2[inputIndex]) {
        addNonWitnessTxCache(cache, input, inputIndex);
      }
      return c2[inputIndex];
    }
    function getScriptFromUtxo(inputIndex, input, cache) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
      return script;
    }
    function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
      if (input.witnessUtxo !== void 0) {
        return {
          script: input.witnessUtxo.script,
          value: input.witnessUtxo.value
        };
      } else if (input.nonWitnessUtxo !== void 0) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        const o2 = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
        return { script: o2.script, value: o2.value };
      } else {
        throw new Error("Can't find pubkey in input without Utxo data");
      }
    }
    function pubkeyInInput(pubkey, input, inputIndex, cache) {
      const script = getScriptFromUtxo(inputIndex, input, cache);
      const { meaningfulScript } = getMeaningfulScript(
        script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function pubkeyInOutput(pubkey, output, outputIndex, cache) {
      const script = cache.__TX.outs[outputIndex].script;
      const { meaningfulScript } = getMeaningfulScript(
        script,
        outputIndex,
        "output",
        output.redeemScript,
        output.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function redeemFromFinalScriptSig(finalScript) {
      if (!finalScript) return;
      const decomp = bscript.decompile(finalScript);
      if (!decomp) return;
      const lastItem = decomp[decomp.length - 1];
      if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem))
        return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function redeemFromFinalWitnessScript(finalScript) {
      if (!finalScript) return;
      const decomp = scriptWitnessToWitnessStack(finalScript);
      const lastItem = decomp[decomp.length - 1];
      if (isPubkeyLike(lastItem)) return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function compressPubkey(pubkey) {
      if (pubkey.length === 65) {
        const parity = pubkey[64] & 1;
        const newKey = pubkey.slice(0, 33);
        newKey[0] = 2 | parity;
        return newKey;
      }
      return pubkey.slice();
    }
    function isPubkeyLike(buf) {
      return buf.length === 33 && bscript.isCanonicalPubKey(buf);
    }
    function isSigLike(buf) {
      return bscript.isCanonicalScriptSignature(buf);
    }
    function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
      const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
      const isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
      const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
      if (isP2SH && redeemScript === void 0)
        throw new Error("scriptPubkey is P2SH but redeemScript missing");
      if ((isP2WSH || isP2SHP2WSH) && witnessScript === void 0)
        throw new Error(
          "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
        );
      let meaningfulScript;
      if (isP2SHP2WSH) {
        meaningfulScript = witnessScript;
        checkRedeemScript(index, script, redeemScript, ioType);
        checkWitnessScript(index, redeemScript, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2WSH) {
        meaningfulScript = witnessScript;
        checkWitnessScript(index, script, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2SH) {
        meaningfulScript = redeemScript;
        checkRedeemScript(index, script, redeemScript, ioType);
      } else {
        meaningfulScript = script;
      }
      return {
        meaningfulScript,
        type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
      };
    }
    function checkInvalidP2WSH(script) {
      if ((0, psbtutils_1.isP2WPKH)(script) || (0, psbtutils_1.isP2SHScript)(script)) {
        throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
      }
    }
    function classifyScript(script) {
      if ((0, psbtutils_1.isP2WPKH)(script)) return "witnesspubkeyhash";
      if ((0, psbtutils_1.isP2PKH)(script)) return "pubkeyhash";
      if ((0, psbtutils_1.isP2MS)(script)) return "multisig";
      if ((0, psbtutils_1.isP2PK)(script)) return "pubkey";
      return "nonstandard";
    }
    function range(n2) {
      return [...Array(n2).keys()];
    }
  }
});

// node_modules/bitcoinjs-lib/src/index.js
var require_src = __commonJS({
  "node_modules/bitcoinjs-lib/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initEccLib = exports.Transaction = exports.opcodes = exports.Psbt = exports.Block = exports.script = exports.payments = exports.networks = exports.crypto = exports.address = void 0;
    var address2 = require_address();
    exports.address = address2;
    var crypto2 = require_crypto2();
    exports.crypto = crypto2;
    var networks2 = require_networks();
    exports.networks = networks2;
    var payments2 = require_payments();
    exports.payments = payments2;
    var script = require_script();
    exports.script = script;
    var block_1 = require_block();
    Object.defineProperty(exports, "Block", {
      enumerable: true,
      get: function() {
        return block_1.Block;
      }
    });
    var psbt_1 = require_psbt2();
    Object.defineProperty(exports, "Psbt", {
      enumerable: true,
      get: function() {
        return psbt_1.Psbt;
      }
    });
    var ops_1 = require_ops();
    Object.defineProperty(exports, "opcodes", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var transaction_1 = require_transaction();
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function() {
        return transaction_1.Transaction;
      }
    });
    var ecc_lib_1 = require_ecc_lib();
    Object.defineProperty(exports, "initEccLib", {
      enumerable: true,
      get: function() {
        return ecc_lib_1.initEccLib;
      }
    });
  }
});

// node_modules/@dynamic-labs/bitcoin/package.js
var version = "4.26.0";

// node_modules/@dynamic-labs/bitcoin/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/sats-connect/node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
function _stringify(input) {
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message2 = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message2 !== void 0) {
    issue.message = typeof message2 === "function" ? (
      // @ts-expect-error
      message2(issue)
    ) : message2;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value2) {
      return context["~run"]({ value: value2 }, getGlobalConfig());
    }
  };
}
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
function _joinExpects(values2, separator) {
  const list = [...new Set(values2)];
  if (list.length > 1) {
    return `(${list.join(` ${separator} `)})`;
  }
  return list[0] ?? "never";
}
var EMOJI_REGEX = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
  new RegExp("^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$", "u")
);
function check(requirement, message2) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message: message2,
    "~run"(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}
function maxLength(requirement, message2) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message2,
    "~run"(dataset, config2) {
      if (dataset.typed && dataset.value.length > this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: `${dataset.value.length}`
        });
      }
      return dataset;
    }
  };
}
function minLength(requirement, message2) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message2,
    "~run"(dataset, config2) {
      if (dataset.typed && dataset.value.length < this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: `${dataset.value.length}`
        });
      }
      return dataset;
    }
  };
}
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function is(schema, input) {
  return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
}
function array(item, message2) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item["~run"]({ value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function boolean(message2) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function enum_(enum__, message2) {
  const options = [];
  for (const key in enum__) {
    if (`${+key}` !== key || typeof enum__[key] !== "string" || !Object.is(enum__[enum__[key]], +key)) {
      options.push(enum__[key]);
    }
  }
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(options.map(_stringify), "|"),
    async: false,
    enum: enum__,
    options,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (this.options.includes(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function literal(literal_, message2) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function looseObject(entries2, message2) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: false,
    entries: entries2,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
          valueSchema.default !== void 0) {
            const value2 = key in input ? (
              // @ts-expect-error
              input[key]
            ) : getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value2 }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value2
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) {
            dataset.value[key] = getFallback(valueSchema);
          } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config2, {
              input: void 0,
              expected: `"${key}"`,
              path: [
                {
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  // @ts-expect-error
                  value: input[key]
                }
              ]
            });
            if (config2.abortEarly) {
              break;
            }
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (const key in input) {
            if (_isValidObjectKey(input, key) && !(key in this.entries)) {
              dataset.value[key] = input[key];
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function nonOptional(wrapped, message2) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: false,
    wrapped,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value !== void 0) {
        dataset = this.wrapped["~run"](dataset, config2);
      }
      if (dataset.value === void 0) {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function null_(message2) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: false,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === null) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function nullish(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
function number(message2) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function object(entries2, message2) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries: entries2,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
          valueSchema.default !== void 0) {
            const value2 = key in input ? (
              // @ts-expect-error
              input[key]
            ) : getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value2 }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value2
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) {
            dataset.value[key] = getFallback(valueSchema);
          } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config2, {
              input: void 0,
              expected: `"${key}"`,
              path: [
                {
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  // @ts-expect-error
                  value: input[key]
                }
              ]
            });
            if (config2.abortEarly) {
              break;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
function picklist(options, message2) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(options.map(_stringify), "|"),
    async: false,
    options,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (this.options.includes(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function record(key, value2, message2) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key,
    value: value2,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            const entryValue = input[entryKey];
            const keyDataset = this.key["~run"]({ value: entryKey }, config2);
            if (keyDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues) {
                issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            const valueDataset = this.value["~run"](
              { value: entryValue },
              config2
            );
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function string(message2) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function _subIssues(datasets) {
  let issues;
  if (datasets) {
    for (const dataset of datasets) {
      if (issues) {
        issues.push(...dataset.issues);
      } else {
        issues = dataset.issues;
      }
    }
  }
  return issues;
}
function union(options, message2) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      options.map((option) => option.expects),
      "|"
    ),
    async: false,
    options,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema["~run"]({ value: dataset.value }, config2);
        if (optionDataset.typed) {
          if (optionDataset.issues) {
            if (typedDatasets) {
              typedDatasets.push(optionDataset);
            } else {
              typedDatasets = [optionDataset];
            }
          } else {
            validDataset = optionDataset;
            break;
          }
        } else {
          if (untypedDatasets) {
            untypedDatasets.push(optionDataset);
          } else {
            untypedDatasets = [optionDataset];
          }
        }
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
function variant(key, options, message2) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: false,
    key,
    options,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        let outputDataset;
        let maxDiscriminatorPriority = 0;
        let invalidDiscriminatorKey = this.key;
        let expectedDiscriminators = [];
        const parseOptions = (variant2, allKeys) => {
          for (const schema of variant2.options) {
            if (schema.type === "variant") {
              parseOptions(schema, new Set(allKeys).add(schema.key));
            } else {
              let keysAreValid = true;
              let currentPriority = 0;
              for (const currentKey of allKeys) {
                const discriminatorSchema = schema.entries[currentKey];
                if (currentKey in input ? discriminatorSchema["~run"](
                  // @ts-expect-error
                  { typed: false, value: input[currentKey] },
                  { abortEarly: true }
                ).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                  keysAreValid = false;
                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                    maxDiscriminatorPriority = currentPriority;
                    invalidDiscriminatorKey = currentKey;
                    expectedDiscriminators = [];
                  }
                  if (invalidDiscriminatorKey === currentKey) {
                    expectedDiscriminators.push(
                      schema.entries[currentKey].expects
                    );
                  }
                  break;
                }
                currentPriority++;
              }
              if (keysAreValid) {
                const optionDataset = schema["~run"]({ value: input }, config2);
                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                  outputDataset = optionDataset;
                }
              }
            }
            if (outputDataset && !outputDataset.issues) {
              break;
            }
          }
        };
        parseOptions(this, /* @__PURE__ */ new Set([this.key]));
        if (outputDataset) {
          return outputDataset;
        }
        _addIssue(this, "type", dataset, config2, {
          // @ts-expect-error
          input: input[invalidDiscriminatorKey],
          expected: _joinExpects(expectedDiscriminators, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input,
              key: invalidDiscriminatorKey,
              // @ts-expect-error
              value: input[invalidDiscriminatorKey]
            }
          ]
        });
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function omit(schema, keys) {
  const entries2 = {
    ...schema.entries
  };
  for (const key of keys) {
    delete entries2[key];
  }
  return {
    ...schema,
    entries: entries2,
    get "~standard"() {
      return _getStandardProps(this);
    }
  };
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      for (const item of pipe2) {
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item["~run"](dataset, config2);
          }
        }
      }
      return dataset;
    }
  };
}
function unwrap(schema) {
  return schema.wrapped;
}

// node_modules/sats-connect/node_modules/@sats-connect/core/dist/index.mjs
var import_jsontokens = __toESM(require_lib2(), 1);

// node_modules/sats-connect/node_modules/axios/lib/helpers/bind.js
function bind(fn3, thisArg) {
  return function wrap() {
    return fn3.apply(thisArg, arguments);
  };
}

// node_modules/sats-connect/node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn3, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn3.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn3.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
var extend = (a2, b3, thisArg, { allOwnKeys } = {}) => {
  forEach(b3, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn3) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn3.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m4, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/sats-connect/node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/sats-connect/node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/sats-connect/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/sats-connect/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/sats-connect/node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/sats-connect/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn3) {
    utils_default.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn3(h2);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/sats-connect/node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/sats-connect/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/sats-connect/node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/sats-connect/node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/sats-connect/node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/sats-connect/node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/sats-connect/node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/sats-connect/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/sats-connect/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/sats-connect/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/sats-connect/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/sats-connect/node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w3, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/sats-connect/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn3) {
    data = fn3.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/sats-connect/node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/sats-connect/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/sats-connect/node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/sats-connect/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/sats-connect/node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/sats-connect/node_modules/axios/lib/helpers/throttle.js
function throttle(fn3, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn3.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/sats-connect/node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn3) => (...args) => utils_default.asap(() => fn3(...args));

// node_modules/sats-connect/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/sats-connect/node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/sats-connect/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/sats-connect/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/sats-connect/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/sats-connect/node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b3, prop, caseless) {
    if (!utils_default.isUndefined(b3)) {
      return getMergedValue(a2, b3, prop, caseless);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b3) {
    if (!utils_default.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    }
  }
  function defaultToConfig2(a2, b3) {
    if (!utils_default.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b3, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b3);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b3, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b3), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/sats-connect/node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/sats-connect/node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/sats-connect/node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/sats-connect/node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/sats-connect/node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn3, ...args) => {
  try {
    return !!fn3(...args);
  } catch (e2) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request: request2
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request2),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request2);
  }
});

// node_modules/sats-connect/node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn3, value) => {
  if (fn3) {
    try {
      Object.defineProperty(fn3, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn3, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters[i2];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/sats-connect/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/sats-connect/node_modules/axios/lib/env/data.js
var VERSION = "1.8.4";

// node_modules/sats-connect/node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/sats-connect/node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/sats-connect/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/sats-connect/node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/sats-connect/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/sats-connect/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/sats-connect/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/sats-connect/node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/bitcoin-address-validation/lib/index.esm.js
var t = function() {
  return t = Object.assign || function(t2) {
    for (var r2, e2 = 1, n2 = arguments.length; e2 < n2; e2++) for (var s2 in r2 = arguments[e2]) Object.prototype.hasOwnProperty.call(r2, s2) && (t2[s2] = r2[s2]);
    return t2;
  }, t.apply(this, arguments);
};
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var e = (t2) => {
  if (!t2 || "string" != typeof t2) throw new Error(`Expected base58 string but got ${t2}`);
  if (t2.match(/[IOl0]/gmu)) throw new Error(`Invalid base58 character ${t2.match(/[IOl0]/gmu)}`);
  const e2 = t2.match(/^1+/gmu), n2 = e2 ? e2[0].length : 0, s2 = (t2.length - n2) * (Math.log(58) / Math.log(256)) + 1 >>> 0;
  return new Uint8Array([...new Uint8Array(n2), ...t2.match(/.{1}/gmu).map(((t3) => r.indexOf(t3))).reduce(((t3, r2) => t3 = t3.map(((t4) => {
    const e3 = 58 * t4 + r2;
    return r2 = e3 >> 8, e3;
  }))), new Uint8Array(s2)).reverse().filter((i2 = false, (t3) => i2 = i2 || t3))]);
  var i2;
};
(() => {
  const t2 = Array(256).fill(-1);
  for (let e2 = 0; e2 < r.length; ++e2) t2[r.charCodeAt(e2)] = e2;
})();
var n = e;
var s;
var i;
var o;
var h = (s = function(t2, r2) {
  Object.defineProperty(r2, "__esModule", { value: true }), r2.bech32m = r2.bech32 = void 0;
  const e2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n2 = {};
  for (let t3 = 0; t3 < 32; t3++) {
    const r3 = e2.charAt(t3);
    n2[r3] = t3;
  }
  function s2(t3) {
    const r3 = t3 >> 25;
    return (33554431 & t3) << 5 ^ 996825010 & -(r3 >> 0 & 1) ^ 642813549 & -(r3 >> 1 & 1) ^ 513874426 & -(r3 >> 2 & 1) ^ 1027748829 & -(r3 >> 3 & 1) ^ 705979059 & -(r3 >> 4 & 1);
  }
  function i2(t3) {
    let r3 = 1;
    for (let e3 = 0; e3 < t3.length; ++e3) {
      const n3 = t3.charCodeAt(e3);
      if (n3 < 33 || n3 > 126) return "Invalid prefix (" + t3 + ")";
      r3 = s2(r3) ^ n3 >> 5;
    }
    r3 = s2(r3);
    for (let e3 = 0; e3 < t3.length; ++e3) {
      const n3 = t3.charCodeAt(e3);
      r3 = s2(r3) ^ 31 & n3;
    }
    return r3;
  }
  function o2(t3, r3, e3, n3) {
    let s3 = 0, i3 = 0;
    const o3 = (1 << e3) - 1, h3 = [];
    for (let n4 = 0; n4 < t3.length; ++n4) for (s3 = s3 << r3 | t3[n4], i3 += r3; i3 >= e3; ) i3 -= e3, h3.push(s3 >> i3 & o3);
    if (n3) i3 > 0 && h3.push(s3 << e3 - i3 & o3);
    else {
      if (i3 >= r3) return "Excess padding";
      if (s3 << e3 - i3 & o3) return "Non-zero padding";
    }
    return h3;
  }
  function h2(t3) {
    return o2(t3, 8, 5, true);
  }
  function c2(t3) {
    const r3 = o2(t3, 5, 8, false);
    if (Array.isArray(r3)) return r3;
  }
  function a2(t3) {
    const r3 = o2(t3, 5, 8, false);
    if (Array.isArray(r3)) return r3;
    throw new Error(r3);
  }
  function f2(t3) {
    let r3;
    function o3(t4, e3) {
      if (e3 = e3 || 90, t4.length < 8) return t4 + " too short";
      if (t4.length > e3) return "Exceeds length limit";
      const o4 = t4.toLowerCase(), h3 = t4.toUpperCase();
      if (t4 !== o4 && t4 !== h3) return "Mixed-case string " + t4;
      const c3 = (t4 = o4).lastIndexOf("1");
      if (-1 === c3) return "No separator character for " + t4;
      if (0 === c3) return "Missing prefix for " + t4;
      const a3 = t4.slice(0, c3), f3 = t4.slice(c3 + 1);
      if (f3.length < 6) return "Data too short";
      let u2 = i2(a3);
      if ("string" == typeof u2) return u2;
      const l2 = [];
      for (let t5 = 0; t5 < f3.length; ++t5) {
        const r4 = f3.charAt(t5), e4 = n2[r4];
        if (void 0 === e4) return "Unknown character " + r4;
        u2 = s2(u2) ^ e4, t5 + 6 >= f3.length || l2.push(e4);
      }
      return u2 !== r3 ? "Invalid checksum for " + t4 : { prefix: a3, words: l2 };
    }
    return r3 = "bech32" === t3 ? 1 : 734539939, { decodeUnsafe: function(t4, r4) {
      const e3 = o3(t4, r4);
      if ("object" == typeof e3) return e3;
    }, decode: function(t4, r4) {
      const e3 = o3(t4, r4);
      if ("object" == typeof e3) return e3;
      throw new Error(e3);
    }, encode: function(t4, n3, o4) {
      if (o4 = o4 || 90, t4.length + 7 + n3.length > o4) throw new TypeError("Exceeds length limit");
      let h3 = i2(t4 = t4.toLowerCase());
      if ("string" == typeof h3) throw new Error(h3);
      let c3 = t4 + "1";
      for (let t5 = 0; t5 < n3.length; ++t5) {
        const r4 = n3[t5];
        if (r4 >> 5 != 0) throw new Error("Non 5-bit word");
        h3 = s2(h3) ^ r4, c3 += e2.charAt(r4);
      }
      for (let t5 = 0; t5 < 6; ++t5) h3 = s2(h3);
      h3 ^= r3;
      for (let t5 = 0; t5 < 6; ++t5) c3 += e2.charAt(h3 >> 5 * (5 - t5) & 31);
      return c3;
    }, toWords: h2, fromWordsUnsafe: c2, fromWords: a2 };
  }
  r2.bech32 = f2("bech32"), r2.bech32m = f2("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
var c = h.bech32m;
var a = h.bech32;
var f = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998];
var u = { sha256: 1 };
var l = class {
  constructor() {
    this.A = 1779033703, this.B = -1150833019, this.C = 1013904242, this.D = -1521486534, this.E = 1359893119, this.F = -1694144372, this.G = 528734635, this.H = 1541459225, this._size = 0, this._sp = 0, (!p || w >= 8e3) && (p = new ArrayBuffer(8e3), w = 0), this._byte = new Uint8Array(p, w, 80), this._word = new Int32Array(p, w, 20), w += 80;
  }
  update(t2) {
    if ("string" == typeof t2) return this._utf8(t2);
    if (null == t2) throw new TypeError("Invalid type: " + typeof t2);
    const r2 = t2.byteOffset, e2 = t2.byteLength;
    let n2 = e2 / 64 | 0, s2 = 0;
    if (n2 && !(3 & r2) && !(this._size % 64)) {
      const e3 = new Int32Array(t2.buffer, r2, 16 * n2);
      for (; n2--; ) this._int32(e3, s2 >> 2), s2 += 64;
      this._size += s2;
    }
    if (1 !== t2.BYTES_PER_ELEMENT && t2.buffer) {
      const n3 = new Uint8Array(t2.buffer, r2 + s2, e2 - s2);
      return this._uint8(n3);
    }
    return s2 === e2 ? this : this._uint8(t2, s2);
  }
  _uint8(t2, r2) {
    const { _byte: e2, _word: n2 } = this, s2 = t2.length;
    for (r2 |= 0; r2 < s2; ) {
      const i2 = this._size % 64;
      let o2 = i2;
      for (; r2 < s2 && o2 < 64; ) e2[o2++] = t2[r2++];
      o2 >= 64 && this._int32(n2), this._size += o2 - i2;
    }
    return this;
  }
  _utf8(t2) {
    const { _byte: r2, _word: e2 } = this, n2 = t2.length;
    let s2 = this._sp;
    for (let i2 = 0; i2 < n2; ) {
      const o2 = this._size % 64;
      let h2 = o2;
      for (; i2 < n2 && h2 < 64; ) {
        let e3 = 0 | t2.charCodeAt(i2++);
        e3 < 128 ? r2[h2++] = e3 : e3 < 2048 ? (r2[h2++] = 192 | e3 >>> 6, r2[h2++] = 128 | 63 & e3) : e3 < 55296 || e3 > 57343 ? (r2[h2++] = 224 | e3 >>> 12, r2[h2++] = 128 | e3 >>> 6 & 63, r2[h2++] = 128 | 63 & e3) : s2 ? (e3 = ((1023 & s2) << 10) + (1023 & e3) + 65536, r2[h2++] = 240 | e3 >>> 18, r2[h2++] = 128 | e3 >>> 12 & 63, r2[h2++] = 128 | e3 >>> 6 & 63, r2[h2++] = 128 | 63 & e3, s2 = 0) : s2 = e3;
      }
      h2 >= 64 && (this._int32(e2), e2[0] = e2[16]), this._size += h2 - o2;
    }
    return this._sp = s2, this;
  }
  _int32(t2, r2) {
    let { A: e2, B: n2, C: s2, D: i2, E: o2, F: h2, G: c2, H: a2 } = this, u2 = 0;
    for (r2 |= 0; u2 < 16; ) d[u2++] = g(t2[r2++]);
    for (u2 = 16; u2 < 64; u2++) d[u2] = A(d[u2 - 2]) + d[u2 - 7] + m(d[u2 - 15]) + d[u2 - 16] | 0;
    for (u2 = 0; u2 < 64; u2++) {
      const t3 = a2 + E(o2) + b(o2, h2, c2) + f[u2] + d[u2] | 0, r3 = v(e2) + _(e2, n2, s2) | 0;
      a2 = c2, c2 = h2, h2 = o2, o2 = i2 + t3 | 0, i2 = s2, s2 = n2, n2 = e2, e2 = t3 + r3 | 0;
    }
    this.A = e2 + this.A | 0, this.B = n2 + this.B | 0, this.C = s2 + this.C | 0, this.D = i2 + this.D | 0, this.E = o2 + this.E | 0, this.F = h2 + this.F | 0, this.G = c2 + this.G | 0, this.H = a2 + this.H | 0;
  }
  digest(t2) {
    const { _byte: r2, _word: e2 } = this;
    let n2 = this._size % 64 | 0;
    for (r2[n2++] = 128; 3 & n2; ) r2[n2++] = 0;
    if (n2 >>= 2, n2 > 14) {
      for (; n2 < 16; ) e2[n2++] = 0;
      n2 = 0, this._int32(e2);
    }
    for (; n2 < 16; ) e2[n2++] = 0;
    const s2 = 8 * this._size, i2 = (4294967295 & s2) >>> 0, o2 = (s2 - i2) / 4294967296;
    return o2 && (e2[14] = g(o2)), i2 && (e2[15] = g(i2)), this._int32(e2), "hex" === t2 ? this._hex() : this._bin();
  }
  _hex() {
    const { A: t2, B: r2, C: e2, D: n2, E: s2, F: i2, G: o2, H: h2 } = this;
    return y(t2) + y(r2) + y(e2) + y(n2) + y(s2) + y(i2) + y(o2) + y(h2);
  }
  _bin() {
    const { A: t2, B: r2, C: e2, D: n2, E: s2, F: i2, G: o2, H: h2, _byte: c2, _word: a2 } = this;
    return a2[0] = g(t2), a2[1] = g(r2), a2[2] = g(e2), a2[3] = g(n2), a2[4] = g(s2), a2[5] = g(i2), a2[6] = g(o2), a2[7] = g(h2), c2.slice(0, 32);
  }
};
var d = new Int32Array(64);
var p;
var w = 0;
var y = (t2) => (t2 + 4294967296).toString(16).substr(-8);
var g = 254 === new Uint8Array(new Uint16Array([65279]).buffer)[0] ? (t2) => t2 : (t2) => t2 << 24 & 4278190080 | t2 << 8 & 16711680 | t2 >> 8 & 65280 | t2 >> 24 & 255;
var b = (t2, r2, e2) => e2 ^ t2 & (r2 ^ e2);
var _ = (t2, r2, e2) => t2 & r2 | e2 & (t2 | r2);
var v = (t2) => (t2 >>> 2 | t2 << 30) ^ (t2 >>> 13 | t2 << 19) ^ (t2 >>> 22 | t2 << 10);
var E = (t2) => (t2 >>> 6 | t2 << 26) ^ (t2 >>> 11 | t2 << 21) ^ (t2 >>> 25 | t2 << 7);
var m = (t2) => (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
var A = (t2) => (t2 >>> 17 | t2 << 15) ^ (t2 >>> 19 | t2 << 13) ^ t2 >>> 10;
var x;
var k;
var I = function(t2) {
  return (function(t3) {
    if (t3 && !u[t3] && !u[t3.toLowerCase()]) throw new Error("Digest method not supported");
    return new l();
  })().update(t2).digest();
};
!(function(t2) {
  t2.mainnet = "mainnet", t2.testnet = "testnet", t2.regtest = "regtest";
})(x || (x = {})), (function(t2) {
  t2.p2pkh = "p2pkh", t2.p2sh = "p2sh", t2.p2wpkh = "p2wpkh", t2.p2wsh = "p2wsh", t2.p2tr = "p2tr";
})(k || (k = {}));
var C = { 0: { type: k.p2pkh, network: x.mainnet }, 111: { type: k.p2pkh, network: x.testnet }, 5: { type: k.p2sh, network: x.mainnet }, 196: { type: k.p2sh, network: x.testnet } };
var z = function(r2) {
  var e2, s2 = r2.substr(0, 2).toLowerCase();
  if ("bc" === s2 || "tb" === s2) return (function(t2) {
    var r3;
    try {
      r3 = t2.startsWith("bc1p") || t2.startsWith("tb1p") || t2.startsWith("bcrt1p") ? c.decode(t2) : a.decode(t2);
    } catch (t3) {
      throw new Error("Invalid address");
    }
    var e3 = { bc: x.mainnet, tb: x.testnet, bcrt: x.regtest }[r3.prefix];
    if (void 0 === e3) throw new Error("Invalid address");
    var n2 = r3.words[0];
    if (n2 < 0 || n2 > 16) throw new Error("Invalid address");
    return { bech32: true, network: e3, address: t2, type: 20 === a.fromWords(r3.words.slice(1)).length ? k.p2wpkh : 1 === n2 ? k.p2tr : k.p2wsh };
  })(r2);
  try {
    e2 = n(r2);
  } catch (t2) {
    throw new Error("Invalid address");
  }
  var i2 = e2.length;
  if (25 !== i2) throw new Error("Invalid address");
  var o2 = e2[0], h2 = e2.slice(i2 - 4, i2), f2 = e2.slice(0, i2 - 4), u2 = I(I(f2)).slice(0, 4);
  if (h2.some((function(t2, r3) {
    return t2 !== u2[r3];
  }))) throw new Error("Invalid address");
  if (!Object.keys(C).map(Number).includes(o2)) throw new Error("Invalid address");
  return t(t({}, C[o2]), { address: r2, bech32: false });
};

// node_modules/sats-connect/node_modules/@sats-connect/core/dist/index.mjs
var import_buffer = __toESM(require_buffer(), 1);
var import_jsontokens2 = __toESM(require_lib2(), 1);
var import_jsontokens3 = __toESM(require_lib2(), 1);
var import_jsontokens4 = __toESM(require_lib2(), 1);
var import_jsontokens5 = __toESM(require_lib2(), 1);
var import_jsontokens6 = __toESM(require_lib2(), 1);
var import_jsontokens7 = __toESM(require_lib2(), 1);
var import_jsontokens8 = __toESM(require_lib2(), 1);
var walletTypes = ["software", "ledger", "keystone"];
var walletTypeSchema = picklist(walletTypes);
var AddressPurpose = ((AddressPurpose2) => {
  AddressPurpose2["Ordinals"] = "ordinals";
  AddressPurpose2["Payment"] = "payment";
  AddressPurpose2["Stacks"] = "stacks";
  return AddressPurpose2;
})(AddressPurpose || {});
var AddressType = ((AddressType3) => {
  AddressType3["p2pkh"] = "p2pkh";
  AddressType3["p2sh"] = "p2sh";
  AddressType3["p2wpkh"] = "p2wpkh";
  AddressType3["p2wsh"] = "p2wsh";
  AddressType3["p2tr"] = "p2tr";
  AddressType3["stacks"] = "stacks";
  return AddressType3;
})(AddressType || {});
var addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
});
var getAddress = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { purposes } = options.payload;
  if (!purposes) {
    throw new Error("Address purposes are required");
  }
  try {
    const request2 = (0, import_jsontokens.createUnsecuredToken)(options.payload);
    const response = await provider.connect(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during address request", error);
    options.onCancel?.();
  }
};
var BitcoinNetworkType = ((BitcoinNetworkType2) => {
  BitcoinNetworkType2["Mainnet"] = "Mainnet";
  BitcoinNetworkType2["Testnet"] = "Testnet";
  BitcoinNetworkType2["Testnet4"] = "Testnet4";
  BitcoinNetworkType2["Signet"] = "Signet";
  BitcoinNetworkType2["Regtest"] = "Regtest";
  return BitcoinNetworkType2;
})(BitcoinNetworkType || {});
var StacksNetworkType = ((StacksNetworkType2) => {
  StacksNetworkType2["Mainnet"] = "mainnet";
  StacksNetworkType2["Testnet"] = "testnet";
  return StacksNetworkType2;
})(StacksNetworkType || {});
var StarknetNetworkType = ((StarknetNetworkType2) => {
  StarknetNetworkType2["Mainnet"] = "mainnet";
  StarknetNetworkType2["Sepolia"] = "sepolia";
  return StarknetNetworkType2;
})(StarknetNetworkType || {});
var RpcIdSchema = optional(union([string(), number(), null_()]));
var rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
});
var RpcErrorCode = ((RpcErrorCode2) => {
  RpcErrorCode2[RpcErrorCode2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  RpcErrorCode2[RpcErrorCode2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  RpcErrorCode2[RpcErrorCode2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  RpcErrorCode2[RpcErrorCode2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  RpcErrorCode2[RpcErrorCode2["USER_REJECTION"] = -32e3] = "USER_REJECTION";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_SUPPORTED"] = -32001] = "METHOD_NOT_SUPPORTED";
  RpcErrorCode2[RpcErrorCode2["ACCESS_DENIED"] = -32002] = "ACCESS_DENIED";
  return RpcErrorCode2;
})(RpcErrorCode || {});
var rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
});
var rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
var rpcResponseMessageSchema = union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var accountChangeEventName = "accountChange";
var accountChangeSchema = object({
  type: literal(accountChangeEventName),
  addresses: optional(array(addressSchema))
});
var networkChangeEventName = "networkChange";
var networkChangeSchema = object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: enum_(BitcoinNetworkType)
  }),
  stacks: object({
    name: string()
  }),
  addresses: optional(array(addressSchema))
});
var disconnectEventName = "disconnect";
var disconnectSchema = object({
  type: literal(disconnectEventName)
});
var walletEventSchema = variant("type", [
  accountChangeSchema,
  networkChangeSchema,
  disconnectSchema
]);
async function getProviderOrThrow(getProvider) {
  const provider = await getProvider?.() || window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (!provider) {
    throw new Error("No Bitcoin wallet installed");
  }
  return provider;
}
function getProviderById(providerId) {
  return providerId?.split(".").reduce((acc, part) => acc?.[part], window);
}
function isProviderInstalled(providerId) {
  return !!getProviderById(providerId);
}
function setDefaultProvider(providerId) {
  localStorage.setItem("sats-connect_defaultProvider", providerId);
}
function getDefaultProvider() {
  return localStorage.getItem("sats-connect_defaultProvider");
}
function removeDefaultProvider() {
  localStorage.removeItem("sats-connect_defaultProvider");
}
function getSupportedWallets() {
  const wallets = Object.values(DefaultAdaptersInfo).map((provider) => {
    {
      return {
        ...provider,
        isInstalled: isProviderInstalled(provider.id)
      };
    }
  });
  return wallets;
}
var stxCallContractMethodName = "stx_callContract";
var stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * @deprecated in favor of `functionArgs` for @stacks/connect compatibility
   */
  arguments: optional(array(string())),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  functionArgs: optional(array(string())),
  /**
   * The post conditions to apply to the contract call.
   */
  postConditions: optional(array(string())),
  /**
   * The mode to apply to the post conditions.
   */
  postConditionMode: optional(union([literal("allow"), literal("deny")]))
});
var stxCallContractResultSchema = object({
  /**
   * The ID of the transaction.
   */
  txid: string(),
  /**
   * A Stacks transaction as a hex-encoded string.
   */
  transaction: string()
});
var stxCallContractRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract";
var stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(number()),
  /**
   * The post conditions to apply to the contract call.
   */
  postConditions: optional(array(string())),
  /**
   * The mode to apply to the post conditions.
   */
  postConditionMode: optional(union([literal("allow"), literal("deny")]))
});
var stxDeployContractResultSchema = object({
  /**
   * The ID of the transaction.
   */
  txid: string(),
  /**
   * A Stacks transaction as a hex-encoded string.
   */
  transaction: string()
});
var stxDeployContractRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
});
var walletActionsSchema = object({
  readNetwork: optional(boolean())
});
var accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
});
var walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
});
var PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]);
var permission = variant("type", [accountPermissionSchema, walletPermissionSchema]);
var requestPermissionsMethodName = "wallet_requestPermissions";
var requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
var requestPermissionsResultSchema = literal(true);
var requestPermissionsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions";
var renouncePermissionsParamsSchema = nullish(null_());
var renouncePermissionsResultSchema = nullish(null_());
var renouncePermissionsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect";
var disconnectParamsSchema = nullish(null_());
var disconnectResultSchema = nullish(null_());
var disconnectRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType";
var getWalletTypeParamsSchema = nullish(null_());
var getWalletTypeRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions";
var getCurrentPermissionsParamsSchema = nullish(null_());
var getCurrentPermissionsResultSchema = array(permission);
var getCurrentPermissionsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork";
var getNetworkParamsSchema = nullish(null_());
var getNetworkResultSchema = object({
  bitcoin: object({
    name: enum_(BitcoinNetworkType)
  }),
  stacks: object({
    name: string()
  })
});
var getNetworkRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var changeNetworkMethodName = "wallet_changeNetwork";
var changeNetworkParamsSchema = object({
  name: enum_(BitcoinNetworkType)
});
var changeNetworkResultSchema = nullish(null_());
var changeNetworkRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(changeNetworkMethodName),
    params: changeNetworkParamsSchema,
    id: string()
  }).entries
});
var changeNetworkByIdMethodName = "wallet_changeNetworkById";
var changeNetworkByIdParamsSchema = object({
  id: string()
});
var changeNetworkByIdResultSchema = nullish(null_());
var changeNetworkByIdRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(changeNetworkByIdMethodName),
    params: changeNetworkByIdParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount";
var getAccountParamsSchema = nullish(null_());
var getAccountResultSchema = object({
  id: string(),
  addresses: array(addressSchema),
  walletType: walletTypeSchema,
  network: getNetworkResultSchema
});
var getAccountRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect";
var connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    ),
    network: optional(enum_(BitcoinNetworkType))
  })
);
var connectResultSchema = object({
  id: string(),
  addresses: array(addressSchema),
  walletType: walletTypeSchema,
  network: getNetworkResultSchema
});
var connectRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var addNetworkMethodName = "wallet_addNetwork";
var addNetworkParamsSchema = variant("chain", [
  object({
    chain: literal("bitcoin"),
    type: enum_(BitcoinNetworkType),
    name: string(),
    rpcUrl: string(),
    rpcFallbackUrl: optional(string()),
    indexerUrl: optional(string()),
    blockExplorerUrl: optional(string()),
    switch: optional(boolean())
  }),
  object({
    chain: literal("stacks"),
    name: string(),
    type: enum_(StacksNetworkType),
    rpcUrl: string(),
    blockExplorerUrl: optional(string()),
    switch: optional(boolean())
  }),
  object({
    chain: literal("starknet"),
    name: string(),
    type: enum_(StarknetNetworkType),
    rpcUrl: string(),
    blockExplorerUrl: optional(string()),
    switch: optional(boolean())
  })
]);
var addNetworkRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(addNetworkMethodName),
    params: addNetworkParamsSchema,
    id: string()
  }).entries
});
var addNetworkResultSchema = object({
  id: string()
});
var stxGetAccountsMethodName = "stx_getAccounts";
var stxGetAccountsParamsSchema = nullish(null_());
var stxGetAccountsResultSchema = object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: array(
    object({
      address: string(),
      publicKey: string(),
      gaiaHubUrl: string(),
      gaiaAppKey: string()
    })
  ),
  network: getNetworkResultSchema
});
var stxGetAccountsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var stxGetAddressesMethodName = "stx_getAddresses";
var stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
var stxGetAddressesResultSchema = object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: array(addressSchema),
  network: getNetworkResultSchema
});
var stxGetAddressesRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage";
var stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string()
});
var stxSignMessageResultSchema = object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * The public key used to sign the message.
   */
  publicKey: string()
});
var stxSignMessageRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage";
var stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
var stxSignStructuredMessageResultSchema = object({
  /**
   * Signature of the message.
   */
  signature: string(),
  /**
   * Public key as hex-encoded string.
   */
  publicKey: string()
});
var stxSignStructuredMessageRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction";
var stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
var stxSignTransactionResultSchema = object({
  /**
   * The signed transaction as a hex-encoded string.
   */
  transaction: string()
});
var stxSignTransactionRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions";
var stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check((hex) => {
          return true;
        }, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
var stxSignTransactionsResultSchema = object({
  /**
   * The signed transactions as hex-encoded strings, in the same order as in the
   * sign request.
   */
  transactions: array(string())
});
var stxSignTransactionsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx";
var stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
var stxTransferStxResultSchema = object({
  /**
   * The ID of the transaction.
   */
  txid: string(),
  /**
   * A Stacks transaction as a hex-encoded string.
   */
  transaction: string()
});
var stxTransferStxRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var getInfoMethodName = "getInfo";
var getInfoParamsSchema = nullish(null_());
var getInfoResultSchema = object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
var getInfoRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses";
var getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
var getAddressesResultSchema = object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: array(addressSchema),
  network: getNetworkResultSchema
});
var getAddressesRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage";
var MessageSigningProtocols = ((MessageSigningProtocols2) => {
  MessageSigningProtocols2["ECDSA"] = "ECDSA";
  MessageSigningProtocols2["BIP322"] = "BIP322";
  return MessageSigningProtocols2;
})(MessageSigningProtocols || {});
var signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
var signMessageResultSchema = object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
var signMessageRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer";
var sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
var sendTransferResultSchema = object({
  /**
   * The transaction id as a hex-encoded string.
   */
  txid: string()
});
var sendTransferRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt";
var signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: optional(record(string(), array(number()))),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
var signPsbtResultSchema = object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
var signPsbtRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts";
var getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
var getAccountsResultSchema = array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
var getAccountsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
var getBalanceParamsSchema = nullish(null_());
var getBalanceResultSchema = object({
  /**
   * The confirmed balance of the wallet in sats. Using a string due to chrome
   * messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  confirmed: string(),
  /**
   * The unconfirmed balance of the wallet in sats. Using a string due to chrome
   * messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  unconfirmed: string(),
  /**
   * The total balance (both confirmed and unconfrimed UTXOs) of the wallet in
   * sats. Using a string due to chrome messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  total: string()
});
var getBalanceRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch";
var etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
});
var inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
});
var runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
var runesEtchResultSchema = object({
  orderId: string(),
  fundTransactionId: string(),
  fundingAddress: string()
});
var runesEtchRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance";
var runesGetBalanceParamsSchema = nullish(null_());
var runesGetBalanceResultSchema = object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string()),
      spendableBalance: string()
    })
  )
});
var runesGetBalanceRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint";
var runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
var runesMintResultSchema = object({
  orderId: string(),
  fundTransactionId: string(),
  fundingAddress: string()
});
var runesMintRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer";
var runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
var runesTransferResultSchema = object({
  txid: string()
});
var runesTransferRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions";
var getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
var getInscriptionsResultSchema = object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
var getInscriptionsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions";
var sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
var sendInscriptionsResultSchema = object({
  txid: string()
});
var sendInscriptionsRequestMessageSchema = object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var request = async (method, params, providerId) => {
  let provider = window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (providerId) {
    provider = await getProviderById(providerId);
  }
  if (!provider) {
    throw new Error("no wallet provider was found");
  }
  if (!method) {
    throw new Error("A wallet method is required");
  }
  const response = await provider.request(method, params);
  if (is(rpcErrorResponseMessageSchema, response)) {
    return {
      status: "error",
      error: response.error
    };
  }
  if (is(rpcSuccessResponseMessageSchema, response)) {
    return {
      status: "success",
      result: response.result
    };
  }
  return {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: response
    }
  };
};
var addListener = (event, cb, providerId) => {
  let provider = window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (providerId) {
    provider = getProviderById(providerId);
  }
  if (!provider) {
    throw new Error("no wallet provider was found");
  }
  if (!provider.addListener) {
    console.error(
      `The wallet provider you are using does not support the addListener method. Please update your wallet provider.`
    );
    return () => {
    };
  }
  return provider.addListener(event, cb);
};
var urlNetworkSuffix = {
  [
    "Mainnet"
    /* Mainnet */
  ]: "",
  [
    "Testnet"
    /* Testnet */
  ]: "-testnet",
  [
    "Testnet4"
    /* Testnet4 */
  ]: "-testnet4",
  [
    "Signet"
    /* Signet */
  ]: "-signet"
};
var ORDINALS_API_BASE_URL = (network = "Mainnet") => {
  if (network === "Regtest") {
    throw new Error(`Ordinals API does not support ${network} network`);
  }
  return `https://ordinals${urlNetworkSuffix[network]}.xverse.app/v1`;
};
var RunesApi = class {
  client;
  constructor(network) {
    this.client = axios_default.create({
      baseURL: ORDINALS_API_BASE_URL(network)
    });
  }
  parseError = (error) => {
    return {
      code: error.response?.status,
      message: JSON.stringify(error.response?.data)
    };
  };
  estimateMintCost = async (mintParams) => {
    try {
      const response = await this.client.post("/runes/mint/estimate", {
        ...mintParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  estimateEtchCost = async (etchParams) => {
    try {
      const response = await this.client.post("/runes/etch/estimate", {
        ...etchParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createMintOrder = async (mintOrderParams) => {
    try {
      const response = await this.client.post("/runes/mint/orders", {
        ...mintOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createEtchOrder = async (etchOrderParams) => {
    try {
      const response = await this.client.post("/runes/etch/orders", {
        ...etchOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeMint = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/mint/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeEtch = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/etch/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  getOrder = async (orderId) => {
    try {
      const response = await this.client.get(`/orders/${orderId}`);
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  rbfOrder = async (rbfRequest) => {
    const { orderId, newFeeRate } = rbfRequest;
    try {
      const response = await this.client.post(`/orders/${orderId}/rbf-estimate`, {
        newFeeRate
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
};
var clients = {};
var getRunesApiClient = (network = "Mainnet") => {
  if (!clients[network]) {
    clients[network] = new RunesApi(network);
  }
  return clients[network];
};
var SatsConnectAdapter = class {
  async mintRunes(params) {
    try {
      const walletInfo = await this.requestInternal("getInfo", null).catch(() => null);
      if (walletInfo && walletInfo.status === "success") {
        const isMintSupported = walletInfo.result.methods?.includes("runes_mint");
        if (isMintSupported) {
          const response = await this.requestInternal("runes_mint", params);
          if (response) {
            if (response.status === "success") {
              return response;
            }
            if (response.status === "error" && response.error.code !== -32601) {
              return response;
            }
          }
        }
      }
      const mintRequest = {
        destinationAddress: params.destinationAddress,
        feeRate: params.feeRate,
        refundAddress: params.refundAddress,
        repeats: params.repeats,
        runeName: params.runeName,
        appServiceFee: params.appServiceFee,
        appServiceFeeAddress: params.appServiceFeeAddress
      };
      const orderResponse = await new RunesApi(params.network).createMintOrder(mintRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 : -32603,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      await new RunesApi(params.network).executeMint(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid,
          fundingAddress: orderResponse.data.fundAddress
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603,
          message: error.message
        }
      };
    }
  }
  async etchRunes(params) {
    const etchRequest = {
      destinationAddress: params.destinationAddress,
      refundAddress: params.refundAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    try {
      const walletInfo = await this.requestInternal("getInfo", null).catch(() => null);
      if (walletInfo && walletInfo.status === "success") {
        const isEtchSupported = walletInfo.result.methods?.includes("runes_etch");
        if (isEtchSupported) {
          const response = await this.requestInternal("runes_etch", params);
          if (response) {
            if (response.status === "success") {
              return response;
            }
            if (response.status === "error" && response.error.code !== -32601) {
              return response;
            }
          }
        }
      }
      const orderResponse = await new RunesApi(params.network).createEtchOrder(etchRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 : -32603,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      await new RunesApi(params.network).executeEtch(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid,
          fundingAddress: orderResponse.data.fundAddress
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603,
          message: error.message
        }
      };
    }
  }
  async estimateMint(params) {
    const estimateMintRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      repeats: params.repeats,
      runeName: params.runeName,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(
      params.network
    ).estimateMintCost(estimateMintRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 : -32603,
        message: response.error.message
      }
    };
  }
  async estimateEtch(params) {
    const estimateEtchRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(params.network).estimateEtchCost(estimateEtchRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 : -32603,
        message: response.error.message
      }
    };
  }
  async getOrder(params) {
    const response = await getRunesApiClient(params.network).getOrder(params.id);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 || response.error.code === 404 ? -32600 : -32603,
        message: response.error.message
      }
    };
  }
  async estimateRbfOrder(params) {
    const rbfOrderRequest = {
      newFeeRate: params.newFeeRate,
      orderId: params.orderId
    };
    const response = await getRunesApiClient(params.network).rbfOrder(rbfOrderRequest);
    if (response.data) {
      return {
        status: "success",
        result: {
          fundingAddress: response.data.fundingAddress,
          rbfCost: response.data.rbfCost
        }
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 || response.error.code === 404 ? -32600 : -32603,
        message: response.error.message
      }
    };
  }
  async rbfOrder(params) {
    try {
      const rbfOrderRequest = {
        newFeeRate: params.newFeeRate,
        orderId: params.orderId
      };
      const orderResponse = await getRunesApiClient(params.network).rbfOrder(rbfOrderRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 || orderResponse.error.code === 404 ? -32600 : -32603,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundingAddress,
            amount: orderResponse.data.rbfCost
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      return {
        status: "success",
        result: {
          fundingAddress: orderResponse.data.fundingAddress,
          orderId: rbfOrderRequest.orderId,
          fundRBFTransactionId: paymentResponse.result.txid
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603,
          message: error.message
        }
      };
    }
  }
  async request(method, params) {
    switch (method) {
      case "runes_mint":
        return this.mintRunes(params);
      case "runes_etch":
        return this.etchRunes(params);
      case "runes_estimateMint":
        return this.estimateMint(params);
      case "runes_estimateEtch":
        return this.estimateEtch(params);
      case "runes_getOrder": {
        return this.getOrder(params);
      }
      case "runes_estimateRbfOrder": {
        return this.estimateRbfOrder(params);
      }
      case "runes_rbfOrder": {
        return this.rbfOrder(params);
      }
      default:
        return this.requestInternal(method, params);
    }
  }
};
var XverseAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.xverse.id;
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
  addListener = (event, cb) => {
    return addListener(
      event,
      // The types of the `addListener` function being called here are not
      // entirely accurate.
      cb,
      this.id
    );
  };
};
function convertSignInputsToInputType(signInputs) {
  let result = [];
  if (!signInputs) {
    return result;
  }
  for (let address2 in signInputs) {
    let indexes = signInputs[address2];
    for (let index of indexes) {
      result.push({
        index,
        address: address2
      });
    }
  }
  return result;
}
var UnisatAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.unisat.id;
  async getAccounts(params) {
    const { purposes } = params;
    if (purposes.includes(
      "stacks"
      /* Stacks */
    )) {
      throw new Error("Only bitcoin addresses are supported");
    }
    const accounts = await window.unisat.requestAccounts();
    const publicKey = await window.unisat.getPublicKey();
    const address2 = accounts[0];
    const addressType = z(accounts[0]).type;
    const pk = addressType === k.p2tr ? publicKey.slice(2) : publicKey;
    const paymentAddress = {
      address: address2,
      publicKey: pk,
      addressType,
      purpose: "payment",
      walletType: "software"
    };
    const ordinalsAddress = {
      address: address2,
      publicKey: pk,
      addressType,
      purpose: "ordinals",
      walletType: "software"
    };
    const response = [];
    if (purposes.includes(
      "payment"
      /* Payment */
    )) {
      response.push({ ...paymentAddress, walletType: "software" });
    }
    if (purposes.includes(
      "ordinals"
      /* Ordinals */
    )) {
      response.push({ ...ordinalsAddress, walletType: "software" });
    }
    return response;
  }
  async signMessage(params) {
    const { message, address: address2 } = params;
    const addressType = z(address2).type;
    const Bip322supportedTypes = [k.p2wpkh, k.p2tr];
    if (Bip322supportedTypes.includes(addressType)) {
      const response2 = await window.unisat.signMessage(message, "bip322-simple");
      return {
        address: address2,
        messageHash: "",
        signature: response2,
        protocol: "BIP322"
        /* BIP322 */
      };
    }
    const response = await window.unisat.signMessage(message, "ecdsa");
    return {
      address: address2,
      messageHash: "",
      signature: response,
      protocol: "ECDSA"
      /* ECDSA */
    };
  }
  async sendTransfer(params) {
    const { recipients } = params;
    if (recipients.length > 1) {
      throw new Error("Only one recipient is supported by this wallet provider");
    }
    const txid = await window.unisat.sendBitcoin(recipients[0].address, recipients[0].amount);
    return {
      txid
    };
  }
  async signPsbt(params) {
    const { psbt, signInputs, broadcast } = params;
    const psbtHex = import_buffer.Buffer.from(psbt, "base64").toString("hex");
    const signedPsbt = await window.unisat.signPsbt(psbtHex, {
      autoFinalized: broadcast,
      toSignInputs: convertSignInputsToInputType(signInputs)
    });
    const signedPsbtBase64 = import_buffer.Buffer.from(signedPsbt, "hex").toString("base64");
    let txid;
    if (broadcast) {
      txid = await window.unisat.pushPsbt(signedPsbt);
    }
    return {
      psbt: signedPsbtBase64,
      txid
    };
  }
  requestInternal = async (method, params) => {
    try {
      switch (method) {
        case "getAccounts": {
          const response = await this.getAccounts(
            params
          );
          return {
            status: "success",
            result: response
          };
        }
        case "sendTransfer": {
          const response = await this.sendTransfer(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signMessage": {
          const response = await this.signMessage(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signPsbt": {
          const response = await this.signPsbt(params);
          return {
            status: "success",
            result: response
          };
        }
        default: {
          const error = {
            code: -32001,
            message: "Method not supported by the selected wallet"
          };
          console.error("Error calling the method", error);
          return {
            status: "error",
            error
          };
        }
      }
    } catch (error) {
      console.error("Error calling the method", error);
      return {
        status: "error",
        error: {
          code: error.code === 4001 ? -32e3 : -32603,
          message: error.message ? error.message : "Wallet method call error",
          data: error
        }
      };
    }
  };
  addListener = (eventName, cb) => {
    switch (eventName) {
      case "accountChange": {
        const handler = () => {
          cb({ type: "accountChange" });
        };
        window.unisat.on("accountsChanged", handler);
        return () => {
          window.unisat.removeListener("accountsChanged", handler);
        };
      }
      case "networkChange": {
        const handler = () => {
          cb({ type: "networkChange" });
        };
        window.unisat.on("networkChanged", handler);
        return () => {
          window.unisat.removeListener("networkChanged", handler);
        };
      }
      default: {
        console.error("Event not supported by the selected wallet");
        return () => {
        };
      }
    }
  };
};
var FordefiAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.fordefi.id;
  requestInternal = async (method, params) => {
    const provider = getProviderById(this.id);
    if (!provider) {
      throw new Error("no wallet provider was found");
    }
    if (!method) {
      throw new Error("A wallet method is required");
    }
    return await provider.request(method, params);
  };
  addListener = (eventName, cb) => {
    const provider = getProviderById(this.id);
    if (!provider) {
      throw new Error("no wallet provider was found");
    }
    if (!provider.addListener) {
      console.error(
        `The wallet provider you are using does not support the addListener method. Please update your wallet provider.`
      );
      return () => {
      };
    }
    return provider.addListener(
      eventName,
      cb
    );
  };
};
var BaseAdapter = class extends SatsConnectAdapter {
  id = "";
  constructor(providerId) {
    super();
    this.id = providerId;
  }
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
  addListener = (..._args) => {
    throw new Error("Method not supported for `BaseAdapter`.");
  };
};
var DefaultAdaptersInfo = {
  fordefi: {
    id: "FordefiProviders.UtxoProvider",
    name: "Fordefi",
    webUrl: "https://www.fordefi.com/",
    chromeWebStoreUrl: "https://chromewebstore.google.com/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
  },
  xverse: {
    id: "XverseProviders.BitcoinProvider",
    name: "Xverse",
    webUrl: "https://www.xverse.app/",
    googlePlayStoreUrl: "https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse",
    iOSAppStoreUrl: "https://apps.apple.com/app/xverse-bitcoin-web3-wallet/id1552272513",
    chromeWebStoreUrl: "https://chromewebstore.google.com/detail/xverse-wallet/idnnbdplmphpflfnlkomgpfbpcgelopg",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgdmlld0JveD0iMCAwIDEwMiAxMDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGlkPSJJY29uX0FydCAoRWRpdCBNZSkiPgo8cmVjdCB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgZmlsbD0iIzE4MTgxOCIvPgo8ZyBpZD0iTG9nby9FbWJsZW0iIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMF8xMjIzKSI+CjxwYXRoIGlkPSJWZWN0b3IiIGQ9Ik03NC42NTQyIDczLjg4ODNWNjUuMjMxMkM3NC42NTQyIDY0Ljg4OCA3NC41MTc3IDY0LjU2MDYgNzQuMjc0NSA2NC4zMTc0TDM3LjQzOTcgMjcuNDgyNUMzNy4xOTY1IDI3LjIzOTIgMzYuODY5MSAyNy4xMDI4IDM2LjUyNTggMjcuMTAyOEgyNy44NjlDMjcuNDQxNiAyNy4xMDI4IDI3LjA5MzggMjcuNDUwNiAyNy4wOTM4IDI3Ljg3OFYzNS45MjExQzI3LjA5MzggMzYuMjY0NCAyNy4yMzAyIDM2LjU5MTcgMjcuNDczNCAzNi44MzVMNDAuNjk1MiA1MC4wNTY3QzQwLjk5NzUgNTAuMzU5MSA0MC45OTc1IDUwLjg1MDEgNDAuNjk1MiA1MS4xNTI0TDI3LjMyMTEgNjQuNTI2NUMyNy4xNzU2IDY0LjY3MiAyNy4wOTM4IDY0Ljg2OTggMjcuMDkzOCA2NS4wNzQ0VjczLjg4ODNDMjcuMDkzOCA3NC4zMTUzIDI3LjQ0MTYgNzQuNjYzNSAyNy44NjkgNzQuNjYzNUg0Mi4zMzQyQzQyLjc2MTYgNzQuNjYzNSA0My4xMDk0IDc0LjMxNTMgNDMuMTA5NCA3My44ODgzVjY4LjY5NThDNDMuMTA5NCA2OC40OTEyIDQzLjE5MTIgNjguMjkzNSA0My4zMzY4IDY4LjE0NzlMNTAuNTExNCA2MC45NzMzQzUwLjgxMzggNjAuNjcwOSA1MS4zMDQ4IDYwLjY3MDkgNTEuNjA3MiA2MC45NzMzTDY0LjkxOTggNzQuMjg2MUM2NS4xNjMxIDc0LjUyOTMgNjUuNDkwNCA3NC42NjU4IDY1LjgzMzcgNzQuNjY1OEg3My44NzY3Qzc0LjMwNDIgNzQuNjY1OCA3NC42NTE5IDc0LjMxNzYgNzQuNjUxOSA3My44OTA2TDc0LjY1NDIgNzMuODg4M1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGlkPSJWZWN0b3JfMiIgZD0iTTU1LjM1OCAzOC41NjcySDYyLjYwMzFDNjMuMDMyOCAzOC41NjcyIDYzLjM4MjkgMzguOTE3MyA2My4zODI5IDM5LjM0NjlWNDYuNTkyMUM2My4zODI5IDQ3LjI4NzcgNjQuMjI0IDQ3LjYzNTUgNjQuNzE1MSA0Ny4xNDIyTDc0LjY1NDEgMzcuMTg3M0M3NC43OTk0IDM3LjA0MTggNzQuODgxNiAzNi44NDQgNzQuODgxNiAzNi42MzcxVjI3LjkxODlDNzQuODgxNiAyNy40ODkyIDc0LjUzMzQgMjcuMTM5MSA3NC4xMDE3IDI3LjEzOTFMNjUuMjUzOCAyNy4xMjc3QzY1LjA0NyAyNy4xMjc3IDY0Ljg0OTIgMjcuMjA5NiA2NC43MDE0IDI3LjM1NTFMNTQuODA1NiAzNy4yMzVDNTQuMzE0NSAzNy43MjYgNTQuNjYyMyAzOC41NjcyIDU1LjM1NTcgMzguNTY3Mkg1NS4zNThaIiBmaWxsPSIjRUU3QTMwIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMF8xMjIzIj4KPHJlY3Qgd2lkdGg9IjQ3LjgxMjUiIGhlaWdodD0iNDcuODEyNSIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3LjA5MzggMjcuMDkzOCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K"
  },
  unisat: {
    id: "unisat",
    name: "Unisat",
    webUrl: "https://unisat.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTAwNTBfNDE3MSkiPgo8cGF0aCBkPSJNMTEzLjY2IDI5LjI4OTdMMTQzLjk3IDU5LjMwOTdDMTQ2LjU1IDYxLjg1OTcgMTQ3LjgyIDY0LjQzOTcgMTQ3Ljc4IDY3LjAzOTdDMTQ3Ljc0IDY5LjYzOTcgMTQ2LjYzIDcyLjAwOTcgMTQ0LjQ2IDc0LjE1OTdDMTQyLjE5IDc2LjQwOTcgMTM5Ljc0IDc3LjU0OTcgMTM3LjEyIDc3LjU5OTdDMTM0LjUgNzcuNjM5NyAxMzEuOSA3Ni4zNzk3IDEyOS4zMiA3My44Mjk3TDk4LjMxOTkgNDMuMTI5N0M5NC43OTk5IDM5LjYzOTcgOTEuMzk5OSAzNy4xNjk3IDg4LjEyOTkgMzUuNzE5N0M4NC44NTk5IDM0LjI2OTcgODEuNDE5OSAzNC4wMzk3IDc3LjgxOTkgMzUuMDM5N0M3NC4yMDk5IDM2LjAyOTcgNzAuMzM5OSAzOC41Nzk3IDY2LjE4OTkgNDIuNjc5N0M2MC40Njk5IDQ4LjM0OTcgNTcuNzM5OSA1My42Njk3IDU4LjAxOTkgNTguNjM5N0M1OC4yOTk5IDYzLjYwOTcgNjEuMTM5OSA2OC43Njk3IDY2LjUyOTkgNzQuMDk5N0w5Ny43Nzk5IDEwNS4wNkMxMDAuMzkgMTA3LjY0IDEwMS42NyAxMTAuMjIgMTAxLjYzIDExMi43OEMxMDEuNTkgMTE1LjM1IDEwMC40NyAxMTcuNzIgOTguMjU5OSAxMTkuOTFDOTYuMDU5OSAxMjIuMDkgOTMuNjI5OSAxMjMuMjMgOTAuOTg5OSAxMjMuMzJDODguMzQ5OSAxMjMuNDEgODUuNzE5OSAxMjIuMTYgODMuMTE5OSAxMTkuNThMNTIuODA5OSA4OS41NTk3QzQ3Ljg3OTkgODQuNjc5NyA0NC4zMTk5IDgwLjA1OTcgNDIuMTI5OSA3NS42OTk3QzM5LjkzOTkgNzEuMzM5NyAzOS4xMTk5IDY2LjQwOTcgMzkuNjg5OSA2MC45MDk3QzQwLjE5OTkgNTYuMTk5NyA0MS43MDk5IDUxLjYzOTcgNDQuMjI5OSA0Ny4yMTk3QzQ2LjczOTkgNDIuNzk5NyA1MC4zMzk5IDM4LjI3OTcgNTUuMDA5OSAzMy42NDk3QzYwLjU2OTkgMjguMTM5NyA2NS44Nzk5IDIzLjkxOTcgNzAuOTM5OSAyMC45Nzk3Qzc1Ljk4OTkgMTguMDM5NyA4MC44Nzk5IDE2LjQwOTcgODUuNTk5OSAxNi4wNjk3QzkwLjMyOTkgMTUuNzI5NyA5NC45ODk5IDE2LjY2OTcgOTkuNTk5OSAxOC44ODk3QzEwNC4yMSAyMS4xMDk3IDEwOC44OSAyNC41Njk3IDExMy42NSAyOS4yODk3SDExMy42NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxKSIvPgo8cGF0aCBkPSJNNjYuMTA5OSAxNTAuNDJMMzUuODA5OSAxMjAuNEMzMy4yMjk5IDExNy44NCAzMS45NTk5IDExNS4yNyAzMS45OTk5IDExMi42N0MzMi4wMzk5IDExMC4wNyAzMy4xNDk5IDEwNy43IDM1LjMxOTkgMTA1LjU1QzM3LjU4OTkgMTAzLjMgNDAuMDM5OSAxMDIuMTYgNDIuNjU5OSAxMDIuMTFDNDUuMjc5OSAxMDIuMDcgNDcuODc5OSAxMDMuMzIgNTAuNDU5OSAxMDUuODhMODEuNDQ5OSAxMzYuNThDODQuOTc5OSAxNDAuMDcgODguMzY5OSAxNDIuNTQgOTEuNjM5OSAxNDMuOTlDOTQuOTA5OSAxNDUuNDQgOTguMzQ5OSAxNDUuNjYgMTAxLjk2IDE0NC42N0MxMDUuNTcgMTQzLjY4IDEwOS40NCAxNDEuMTMgMTEzLjU5IDEzNy4wMkMxMTkuMzEgMTMxLjM1IDEyMi4wNCAxMjYuMDMgMTIxLjc2IDEyMS4wNkMxMjEuNDggMTE2LjA5IDExOC42NCAxMTAuOTMgMTEzLjI1IDEwNS41OUw5Ni41OTk5IDg5LjI0MDFDOTMuOTg5OSA4Ni42NjAxIDkyLjcwOTkgODQuMDgwMSA5Mi43NDk5IDgxLjUyMDFDOTIuNzg5OSA3OC45NTAxIDkzLjkwOTkgNzYuNTgwMSA5Ni4xMTk5IDc0LjM5MDFDOTguMzE5OSA3Mi4yMTAxIDEwMC43NSA3MS4wNzAxIDEwMy4zOSA3MC45ODAxQzEwNi4wMyA3MC44OTAxIDEwOC42NiA3Mi4xNDAxIDExMS4yNiA3NC43MjAxTDEyNi45NiA5MC4xMzAxQzEzMS44OSA5NS4wMTAxIDEzNS40NSA5OS42MzAxIDEzNy42NCAxMDMuOTlDMTM5LjgzIDEwOC4zNSAxNDAuNjUgMTEzLjI4IDE0MC4wOCAxMTguNzhDMTM5LjU3IDEyMy40OSAxMzguMDYgMTI4LjA1IDEzNS41NCAxMzIuNDdDMTMzLjAzIDEzNi44OSAxMjkuNDMgMTQxLjQxIDEyNC43NiAxNDYuMDRDMTE5LjIgMTUxLjU1IDExMy44OSAxNTUuNzcgMTA4LjgzIDE1OC43MUMxMDMuNzcgMTYxLjY1IDk4Ljg3OTkgMTYzLjI5IDk0LjE0OTkgMTYzLjYzQzg5LjQxOTkgMTYzLjk3IDg0Ljc1OTkgMTYzLjAzIDgwLjE0OTkgMTYwLjgxQzc1LjUzOTkgMTU4LjU5IDcwLjg1OTkgMTU1LjEzIDY2LjA5OTkgMTUwLjQxTDY2LjEwOTkgMTUwLjQyWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzEwMDUwXzQxNzEpIi8+CjxwYXRoIGQ9Ik04NS4wMDk5IDcyLjk1OTJDOTEuMTU2OCA3Mi45NTkyIDk2LjEzOTkgNjcuOTc2MSA5Ni4xMzk5IDYxLjgyOTJDOTYuMTM5OSA1NS42ODIzIDkxLjE1NjggNTAuNjk5MiA4NS4wMDk5IDUwLjY5OTJDNzguODYzIDUwLjY5OTIgNzMuODc5OSA1NS42ODIzIDczLjg3OTkgNjEuODI5MkM3My44Nzk5IDY3Ljk3NjEgNzguODYzIDcyLjk1OTIgODUuMDA5OSA3Mi45NTkyWiIgZmlsbD0idXJsKCNwYWludDJfcmFkaWFsXzEwMDUwXzQxNzEpIi8+CjwvZz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iMTM4Ljk4NSIgeTE9IjQ2Ljc3OTUiIHgyPSI0NS4wNTI5IiB5Mj0iODguNTIzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMjAxQzFCIi8+CjxzdG9wIG9mZnNldD0iMC4zNiIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRCODUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iNDMuMzgxMiIgeTE9IjEzNC4xNjciIHgyPSIxNTIuMjMxIiB5Mj0iMTAxLjc3MSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMUYxRDFDIi8+CjxzdG9wIG9mZnNldD0iMC4zNyIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRGQjUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQyX3JhZGlhbF8xMDA1MF80MTcxIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDg1LjAwOTkgNjEuODM5Mikgc2NhbGUoMTEuMTMpIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y0Qjg1MiIvPgo8c3RvcCBvZmZzZXQ9IjAuMzMiIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0IiBzdG9wLWNvbG9yPSIjNzczOTBEIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzIxMUMxRCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEwMDUwXzQxNzEiPgo8cmVjdCB3aWR0aD0iMTE1Ljc3IiBoZWlnaHQ9IjE0Ny43IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzIgMTYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
  }
};
var defaultAdapters = {
  [DefaultAdaptersInfo.fordefi.id]: FordefiAdapter,
  [DefaultAdaptersInfo.xverse.id]: XverseAdapter,
  [DefaultAdaptersInfo.unisat.id]: UnisatAdapter
};
var signMessage = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { address: address2, message } = options.payload;
  if (!address2) {
    throw new Error("An address is required to sign a message");
  }
  if (!message) {
    throw new Error("A message to be signed is required");
  }
  try {
    const request2 = (0, import_jsontokens5.createUnsecuredToken)(options.payload);
    const response = await provider.signMessage(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign message request", error);
    options.onCancel?.();
  }
};
var serializer = (recipient) => {
  return recipient.map((value) => {
    const { address: address2, amountSats } = value;
    return {
      address: address2,
      amountSats: amountSats.toString()
    };
  });
};
var sendBtcTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { recipients, senderAddress, network, message } = options.payload;
  if (!recipients || recipients.length === 0) {
    throw new Error("At least one recipient is required");
  }
  if (recipients.some(
    (item) => typeof item.address !== "string" || typeof item.amountSats !== "bigint"
  )) {
    throw new Error("Incorrect recipient format");
  }
  if (!senderAddress) {
    throw new Error("The sender address is required");
  }
  try {
    const serializedRecipients = serializer(recipients);
    const serializedPayload = {
      network,
      senderAddress,
      message,
      recipients: serializedRecipients
    };
    const request2 = (0, import_jsontokens6.createUnsecuredToken)(serializedPayload);
    const response = await provider.sendBtcTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during send BTC transaction request", error);
    options.onCancel?.();
  }
};
var signTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbtBase64, inputsToSign } = options.payload;
  if (!psbtBase64) {
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  }
  if (!inputsToSign) {
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  }
  try {
    const request2 = (0, import_jsontokens7.createUnsecuredToken)(options.payload);
    const response = await provider.signTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign transaction request", error);
    options.onCancel?.();
  }
};
var signMultipleTransactions = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbts } = options.payload;
  if (!psbts || !psbts.length) {
    throw new Error("psbts array is required");
  }
  if (psbts.length > 100) {
    throw new Error("psbts array must contain less than 100 psbts");
  }
  try {
    const request2 = (0, import_jsontokens8.createUnsecuredToken)(options.payload);
    const response = await provider.signMultipleTransactions(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign Multiple transactions request", error);
    options.onCancel?.();
  }
};

// node_modules/sats-connect/node_modules/@sats-connect/make-default-provider-config/node_modules/@sats-connect/ui/dist/index.js
var me = Symbol("solid-proxy");
var yt = Symbol("solid-track");
var m2 = null;
function T(e2) {
  if (m2 === null)
    return e2();
  const t2 = m2;
  m2 = null;
  try {
    return e2();
  } finally {
    m2 = t2;
  }
}
var St = Symbol("fallback");
var Ot = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
var jt = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  ...Ot
]);
var Nt = Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
var zt = Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function C2(e2, t2, n2) {
  let i2;
  const r2 = () => {
    const l2 = document.createElement("template");
    return l2.innerHTML = e2, n2 ? l2.content.firstChild.firstChild : l2.content.firstChild;
  }, s2 = t2 ? () => T(() => document.importNode(i2 || (i2 = r2()), true)) : () => (i2 || (i2 = r2())).cloneNode(true);
  return s2.cloneNode = s2, s2;
}
var en = C2('<svg width=24 height=24 viewBox="0 0 24 24"fill=none xmlns=http://www.w3.org/2000/svg><g id=XCircle><path id=Vector d="M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.745 9.41566 20.7162 6.93859 18.8888 5.11118C17.0614 3.28378 14.5843 2.25496 12 2.25ZM15.5344 14.4656C15.6752 14.6078 15.7542 14.7999 15.7542 15C15.7542 15.2001 15.6752 15.3922 15.5344 15.5344C15.391 15.673 15.1994 15.7505 15 15.7505C14.8006 15.7505 14.609 15.673 14.4656 15.5344L12 13.0594L9.53438 15.5344C9.39102 15.673 9.19942 15.7505 9 15.7505C8.80059 15.7505 8.60898 15.673 8.46563 15.5344C8.32479 15.3922 8.24578 15.2001 8.24578 15C8.24578 14.7999 8.32479 14.6078 8.46563 14.4656L10.9406 12L8.46563 9.53437C8.34603 9.38865 8.28491 9.20366 8.29416 9.01537C8.30341 8.82708 8.38236 8.64896 8.51566 8.51566C8.64896 8.38236 8.82708 8.3034 9.01537 8.29416C9.20366 8.28491 9.38866 8.34603 9.53438 8.46563L12 10.9406L14.4656 8.46563C14.6114 8.34603 14.7963 8.28491 14.9846 8.29416C15.1729 8.3034 15.351 8.38236 15.4843 8.51566C15.6176 8.64896 15.6966 8.82708 15.7058 9.01537C15.7151 9.20366 15.654 9.38865 15.5344 9.53437L13.0594 12L15.5344 14.4656Z"fill=black fill-opacity=0.3>');
var tn = C2(`<style>
          .close-selector-button:focus-visible {
            outline: 2px solid #181818;
            outline-offset: -0.25px;
          }
        `);
var nn = C2("<div role=button tabindex=0 class=close-selector-button>");
var on = C2(`<style>
/*! modern-normalize v2.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */

/*
Document
========
*/

/**
Use a better box model (opinionated).
*/

*,
::before,
::after {
	box-sizing: border-box;
	margin: 0; /* Remove all margins from everywhere. */
}

:host {
	/* Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3) */
	font-family:
		'DM Sans', /* Note: not part of modern-normalize, added specifically for this project. */
		system-ui,
		'Segoe UI',
		Roboto,
		Helvetica,
		Arial,
		sans-serif,
		'Apple Color Emoji',
		'Segoe UI Emoji';
	line-height: 1.15; /* 1. Correct the line height in all browsers. */
	-webkit-text-size-adjust: 100%; /* 2. Prevent adjustments of font size after orientation changes in iOS. */
	-moz-tab-size: 4; /* 3. Use a more readable tab size (opinionated). */
	tab-size: 4; /* 3 */
}

/*
Sections
========
*/

:host {
	margin: 0; /* Remove the margin in all browsers. */
}

/*
Grouping content
================
*/

/**
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
*/

hr {
	height: 0; /* 1 */
	color: inherit; /* 2 */
}

/*
Text-level semantics
====================
*/

/**
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr[title] {
	text-decoration: underline dotted;
}

/**
Add the correct font weight in Edge and Safari.
*/

b,
strong {
	font-weight: bolder;
}

/**
1. Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)
2. Correct the odd 'em' font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
	font-family:
		ui-monospace,
		SFMono-Regular,
		Consolas,
		'Liberation Mono',
		Menlo,
		monospace; /* 1 */
	font-size: 1em; /* 2 */
}

/**
Add the correct font size in all browsers.
*/

small {
	font-size: 80%;
}

/**
Prevent 'sub' and 'sup' elements from affecting the line height in all browsers.
*/

sub,
sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}

sub {
	bottom: -0.25em;
}

sup {
	top: -0.5em;
}

/*
Tabular data
============
*/

/**
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
*/

table {
	text-indent: 0; /* 1 */
	border-color: inherit; /* 2 */
}

/*
Forms
=====
*/

/**
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
*/

button,
input,
optgroup,
select,
textarea {
	font-family: inherit; /* 1 */
	font-size: 100%; /* 1 */
	line-height: 1.15; /* 1 */
	margin: 0; /* 2 */
}

/**
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
	text-transform: none;
}

/**
Correct the inability to style clickable types in iOS and Safari.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
	-webkit-appearance: button;
}

/**
Remove the inner border and padding in Firefox.
*/

::-moz-focus-inner {
	border-style: none;
	padding: 0;
}

/**
Restore the focus styles unset by the previous rule.
*/

:-moz-focusring {
	outline: 1px dotted ButtonText;
}

/**
Remove the additional ':invalid' styles in Firefox.
See: https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737
*/

:-moz-ui-invalid {
	box-shadow: none;
}

/**
Remove the padding so developers are not caught out when they zero out 'fieldset' elements in all browsers.
*/

legend {
	padding: 0;
}

/**
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
	vertical-align: baseline;
}

/**
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
	height: auto;
}

/**
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
	-webkit-appearance: textfield; /* 1 */
	outline-offset: -2px; /* 2 */
}

/**
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
	-webkit-appearance: none;
}

/**
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to 'inherit' in Safari.
*/

::-webkit-file-upload-button {
	-webkit-appearance: button; /* 1 */
	font: inherit; /* 2 */
}

/*
Interactive
===========
*/

/*
Add the correct display in Chrome and Safari.
*/

summary {
	display: list-item;
}
`);
var an = C2("<div class=divider><div>");
var un = C2("<div>");
var fn = C2("<div>");
var pn = C2("<div><div></div><div>What is a wallet?</div><p>Wallets let you send, receive, store and display digital assets like Bitcoin, Stacks, Ordinals & NFTs.</p><p>Explore Bitcoin apps by connecting your wallet.");
var gn = C2(`<style>
          .install-prompt-button:focus-visible {
            outline: 2px solid #181818;
            outline-offset: 2px;
          }
        `);
var mn = C2("<div><img><h1>Don't have <!>?</h1><p>Download it on the Chrome web store.</p><div class=install-prompt-button role=button tabindex=0>Get");
var wn = C2('<svg width=20 height=20 viewBox="0 0 20 20"xmlns=http://www.w3.org/2000/svg><circle cx=10 cy=10 r=9.05 stroke=black stroke-width=1.9 fill=none stroke-dasharray="42.65 14.22"stroke-dashoffset=0><animateTransform attributeName=transform attributeType=XML type=rotate from="0 10 10"to="360 10 10"dur=0.75s repeatCount=indefinite>');
var vn = C2("<div>");
var Pn = C2("<div><img><h1>Opening <!>...</h1><p>Confirm the operation in ");
var _n = C2("<div><div tabindex=0><img><div>");
var kn = C2('<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&amp;display=swap"rel=stylesheet>');
var $n = C2("<div class=side-panel>");
var An = C2('<div><div></div><div><div class=card-width-container><div class=card-height-container><div class=card><div class=card-grid><div class=main-panel><div></div><div></div><div class=wallets-grid-container data-desc="wallet grid container for padding"><div class=wallets-grid data-desc="wallet grid container">');
var Ln = C2(`<div><style>
        @keyframes wallet-selector-fade-in {
          from {opacity: 0; transform: translateY(40px);}
          to {opacity: 1; transform: translateY(0);}
        }

        @keyframes wallet-selector-fade-out {
          from {opacity: 1; transform: translateY(0);}
          to {opacity: 0; transform: translateY(40px);}
        }
        @keyframes wallet-selector-blur-in {
          from {opacity: 0; backdrop-filter: blur(0px);}
          to {opacity: 1; backdrop-filter: blur(10px);}
        }

        @keyframes wallet-selector-blur-out {
          from {opacity: 1; backdrop-filter: blur(10px);}
          to {opacity: 0; backdrop-filter: blur(0px);}
        }
      </style><style>`);

// node_modules/bowser/src/constants.js
var BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  "Pale Moon": "pale_moon",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  pale_moon: "Pale Moon",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv",
  bot: "bot"
};
var OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};

// node_modules/bowser/src/utils.js
var Utils = class _Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version2) {
    switch (version2) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version2) {
    const v2 = version2.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] !== 10) return void 0;
    switch (v2[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version2) {
    const v2 = version2.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] === 1 && v2[1] < 5) return void 0;
    if (v2[0] === 1 && v2[1] < 6) return "Cupcake";
    if (v2[0] === 1 && v2[1] >= 6) return "Donut";
    if (v2[0] === 2 && v2[1] < 2) return "Eclair";
    if (v2[0] === 2 && v2[1] === 2) return "Froyo";
    if (v2[0] === 2 && v2[1] > 2) return "Gingerbread";
    if (v2[0] === 3) return "Honeycomb";
    if (v2[0] === 4 && v2[1] < 1) return "Ice Cream Sandwich";
    if (v2[0] === 4 && v2[1] < 4) return "Jelly Bean";
    if (v2[0] === 4 && v2[1] >= 4) return "KitKat";
    if (v2[0] === 5) return "Lollipop";
    if (v2[0] === 6) return "Marshmallow";
    if (v2[0] === 7) return "Nougat";
    if (v2[0] === 8) return "Oreo";
    if (v2[0] === 9) return "Pie";
    return void 0;
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version2) {
    return version2.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = _Utils.getVersionPrecision(versionA);
    const versionBPrecision = _Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = _Utils.map([versionA, versionB], (version2) => {
      const delta = precision - _Utils.getVersionPrecision(version2);
      const _version = version2 + new Array(delta + 1).join(".0");
      return _Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i2;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i2 = 0; i2 < arr.length; i2 += 1) {
      result.push(iterator(arr[i2]));
    }
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i2;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i2 = 0, l2 = arr.length; i2 < l2; i2 += 1) {
      const value = arr[i2];
      if (predicate(value, i2)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i2;
    let l2;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i2 = 0, l2 = assigners.length; i2 < l2; i2 += 1) {
      const assigner = assigners[i2];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get browser name for a short version/alias
   *
   * @example
   *   getBrowserTypeByAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
};

// node_modules/bowser/src/parser-browsers.js
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      };
      const version2 = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/PaleMoon/i],
    describe(ua) {
      const browser = {
        name: "Pale Moon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      };
      const version2 = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      };
      const version2 = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      };
      const version2 = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      };
      const version2 = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      };
      const version2 = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      };
      const version2 = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      };
      const version2 = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      };
      const version2 = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      };
      const version2 = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      };
      const version2 = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      };
      const version2 = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      };
      const version2 = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      };
      const version2 = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      };
      const version2 = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      };
      const version2 = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      };
      const version2 = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      };
      const version2 = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      };
      const version2 = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      };
      const version2 = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      };
      const version2 = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser.version = version2;
      }
      return browser;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
var parser_browsers_default = browsersList;

// node_modules/bowser/src/parser-os.js
var parser_os_default = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version: version2
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version: version2
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version2);
      return {
        name: OS_MAP.Windows,
        version: version2,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version2 = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version2) {
        result.version = version2;
      }
      return result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version2);
      const os = {
        name: OS_MAP.MacOS,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: version2
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version2 = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version2);
      const os = {
        name: OS_MAP.Android,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version2 && version2.length) {
        os.version = version2;
      }
      return os;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version: version2
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version: version2
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version: version2
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version: version2
      };
    }
  }
];

// node_modules/bowser/src/parser-platforms.js
var parser_platforms_default = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: PLATFORMS_MAP.bot,
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Nokia */
  {
    test: [/Nokia/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i, ua);
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nokia"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];

// node_modules/bowser/src/parser-engines.js
var parser_engines_default = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version2 = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: version2
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version2 = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version2 = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version2 = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version2 = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  }
];

// node_modules/bowser/src/parser.js
var Parser = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(parser_browsers_default, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (Array.isArray(_browser.test)) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(parser_os_default, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (Array.isArray(_os.test)) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    if (toLowerCase) {
      return String(name).toLowerCase() || "";
    }
    return name || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(parser_platforms_default, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (Array.isArray(_platform.test)) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(parser_engines_default, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (Array.isArray(_engine.test)) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name) => this.isPlatform(name)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  /**
   * Check if the browser name equals the passed string
   * @param {string} browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version2) {
    let expectedResults = [0];
    let comparableVersion = version2;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version2[0] === ">" || version2[0] === "<") {
      comparableVersion = version2.substr(1);
      if (version2[1] === "=") {
        isLoose = true;
        comparableVersion = version2.substr(2);
      } else {
        expectedResults = [];
      }
      if (version2[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version2[0] === "=") {
      comparableVersion = version2.substr(1);
    } else if (version2[0] === "~") {
      isLoose = true;
      comparableVersion = version2.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  /**
   * Check if the OS name equals the passed string
   * @param {string} osName The string to compare with the OS name
   * @returns {boolean}
   */
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  /**
   * Check if the platform type equals the passed string
   * @param {string} platformType The string to compare with the platform type
   * @returns {boolean}
   */
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  /**
   * Check if the engine name equals the passed string
   * @param {string} engineName The string to compare with the engine name
   * @returns {boolean}
   */
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
};
var parser_default = Parser;

// node_modules/bowser/src/bowser.js
var Bowser = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new parser_default(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new parser_default(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
};
var bowser_default = Bowser;

// node_modules/sats-connect/node_modules/@sats-connect/make-default-provider-config/dist/isXverseInAppBrowser.js
function isXverseInAppBrowser() {
  return typeof window.ReactNativeWebView !== "undefined";
}

// node_modules/sats-connect/node_modules/@sats-connect/make-default-provider-config/dist/index.js
function appStoreUrl(p2) {
  const browser = bowser_default.getParser(window.navigator.userAgent);
  if (browser.satisfies({
    desktop: {
      chrome: ">=1"
    }
  })) {
    return p2.chromeWebStoreUrl;
  }
  if (browser.satisfies({
    desktop: {
      firefox: ">=1"
    }
  })) {
    return p2.mozillaAddOnsUrl;
  }
  if (browser.satisfies({
    android: {
      chrome: ">=1",
      safari: ">=1"
    }
  })) {
    return p2.googlePlayStoreUrl;
  }
  if (browser.satisfies({
    ios: {
      chrome: ">=1",
      safari: ">=1"
    }
  })) {
    return p2.iOSAppStoreUrl;
  }
}
function getInstallPrompt(provider) {
  const url = appStoreUrl(provider);
  if (url)
    return { installPrompt: { url } };
  console.error(`[makeDefaultConfig]: No app store URL found for ${provider.name}.`);
  return {};
}
function makeDefaultConfig(providers) {
  const config = { options: [] };
  const xverseProvider = providers.find((provider) => provider.id === DefaultAdaptersInfo.xverse.id);
  config.options.push(xverseProvider ? xverseProvider : {
    ...DefaultAdaptersInfo.xverse,
    ...getInstallPrompt(DefaultAdaptersInfo.xverse)
  });
  if (isXverseInAppBrowser()) {
    return config;
  }
  const unisatProvider = providers.find((provider) => provider.id === "unisat");
  if (unisatProvider && unisatProvider.isInstalled) {
    config.options.push(unisatProvider);
  }
  config.options = config.options.concat(providers.filter((provider) => {
    return provider.id !== DefaultAdaptersInfo.xverse.id && provider.id !== "unisat";
  }).map((provider) => {
    return {
      ...provider,
      ...provider.isInstalled ? {} : getInstallPrompt(provider)
    };
  }));
  return config;
}

// node_modules/@sats-connect/ui/dist/index.js
function st(e2) {
  return Object.keys(e2).reduce((n2, i2) => {
    const r2 = e2[i2];
    return n2[i2] = Object.assign({}, r2), ze(r2.value) && !ut(r2.value) && !Array.isArray(r2.value) && (n2[i2].value = Object.assign({}, r2.value)), Array.isArray(r2.value) && (n2[i2].value = r2.value.slice(0)), n2;
  }, {});
}
function ot(e2) {
  return e2 ? Object.keys(e2).reduce((n2, i2) => {
    const r2 = e2[i2];
    return n2[i2] = ze(r2) && "value" in r2 ? r2 : {
      value: r2
    }, n2[i2].attribute || (n2[i2].attribute = ct(i2)), n2[i2].parse = "parse" in n2[i2] ? n2[i2].parse : typeof n2[i2].value != "string", n2;
  }, {}) : {};
}
function lt(e2) {
  return Object.keys(e2).reduce((n2, i2) => (n2[i2] = e2[i2].value, n2), {});
}
function at(e2, t2) {
  const n2 = st(t2);
  return Object.keys(t2).forEach((r2) => {
    const s2 = n2[r2], l2 = e2.getAttribute(s2.attribute), o2 = e2[r2];
    l2 && (s2.value = s2.parse ? Ne(l2) : l2), o2 != null && (s2.value = Array.isArray(o2) ? o2.slice(0) : o2), s2.reflect && $e(e2, s2.attribute, s2.value), Object.defineProperty(e2, r2, {
      get() {
        return s2.value;
      },
      set(c2) {
        const f2 = s2.value;
        s2.value = c2, s2.reflect && $e(this, s2.attribute, s2.value);
        for (let a2 = 0, u2 = this.__propertyChangedCallbacks.length; a2 < u2; a2++)
          this.__propertyChangedCallbacks[a2](r2, c2, f2);
      },
      enumerable: true,
      configurable: true
    });
  }), n2;
}
function Ne(e2) {
  if (e2)
    try {
      return JSON.parse(e2);
    } catch {
      return e2;
    }
}
function $e(e2, t2, n2) {
  if (n2 == null || n2 === false)
    return e2.removeAttribute(t2);
  let i2 = JSON.stringify(n2);
  e2.__updating[t2] = true, i2 === "true" && (i2 = ""), e2.setAttribute(t2, i2), Promise.resolve().then(() => delete e2.__updating[t2]);
}
function ct(e2) {
  return e2.replace(/\.?([A-Z]+)/g, (t2, n2) => "-" + n2.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function ze(e2) {
  return e2 != null && (typeof e2 == "object" || typeof e2 == "function");
}
function ut(e2) {
  return Object.prototype.toString.call(e2) === "[object Function]";
}
function dt(e2) {
  return typeof e2 == "function" && e2.toString().indexOf("class") === 0;
}
var ue;
function ft(e2, t2) {
  const n2 = Object.keys(t2);
  return class extends e2 {
    static get observedAttributes() {
      return n2.map((r2) => t2[r2].attribute);
    }
    constructor() {
      super(), this.__initialized = false, this.__released = false, this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = {};
    }
    connectedCallback() {
      if (this.__initialized)
        return;
      this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = at(this, t2);
      const r2 = lt(this.props), s2 = this.Component, l2 = ue;
      try {
        ue = this, this.__initialized = true, dt(s2) ? new s2(r2, {
          element: this
        }) : s2(r2, {
          element: this
        });
      } finally {
        ue = l2;
      }
    }
    async disconnectedCallback() {
      if (await Promise.resolve(), this.isConnected)
        return;
      this.__propertyChangedCallbacks.length = 0;
      let r2 = null;
      for (; r2 = this.__releaseCallbacks.pop(); )
        r2(this);
      delete this.__initialized, this.__released = true;
    }
    attributeChangedCallback(r2, s2, l2) {
      if (this.__initialized && !this.__updating[r2] && (r2 = this.lookupProp(r2), r2 in t2)) {
        if (l2 == null && !this[r2])
          return;
        this[r2] = t2[r2].parse ? Ne(l2) : l2;
      }
    }
    lookupProp(r2) {
      if (t2)
        return n2.find((s2) => r2 === s2 || r2 === t2[s2].attribute);
    }
    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }
    addReleaseCallback(r2) {
      this.__releaseCallbacks.push(r2);
    }
    addPropertyChangedCallback(r2) {
      this.__propertyChangedCallbacks.push(r2);
    }
  };
}
function ht(e2, t2 = {}, n2 = {}) {
  const {
    BaseElement: i2 = HTMLElement,
    extension: r2
  } = n2;
  return (s2) => {
    if (!e2)
      throw new Error("tag is required to register a Component");
    let l2 = customElements.get(e2);
    return l2 ? (l2.prototype.Component = s2, l2) : (l2 = ft(i2, ot(t2)), l2.prototype.Component = s2, l2.prototype.registeredTag = e2, customElements.define(e2, l2, r2), l2);
  };
}
var pt = (e2, t2) => e2 === t2;
var me2 = Symbol("solid-proxy");
var yt2 = Symbol("solid-track");
var J = {
  equals: pt
};
var Re = De;
var M = 1;
var Q = 2;
var Ie = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var w2 = null;
var de = null;
var m3 = null;
var S = null;
var I2 = null;
var ne = 0;
function Z(e2, t2) {
  const n2 = m3, i2 = w2, r2 = e2.length === 0, s2 = t2 === void 0 ? i2 : t2, l2 = r2 ? Ie : {
    owned: null,
    cleanups: null,
    context: s2 ? s2.context : null,
    owner: s2
  }, o2 = r2 ? e2 : () => e2(() => T2(() => ie(l2)));
  w2 = l2, m3 = null;
  try {
    return V(o2, true);
  } finally {
    m3 = n2, w2 = i2;
  }
}
function j(e2, t2) {
  t2 = t2 ? Object.assign({}, J, t2) : J;
  const n2 = {
    value: e2,
    observers: null,
    observerSlots: null,
    comparator: t2.equals || void 0
  }, i2 = (r2) => (typeof r2 == "function" && (r2 = r2(n2.value)), Be(n2, r2));
  return [Ke.bind(n2), i2];
}
function A2(e2, t2, n2) {
  const i2 = _e(e2, t2, false, M);
  q(i2);
}
function Fe(e2, t2, n2) {
  Re = Ct;
  const i2 = _e(e2, t2, false, M);
  (!n2 || !n2.render) && (i2.user = true), I2 ? I2.push(i2) : q(i2);
}
function F(e2, t2, n2) {
  n2 = n2 ? Object.assign({}, J, n2) : J;
  const i2 = _e(e2, t2, true, 0);
  return i2.observers = null, i2.observerSlots = null, i2.comparator = n2.equals || void 0, q(i2), Ke.bind(i2);
}
function mt(e2) {
  return V(e2, false);
}
function T2(e2) {
  if (m3 === null)
    return e2();
  const t2 = m3;
  m3 = null;
  try {
    return e2();
  } finally {
    m3 = t2;
  }
}
function bt(e2) {
  Fe(() => T2(e2));
}
function Me(e2) {
  return w2 === null || (w2.cleanups === null ? w2.cleanups = [e2] : w2.cleanups.push(e2)), e2;
}
function wt(e2) {
  const t2 = F(e2), n2 = F(() => be(t2()));
  return n2.toArray = () => {
    const i2 = n2();
    return Array.isArray(i2) ? i2 : i2 != null ? [i2] : [];
  }, n2;
}
function Ke() {
  if (this.sources && this.state)
    if (this.state === M)
      q(this);
    else {
      const e2 = S;
      S = null, V(() => te(this), false), S = e2;
    }
  if (m3) {
    const e2 = this.observers ? this.observers.length : 0;
    m3.sources ? (m3.sources.push(this), m3.sourceSlots.push(e2)) : (m3.sources = [this], m3.sourceSlots = [e2]), this.observers ? (this.observers.push(m3), this.observerSlots.push(m3.sources.length - 1)) : (this.observers = [m3], this.observerSlots = [m3.sources.length - 1]);
  }
  return this.value;
}
function Be(e2, t2, n2) {
  let i2 = e2.value;
  return (!e2.comparator || !e2.comparator(i2, t2)) && (e2.value = t2, e2.observers && e2.observers.length && V(() => {
    for (let r2 = 0; r2 < e2.observers.length; r2 += 1) {
      const s2 = e2.observers[r2], l2 = de && de.running;
      l2 && de.disposed.has(s2), (l2 ? !s2.tState : !s2.state) && (s2.pure ? S.push(s2) : I2.push(s2), s2.observers && Ue(s2)), l2 || (s2.state = M);
    }
    if (S.length > 1e6)
      throw S = [], new Error();
  }, false)), t2;
}
function q(e2) {
  if (!e2.fn)
    return;
  ie(e2);
  const t2 = ne;
  vt(
    e2,
    e2.value,
    t2
  );
}
function vt(e2, t2, n2) {
  let i2;
  const r2 = w2, s2 = m3;
  m3 = w2 = e2;
  try {
    i2 = e2.fn(t2);
  } catch (l2) {
    return e2.pure && (e2.state = M, e2.owned && e2.owned.forEach(ie), e2.owned = null), e2.updatedAt = n2 + 1, We(l2);
  } finally {
    m3 = s2, w2 = r2;
  }
  (!e2.updatedAt || e2.updatedAt <= n2) && (e2.updatedAt != null && "observers" in e2 ? Be(e2, i2) : e2.value = i2, e2.updatedAt = n2);
}
function _e(e2, t2, n2, i2 = M, r2) {
  const s2 = {
    fn: e2,
    state: i2,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: t2,
    owner: w2,
    context: w2 ? w2.context : null,
    pure: n2
  };
  return w2 === null || w2 !== Ie && (w2.owned ? w2.owned.push(s2) : w2.owned = [s2]), s2;
}
function ee(e2) {
  if (e2.state === 0)
    return;
  if (e2.state === Q)
    return te(e2);
  if (e2.suspense && T2(e2.suspense.inFallback))
    return e2.suspense.effects.push(e2);
  const t2 = [e2];
  for (; (e2 = e2.owner) && (!e2.updatedAt || e2.updatedAt < ne); )
    e2.state && t2.push(e2);
  for (let n2 = t2.length - 1; n2 >= 0; n2--)
    if (e2 = t2[n2], e2.state === M)
      q(e2);
    else if (e2.state === Q) {
      const i2 = S;
      S = null, V(() => te(e2, t2[0]), false), S = i2;
    }
}
function V(e2, t2) {
  if (S)
    return e2();
  let n2 = false;
  t2 || (S = []), I2 ? n2 = true : I2 = [], ne++;
  try {
    const i2 = e2();
    return xt(n2), i2;
  } catch (i2) {
    n2 || (I2 = null), S = null, We(i2);
  }
}
function xt(e2) {
  if (S && (De(S), S = null), e2)
    return;
  const t2 = I2;
  I2 = null, t2.length && V(() => Re(t2), false);
}
function De(e2) {
  for (let t2 = 0; t2 < e2.length; t2++)
    ee(e2[t2]);
}
function Ct(e2) {
  let t2, n2 = 0;
  for (t2 = 0; t2 < e2.length; t2++) {
    const i2 = e2[t2];
    i2.user ? e2[n2++] = i2 : ee(i2);
  }
  for (t2 = 0; t2 < n2; t2++)
    ee(e2[t2]);
}
function te(e2, t2) {
  e2.state = 0;
  for (let n2 = 0; n2 < e2.sources.length; n2 += 1) {
    const i2 = e2.sources[n2];
    if (i2.sources) {
      const r2 = i2.state;
      r2 === M ? i2 !== t2 && (!i2.updatedAt || i2.updatedAt < ne) && ee(i2) : r2 === Q && te(i2, t2);
    }
  }
}
function Ue(e2) {
  for (let t2 = 0; t2 < e2.observers.length; t2 += 1) {
    const n2 = e2.observers[t2];
    n2.state || (n2.state = Q, n2.pure ? S.push(n2) : I2.push(n2), n2.observers && Ue(n2));
  }
}
function ie(e2) {
  let t2;
  if (e2.sources)
    for (; e2.sources.length; ) {
      const n2 = e2.sources.pop(), i2 = e2.sourceSlots.pop(), r2 = n2.observers;
      if (r2 && r2.length) {
        const s2 = r2.pop(), l2 = n2.observerSlots.pop();
        i2 < r2.length && (s2.sourceSlots[l2] = i2, r2[i2] = s2, n2.observerSlots[i2] = l2);
      }
    }
  if (e2.owned) {
    for (t2 = e2.owned.length - 1; t2 >= 0; t2--)
      ie(e2.owned[t2]);
    e2.owned = null;
  }
  if (e2.cleanups) {
    for (t2 = e2.cleanups.length - 1; t2 >= 0; t2--)
      e2.cleanups[t2]();
    e2.cleanups = null;
  }
  e2.state = 0;
}
function Pt(e2) {
  return e2 instanceof Error ? e2 : new Error(typeof e2 == "string" ? e2 : "Unknown error", {
    cause: e2
  });
}
function We(e2, t2 = w2) {
  throw Pt(e2);
}
function be(e2) {
  if (typeof e2 == "function" && !e2.length)
    return be(e2());
  if (Array.isArray(e2)) {
    const t2 = [];
    for (let n2 = 0; n2 < e2.length; n2++) {
      const i2 = be(e2[n2]);
      Array.isArray(i2) ? t2.push.apply(t2, i2) : t2.push(i2);
    }
    return t2;
  }
  return e2;
}
var St2 = Symbol("fallback");
function Ae(e2) {
  for (let t2 = 0; t2 < e2.length; t2++)
    e2[t2]();
}
function _t(e2, t2, n2 = {}) {
  let i2 = [], r2 = [], s2 = [], l2 = 0, o2 = t2.length > 1 ? [] : null;
  return Me(() => Ae(s2)), () => {
    let c2 = e2() || [], f2, a2;
    return c2[yt2], T2(() => {
      let d2 = c2.length, h2, v2, y2, z2, $, P, _2, E2, R;
      if (d2 === 0)
        l2 !== 0 && (Ae(s2), s2 = [], i2 = [], r2 = [], l2 = 0, o2 && (o2 = [])), n2.fallback && (i2 = [St2], r2[0] = Z((se) => (s2[0] = se, n2.fallback())), l2 = 1);
      else if (l2 === 0) {
        for (r2 = new Array(d2), a2 = 0; a2 < d2; a2++)
          i2[a2] = c2[a2], r2[a2] = Z(u2);
        l2 = d2;
      } else {
        for (y2 = new Array(d2), z2 = new Array(d2), o2 && ($ = new Array(d2)), P = 0, _2 = Math.min(l2, d2); P < _2 && i2[P] === c2[P]; P++)
          ;
        for (_2 = l2 - 1, E2 = d2 - 1; _2 >= P && E2 >= P && i2[_2] === c2[E2]; _2--, E2--)
          y2[E2] = r2[_2], z2[E2] = s2[_2], o2 && ($[E2] = o2[_2]);
        for (h2 = /* @__PURE__ */ new Map(), v2 = new Array(E2 + 1), a2 = E2; a2 >= P; a2--)
          R = c2[a2], f2 = h2.get(R), v2[a2] = f2 === void 0 ? -1 : f2, h2.set(R, a2);
        for (f2 = P; f2 <= _2; f2++)
          R = i2[f2], a2 = h2.get(R), a2 !== void 0 && a2 !== -1 ? (y2[a2] = r2[f2], z2[a2] = s2[f2], o2 && ($[a2] = o2[f2]), a2 = v2[a2], h2.set(R, a2)) : s2[f2]();
        for (a2 = P; a2 < d2; a2++)
          a2 in y2 ? (r2[a2] = y2[a2], s2[a2] = z2[a2], o2 && (o2[a2] = $[a2], o2[a2](a2))) : r2[a2] = Z(u2);
        r2 = r2.slice(0, l2 = d2), i2 = c2.slice(0);
      }
      return r2;
    });
    function u2(d2) {
      if (s2[a2] = d2, o2) {
        const [h2, v2] = j(a2);
        return o2[a2] = v2, t2(c2[a2], h2);
      }
      return t2(c2[a2]);
    }
  };
}
function g2(e2, t2) {
  return T2(() => e2(t2 || {}));
}
function Y() {
  return true;
}
var Et = {
  get(e2, t2, n2) {
    return t2 === me2 ? n2 : e2.get(t2);
  },
  has(e2, t2) {
    return t2 === me2 ? true : e2.has(t2);
  },
  set: Y,
  deleteProperty: Y,
  getOwnPropertyDescriptor(e2, t2) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return e2.get(t2);
      },
      set: Y,
      deleteProperty: Y
    };
  },
  ownKeys(e2) {
    return e2.keys();
  }
};
function fe(e2) {
  return (e2 = typeof e2 == "function" ? e2() : e2) ? e2 : {};
}
function kt() {
  for (let e2 = 0, t2 = this.length; e2 < t2; ++e2) {
    const n2 = this[e2]();
    if (n2 !== void 0)
      return n2;
  }
}
function $t(...e2) {
  let t2 = false;
  for (let l2 = 0; l2 < e2.length; l2++) {
    const o2 = e2[l2];
    t2 = t2 || !!o2 && me2 in o2, e2[l2] = typeof o2 == "function" ? (t2 = true, F(o2)) : o2;
  }
  if (t2)
    return new Proxy(
      {
        get(l2) {
          for (let o2 = e2.length - 1; o2 >= 0; o2--) {
            const c2 = fe(e2[o2])[l2];
            if (c2 !== void 0)
              return c2;
          }
        },
        has(l2) {
          for (let o2 = e2.length - 1; o2 >= 0; o2--)
            if (l2 in fe(e2[o2]))
              return true;
          return false;
        },
        keys() {
          const l2 = [];
          for (let o2 = 0; o2 < e2.length; o2++)
            l2.push(...Object.keys(fe(e2[o2])));
          return [...new Set(l2)];
        }
      },
      Et
    );
  const n2 = {}, i2 = /* @__PURE__ */ Object.create(null);
  for (let l2 = e2.length - 1; l2 >= 0; l2--) {
    const o2 = e2[l2];
    if (!o2)
      continue;
    const c2 = Object.getOwnPropertyNames(o2);
    for (let f2 = c2.length - 1; f2 >= 0; f2--) {
      const a2 = c2[f2];
      if (a2 === "__proto__" || a2 === "constructor")
        continue;
      const u2 = Object.getOwnPropertyDescriptor(o2, a2);
      if (!i2[a2])
        i2[a2] = u2.get ? {
          enumerable: true,
          configurable: true,
          get: kt.bind(n2[a2] = [u2.get.bind(o2)])
        } : u2.value !== void 0 ? u2 : void 0;
      else {
        const d2 = n2[a2];
        d2 && (u2.get ? d2.push(u2.get.bind(o2)) : u2.value !== void 0 && d2.push(() => u2.value));
      }
    }
  }
  const r2 = {}, s2 = Object.keys(i2);
  for (let l2 = s2.length - 1; l2 >= 0; l2--) {
    const o2 = s2[l2], c2 = i2[o2];
    c2 && c2.get ? Object.defineProperty(r2, o2, c2) : r2[o2] = c2 ? c2.value : void 0;
  }
  return r2;
}
var Ve = (e2) => `Stale read from <${e2}>.`;
function At(e2) {
  const t2 = "fallback" in e2 && {
    fallback: () => e2.fallback
  };
  return F(_t(() => e2.each, e2.children, t2 || void 0));
}
function he(e2) {
  const t2 = e2.keyed, n2 = F(() => e2.when, void 0, {
    equals: (i2, r2) => t2 ? i2 === r2 : !i2 == !r2
  });
  return F(
    () => {
      const i2 = n2();
      if (i2) {
        const r2 = e2.children;
        return typeof r2 == "function" && r2.length > 0 ? T2(
          () => r2(
            t2 ? i2 : () => {
              if (!T2(n2))
                throw Ve("Show");
              return e2.when;
            }
          )
        ) : r2;
      }
      return e2.fallback;
    },
    void 0,
    void 0
  );
}
function Lt(e2) {
  let t2 = false;
  const n2 = (s2, l2) => (t2 ? s2[1] === l2[1] : !s2[1] == !l2[1]) && s2[2] === l2[2], i2 = wt(() => e2.children), r2 = F(
    () => {
      let s2 = i2();
      Array.isArray(s2) || (s2 = [s2]);
      for (let l2 = 0; l2 < s2.length; l2++) {
        const o2 = s2[l2].when;
        if (o2)
          return t2 = !!s2[l2].keyed, [l2, o2, s2[l2]];
      }
      return [-1];
    },
    void 0,
    {
      equals: n2
    }
  );
  return F(
    () => {
      const [s2, l2, o2] = r2();
      if (s2 < 0)
        return e2.fallback;
      const c2 = o2.children;
      return typeof c2 == "function" && c2.length > 0 ? T2(
        () => c2(
          t2 ? l2 : () => {
            if (T2(r2)[0] !== s2)
              throw Ve("Match");
            return o2.when;
          }
        )
      ) : c2;
    },
    void 0,
    void 0
  );
}
function pe(e2) {
  return e2;
}
var Ot2 = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
var jt2 = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  ...Ot2
]);
var Tt = /* @__PURE__ */ new Set([
  "innerHTML",
  "textContent",
  "innerText",
  "children"
]);
var Nt2 = Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
var zt2 = Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function Rt(e2, t2) {
  const n2 = zt2[e2];
  return typeof n2 == "object" ? n2[t2] ? n2.$ : void 0 : n2;
}
var It = /* @__PURE__ */ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]);
var Ft = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};
function Mt(e2, t2, n2) {
  let i2 = n2.length, r2 = t2.length, s2 = i2, l2 = 0, o2 = 0, c2 = t2[r2 - 1].nextSibling, f2 = null;
  for (; l2 < r2 || o2 < s2; ) {
    if (t2[l2] === n2[o2]) {
      l2++, o2++;
      continue;
    }
    for (; t2[r2 - 1] === n2[s2 - 1]; )
      r2--, s2--;
    if (r2 === l2) {
      const a2 = s2 < i2 ? o2 ? n2[o2 - 1].nextSibling : n2[s2 - o2] : c2;
      for (; o2 < s2; )
        e2.insertBefore(n2[o2++], a2);
    } else if (s2 === o2)
      for (; l2 < r2; )
        (!f2 || !f2.has(t2[l2])) && t2[l2].remove(), l2++;
    else if (t2[l2] === n2[s2 - 1] && n2[o2] === t2[r2 - 1]) {
      const a2 = t2[--r2].nextSibling;
      e2.insertBefore(n2[o2++], t2[l2++].nextSibling), e2.insertBefore(n2[--s2], a2), t2[r2] = n2[s2];
    } else {
      if (!f2) {
        f2 = /* @__PURE__ */ new Map();
        let u2 = o2;
        for (; u2 < s2; )
          f2.set(n2[u2], u2++);
      }
      const a2 = f2.get(t2[l2]);
      if (a2 != null)
        if (o2 < a2 && a2 < s2) {
          let u2 = l2, d2 = 1, h2;
          for (; ++u2 < r2 && u2 < s2 && !((h2 = f2.get(t2[u2])) == null || h2 !== a2 + d2); )
            d2++;
          if (d2 > a2 - o2) {
            const v2 = t2[l2];
            for (; o2 < a2; )
              e2.insertBefore(n2[o2++], v2);
          } else
            e2.replaceChild(n2[o2++], t2[l2++]);
        } else
          l2++;
      else
        t2[l2++].remove();
    }
  }
}
var Le = "_$DX_DELEGATE";
function C3(e2, t2, n2) {
  let i2;
  const r2 = () => {
    const l2 = document.createElement("template");
    return l2.innerHTML = e2, n2 ? l2.content.firstChild.firstChild : l2.content.firstChild;
  }, s2 = t2 ? () => T2(() => document.importNode(i2 || (i2 = r2()), true)) : () => (i2 || (i2 = r2())).cloneNode(true);
  return s2.cloneNode = s2, s2;
}
function Kt(e2, t2 = window.document) {
  const n2 = t2[Le] || (t2[Le] = /* @__PURE__ */ new Set());
  for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) {
    const s2 = e2[i2];
    n2.has(s2) || (n2.add(s2), t2.addEventListener(s2, Ht));
  }
}
function N(e2, t2, n2) {
  n2 == null ? e2.removeAttribute(t2) : e2.setAttribute(t2, n2);
}
function Bt(e2, t2, n2, i2) {
  i2 == null ? e2.removeAttributeNS(t2, n2) : e2.setAttributeNS(t2, n2, i2);
}
function Dt(e2, t2) {
  t2 == null ? e2.removeAttribute("class") : e2.className = t2;
}
function Ut(e2, t2, n2, i2) {
  if (i2)
    Array.isArray(n2) ? (e2[`$$${t2}`] = n2[0], e2[`$$${t2}Data`] = n2[1]) : e2[`$$${t2}`] = n2;
  else if (Array.isArray(n2)) {
    const r2 = n2[0];
    e2.addEventListener(t2, n2[0] = (s2) => r2.call(e2, n2[1], s2));
  } else
    e2.addEventListener(t2, n2);
}
function Wt(e2, t2, n2 = {}) {
  const i2 = Object.keys(t2 || {}), r2 = Object.keys(n2);
  let s2, l2;
  for (s2 = 0, l2 = r2.length; s2 < l2; s2++) {
    const o2 = r2[s2];
    !o2 || o2 === "undefined" || t2[o2] || (Oe(e2, o2, false), delete n2[o2]);
  }
  for (s2 = 0, l2 = i2.length; s2 < l2; s2++) {
    const o2 = i2[s2], c2 = !!t2[o2];
    !o2 || o2 === "undefined" || n2[o2] === c2 || !c2 || (Oe(e2, o2, true), n2[o2] = c2);
  }
  return n2;
}
function L(e2, t2, n2) {
  if (!t2)
    return n2 ? N(e2, "style") : t2;
  const i2 = e2.style;
  if (typeof t2 == "string")
    return i2.cssText = t2;
  typeof n2 == "string" && (i2.cssText = n2 = void 0), n2 || (n2 = {}), t2 || (t2 = {});
  let r2, s2;
  for (s2 in n2)
    t2[s2] == null && i2.removeProperty(s2), delete n2[s2];
  for (s2 in t2)
    r2 = t2[s2], r2 !== n2[s2] && (i2.setProperty(s2, r2), n2[s2] = r2);
  return n2;
}
function Vt(e2, t2 = {}, n2, i2) {
  const r2 = {};
  return i2 || A2(
    () => r2.children = U(e2, t2.children, r2.children)
  ), A2(() => t2.ref && t2.ref(e2)), A2(() => Xt(e2, t2, n2, true, r2, true)), r2;
}
function ye(e2, t2, n2) {
  return T2(() => e2(t2, n2));
}
function b2(e2, t2, n2, i2) {
  if (n2 !== void 0 && !i2 && (i2 = []), typeof t2 != "function")
    return U(e2, t2, i2, n2);
  A2((r2) => U(e2, t2(), r2, n2), i2);
}
function Xt(e2, t2, n2, i2, r2 = {}, s2 = false) {
  t2 || (t2 = {});
  for (const l2 in r2)
    if (!(l2 in t2)) {
      if (l2 === "children")
        continue;
      r2[l2] = je(e2, l2, null, r2[l2], n2, s2);
    }
  for (const l2 in t2) {
    if (l2 === "children") {
      i2 || U(e2, t2.children);
      continue;
    }
    const o2 = t2[l2];
    r2[l2] = je(e2, l2, o2, r2[l2], n2, s2);
  }
}
function qt(e2) {
  return e2.toLowerCase().replace(/-([a-z])/g, (t2, n2) => n2.toUpperCase());
}
function Oe(e2, t2, n2) {
  const i2 = t2.trim().split(/\s+/);
  for (let r2 = 0, s2 = i2.length; r2 < s2; r2++)
    e2.classList.toggle(i2[r2], n2);
}
function je(e2, t2, n2, i2, r2, s2) {
  let l2, o2, c2, f2, a2;
  if (t2 === "style")
    return L(e2, n2, i2);
  if (t2 === "classList")
    return Wt(e2, n2, i2);
  if (n2 === i2)
    return i2;
  if (t2 === "ref")
    s2 || n2(e2);
  else if (t2.slice(0, 3) === "on:") {
    const u2 = t2.slice(3);
    i2 && e2.removeEventListener(u2, i2), n2 && e2.addEventListener(u2, n2);
  } else if (t2.slice(0, 10) === "oncapture:") {
    const u2 = t2.slice(10);
    i2 && e2.removeEventListener(u2, i2, true), n2 && e2.addEventListener(u2, n2, true);
  } else if (t2.slice(0, 2) === "on") {
    const u2 = t2.slice(2).toLowerCase(), d2 = It.has(u2);
    if (!d2 && i2) {
      const h2 = Array.isArray(i2) ? i2[0] : i2;
      e2.removeEventListener(u2, h2);
    }
    (d2 || n2) && (Ut(e2, u2, n2, d2), d2 && Kt([u2]));
  } else if (t2.slice(0, 5) === "attr:")
    N(e2, t2.slice(5), n2);
  else if ((a2 = t2.slice(0, 5) === "prop:") || (c2 = Tt.has(t2)) || !r2 && ((f2 = Rt(t2, e2.tagName)) || (o2 = jt2.has(t2))) || (l2 = e2.nodeName.includes("-")))
    a2 && (t2 = t2.slice(5), o2 = true), t2 === "class" || t2 === "className" ? Dt(e2, n2) : l2 && !o2 && !c2 ? e2[qt(t2)] = n2 : e2[f2 || t2] = n2;
  else {
    const u2 = r2 && t2.indexOf(":") > -1 && Ft[t2.split(":")[0]];
    u2 ? Bt(e2, u2, t2, n2) : N(e2, Nt2[t2] || t2, n2);
  }
  return n2;
}
function Ht(e2) {
  const t2 = `$$${e2.type}`;
  let n2 = e2.composedPath && e2.composedPath()[0] || e2.target;
  for (e2.target !== n2 && Object.defineProperty(e2, "target", {
    configurable: true,
    value: n2
  }), Object.defineProperty(e2, "currentTarget", {
    configurable: true,
    get() {
      return n2 || document;
    }
  }); n2; ) {
    const i2 = n2[t2];
    if (i2 && !n2.disabled) {
      const r2 = n2[`${t2}Data`];
      if (r2 !== void 0 ? i2.call(n2, r2, e2) : i2.call(n2, e2), e2.cancelBubble)
        return;
    }
    n2 = n2._$host || n2.parentNode || n2.host;
  }
}
function U(e2, t2, n2, i2, r2) {
  for (; typeof n2 == "function"; )
    n2 = n2();
  if (t2 === n2)
    return n2;
  const s2 = typeof t2, l2 = i2 !== void 0;
  if (e2 = l2 && n2[0] && n2[0].parentNode || e2, s2 === "string" || s2 === "number")
    if (s2 === "number" && (t2 = t2.toString()), l2) {
      let o2 = n2[0];
      o2 && o2.nodeType === 3 ? o2.data !== t2 && (o2.data = t2) : o2 = document.createTextNode(t2), n2 = D(e2, n2, i2, o2);
    } else
      n2 !== "" && typeof n2 == "string" ? n2 = e2.firstChild.data = t2 : n2 = e2.textContent = t2;
  else if (t2 == null || s2 === "boolean")
    n2 = D(e2, n2, i2);
  else {
    if (s2 === "function")
      return A2(() => {
        let o2 = t2();
        for (; typeof o2 == "function"; )
          o2 = o2();
        n2 = U(e2, o2, n2, i2);
      }), () => n2;
    if (Array.isArray(t2)) {
      const o2 = [], c2 = n2 && Array.isArray(n2);
      if (we(o2, t2, n2, r2))
        return A2(() => n2 = U(e2, o2, n2, i2, true)), () => n2;
      if (o2.length === 0) {
        if (n2 = D(e2, n2, i2), l2)
          return n2;
      } else
        c2 ? n2.length === 0 ? Te(e2, o2, i2) : Mt(e2, n2, o2) : (n2 && D(e2), Te(e2, o2));
      n2 = o2;
    } else if (t2.nodeType) {
      if (Array.isArray(n2)) {
        if (l2)
          return n2 = D(e2, n2, i2, t2);
        D(e2, n2, null, t2);
      } else
        n2 == null || n2 === "" || !e2.firstChild ? e2.appendChild(t2) : e2.replaceChild(t2, e2.firstChild);
      n2 = t2;
    }
  }
  return n2;
}
function we(e2, t2, n2, i2) {
  let r2 = false;
  for (let s2 = 0, l2 = t2.length; s2 < l2; s2++) {
    let o2 = t2[s2], c2 = n2 && n2[e2.length], f2;
    if (!(o2 == null || o2 === true || o2 === false))
      if ((f2 = typeof o2) == "object" && o2.nodeType)
        e2.push(o2);
      else if (Array.isArray(o2))
        r2 = we(e2, o2, c2) || r2;
      else if (f2 === "function")
        if (i2) {
          for (; typeof o2 == "function"; )
            o2 = o2();
          r2 = we(
            e2,
            Array.isArray(o2) ? o2 : [o2],
            Array.isArray(c2) ? c2 : [c2]
          ) || r2;
        } else
          e2.push(o2), r2 = true;
      else {
        const a2 = String(o2);
        c2 && c2.nodeType === 3 && c2.data === a2 ? e2.push(c2) : e2.push(document.createTextNode(a2));
      }
  }
  return r2;
}
function Te(e2, t2, n2 = null) {
  for (let i2 = 0, r2 = t2.length; i2 < r2; i2++)
    e2.insertBefore(t2[i2], n2);
}
function D(e2, t2, n2, i2) {
  if (n2 === void 0)
    return e2.textContent = "";
  const r2 = i2 || document.createTextNode("");
  if (t2.length) {
    let s2 = false;
    for (let l2 = t2.length - 1; l2 >= 0; l2--) {
      const o2 = t2[l2];
      if (r2 !== o2) {
        const c2 = o2.parentNode === e2;
        !s2 && !l2 ? c2 ? e2.replaceChild(r2, o2) : e2.insertBefore(r2, n2) : c2 && o2.remove();
      } else
        s2 = true;
    }
  } else
    e2.insertBefore(r2, n2);
  return [r2];
}
function Yt(e2) {
  const t2 = Object.keys(e2), n2 = {};
  for (let i2 = 0; i2 < t2.length; i2++) {
    const [r2, s2] = j(e2[t2[i2]]);
    Object.defineProperty(n2, t2[i2], {
      get: r2,
      set(l2) {
        s2(() => l2);
      }
    });
  }
  return n2;
}
function Gt(e2) {
  if (e2.assignedSlot && e2.assignedSlot._$owner)
    return e2.assignedSlot._$owner;
  let t2 = e2.parentNode;
  for (; t2 && !t2._$owner && !(t2.assignedSlot && t2.assignedSlot._$owner); )
    t2 = t2.parentNode;
  return t2 && t2.assignedSlot ? t2.assignedSlot._$owner : e2._$owner;
}
function Zt(e2) {
  return (t2, n2) => {
    const { element: i2 } = n2;
    return Z((r2) => {
      const s2 = Yt(t2);
      i2.addPropertyChangedCallback((o2, c2) => s2[o2] = c2), i2.addReleaseCallback(() => {
        i2.renderRoot.textContent = "", r2();
      });
      const l2 = e2(s2, n2);
      return b2(i2.renderRoot, l2);
    }, Gt(i2));
  };
}
function Jt(e2, t2, n2) {
  return arguments.length === 2 && (n2 = t2, t2 = {}), ht(e2, t2)(Zt(n2));
}
var ve = "sats-connect_wallet-provider-selector_select";
var xe = "sats-connect_wallet-provider-selector_cancel";
var Ce = "sats-connect_wallet-provider-selector_open";
var Pe = "sats-connect_wallet-provider-selector_close";
var Xe = "sats-connect_wallet-provider-selector_walletOpen";
var qe = "sats-connect_wallet-provider-selector_walletClose";
var re = {
  color: "#181818",
  "font-size": "18px",
  "font-weight": "700",
  "line-height": "1.4"
};
var W = {
  color: "#181818",
  "font-size": "14px",
  "font-weight": "400",
  "line-height": "1.4"
};
var Qt = {
  color: "#181818",
  "font-size": "14px",
  "font-weight": "500"
};
var en2 = C3('<svg width=24 height=24 viewBox="0 0 24 24"fill=none xmlns=http://www.w3.org/2000/svg><g id=XCircle><path id=Vector d="M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.745 9.41566 20.7162 6.93859 18.8888 5.11118C17.0614 3.28378 14.5843 2.25496 12 2.25ZM15.5344 14.4656C15.6752 14.6078 15.7542 14.7999 15.7542 15C15.7542 15.2001 15.6752 15.3922 15.5344 15.5344C15.391 15.673 15.1994 15.7505 15 15.7505C14.8006 15.7505 14.609 15.673 14.4656 15.5344L12 13.0594L9.53438 15.5344C9.39102 15.673 9.19942 15.7505 9 15.7505C8.80059 15.7505 8.60898 15.673 8.46563 15.5344C8.32479 15.3922 8.24578 15.2001 8.24578 15C8.24578 14.7999 8.32479 14.6078 8.46563 14.4656L10.9406 12L8.46563 9.53437C8.34603 9.38865 8.28491 9.20366 8.29416 9.01537C8.30341 8.82708 8.38236 8.64896 8.51566 8.51566C8.64896 8.38236 8.82708 8.3034 9.01537 8.29416C9.20366 8.28491 9.38866 8.34603 9.53438 8.46563L12 10.9406L14.4656 8.46563C14.6114 8.34603 14.7963 8.28491 14.9846 8.29416C15.1729 8.3034 15.351 8.38236 15.4843 8.51566C15.6176 8.64896 15.6966 8.82708 15.7058 9.01537C15.7151 9.20366 15.654 9.38865 15.5344 9.53437L13.0594 12L15.5344 14.4656Z"fill=black fill-opacity=0.3>');
var tn2 = C3(`<style>
          .close-selector-button:focus-visible {
            outline: 2px solid #181818;
            outline-offset: -0.25px;
          }
        `);
var nn2 = C3("<div role=button tabindex=0 class=close-selector-button>");
function rn(e2) {
  return (() => {
    var t2 = en2();
    return t2.style.setProperty("display", "block"), Vt(t2, e2, true, true), t2;
  })();
}
function sn(e2) {
  function t2(n2) {
    (n2.key === "Enter" || n2.key === " ") && e2.onClose();
  }
  return [tn2(), (() => {
    var n2 = nn2();
    return n2.style.setProperty("position", "absolute"), n2.style.setProperty("top", "16px"), n2.style.setProperty("right", "16px"), n2.style.setProperty("background", "none"), n2.style.setProperty("border", "none"), n2.style.setProperty("cursor", "pointer"), n2.style.setProperty("padding", "0"), n2.style.setProperty("margin", "0"), n2.style.setProperty("border-radius", "50%"), n2.addEventListener("click", e2.onClose), n2.addEventListener("keydown", t2), b2(n2, g2(rn, {})), n2;
  })()];
}
var on2 = C3(`<style>
/*! modern-normalize v2.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */

/*
Document
========
*/

/**
Use a better box model (opinionated).
*/

*,
::before,
::after {
	box-sizing: border-box;
	margin: 0; /* Remove all margins from everywhere. */
}

:host {
	/* Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3) */
	font-family:
		'DM Sans', /* Note: not part of modern-normalize, added specifically for this project. */
		system-ui,
		'Segoe UI',
		Roboto,
		Helvetica,
		Arial,
		sans-serif,
		'Apple Color Emoji',
		'Segoe UI Emoji';
	line-height: 1.15; /* 1. Correct the line height in all browsers. */
	-webkit-text-size-adjust: 100%; /* 2. Prevent adjustments of font size after orientation changes in iOS. */
	-moz-tab-size: 4; /* 3. Use a more readable tab size (opinionated). */
	tab-size: 4; /* 3 */
}

/*
Sections
========
*/

:host {
	margin: 0; /* Remove the margin in all browsers. */
}

/*
Grouping content
================
*/

/**
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
*/

hr {
	height: 0; /* 1 */
	color: inherit; /* 2 */
}

/*
Text-level semantics
====================
*/

/**
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr[title] {
	text-decoration: underline dotted;
}

/**
Add the correct font weight in Edge and Safari.
*/

b,
strong {
	font-weight: bolder;
}

/**
1. Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)
2. Correct the odd 'em' font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
	font-family:
		ui-monospace,
		SFMono-Regular,
		Consolas,
		'Liberation Mono',
		Menlo,
		monospace; /* 1 */
	font-size: 1em; /* 2 */
}

/**
Add the correct font size in all browsers.
*/

small {
	font-size: 80%;
}

/**
Prevent 'sub' and 'sup' elements from affecting the line height in all browsers.
*/

sub,
sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}

sub {
	bottom: -0.25em;
}

sup {
	top: -0.5em;
}

/*
Tabular data
============
*/

/**
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
*/

table {
	text-indent: 0; /* 1 */
	border-color: inherit; /* 2 */
}

/*
Forms
=====
*/

/**
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
*/

button,
input,
optgroup,
select,
textarea {
	font-family: inherit; /* 1 */
	font-size: 100%; /* 1 */
	line-height: 1.15; /* 1 */
	margin: 0; /* 2 */
}

/**
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
	text-transform: none;
}

/**
Correct the inability to style clickable types in iOS and Safari.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
	-webkit-appearance: button;
}

/**
Remove the inner border and padding in Firefox.
*/

::-moz-focus-inner {
	border-style: none;
	padding: 0;
}

/**
Restore the focus styles unset by the previous rule.
*/

:-moz-focusring {
	outline: 1px dotted ButtonText;
}

/**
Remove the additional ':invalid' styles in Firefox.
See: https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737
*/

:-moz-ui-invalid {
	box-shadow: none;
}

/**
Remove the padding so developers are not caught out when they zero out 'fieldset' elements in all browsers.
*/

legend {
	padding: 0;
}

/**
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
	vertical-align: baseline;
}

/**
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
	height: auto;
}

/**
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
	-webkit-appearance: textfield; /* 1 */
	outline-offset: -2px; /* 2 */
}

/**
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
	-webkit-appearance: none;
}

/**
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to 'inherit' in Safari.
*/

::-webkit-file-upload-button {
	-webkit-appearance: button; /* 1 */
	font: inherit; /* 2 */
}

/*
Interactive
===========
*/

/*
Add the correct display in Chrome and Safari.
*/

summary {
	display: list-item;
}
`);
function ln() {
  return on2();
}
var an2 = C3("<div class=divider><div>");
function cn() {
  return (() => {
    var e2 = an2(), t2 = e2.firstChild;
    return t2.style.setProperty("height", "100%"), t2.style.setProperty("width", "1px"), t2.style.setProperty("background", "#dcdcdc"), e2;
  })();
}
var un2 = C3("<div>");
function dn(e2) {
  return (() => {
    var t2 = un2();
    return t2.style.setProperty("padding", "24px"), t2.style.setProperty("height", "100%"), b2(t2, () => e2.children), t2;
  })();
}
var fn2 = C3("<div>");
function hn(e2) {
  return (() => {
    var t2 = fn2();
    return t2.style.setProperty("display", "flex"), t2.style.setProperty("flex-direction", "column"), t2.style.setProperty("justify-content", "center"), t2.style.setProperty("align-items", "center"), t2.style.setProperty("height", "100%"), b2(t2, () => e2.children), t2;
  })();
}
var pn2 = C3("<div><div></div><div>What is a wallet?</div><p>Wallets let you send, receive, store and display digital assets like Bitcoin, Stacks, Ordinals & NFTs.</p><p>Explore Bitcoin apps by connecting your wallet.");
function yn() {
  return (() => {
    var e2 = pn2(), t2 = e2.firstChild, n2 = t2.nextSibling, i2 = n2.nextSibling, r2 = i2.nextSibling;
    return e2.style.setProperty("display", "flex"), e2.style.setProperty("flex-direction", "column"), e2.style.setProperty("row-gap", "8px"), e2.style.setProperty("justify-content", "center"), e2.style.setProperty("align-items", "center"), t2.style.setProperty("font-size", "50px"), t2.style.setProperty("line-height", "140%"), A2((s2) => {
      var l2 = re, o2 = W, c2 = W;
      return s2.e = L(n2, l2, s2.e), s2.t = L(i2, o2, s2.t), s2.a = L(r2, c2, s2.a), s2;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    }), e2;
  })();
}
function Se(e2) {
  var n2;
  const t2 = (n2 = e2.installPrompt) == null ? void 0 : n2.url;
  if (!t2) {
    console.error("No install prompt URL found for", e2.id);
    return;
  }
  window.open(t2, "_blank");
}
var gn2 = C3(`<style>
          .install-prompt-button:focus-visible {
            outline: 2px solid #181818;
            outline-offset: 2px;
          }
        `);
var mn2 = C3("<div><img><h1>Don't have <!>?</h1><p>Download it on the Chrome web store.</p><div class=install-prompt-button role=button tabindex=0>Get");
function bn(e2) {
  function t2(i2) {
    (i2.key === "Enter" || i2.key === " ") && Se(e2.option);
  }
  function n2() {
    Se(e2.option);
  }
  return [gn2(), (() => {
    var i2 = mn2(), r2 = i2.firstChild, s2 = r2.nextSibling, l2 = s2.firstChild, o2 = l2.nextSibling;
    o2.nextSibling;
    var c2 = s2.nextSibling, f2 = c2.nextSibling;
    return i2.style.setProperty("display", "flex"), i2.style.setProperty("flex-direction", "column"), i2.style.setProperty("align-items", "center"), i2.style.setProperty("row-gap", "16px"), r2.style.setProperty("border-radius", "12px"), r2.style.setProperty("height", "64px"), r2.style.setProperty("width", "64px"), r2.style.setProperty("object-fit", "cover"), b2(s2, () => e2.option.name, o2), f2.addEventListener("click", n2), f2.addEventListener("keydown", t2), A2((a2) => {
      var u2 = e2.option.icon, d2 = e2.option.name, h2 = {
        ...re,
        "text-align": "center"
      }, v2 = W, y2 = {
        ...Qt,
        cursor: "pointer",
        "border-radius": "12px",
        background: "#181818",
        color: "white",
        padding: "12px 16px"
      };
      return u2 !== a2.e && N(r2, "src", a2.e = u2), d2 !== a2.t && N(r2, "alt", a2.t = d2), a2.a = L(s2, h2, a2.a), a2.o = L(c2, v2, a2.o), a2.i = L(f2, y2, a2.i), a2;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    }), i2;
  })()];
}
var wn2 = C3('<svg width=20 height=20 viewBox="0 0 20 20"xmlns=http://www.w3.org/2000/svg><circle cx=10 cy=10 r=9.05 stroke=black stroke-width=1.9 fill=none stroke-dasharray="42.65 14.22"stroke-dashoffset=0><animateTransform attributeName=transform attributeType=XML type=rotate from="0 10 10"to="360 10 10"dur=0.75s repeatCount=indefinite>');
var vn2 = C3("<div>");
var xn = () => wn2();
function Cn() {
  return (() => {
    var e2 = vn2();
    return e2.style.setProperty("display", "flex"), e2.style.setProperty("justify-content", "center"), e2.style.setProperty("align-items", "center"), e2.style.setProperty("height", "100%"), e2.style.setProperty("animation", "spin 1s linear infinite"), b2(e2, g2(xn, {})), e2;
  })();
}
var Pn2 = C3("<div><img><h1>Opening <!>...</h1><p>Confirm the operation in ");
function Sn(e2) {
  return (() => {
    var t2 = Pn2(), n2 = t2.firstChild, i2 = n2.nextSibling, r2 = i2.firstChild, s2 = r2.nextSibling;
    s2.nextSibling;
    var l2 = i2.nextSibling;
    return l2.firstChild, t2.style.setProperty("display", "flex"), t2.style.setProperty("flex-direction", "column"), t2.style.setProperty("align-items", "center"), t2.style.setProperty("row-gap", "16px"), n2.style.setProperty("border-radius", "12px"), n2.style.setProperty("height", "64px"), n2.style.setProperty("width", "64px"), n2.style.setProperty("object-fit", "cover"), b2(i2, () => e2.option.name, s2), b2(l2, () => e2.option.name, null), b2(t2, g2(Cn, {}), null), A2((o2) => {
      var c2 = e2.option.icon, f2 = e2.option.name, a2 = {
        ...re,
        "text-align": "center"
      }, u2 = W;
      return c2 !== o2.e && N(n2, "src", o2.e = c2), f2 !== o2.t && N(n2, "alt", o2.t = f2), o2.a = L(i2, a2, o2.a), o2.o = L(l2, u2, o2.o), o2;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0
    }), t2;
  })();
}
var _n2 = C3("<div><div tabindex=0><img><div>");
function En(e2) {
  function t2() {
    e2.onProviderSelected(e2.id);
  }
  const n2 = F(() => ke(e2) ? "button" : "link");
  function i2(u2) {
    if (n2() === "link") {
      u2.key === "Enter" && t2();
      return;
    }
    if (n2() === "button") {
      (u2.key === "Enter" || u2.key === " ") && t2();
      return;
    }
  }
  const [r2, s2] = j(false), [l2, o2] = j(false), c2 = () => r2() || l2(), f2 = "rgba(24, 24, 24, 0.20)", a2 = "rgba(24, 24, 24, 0.60)";
  return (() => {
    var u2 = _n2(), d2 = u2.firstChild, h2 = d2.firstChild, v2 = h2.nextSibling;
    return u2.style.setProperty("aspect-ratio", "1 / 1"), u2.style.setProperty("overflow", "hidden"), d2.style.setProperty("display", "flex"), d2.style.setProperty("flex-direction", "column"), d2.style.setProperty("row-gap", "12px"), d2.style.setProperty("align-items", "center"), d2.style.setProperty("cursor", "pointer"), d2.style.setProperty("outline", "none"), d2.style.setProperty("padding-top", "10px"), d2.addEventListener("click", t2), d2.addEventListener("keydown", i2), d2.addEventListener("mouseenter", () => s2(true)), d2.addEventListener("mouseleave", () => s2(false)), d2.addEventListener("focus", () => o2(true)), d2.addEventListener("blur", () => o2(false)), h2.style.setProperty("width", "56px"), h2.style.setProperty("height", "56px"), h2.style.setProperty("object-fit", "cover"), h2.style.setProperty("border-radius", "12px"), b2(v2, () => e2.name), A2((y2) => {
      var z2 = n2(), $ = c2() ? `6px solid ${f2}` : "none", P = e2.icon, _2 = e2.name, E2 = {
        ...W,
        color: c2() ? a2 : void 0,
        "text-align": "center"
      };
      return z2 !== y2.e && N(d2, "role", y2.e = z2), $ !== y2.t && ((y2.t = $) != null ? h2.style.setProperty("outline", $) : h2.style.removeProperty("outline")), P !== y2.a && N(h2, "src", y2.a = P), _2 !== y2.o && N(h2, "alt", y2.o = _2), y2.i = L(v2, E2, y2.i), y2;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    }), u2;
  })();
}
var kn2 = C3('<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&amp;display=swap"rel=stylesheet>');
var $n2 = C3("<div class=side-panel>");
var An2 = C3('<div><div></div><div><div class=card-width-container><div class=card-height-container><div class=card><div class=card-grid><div class=main-panel><div></div><div></div><div class=wallets-grid-container data-desc="wallet grid container for padding"><div class=wallets-grid data-desc="wallet grid container">');
var Ln2 = C3(`<div><style>
        @keyframes wallet-selector-fade-in {
          from {opacity: 0; transform: translateY(40px);}
          to {opacity: 1; transform: translateY(0);}
        }

        @keyframes wallet-selector-fade-out {
          from {opacity: 1; transform: translateY(0);}
          to {opacity: 0; transform: translateY(40px);}
        }
        @keyframes wallet-selector-blur-in {
          from {opacity: 0; backdrop-filter: blur(0px);}
          to {opacity: 1; backdrop-filter: blur(10px);}
        }

        @keyframes wallet-selector-blur-out {
          from {opacity: 1; backdrop-filter: blur(10px);}
          to {opacity: 0; backdrop-filter: blur(0px);}
        }
      </style><style>`);
var G = "24px";
function On() {
  const [e2, t2] = j(), [n2, i2] = j(), [r2, s2] = j();
  function l2() {
    const p2 = e2(), x2 = r2();
    return !(!p2 || !x2 || !p2.contains(x2) || getComputedStyle(x2).display === "none");
  }
  const [o2, c2] = j(false), [f2, a2] = j(false), [u2, d2] = j([]), [h2, v2] = j({
    type: "none"
  }), y2 = () => u2().some((p2) => jn(p2)), z2 = () => c2(false);
  function $() {
    const p2 = new CustomEvent(xe, {
      bubbles: true,
      composed: true
    });
    window.dispatchEvent(p2), z2();
  }
  function P(p2) {
    p2.key === "Escape" && $();
  }
  Fe(() => {
    if (o2()) {
      window.addEventListener("keydown", P);
      return;
    }
    window.removeEventListener("keydown", P);
  });
  function _2(p2) {
    const x2 = u2().find((K) => K.id === p2);
    if (ke(x2)) {
      l2() ? v2({
        type: "install-wallet-prompt",
        option: x2
      }) : Se(x2);
      return;
    }
    const O = new CustomEvent(ve, {
      detail: p2,
      bubbles: true,
      composed: true
    });
    window.dispatchEvent(O);
  }
  function E2(p2) {
    mt(() => {
      c2(true), a2(true);
      const x2 = p2.detail.options;
      d2(x2), x2.some((O) => !O.installPrompt) ? v2({
        type: "explainer"
      }) : v2({
        type: "none"
      });
    });
  }
  function R() {
    c2(false);
  }
  const se = () => {
    o2() || a2(false);
  };
  function Ye(p2) {
    const x2 = p2.detail;
    v2({
      type: "opening-wallet",
      option: u2().find((O) => O.id === x2)
    });
  }
  function Ge() {
    v2({
      type: "explainer"
    });
  }
  bt(() => {
    window.addEventListener(Ce, E2), window.addEventListener(Pe, R), window.addEventListener(Xe, Ye), window.addEventListener(qe, Ge), document.head.appendChild(kn2());
  }), Me(() => {
    window.removeEventListener(Ce, E2), window.removeEventListener(Pe, R);
  });
  function Ze(p2) {
    const x2 = p2.target;
    if (!x2)
      return;
    const O = n2();
    O && (O.contains(x2) || $());
  }
  return (() => {
    var p2 = Ln2(), x2 = p2.firstChild, O = x2.nextSibling;
    return ye(t2, p2), p2.style.setProperty("inset", "0"), p2.addEventListener("click", Ze), p2.addEventListener("keydown", () => {
      console.log("Inside root keydown");
    }), b2(p2, g2(ln, {}), x2), b2(O, () => `
        .card-width-container {
          container: card-width-container / inline-size;
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100%;
          width: 740px;
        }

        .card-height-container {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: flex-end;
          height: 100%;
          width: 100%;
        }

        .card {
          min-height: 340px;
          max-height: calc(100vh - 8rem);
          width: 100%;
          border-top-left-radius: ${G};
          border-top-right-radius: ${G};

          background: rgb(196, 177, 217);
          overflow: hidden;

          display: flex;
          flex-direction: column;

          position: "relative"; /* For the close button */
          background-color: #ffffff;
          display: ${f2() ? "block" : "none"};

          box-shadow: 0px 8px 64px 0px rgba(0, 0, 0, 0.25);
          animation: ${o2() ? "wallet-selector-fade-in 0.4s cubic-bezier(.05, .7, .1, 1) forwards" : "wallet-selector-fade-out 0.2s cubic-bezier(.3, 0, .8, .15) forwards"};
        }

        .card-grid {
          flex-grow: 1;
          height: 100%;
          
          display: grid;
          grid-template-columns: 1fr;
          grid-template-areas: "mainPanel";
        }

        .main-panel {
          height: 100%;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          grid-area: mainPanel;
        }

        .wallets-grid-container {
          overflow: auto;
          flex-grow: 1;
        }

        .wallets-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
          align-content: start;

          padding-left: 24px;
          padding-right: 24px;
          padding-bottom: 40px;
        }

        .divider {
          display: none;
          grid-area: divider;
        }

        .side-panel {
          display: none;
          grid-area: sidePanel;
        }

        @container card-width-container (width > 400px) {
          .card-height-container {
            justify-content: center;
          }

          .card {
            max-width: calc(100vw - 2rem);
            max-height: 460px;
            ${y2() ? "" : "width: 360px;"}
            border-bottom-left-radius: ${G};
            border-bottom-right-radius: ${G};
          }

          .card-grid {
            grid-template-columns: ${y2() ? "5fr auto 4fr" : "1fr"};
            grid-template-areas: ${y2() ? '"mainPanel divider sidePanel"' : '"mainPanel"'};
          }

          .divider {
            display: block;
          }

          .side-panel {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
          }
        }
      `), b2(p2, g2(he, {
      get when() {
        return f2();
      },
      get children() {
        var K = An2(), B = K.firstChild, X = B.nextSibling, Je = X.firstChild, Qe = Je.firstChild, H = Qe.firstChild, oe = H.firstChild, et = oe.firstChild, le = et.firstChild, ae = le.nextSibling, tt = ae.nextSibling, nt = tt.firstChild;
        return K.style.setProperty("position", "fixed"), K.style.setProperty("inset", "0"), B.style.setProperty("background-color", "#FFFFFF80"), B.style.setProperty("position", "absolute"), B.style.setProperty("inset", "0"), X.style.setProperty("display", "flex"), X.style.setProperty("justify-content", "center"), X.style.setProperty("align-items", "center"), X.style.setProperty("height", "100%"), ye(i2, H), H.addEventListener("animationend", se), b2(le, () => y2() ? "Choose wallet to connect" : "Don't have a wallet?"), b2(ae, () => y2() ? "Start by selecting one of the wallets below and confirming the connection." : "Start by installing one of the wallets below."), b2(nt, g2(At, {
          get each() {
            return u2();
          },
          children: (k2) => g2(En, $t(k2, {
            onProviderSelected: _2
          }))
        })), b2(oe, g2(he, {
          get when() {
            return h2().type !== "none";
          },
          get children() {
            return g2(cn, {});
          }
        }), null), b2(oe, g2(he, {
          get when() {
            return h2().type !== "none";
          },
          get children() {
            var k2 = $n2();
            return ye(s2, k2), b2(k2, g2(dn, {
              get children() {
                return g2(hn, {
                  get children() {
                    return g2(Lt, {
                      fallback: null,
                      get children() {
                        return [g2(pe, {
                          get when() {
                            return h2().type === "install-wallet-prompt";
                          },
                          get children() {
                            return g2(bn, {
                              get option() {
                                return h2().option;
                              }
                            });
                          }
                        }), g2(pe, {
                          get when() {
                            return h2().type === "explainer";
                          },
                          get children() {
                            return g2(yn, {});
                          }
                        }), g2(pe, {
                          get when() {
                            return h2().type === "opening-wallet";
                          },
                          get children() {
                            return g2(Sn, {
                              get option() {
                                return h2().option;
                              }
                            });
                          }
                        })];
                      }
                    });
                  }
                });
              }
            })), k2;
          }
        }), null), b2(H, g2(sn, {
          onClose: $
        }), null), A2((k2) => {
          var ce = o2() ? "wallet-selector-blur-in 0.2s cubic-bezier(.05, .7, .1, 1) forwards" : "wallet-selector-blur-out 0.2s cubic-bezier(.3, 0, .8, .15) forwards", it = {
            ...re,
            margin: "0",
            "padding-top": "24px",
            "padding-left": "24px",
            "padding-right": "24px",
            "padding-bottom": "16px"
          }, rt = {
            ...W,
            "padding-left": "24px",
            "padding-right": "24px",
            "padding-bottom": "30px"
          };
          return ce !== k2.e && ((k2.e = ce) != null ? B.style.setProperty("animation", ce) : B.style.removeProperty("animation")), k2.t = L(le, it, k2.t), k2.a = L(ae, rt, k2.a), k2;
        }, {
          e: void 0,
          t: void 0,
          a: void 0
        }), K;
      }
    }), null), A2(() => (f2() ? "fixed" : "static") != null ? p2.style.setProperty("position", f2() ? "fixed" : "static") : p2.style.removeProperty("position")), p2;
  })();
}
var Ee = "sats-connect-wallet-provider-selector";
var ge = Ee;
function He() {
  return document.getElementById(Ee);
}
function Nn() {
  if (customElements.get(ge))
    return;
  Jt(ge, On);
  const e2 = document.createElement(ge);
  e2.id = Ee, e2.style.position = "relative", e2.style.zIndex = "999999", document.body.appendChild(e2);
}
function ke(e2) {
  return !!e2.installPrompt;
}
function jn(e2) {
  return !ke(e2);
}
function Rn(e2) {
  return new Promise((t2, n2) => {
    if (!He()) {
      n2("Failed to detect the wallet provider selector.");
      return;
    }
    function r2() {
      window.removeEventListener(ve, s2), window.removeEventListener(xe, l2);
    }
    function s2(c2) {
      t2(c2.detail), r2();
    }
    function l2() {
      n2(), r2();
    }
    window.addEventListener(ve, s2), window.addEventListener(xe, l2);
    const o2 = new CustomEvent(Ce, {
      detail: e2
    });
    window.dispatchEvent(o2);
  });
}
function In(e2) {
  const t2 = new CustomEvent(Xe, {
    detail: e2
  });
  window.dispatchEvent(t2);
}
function Fn() {
  const e2 = new CustomEvent(qe);
  window.dispatchEvent(e2);
}
function Mn() {
  const e2 = new CustomEvent(Pe);
  window.dispatchEvent(e2);
}

// node_modules/sats-connect/dist/index.mjs
var Wallet2 = class {
  providerId;
  defaultAdapters = defaultAdapters;
  createCustomConfig;
  isProviderSet() {
    return !!this.providerId;
  }
  setCreateCustomConfig(createCustomConfig) {
    this.createCustomConfig = createCustomConfig;
  }
  async selectProvider() {
    const providers = getSupportedWallets();
    if (providers.length === 0) {
      throw new Error("No wallets detected, may want to prompt user to install a wallet.");
    }
    const selectorConfig = this.createCustomConfig ? this.createCustomConfig(providers) : makeDefaultConfig(providers);
    const nextProviderId = await Rn(selectorConfig);
    this.providerId = nextProviderId;
  }
  async disconnect() {
    await this.request("wallet_renouncePermissions", void 0);
    this.providerId = void 0;
    removeDefaultProvider();
  }
  async request(method, params) {
    Nn();
    const defaultProvider = getDefaultProvider();
    if (!this.isProviderSet()) {
      if (defaultProvider) {
        this.providerId = defaultProvider;
      } else {
        try {
          await this.selectProvider();
        } catch {
          return {
            status: "error",
            error: {
              code: RpcErrorCode.INTERNAL_ERROR,
              message: "Failed to select the provider. User may have cancelled the selection prompt."
            }
          };
        }
      }
    }
    const adapter = this.defaultAdapters[this.providerId];
    In(this.providerId);
    const response = adapter ? await new adapter().request(method, params) : await new BaseAdapter(this.providerId).request(method, params);
    Fn();
    if (response?.status === "error" && response.error?.code === RpcErrorCode.USER_REJECTION) {
      if (!defaultProvider) {
        this.providerId = void 0;
      }
    } else {
      setDefaultProvider(this.providerId);
    }
    Mn();
    if (!response) {
      return {
        status: "error",
        error: {
          code: RpcErrorCode.INTERNAL_ERROR,
          message: "Wallet Error processing the request"
        }
      };
    }
    return response;
  }
  addListener = (event, cb) => {
    const defaultProvider = getDefaultProvider();
    if (!this.isProviderSet() && defaultProvider) {
      this.providerId = defaultProvider;
    }
    if (!this.isProviderSet()) {
      console.error(
        "No wallet provider selected. The user must first select a wallet before adding listeners to wallet events."
      );
      return () => {
      };
    }
    const adapter = this.defaultAdapters[this.providerId];
    if (!adapter || !new adapter().addListener) {
      console.error(
        `The wallet provider you are using does not support the addListener method. Please update your wallet provider.`
      );
      return () => {
      };
    }
    return new adapter().addListener(event, cb);
  };
};
var src_default = new Wallet2();

// node_modules/@dynamic-labs/bitcoin/src/BitcoinLocalStorageCache.js
var BitcoinLocalStorageCache = class {
  constructor(key) {
    this.CONNECTED_ACCOUNTS_KEY = `bitcoin_${key}_connectedAccounts`;
  }
  getActiveAccount() {
    return __awaiter(this, void 0, void 0, function* () {
      const connectedAccounts = yield getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
      if (!connectedAccounts) {
        return;
      }
      const activeAddress = Object.keys(connectedAccounts).find((key) => connectedAccounts[key].active);
      if (!activeAddress) {
        return;
      }
      return {
        additionalAddresses: connectedAccounts[activeAddress].additionalAddresses,
        address: activeAddress
      };
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const connectedAccounts = yield getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
      return connectedAccounts;
    });
  }
  getConnectedAccount(address2) {
    return __awaiter(this, void 0, void 0, function* () {
      const connectedAccounts = yield getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
      return connectedAccounts === null || connectedAccounts === void 0 ? void 0 : connectedAccounts[address2];
    });
  }
  setConnectedAccount(addess, account) {
    return __awaiter(this, void 0, void 0, function* () {
      let connectedAccounts = yield getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
      if (!connectedAccounts) {
        connectedAccounts = {};
      }
      if (account.active) {
        Object.keys(connectedAccounts).forEach((key) => {
          if (connectedAccounts) {
            connectedAccounts[key].active = false;
          }
        });
      }
      connectedAccounts[addess] = account;
      return setItemAsync(this.CONNECTED_ACCOUNTS_KEY, connectedAccounts);
    });
  }
  clearConnectedAcccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      return removeItemAsync(this.CONNECTED_ACCOUNTS_KEY);
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/bitcoinWalletStandardWallets.js
var BitcoinWalletStandardWallets = class {
  registerWallets() {
    this.wallets = getWallets();
  }
};
var BitcoinWalletStandardWalletsSingleton = class _BitcoinWalletStandardWalletsSingleton {
  constructor() {
    this.bitcoinWalletStandardWallets = new BitcoinWalletStandardWallets();
  }
  static get() {
    var _a;
    if (!((_a = _BitcoinWalletStandardWalletsSingleton.instance) === null || _a === void 0 ? void 0 : _a.bitcoinWalletStandardWallets)) {
      _BitcoinWalletStandardWalletsSingleton.instance = new _BitcoinWalletStandardWalletsSingleton();
      _BitcoinWalletStandardWalletsSingleton.instance.bitcoinWalletStandardWallets.registerWallets();
    }
    return _BitcoinWalletStandardWalletsSingleton.instance.bitcoinWalletStandardWallets;
  }
  static getWallets() {
    var _a;
    return (_a = _BitcoinWalletStandardWalletsSingleton.get().wallets) === null || _a === void 0 ? void 0 : _a.get();
  }
};

// node_modules/@dynamic-labs/bitcoin/src/bitcoinProviderHelper.js
var BitcoinProviderHelper = class {
  constructor(walletData) {
    this.walletData = walletData;
  }
  getInjectedConfig() {
    if (!this.walletData || !this.walletData.injectedConfig)
      return;
    const { injectedConfig } = this.walletData;
    return injectedConfig.find((c2) => c2.chain === "btc");
  }
  getProvider() {
    var _a;
    const config = this.getInjectedConfig();
    if (!((_a = config === null || config === void 0 ? void 0 : config.windowLocations) === null || _a === void 0 ? void 0 : _a.length))
      return void 0;
    const foundProviders = getProvidersFromWindow(config.windowLocations[0]);
    if (foundProviders === null || foundProviders === void 0 ? void 0 : foundProviders.length)
      return foundProviders[0];
    return void 0;
  }
  hasAllRequiredFeatures(wallet) {
    const injectedConfig = this.getInjectedConfig();
    if (!(injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.walletStandard) || !wallet) {
      return false;
    }
    const { walletStandard } = injectedConfig;
    for (const feature of walletStandard.features) {
      if (!(feature in wallet.features)) {
        return false;
      }
    }
    return true;
  }
  bitcoinWalletStandardLookup() {
    const wallets = BitcoinWalletStandardWalletsSingleton.getWallets();
    const walletStandardWallet = wallets === null || wallets === void 0 ? void 0 : wallets.find((wallet) => {
      var _a, _b;
      return ((_b = (_a = this.getInjectedConfig()) === null || _a === void 0 ? void 0 : _a.walletStandard) === null || _b === void 0 ? void 0 : _b.name) === wallet.name && this.hasAllRequiredFeatures(wallet);
    });
    return walletStandardWallet;
  }
  findWallet() {
    return this.bitcoinWalletStandardLookup();
  }
  getWalletMethods(wallet) {
    var _a, _b, _c, _d;
    return {
      connect: (_a = wallet.features["bitcoin:connect"]) === null || _a === void 0 ? void 0 : _a.connect,
      signAndSendTransaction: (_b = wallet.features["bitcoin:signAndSendTransaction"]) === null || _b === void 0 ? void 0 : _b.signAndSendTransaction,
      signMessage: (_c = wallet.features["bitcoin:signMessage"]) === null || _c === void 0 ? void 0 : _c.signMessage,
      signTransaction: (_d = wallet.features["bitcoin:signTransaction"]) === null || _d === void 0 ? void 0 : _d.signTransaction
    };
  }
};

// node_modules/@dynamic-labs/bitcoin/src/const.js
var SATSCONNECT_FEATURE = "sats-connect:";
var BTCKIT_INTERFACE = "btckit";
var HTTP_STATUS_TOO_MANY_REQUESTS = 429;
var HTTP_STATUS_NOT_FOUND = 404;
var MEMPOOL_API_URL = "https://mempool.space/api";
var MEMPOOL_API_URL_TESTNET = "https://mempool.space/testnet/api";

// node_modules/@dynamic-labs/bitcoin/src/utils/getMempoolApiUrl.js
var getMempoolApiUrl = (address2) => address2.startsWith("t") ? MEMPOOL_API_URL_TESTNET : MEMPOOL_API_URL;

// node_modules/@dynamic-labs/bitcoin/src/utils/satoshisToBtc/satoshisToBtc.js
var satoshisToBtc = (satoshis) => satoshis / 1e8;

// node_modules/@dynamic-labs/bitcoin/src/utils/getAddressByType/getAddressByType.js
var getAddressByType = (wallet, addressType) => {
  var _a;
  return ((_a = wallet.additionalAddresses.find((addr) => addr.type === addressType)) === null || _a === void 0 ? void 0 : _a.address) || wallet.address;
};

// node_modules/@dynamic-labs/bitcoin/src/wallet/BitcoinWallet.js
var BitcoinWallet = class extends Wallet {
  /**
   * Sends the native balance of the wallet to the given address.
   * @param amount - The amount of balance to send (in satoshis).
   * @param toAddress - The address to send the balance to.
   * @returns The signature of the sent transaction.
   */
  sendBalance(_a) {
    return __awaiter(this, arguments, void 0, function* ({ amount, toAddress }) {
      return this.sendBitcoin({
        amount: BigInt(amount),
        recipientAddress: toAddress
      });
    });
  }
  /**
   * Sends a raw transaction
   * @returns A promise that resolves to the transaction id
   */
  sendRawTransaction(rawTransaction) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sync();
      return this._connector.sendRawTransaction(rawTransaction);
    });
  }
  /**
   * Sends satoshis to a bitcoin address
   * @returns A promise that resolves to the transaction id
   */
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sync();
      return this._connector.sendBitcoin(transaction);
    });
  }
  /**
   * Signs a message using a specific address type (payment or ordinals).
   * @param messageToSign - The message to sign.
   * @param options - Optional configuration for signing
   * @param options.addressType - The type of address to sign with (e.g. 'payment' or 'ordinals')
   * @param options.protocol - The signing protocol to use (e.g. 'ecdsa' or 'bip322-simple')
   * @returns A promise that resolves to the signature of the message as a string,
   * or undefined if the message cannot be signed.
   */
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sync();
      const address2 = (options === null || options === void 0 ? void 0 : options.addressType) ? getAddressByType(this, options.addressType) : this.address;
      return this._connector.signMessage(messageToSign, {
        address: address2,
        protocol: options === null || options === void 0 ? void 0 : options.protocol
      });
    });
  }
  /**
   * Sings a PSBT
   * @returns A promise that resolves to an object with the signed PSBT
   * or undefined if no provider is available
   */
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sync();
      return this._connector.signPsbt(request2);
    });
  }
  /**
   * Sings multiple PSBTs
   * @returns A promise that resolves to an array of signed PSBTs in base64
   * or undefined if no provider is available
   */
  signPsbts(requests) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.sync();
      return this._connector.signPsbts(requests);
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/BitcoinWalletConnector.js
var BitcoinWalletConnector = class extends WalletConnectorBase {
  constructor(opts) {
    var _a;
    super(opts);
    this.ChainWallet = BitcoinWallet;
    this.connectedChain = "BTC";
    this.supportedChains = ["BTC"];
    this.canFetchConnectedAccounts = false;
    this.isHardwareWalletEnabled = false;
    this.verifiedCredentials = [];
    this.overrideKey = (_a = opts.overrideKey) !== null && _a !== void 0 ? _a : this.key;
    const walletBookWallet = opts.walletData || getWalletBookWallet(this.walletBook, this.key);
    this.bitcoinProviderHelper = new BitcoinProviderHelper(walletBookWallet);
    this.wallet = this.bitcoinProviderHelper.findWallet();
    if (this.wallet) {
      this.walletMethods = this.bitcoinProviderHelper.getWalletMethods(this.wallet);
    }
    this.cache = new BitcoinLocalStorageCache(this.overrideKey);
    this.canFetchConnectedAccounts = isConnectorMethodSupported(this, "getConnectedAccounts", "desktop");
  }
  isSameAccountChangeRequest(to) {
    return this.lastAccountChange === to;
  }
  setLastAccountChangeRequest(to) {
    this.lastAccountChange = to;
  }
  clearConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.cache.clearConnectedAcccounts();
    });
  }
  canConnectWithHardwareWallet() {
    var _a;
    return Boolean((_a = this.metadata.supportedHardwareWallets) === null || _a === void 0 ? void 0 : _a.includes("ledger"));
  }
  isInstalledOnBrowser() {
    var _a;
    return Boolean(this.wallet) || Boolean((_a = this.bitcoinProviderHelper) === null || _a === void 0 ? void 0 : _a.getProvider());
  }
  getDeepLink() {
    return void 0;
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.cache.clearConnectedAcccounts();
    });
  }
  apiGetBalance(address2) {
    return __awaiter(this, void 0, void 0, function* () {
      const API_URL = getMempoolApiUrl(address2);
      const response = yield fetch(`${API_URL}/address/${address2}`);
      if (!response.ok) {
        if (response.status === HTTP_STATUS_TOO_MANY_REQUESTS) {
          return "0";
        }
        if (response.status === HTTP_STATUS_NOT_FOUND) {
          return "0";
        }
        return void 0;
      }
      const addressInfo = yield response.json();
      if (!(addressInfo === null || addressInfo === void 0 ? void 0 : addressInfo.chain_stats) || !(addressInfo === null || addressInfo === void 0 ? void 0 : addressInfo.mempool_stats)) {
        return void 0;
      }
      const confirmedBalanceInSats = Number(addressInfo.chain_stats.funded_txo_sum) - Number(addressInfo.chain_stats.spent_txo_sum);
      const unconfirmedBalanceInSats = Number(addressInfo.mempool_stats.funded_txo_sum) - Number(addressInfo.mempool_stats.spent_txo_sum);
      const balance = satoshisToBtc(confirmedBalanceInSats + unconfirmedBalanceInSats);
      return balance.toString();
    });
  }
  getBalance(address2) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!(provider === null || provider === void 0 ? void 0 : provider.getBalance)) {
        return this.apiGetBalance(address2);
      }
      const balanceResponse = yield provider.getBalance();
      const balance = satoshisToBtc(balanceResponse.total);
      return balance.toString();
    });
  }
  getConnectedAccountsFromCache() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const currentAccount = yield this.cache.getActiveAccount();
      const allAccounts = yield this.cache.getConnectedAccounts();
      const allConnectedAddresses = (_a = Object.keys(allAccounts || {})) !== null && _a !== void 0 ? _a : [];
      if (!(currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.address)) {
        return allConnectedAddresses;
      }
      return [
        currentAccount.address,
        ...allConnectedAddresses.filter((address2) => address2 !== currentAccount.address)
      ];
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.canFetchConnectedAccounts) {
        return this.getConnectedAccountsFromCache();
      }
      if (!this.getAddressPromise) {
        this.getAddressPromise = this.getAddress();
      }
      let connectedAccount;
      try {
        connectedAccount = yield this.getAddressPromise;
      } catch (error) {
        logger.error(`${this.key} getConnectedAccounts - error fetching connected account`, error);
      }
      this.getAddressPromise = void 0;
      if (!connectedAccount) {
        return [];
      }
      return [connectedAccount];
    });
  }
  getAdditionalAddresses(mainAddress) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!mainAddress) {
        return [];
      }
      const currentAccount = yield this.cache.getConnectedAccount(mainAddress);
      return (currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.additionalAddresses) || [];
    });
  }
  setAdditionalAddresses(mainAddress, additionalAddresses) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.cache.setConnectedAccount(mainAddress, {
        additionalAddresses
      });
    });
  }
  sendRawTransaction(rawTransaction) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!rawTransaction) {
        throw new DynamicError("No transaction specified!");
      }
      const [connectedAddress] = yield this.getConnectedAccounts();
      if (!connectedAddress) {
        throw new DynamicError("No connected address found!");
      }
      const API_URL = getMempoolApiUrl(connectedAddress);
      const response = yield fetch(`${API_URL}/tx`, {
        body: rawTransaction,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        method: "POST"
      });
      if (!response.ok) {
        if (response.status === HTTP_STATUS_TOO_MANY_REQUESTS) {
          throw new DynamicError("sendRawTransaction - mempool api rate limit exceeded");
        }
        const error = yield response.text();
        logger.debug(`sendRawTransaction - response not ok: ${JSON.stringify(error)}`);
        throw new DynamicError("sendRawTransaction - failed to send transaction");
      }
      return response.text();
    });
  }
  // not all wallets support sendBitcoin method
  // so we have a default implementation that returns undefined
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      logger.debug("sendBitcoin - function not implemented", transaction);
      return void 0;
    });
  }
  getProvider() {
    var _a;
    return (_a = this.bitcoinProviderHelper) === null || _a === void 0 ? void 0 : _a.getProvider();
  }
  signPsbts(requests) {
    return __awaiter(this, void 0, void 0, function* () {
      const signedPsbtResponses = [];
      for (const request2 of requests) {
        const signedPsbtResponse = yield this.signPsbt(request2);
        if (signedPsbtResponse) {
          signedPsbtResponses.push(signedPsbtResponse);
        }
      }
      return signedPsbtResponses.map((response) => response.signedPsbt);
    });
  }
  setConnectedAccountWithAddresses(_a) {
    return __awaiter(this, arguments, void 0, function* ({ mainAddress, ordinalsAddress, paymentAddress, active }) {
      if (!mainAddress) {
        return;
      }
      const additionalAddresses = [];
      if (ordinalsAddress) {
        additionalAddresses.push({
          address: ordinalsAddress.address,
          publicKey: ordinalsAddress.publicKey,
          type: WalletAddressType.Ordinals
        });
      }
      if (paymentAddress) {
        additionalAddresses.push({
          address: paymentAddress.address,
          publicKey: paymentAddress.publicKey,
          type: WalletAddressType.Payment
        });
      }
      this.cache.setConnectedAccount(mainAddress, {
        active,
        additionalAddresses
      });
    });
  }
  setupEventListeners() {
    const provider = this.getProvider();
    if (!(provider === null || provider === void 0 ? void 0 : provider.on)) {
      return;
    }
    const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
    const handleBitcoinAccountChange = (accounts) => __awaiter(this, void 0, void 0, function* () {
      let connectedAccounts = accounts;
      let ordinalsAccount, paymentAccount;
      if (typeof accounts[0] === "object") {
        connectedAccounts = accounts.sort((account) => account.purpose === AddressPurpose.Ordinals ? -1 : 1).map((account) => account.address);
        [ordinalsAccount, paymentAccount] = connectedAccounts;
      }
      const currentConnectedAccounts = yield this.getConnectedAccountsFromCache();
      if (currentConnectedAccounts[0] === connectedAccounts[0] || this.isSameAccountChangeRequest(connectedAccounts[0])) {
        return;
      }
      this.setLastAccountChangeRequest(connectedAccounts[0]);
      if (ordinalsAccount || paymentAccount) {
        this.setConnectedAccountWithAddresses({
          active: true,
          mainAddress: ordinalsAccount !== null && ordinalsAccount !== void 0 ? ordinalsAccount : paymentAccount,
          ordinalsAddress: ordinalsAccount,
          paymentAddress: paymentAccount
        });
      }
      handleAccountChange(connectedAccounts);
    });
    provider.on("accountsChanged", handleBitcoinAccountChange);
    provider.on("networkChanged", handleChainChange);
    provider.on("disconnect", handleDisconnect);
    const tearDownEventListeners = () => {
      const provider2 = this.getProvider();
      if (!(provider2 === null || provider2 === void 0 ? void 0 : provider2.removeListener)) {
        return;
      }
      provider2.removeListener("accountsChanged", handleBitcoinAccountChange);
      provider2.removeListener("networkChanged", handleChainChange);
      provider2.removeListener("disconnect", handleDisconnect);
    };
    this.teardownEventListeners = tearDownEventListeners;
  }
  setVerifiedCredentials(verifiedCredentials) {
    this.verifiedCredentials = verifiedCredentials;
  }
  isLedgerAddress(address2) {
    return isLedgerAddressViaVerifiedCredentials(address2, this.verifiedCredentials);
  }
  // Each wallet has a different supported protocol
  // So we should override this method in each connector
  // and define how to handle the protocol
  signMessage(messageToSign, options) {
    const _super = Object.create(null, {
      signMessage: { get: () => super.signMessage }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (options) {
        logger.debug("[BitcoinWalletConnector] signMessage - Not possible to specify address and/or protocol to sign with", {
          address: options.address,
          protocol: options.protocol
        });
      }
      return _super.signMessage.call(this, messageToSign);
    });
  }
  proveOwnership(address2, messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.signMessage(messageToSign, { address: address2 });
    });
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      return ["https://btcscan.org/"];
    });
  }
  openInAppBrowserIfRequired() {
    var _a;
    if (this.isInstalledOnBrowser() || !isMobile() || !((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl) || this.mobileExperience === "redirect") {
      return false;
    }
    const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
    const deepLink = inAppBrowserCompiledTemplate({
      // TODO: use PlatformService
      encodedDappURI: encodeURIComponent(window.location.toString())
    });
    PlatformService.openURL(deepLink);
    return true;
  }
};

// node_modules/@dynamic-labs/bitcoin/src/index.js
var import_bitcoinjs_lib15 = __toESM(require_src());

// node_modules/@dynamic-labs/bitcoin/src/connectors/BitcoinSatsConnectConnector/BitcoinSatsConnectConnector.js
var import_bitcoinjs_lib5 = __toESM(require_src(), 1);

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/bitcoinNetworkTypeToNetworks.js
var import_bitcoinjs_lib = __toESM(require_src(), 1);
var convertNetworkTypeForPsbt = (network) => ({
  [BitcoinNetworkType.Mainnet]: import_bitcoinjs_lib.networks.bitcoin,
  [BitcoinNetworkType.Testnet]: import_bitcoinjs_lib.networks.testnet,
  [BitcoinNetworkType.Signet]: void 0,
  [BitcoinNetworkType.Regtest]: import_bitcoinjs_lib.networks.regtest,
  [BitcoinNetworkType.Testnet4]: import_bitcoinjs_lib.networks.testnet
})[network];

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/extractAddressFromInput.js
var import_bitcoinjs_lib2 = __toESM(require_src(), 1);
var extractAddressFromInput = (psbt, index, input) => {
  var _a;
  let script;
  if ((_a = input.witnessUtxo) === null || _a === void 0 ? void 0 : _a.script) {
    script = input.witnessUtxo.script;
  } else if (input.nonWitnessUtxo) {
    const nonWitnessTxn = import_bitcoinjs_lib2.Transaction.fromBuffer(input.nonWitnessUtxo);
    const txOut = nonWitnessTxn.outs[psbt.txInputs[index].index];
    script = txOut.script;
  }
  if (!script)
    return;
  try {
    return import_bitcoinjs_lib2.address.fromOutputScript(script);
  } catch (e2) {
    throw new Error("address not found in output script");
  }
};

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/validator/validateAddress.js
var validateAddress = (psbt, signingAddress, index, inputAtIndex) => {
  const extractedAddress = extractAddressFromInput(psbt, index, inputAtIndex);
  if (!extractedAddress)
    throw new DynamicError(`validateAddress - input not found for the given address: ${signingAddress}`);
  if (extractedAddress !== signingAddress)
    throw new DynamicError("validateAddress - address mismatch with index");
};

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/getSigHashType.js
var import_bitcoinjs_lib3 = __toESM(require_src(), 1);
var getSigHashType = (input) => {
  var _a;
  if (input === null || input === void 0 ? void 0 : input.sighashType)
    return input.sighashType;
  let isTaprootAddress = false;
  if ((_a = input.witnessUtxo) === null || _a === void 0 ? void 0 : _a.script) {
    try {
      import_bitcoinjs_lib3.payments.p2tr({
        output: input.witnessUtxo.script
      });
      isTaprootAddress = true;
    } catch (_2) {
      logger.debug("address is not taproot");
    }
  }
  return isTaprootAddress ? import_bitcoinjs_lib3.Transaction.SIGHASH_DEFAULT : import_bitcoinjs_lib3.Transaction.SIGHASH_ALL;
};

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/validator/validateSigHash.js
var validateSigHash = (allowedSigHashTypes, selectedInput) => {
  const sigHashType = getSigHashType(selectedInput);
  if ((allowedSigHashTypes === null || allowedSigHashTypes === void 0 ? void 0 : allowedSigHashTypes.length) && !allowedSigHashTypes.includes(sigHashType))
    throw new Error(`validatePsbt - sigHashType ${sigHashType} not in allowed list`);
};

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/validator/validatePsbt.js
var validatePsbt = (psbt, allowedSigHashTypes, signatureData) => {
  if (!(signatureData === null || signatureData === void 0 ? void 0 : signatureData.length))
    return;
  for (const input of signatureData) {
    const {
      address: signingAddress,
      signingIndexes,
      // request from ME in cases of multi-sig. Steven wanted this defaulted to true
      disableAddressValidation = true
    } = input;
    if (!(signingIndexes === null || signingIndexes === void 0 ? void 0 : signingIndexes.length))
      return;
    if (!signingAddress)
      throw new Error("validatePsbt - address not provided");
    for (const index of signingIndexes) {
      const selectedInput = psbt.data.inputs[index];
      if (!selectedInput)
        throw new Error("validatePsbt - requested input not found");
      if (!disableAddressValidation) {
        validateAddress(psbt, signingAddress, index, selectedInput);
      }
      validateSigHash(allowedSigHashTypes, selectedInput);
    }
  }
};

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/createSignPsbtOptions.js
var import_bitcoinjs_lib4 = __toESM(require_src(), 1);
var createPsbtOptions = (psbt, request2) => {
  var _a;
  const psbtSignOptions = {
    autoFinalized: false
  };
  if (request2.signature) {
    validatePsbt(psbt, request2.allowedSighash, request2.signature);
    const toSignInputs = [];
    for (const signature of request2.signature) {
      if ((_a = signature.signingIndexes) === null || _a === void 0 ? void 0 : _a.length) {
        for (const index of signature.signingIndexes) {
          toSignInputs.push({
            address: signature.address,
            disableAddressValidation: signature.disableAddressValidation,
            index,
            sighashTypes: request2.allowedSighash
          });
        }
      }
    }
    psbtSignOptions.toSignInputs = toSignInputs;
  }
  return psbtSignOptions;
};
var createSignPsbtOptionsForSatsConnect = (psbtFromBase64, request2, isLegacyConnector = false) => {
  var _a, _b, _c;
  if ((_a = request2.signature) === null || _a === void 0 ? void 0 : _a.length) {
    validatePsbt(psbtFromBase64, request2.allowedSighash, request2.signature);
  }
  logger.logVerboseTroubleshootingMessage("createSignPsbtOptionsForSatsConnect", { isLegacyConnector, psbtFromBase64, request: request2 });
  const inputsToSign = ((_c = (_b = request2.signature) === null || _b === void 0 ? void 0 : _b.map((sig) => {
    var _a2;
    return ((_a2 = sig.signingIndexes) !== null && _a2 !== void 0 ? _a2 : []).map((inputIndex) => ({
      address: sig.address,
      sigHash: isLegacyConnector ? getSigHashType(psbtFromBase64.data.inputs[inputIndex]) : request2.allowedSighash[0],
      signingIndexes: [inputIndex]
    }));
  })) !== null && _c !== void 0 ? _c : []).flat();
  logger.logVerboseTroubleshootingMessage("createSignPsbtOptionsForSatsConnect", { inputsToSign });
  return inputsToSign;
};

// node_modules/@dynamic-labs/bitcoin/src/utils/getSatsConnectSigningProtocol/getSatsConnectSigningProtocol.js
var getSatsConnectSigningProtocol = (protocol) => {
  if (!protocol) {
    return void 0;
  }
  return protocol === "ecdsa" ? MessageSigningProtocols.ECDSA : MessageSigningProtocols.BIP322;
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/BitcoinSatsConnectConnector/BitcoinSatsConnectConnector.js
var BitcoinSatsConnectConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    var _a, _b, _c;
    super(opts);
    this.isLegacy = false;
    this.currentNetwork = BitcoinNetworkType.Mainnet;
    if ((_b = (_a = opts.walletData) === null || _a === void 0 ? void 0 : _a.injectedConfig) === null || _b === void 0 ? void 0 : _b.length) {
      this.providerId = (_c = opts.walletData.injectedConfig[0].walletStandard) === null || _c === void 0 ? void 0 : _c.providerId;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getBalance(address2) {
    return __awaiter(this, void 0, void 0, function* () {
      const balance = yield request("getBalance", void 0);
      if (balance.status !== "success") {
        throw balance.error;
      }
      return satoshisToBtc(Number(balance.result.confirmed)).toString();
    });
  }
  getGenericUserCancelledError() {
    const error = new Error();
    error.code = "-32000";
    return error;
  }
  getAddresses() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const getAddressResponse = yield request("getAddresses", {
        purposes: [AddressPurpose.Payment, AddressPurpose.Ordinals]
      });
      if (getAddressResponse.status !== "success") {
        throw getAddressResponse.error;
      }
      const { addresses } = getAddressResponse.result;
      const ordinalsAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address2) => address2.purpose === AddressPurpose.Ordinals);
      const paymentAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address2) => address2.purpose === AddressPurpose.Payment);
      const mainAddress = (_a = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _a !== void 0 ? _a : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress,
        ordinalsAddress: ordinalsAccount,
        paymentAddress: paymentAccount
      });
      return mainAddress;
    });
  }
  /**
   * If is inAppBrowser experience, redirects to the inAppBrowser template.
   * Returns true if redirection was triggered.
   */
  handleInAppBrowserGetAddress() {
    var _a;
    const inAppBrowserUrl = (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl;
    if (!isMobile() || this.isInstalledOnBrowser() || !inAppBrowserUrl || this.mobileExperience !== "in-app-browser")
      return false;
    const inAppBrowserTemplate = template(inAppBrowserUrl);
    const deepLink = inAppBrowserTemplate({
      // TODO: use PlatformService
      encodedDappURI: encodeURIComponent(window.location.toString())
    });
    PlatformService.openURL(deepLink);
    return true;
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.handleInAppBrowserGetAddress())
        return;
      try {
        const permissionResponse = yield request("wallet_requestPermissions", void 0);
        if (permissionResponse.status !== "success") {
          throw permissionResponse.error;
        }
        const address2 = yield this.getAddresses();
        return address2;
      } catch (_2) {
        const error = this.getGenericUserCancelledError();
        throw error;
      }
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const { address: address2, protocol } = options;
      try {
        const response = yield request("signMessage", {
          address: address2,
          message: messageToSign,
          protocol: getSatsConnectSigningProtocol(protocol)
        });
        if (response.status !== "success") {
          throw response.error;
        }
        if (this.isHardwareWalletEnabled) {
          return JSON.stringify({
            signedTransaction: {
              data: response.result.signature
            }
          });
        }
        return response.result.signature;
      } catch (_2) {
        const error = this.getGenericUserCancelledError();
        throw error;
      }
    });
  }
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const response = yield request("sendTransfer", {
          recipients: [
            {
              address: transaction.recipientAddress,
              amount: Number(transaction.amount)
            }
          ]
        });
        if (response.status !== "success") {
          throw response.error;
        }
        return response.result.txid;
      } catch (_2) {
        const error = this.getGenericUserCancelledError();
        throw error;
      }
    });
  }
  signTransaction(params) {
    return __awaiter(this, void 0, void 0, function* () {
      const { allowedSignHash, psbtBase64, broadcast, inputsToSign } = params;
      const signPbstPayload = {
        allowedSignHash,
        broadcast,
        psbt: psbtBase64,
        // we have to combine signing indexes for like addresses
        signInputs: inputsToSign.reduce((accum, curr) => {
          if (!accum[curr.address]) {
            accum[curr.address] = [];
          }
          accum[curr.address].push(...curr.signingIndexes);
          return accum;
        }, {})
      };
      logger.logVerboseTroubleshootingMessage("[BitcoinSatsConnectConnector] signTransaction", {
        signPbstPayload
      });
      try {
        const response = yield request("signPsbt", signPbstPayload);
        if (response.status !== "success") {
          throw response.error;
        }
        return { psbtBase64: response.result.psbt, txId: response.result.txid };
      } catch (_2) {
        const error = this.getGenericUserCancelledError();
        throw error;
      }
    });
  }
  signTransactions(transactions) {
    return __awaiter(this, void 0, void 0, function* () {
      const { message, psbts, network } = transactions;
      logger.logVerboseTroubleshootingMessage("[BitcoinSatsConnectConnector] signTransactions", {
        transactions
      });
      return new Promise((resolve, reject) => {
        signMultipleTransactions({
          getProvider: () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
          }),
          onCancel: () => {
            const error = this.getGenericUserCancelledError();
            reject(error);
          },
          onFinish: (response) => {
            resolve(response);
          },
          payload: {
            message: message || "Sign Transaction",
            network,
            psbts
          }
        });
      });
    });
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      if (!((_a = request2.allowedSighash) === null || _a === void 0 ? void 0 : _a.length))
        throw new Error("allowedSighash cannot be an empty array");
      const network = convertNetworkTypeForPsbt(this.currentNetwork);
      const psbtFromBase64 = import_bitcoinjs_lib5.Psbt.fromBase64(request2.unsignedPsbtBase64, {
        network
      });
      logger.logVerboseTroubleshootingMessage("signPsbt", {
        isLegacy: this.isLegacy,
        psbtFromBase64,
        request: request2
      });
      const signedPsbt = yield this.signTransaction({
        broadcast: false,
        inputsToSign: createSignPsbtOptionsForSatsConnect(psbtFromBase64, request2, this.isLegacy),
        psbtBase64: request2.unsignedPsbtBase64
      });
      if (!signedPsbt) {
        throw new Error("Failed to sign transaction with sats-connect");
      }
      return { signedPsbt: signedPsbt.psbtBase64 };
    });
  }
  signPsbts(requests) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const network = convertNetworkTypeForPsbt(this.currentNetwork);
      const signMultipleTransactionPayload = {
        message: "Sign Transaction",
        network: {
          type: this.currentNetwork
        },
        psbts: []
      };
      for (const request2 of requests) {
        const psbtFromBase64 = import_bitcoinjs_lib5.Psbt.fromBase64(request2.unsignedPsbtBase64, {
          network
        });
        const inputsToSign = createSignPsbtOptionsForSatsConnect(psbtFromBase64, request2, this.isLegacy);
        signMultipleTransactionPayload.psbts.push({
          inputsToSign,
          psbtBase64: request2.unsignedPsbtBase64
        });
      }
      logger.logVerboseTroubleshootingMessage("signPsbts", signMultipleTransactionPayload);
      const signedPsbts = yield this.signTransactions(signMultipleTransactionPayload);
      return (_a = signedPsbts === null || signedPsbts === void 0 ? void 0 : signedPsbts.map((signedPsbts2) => signedPsbts2.psbtBase64)) !== null && _a !== void 0 ? _a : [];
    });
  }
  validateActiveWallet(expectedAddress) {
    const _super = Object.create(null, {
      validateActiveWallet: { get: () => super.validateActiveWallet }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (this.key !== "xverse") {
        yield _super.validateActiveWallet.call(this, expectedAddress);
        return;
      }
      logger.debug("validateActiveWallet - skipping validation for xverse", {
        expectedAddress
      });
    });
  }
  handleXverseAccountChange() {
    return __awaiter(this, void 0, void 0, function* () {
      const { handleAccountChange } = eventListenerHandlers(this);
      const accounts = yield this.getAddresses();
      if (!accounts) {
        return;
      }
      const connectedAccounts = [accounts];
      handleAccountChange(connectedAccounts);
    });
  }
  setupEventListeners() {
    if (this.key !== "xverse") {
      super.setupEventListeners();
      return;
    }
    try {
      const removeListener = addListener("accountChange", this.handleXverseAccountChange.bind(this));
      this.teardownEventListeners = () => {
        logger.debug("[BitcoinSatsConnectConnector] teardownEventListeners");
        removeListener();
      };
    } catch (error) {
      logger.debug("[BitcoinSatsConnectConnector] setupEventListeners", {
        connector: this.key,
        error
      });
    }
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/MagicEdenConnector/MagicEdenConnector.js
var import_jsontokens9 = __toESM(require_lib2(), 1);
var MagicEdenConnector = class extends BitcoinSatsConnectConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "magicedenbtc" }));
    this.name = "Magic Eden";
    this.overrideKey = "magicedenbtc";
    this.isLegacy = true;
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.handleInAppBrowserGetAddress())
        return;
      return new Promise((resolve, reject) => {
        getAddress({
          getProvider: () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
          }),
          onCancel: () => {
            const error = new Error();
            error.code = "-32000";
            reject(error);
          },
          onFinish: (response) => __awaiter(this, void 0, void 0, function* () {
            var _c;
            const { addresses } = response;
            const ordinalsAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address2) => address2.purpose === AddressPurpose.Ordinals);
            const paymentAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address2) => address2.purpose === AddressPurpose.Payment);
            const mainAddress = (_c = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _c !== void 0 ? _c : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
            yield this.setConnectedAccountWithAddresses({
              active: true,
              mainAddress,
              ordinalsAddress: ordinalsAccount,
              paymentAddress: paymentAccount
            });
            resolve(mainAddress);
          }),
          payload: {
            message: "Address for receiving Ordinals and payments",
            network: {
              type: this.currentNetwork
            },
            purposes: [AddressPurpose.Ordinals, AddressPurpose.Payment]
          }
        });
      });
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const { address: address2, protocol } = options;
      return new Promise((resolve, reject) => {
        signMessage({
          getProvider: () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
          }),
          onCancel: () => {
            const error = new Error();
            error.code = "-32000";
            reject(error);
          },
          onFinish: (response) => __awaiter(this, void 0, void 0, function* () {
            if (this.isHardwareWalletEnabled) {
              return resolve(JSON.stringify({
                signedTransaction: {
                  data: response
                }
              }));
            }
            resolve(response);
          }),
          payload: {
            address: address2,
            message: messageToSign,
            network: {
              type: this.currentNetwork
            },
            protocol: getSatsConnectSigningProtocol(protocol)
          }
        });
      });
    });
  }
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const mainAddress = yield this.getAddress();
      const senderAddress = (_a = (yield this.getAdditionalAddresses(mainAddress)).find((address2) => address2.type === "payment")) === null || _a === void 0 ? void 0 : _a.address;
      if (!senderAddress) {
        return;
      }
      return new Promise((resolve, reject) => {
        sendBtcTransaction({
          getProvider: () => __awaiter(this, void 0, void 0, function* () {
            var _a2, _b;
            return (_b = (_a2 = this.wallet) === null || _a2 === void 0 ? void 0 : _a2.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
          }),
          onCancel: () => {
            const error = new Error();
            error.code = "-32000";
            reject(error);
          },
          onFinish: (response) => {
            resolve(response);
          },
          payload: {
            network: {
              type: this.currentNetwork
            },
            recipients: [
              {
                address: transaction.recipientAddress,
                amountSats: BigInt(transaction.amount)
              }
            ],
            senderAddress
          }
        });
      });
    });
  }
  signTransaction(params) {
    return __awaiter(this, void 0, void 0, function* () {
      const { message, psbtBase64, broadcast, inputsToSign } = params;
      return new Promise((resolve, reject) => {
        signTransaction({
          getProvider: () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
          }),
          onCancel: () => {
            const error = new Error();
            error.code = "-32000";
            reject(error);
          },
          onFinish: (response) => {
            resolve(response);
          },
          payload: {
            broadcast,
            inputsToSign,
            message: message || "Sign Transaction",
            network: {
              type: this.currentNetwork
            },
            psbtBase64
          }
        });
      });
    });
  }
  /**
   * Uses the custom Magic Eden signTransactions feature to sign multiple transactions
   */
  signTransactions(transactions) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      (_a = transactions.message) !== null && _a !== void 0 ? _a : transactions.message = "Sign Transaction";
      const request2 = (0, import_jsontokens9.createUnsecuredToken)(transactions);
      const provider = this.getProvider();
      if (!provider)
        throw new DynamicError("signTransactions failed: Magic Eden provider not found");
      return provider.signMultipleTransactions(request2);
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/PhantomConnector/PhantomConnector.js
var import_bitcoinjs_lib7 = __toESM(require_src(), 1);

// node_modules/@dynamic-labs/bitcoin/src/utils/psbt/sighashNumberToString.js
var import_bitcoinjs_lib6 = __toESM(require_src(), 1);
var sighashNumberToString = (sighashType) => {
  switch (sighashType) {
    case import_bitcoinjs_lib6.Transaction.SIGHASH_ALL:
      return "ALL";
    case import_bitcoinjs_lib6.Transaction.SIGHASH_NONE:
      return "NONE";
    case import_bitcoinjs_lib6.Transaction.SIGHASH_SINGLE:
      return "SINGLE";
    case import_bitcoinjs_lib6.Transaction.SIGHASH_ALL + import_bitcoinjs_lib6.Transaction.SIGHASH_ANYONECANPAY:
      return "ALL|ANYONECANPAY";
    case import_bitcoinjs_lib6.Transaction.SIGHASH_NONE + import_bitcoinjs_lib6.Transaction.SIGHASH_ANYONECANPAY:
      return "NONE|ANYONECANPAY";
    case import_bitcoinjs_lib6.Transaction.SIGHASH_SINGLE + import_bitcoinjs_lib6.Transaction.SIGHASH_ANYONECANPAY:
      return "SINGLE|ANYONECANPAY";
    default:
      return;
  }
};

// node_modules/@dynamic-labs/bitcoin/src/utils/base64.js
var decodeBase64 = (base64) => Uint8Array.from(Buffer.from(base64, "base64"));
var encodeBase64 = (uint8Array) => Buffer.from(uint8Array).toString("base64");

// node_modules/@dynamic-labs/bitcoin/src/connectors/PhantomConnector/PhantomConnector.js
var PhantomConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "phantombtc" }));
    this.name = "Phantom";
  }
  connectWithInstalledExtension() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      let paymentAccount, ordinalsAccount;
      if ((_a = this.walletMethods) === null || _a === void 0 ? void 0 : _a.connect) {
        const { accounts } = yield this.walletMethods.connect();
        const parsedAccounts = accounts.map((account) => ({
          address: account.address,
          publicKey: Buffer.from(account.publicKey).toString("hex")
        }));
        [paymentAccount, ordinalsAccount] = parsedAccounts;
        if (!ordinalsAccount) {
          ordinalsAccount = paymentAccount;
        }
      } else {
        const provider = this.getProvider();
        if (!provider) {
          return;
        }
        const accounts = yield provider.requestAccounts();
        ordinalsAccount = accounts === null || accounts === void 0 ? void 0 : accounts.find((address2) => address2.purpose === "ordinals");
        paymentAccount = accounts === null || accounts === void 0 ? void 0 : accounts.find((address2) => address2.purpose === "payment");
      }
      const mainAddress = (_b = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _b !== void 0 ? _b : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress,
        ordinalsAddress: ordinalsAccount,
        paymentAddress: paymentAccount
      });
      return mainAddress;
    });
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.isInstalledOnBrowser()) {
        return this.connectWithInstalledExtension();
      }
      if (isMobile()) {
        handleMobileWalletRedirect({
          nativeLink: "phantom://browse",
          universalLink: "https://phantom.app/ul/browse"
        });
      }
      return void 0;
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const { address: address2 } = options;
      if ((_a = this.walletMethods) === null || _a === void 0 ? void 0 : _a.signMessage) {
        const [result] = yield this.walletMethods.signMessage({
          // we need to sign with the ordinals account
          account: { address: address2 },
          message: new TextEncoder().encode(messageToSign)
        });
        return Buffer.from(result.signature).toString("base64");
      } else {
        const provider = this.getProvider();
        if (!provider) {
          return;
        }
        const result = yield provider.signMessage(address2, new TextEncoder().encode(messageToSign));
        return Buffer.from(result.signature).toString("base64");
      }
    });
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e2;
      const [walletAddress] = yield this.getConnectedAccounts();
      if (!walletAddress) {
        return;
      }
      const psbtFromBase64 = import_bitcoinjs_lib7.Psbt.fromBase64(request2.unsignedPsbtBase64);
      const psbtOptions = createPsbtOptions(psbtFromBase64, request2);
      if ((_a = this.walletMethods) === null || _a === void 0 ? void 0 : _a.signTransaction) {
        const [signedPsbtHex] = yield this.walletMethods.signTransaction({
          inputsToSign: (_c = (_b = psbtOptions.toSignInputs) === null || _b === void 0 ? void 0 : _b.map((input) => ({
            account: { address: input.address },
            sigHash: input.sighashTypes && sighashNumberToString(input.sighashTypes[0]),
            signingIndexes: [input.index]
          }))) !== null && _c !== void 0 ? _c : [],
          psbt: decodeBase64(request2.unsignedPsbtBase64)
        });
        return {
          signedPsbt: Buffer.from(signedPsbtHex.signedPsbt).toString("base64")
        };
      } else {
        const provider = this.getProvider();
        if (!provider) {
          return;
        }
        const inputsToSign = (_e2 = (_d = request2.signature) === null || _d === void 0 ? void 0 : _d.map((sig) => {
          var _a2;
          return {
            address: sig.address,
            sigHash: request2.allowedSighash[0],
            signingIndexes: (_a2 = sig.signingIndexes) !== null && _a2 !== void 0 ? _a2 : []
          };
        })) !== null && _e2 !== void 0 ? _e2 : [];
        const signedPsbt = yield provider.signPSBT(decodeBase64(request2.unsignedPsbtBase64), {
          inputsToSign
        });
        return { signedPsbt: encodeBase64(Uint8Array.from(signedPsbt)) };
      }
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/OkxConnector/OkxConnector.js
var import_bitcoinjs_lib8 = __toESM(require_src(), 1);
var OkxConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "okxwalletbtc" }));
    this.name = "OKX Wallet";
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const { address: address2, publicKey } = yield provider.connect();
      const bitcoinAddress = {
        address: address2,
        publicKey
      };
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress: address2,
        ordinalsAddress: bitcoinAddress
      });
      return address2;
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const protocol = (_a = options === null || options === void 0 ? void 0 : options.protocol) !== null && _a !== void 0 ? _a : "bip322-simple";
      if (options === null || options === void 0 ? void 0 : options.address) {
        logger.debug("[OkxConnector] signMessage - Not possible to specify address to sign with", {
          address: options.address,
          protocol
        });
      }
      return provider.signMessage(messageToSign, protocol);
    });
  }
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      const connectedAddress = yield this.getAddress();
      if (!connectedAddress || !provider) {
        return;
      }
      return provider.sendBitcoin(transaction.recipientAddress, transaction.amount.toString());
    });
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtFromBase64 = import_bitcoinjs_lib8.Psbt.fromBase64(request2.unsignedPsbtBase64);
      const signedPsbtHex = yield provider.signPsbt(psbtFromBase64.toHex(), createPsbtOptions(psbtFromBase64, request2));
      return { signedPsbt: import_bitcoinjs_lib8.Psbt.fromHex(signedPsbtHex).toBase64() };
    });
  }
  signPsbts(requests) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtHexs = [];
      const psbtOptions = [];
      for (const request2 of requests) {
        const psbt = import_bitcoinjs_lib8.Psbt.fromBase64(request2.unsignedPsbtBase64);
        psbtHexs.push(psbt.toHex());
        psbtOptions.push(createPsbtOptions(psbt, request2));
      }
      const signedPsbtHexs = yield provider.signPsbts(psbtHexs, psbtOptions);
      return signedPsbtHexs.map((signedPsbtHex) => import_bitcoinjs_lib8.Psbt.fromHex(signedPsbtHex).toBase64());
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/OneKeyConnector/OneKeyConnector.js
var import_bitcoinjs_lib9 = __toESM(require_src(), 1);
var OneKeyConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "onekeybtc" }));
    this.name = "OneKey";
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const [address2] = yield provider.requestAccounts();
      const bitcoinAddress = {
        address: address2,
        publicKey: yield provider.getPublicKey()
      };
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress: address2,
        ordinalsAddress: bitcoinAddress
      });
      return address2;
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return [];
      }
      return provider.getAccounts();
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const protocol = (_a = options === null || options === void 0 ? void 0 : options.protocol) !== null && _a !== void 0 ? _a : "ecdsa";
      if (options === null || options === void 0 ? void 0 : options.address) {
        logger.debug("[OneKeyConnector] signMessage - Not possible to specify address to sign with", {
          address: options.address
        });
      }
      return provider.signMessage(messageToSign, protocol);
    });
  }
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      return provider.sendBitcoin(transaction.recipientAddress, transaction.amount.toString());
    });
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtFromBase64 = import_bitcoinjs_lib9.Psbt.fromBase64(request2.unsignedPsbtBase64);
      const signedPsbtHex = yield provider.signPsbt(psbtFromBase64.toHex(), {
        autoFinalized: false
      });
      return { signedPsbt: import_bitcoinjs_lib9.Psbt.fromHex(signedPsbtHex).toBase64() };
    });
  }
  signPsbts(requests) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtHexs = [];
      const psbtOptions = [];
      for (const request2 of requests) {
        const psbt = import_bitcoinjs_lib9.Psbt.fromBase64(request2.unsignedPsbtBase64);
        psbtHexs.push(psbt.toHex());
        psbtOptions.push(createPsbtOptions(psbt, request2));
      }
      const signedPsbtHexs = yield provider.signPsbts(psbtHexs, {
        autoFinalized: false
      });
      return signedPsbtHexs.map((signedPsbtHex) => import_bitcoinjs_lib9.Psbt.fromHex(signedPsbtHex).toBase64());
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/OylConnector/OylConnector.js
var import_bitcoinjs_lib10 = __toESM(require_src(), 1);
var OylConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "oylwallet" }));
    this.name = "Oyl Wallet";
    this.overrideKey = "oylwallet";
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const addresses = yield provider.getAddresses();
      const ordinalsAddress = addresses.taproot;
      const paymentAddress = addresses.nativeSegwit;
      const mainAddress = (_a = ordinalsAddress === null || ordinalsAddress === void 0 ? void 0 : ordinalsAddress.address) !== null && _a !== void 0 ? _a : paymentAddress === null || paymentAddress === void 0 ? void 0 : paymentAddress.address;
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress,
        ordinalsAddress,
        paymentAddress
      });
      return mainAddress;
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const { address: address2, protocol } = options;
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const { signature } = yield provider.signMessage({
        address: address2,
        message: messageToSign,
        // Oyl Wallet calls it just bip322 instead of bip322-simple
        protocol: protocol === "bip322-simple" ? "bip322" : protocol
      });
      return signature;
    });
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtFromBase64 = import_bitcoinjs_lib10.Psbt.fromBase64(request2.unsignedPsbtBase64);
      const options = createPsbtOptions(psbtFromBase64, request2);
      const { psbt: signedPsbtHex } = yield provider.signPsbt({
        broadcast: false,
        finalize: options.autoFinalized,
        psbt: psbtFromBase64.toHex()
      });
      return { signedPsbt: import_bitcoinjs_lib10.Psbt.fromHex(signedPsbtHex).toBase64() };
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/UnisatConnector/UnisatConnector.js
var import_bitcoinjs_lib11 = __toESM(require_src(), 1);
var UnisatConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    var _a;
    super(Object.assign(Object.assign({}, opts), { overrideKey: (_a = opts.overrideKey) !== null && _a !== void 0 ? _a : "unisat" }));
    this.name = "UniSat";
    this.overrideKey = "unisat";
  }
  // other connectors use the Unisat api and extend the UnisatConnector class
  // so we need to use a different name for each connector
  getConnectorName() {
    return `${this.name.replace(" ", "")}Connector`;
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const [address2] = yield provider.requestAccounts();
      const publicKey = yield provider.getPublicKey();
      const bitcoinAddress = {
        address: address2,
        publicKey
      };
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress: address2,
        ordinalsAddress: bitcoinAddress
      });
      return address2;
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      if (options === null || options === void 0 ? void 0 : options.address) {
        logger.debug(`[${this.getConnectorName()}] signMessage - Not possible to specify address to sign with`, {
          address: options.address,
          protocol: options.protocol
        });
      }
      return provider.signMessage(messageToSign, options === null || options === void 0 ? void 0 : options.protocol);
    });
  }
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      const connectedAddress = yield this.getAddress();
      if (!connectedAddress || !provider) {
        return;
      }
      return provider.sendBitcoin(transaction.recipientAddress, Number(transaction.amount));
    });
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtFromBase64 = import_bitcoinjs_lib11.Psbt.fromBase64(request2.unsignedPsbtBase64);
      const signedPsbtHex = yield provider.signPsbt(psbtFromBase64.toHex(), createPsbtOptions(psbtFromBase64, request2));
      return { signedPsbt: import_bitcoinjs_lib11.Psbt.fromHex(signedPsbtHex).toBase64() };
    });
  }
  signPsbts(requests) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtHexs = [];
      const psbtOptions = [];
      for (const request2 of requests) {
        const psbtFromBase64 = import_bitcoinjs_lib11.Psbt.fromBase64(request2.unsignedPsbtBase64);
        psbtHexs.push(psbtFromBase64.toHex());
        psbtOptions.push(createPsbtOptions(psbtFromBase64, request2));
      }
      const signedPsbtHexs = yield provider.signPsbts(psbtHexs, psbtOptions);
      return signedPsbtHexs.map((signedPsbtHex) => import_bitcoinjs_lib11.Psbt.fromHex(signedPsbtHex).toBase64());
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return [];
      }
      return provider.getAccounts();
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/FallbackBitcoinConnector/FallbackBitcoinConnector.js
var FallbackBitcoinConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "fallbackconnector" }));
    this.name = "Fallback Connector";
    this.overrideKey = "fallbackconnector";
    this.isAvailable = false;
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      return;
    });
  }
  signPsbt(_request) {
    return __awaiter(this, void 0, void 0, function* () {
      return;
    });
  }
  signPsbts(_requests) {
    return __awaiter(this, void 0, void 0, function* () {
      return;
    });
  }
  sendBitcoin(_transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      return;
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/BinanceConnector/BinanceConnector.js
var import_bitcoinjs_lib12 = __toESM(require_src(), 1);
var BinanceConnector = class extends BitcoinWalletConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "binancewalletbtc" }));
    this.name = "Binance Wallet";
    this.overrideKey = "binancewalletbtc";
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const [address2] = yield provider.requestAccounts();
      const bitcoinAddress = {
        address: address2,
        publicKey: yield provider.getPublicKey()
      };
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress: address2,
        ordinalsAddress: bitcoinAddress
      });
      return address2;
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return [];
      }
      return provider.getAccounts();
    });
  }
  signMessage(messageToSign, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const protocol = (_a = options === null || options === void 0 ? void 0 : options.protocol) !== null && _a !== void 0 ? _a : "ecdsa";
      if (options === null || options === void 0 ? void 0 : options.address) {
        logger.debug("[OneKeyConnector] signMessage - Not possible to specify address to sign with", {
          address: options.address
        });
      }
      return provider.signMessage(messageToSign, protocol);
    });
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getProvider();
      if (!provider) {
        return;
      }
      const psbtFromBase64 = import_bitcoinjs_lib12.Psbt.fromBase64(request2.unsignedPsbtBase64);
      const psbtOptions = createPsbtOptions(psbtFromBase64, request2);
      const signedPsbtHex = yield provider.signPsbt(psbtFromBase64.toHex(), {
        autoFinalized: false,
        toSignInputs: psbtOptions.toSignInputs || []
      });
      return { signedPsbt: import_bitcoinjs_lib12.Psbt.fromHex(signedPsbtHex).toBase64() };
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/BitgetConnector/BitgetConnector.js
var BitgetConnector = class extends UnisatConnector {
  constructor(opts) {
    super(Object.assign(Object.assign({}, opts), { overrideKey: "bitgetwalletbtc" }));
    this.name = "Bitget Wallet";
    this.overrideKey = "bitgetwalletbtc";
  }
};

// node_modules/@dynamic-labs/bitcoin/src/connectors/BitcoinBtcKitConnector/BitcoinBtcKitConnector.js
var import_bitcoinjs_lib13 = __toESM(require_src(), 1);
var BitcoinBtcKitConnector = class extends BitcoinWalletConnector {
  constructor(opts, btcKit) {
    super(opts);
    this.currentNetwork = BitcoinNetworkType.Mainnet;
    this.btcKit = btcKit;
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const [connectedAccount] = yield this.getConnectedAccounts();
      if (connectedAccount) {
        return connectedAccount;
      }
      const response = yield this.btcKit.request("getAddresses", {
        types: ["p2tr", "p2wpkh"]
      });
      if (!("result" in response)) {
        logger.error("Fetch public address error", response);
        return void 0;
      }
      const { addresses } = response.result;
      const ordinalsAddress = addresses === null || addresses === void 0 ? void 0 : addresses.find((address2) => address2.type === "p2tr");
      const paymentAddress = addresses === null || addresses === void 0 ? void 0 : addresses.find((address2) => address2.type === "p2wpkh");
      const mainAddress = (_a = ordinalsAddress === null || ordinalsAddress === void 0 ? void 0 : ordinalsAddress.address) !== null && _a !== void 0 ? _a : paymentAddress === null || paymentAddress === void 0 ? void 0 : paymentAddress.address;
      yield this.setConnectedAccountWithAddresses({
        active: true,
        mainAddress,
        ordinalsAddress,
        paymentAddress
      });
      return mainAddress;
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!(yield this.getConnectedAccounts()).length)
        return void 0;
      const response = yield this.btcKit.request("signMessage", {
        message: messageToSign,
        paymentType: "p2tr"
      }).catch(({ error }) => {
        throw error;
      });
      if (!("result" in response)) {
        logger.error("Signature error", response);
        throw new Error("Failed to sign message");
      }
      const { signature } = response.result;
      if (this.isHardwareWalletEnabled) {
        return JSON.stringify({ signedTransaction: { data: signature } });
      }
      return signature;
    });
  }
  sendBitcoin(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const connectedAddress = yield this.getAddress();
      if (!connectedAddress || !this.btcKit) {
        return;
      }
      const response = yield this.btcKit.request("sendTransfer", {
        address: transaction.recipientAddress,
        amount: transaction.amount.toString(),
        network: this.convertNetworkTypeToNetworkMode()
      });
      if (!("result" in response)) {
        logger.error("Transaction error", response);
        throw new Error("Failed to send transaction");
      }
      return response.result.txid;
    });
  }
  convertNetworkTypeToNetworkMode() {
    return this.currentNetwork === BitcoinNetworkType.Mainnet ? "mainnet" : "testnet";
  }
  signPsbt(request2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const connectedAddress = yield this.getAddress();
      if (!connectedAddress || !this.btcKit) {
        return;
      }
      const network = convertNetworkTypeForPsbt(this.currentNetwork);
      const psbtFromBase64 = import_bitcoinjs_lib13.Psbt.fromBase64(request2.unsignedPsbtBase64, {
        network
      });
      if ((_a = request2.signature) === null || _a === void 0 ? void 0 : _a.length) {
        validatePsbt(psbtFromBase64, request2.allowedSighash, request2.signature);
      }
      const signPsbtRequestParams = {
        allowedSighash: request2.allowedSighash,
        hex: psbtFromBase64.toHex(),
        signAtIndex: (_b = request2.signature) === null || _b === void 0 ? void 0 : _b.flatMap((sig) => sig.signingIndexes).filter(Number.isInteger)
      };
      const signedPsbtResponse = yield this.btcKit.request("signPsbt", Object.assign({ broadcast: false, network: this.convertNetworkTypeToNetworkMode() }, signPsbtRequestParams));
      if (!signedPsbtResponse || !("result" in signedPsbtResponse) || !("hex" in signedPsbtResponse.result)) {
        throw new Error("signPsbt - failed to sign PSBT");
      }
      const psbtHex = signedPsbtResponse.result.hex;
      return { signedPsbt: import_bitcoinjs_lib13.Psbt.fromHex(psbtHex, { network }).toBase64() };
    });
  }
};

// node_modules/@dynamic-labs/bitcoin/src/utils/fetchBtcKitConnectors/fetchBtcKitConnectors.js
var fetchBtcKitConnectors = ({ walletBook }) => {
  var _a;
  return Object.entries((_a = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a !== void 0 ? _a : {}).map(([key, wallet]) => {
    var _a2, _b;
    const injectedConfig = (_a2 = wallet.injectedConfig) === null || _a2 === void 0 ? void 0 : _a2.find((config) => config.chain === "btc" && Boolean(config.providerInterface === BTCKIT_INTERFACE));
    if (!((_b = injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.windowLocations) === null || _b === void 0 ? void 0 : _b.length))
      return void 0;
    const providers = getProvidersFromWindow(injectedConfig.windowLocations[0]);
    return class extends BitcoinBtcKitConnector {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { overrideKey: key, walletData: wallet }), providers === null || providers === void 0 ? void 0 : providers[0]);
        this.name = wallet.shortName || wallet.name;
      }
    };
  }).filter((connector) => Boolean(connector));
};

// node_modules/@dynamic-labs/bitcoin/src/utils/fetchSatsConnectConnectors/fetchSatsConnectConnectors.js
var import_bitcoinjs_lib14 = __toESM(require_src(), 1);
var import_jsontokens10 = __toESM(require_lib2(), 1);
var fetchSatsConnectConnectors = ({ walletBook }) => {
  var _a;
  return Object.entries((_a = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a !== void 0 ? _a : {}).filter(([_2, wallet]) => {
    var _a2;
    return (_a2 = wallet.injectedConfig) === null || _a2 === void 0 ? void 0 : _a2.find((config) => {
      var _a3, _b;
      return config.chain === "btc" && ((_a3 = config.walletStandard) === null || _a3 === void 0 ? void 0 : _a3.features.includes(SATSCONNECT_FEATURE)) && ((_b = config.walletStandard) === null || _b === void 0 ? void 0 : _b.providerId);
    });
  }).map(([key, wallet]) => {
    const { shortName } = wallet;
    const name = shortName || wallet.name;
    return class extends BitcoinSatsConnectConnector {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { overrideKey: key, walletData: wallet }));
        this.name = name;
      }
    };
  });
};

// node_modules/@dynamic-labs/bitcoin/src/utils/hasSatsConnectFeature.js
var hasSatsConnectFeature = (features) => SATSCONNECT_FEATURE in features;

// node_modules/@dynamic-labs/bitcoin/src/wallet/isBitcoinWallet/isBitcoinWallet.js
var isBitcoinWallet = (wallet) => wallet.chain === "BTC";

// node_modules/@dynamic-labs/bitcoin/src/index.js
assertPackageVersion("@dynamic-labs/bitcoin", version);
var BitcoinWalletConnectors = (props) => [
  ...fetchSatsConnectConnectors(props),
  ...fetchBtcKitConnectors(props),
  MagicEdenConnector,
  PhantomConnector,
  OkxConnector,
  OneKeyConnector,
  OylConnector,
  UnisatConnector,
  BitgetConnector,
  BinanceConnector,
  FallbackBitcoinConnector
];
export {
  BitcoinProviderHelper,
  BitcoinSatsConnectConnector,
  BitcoinWallet,
  BitcoinWalletConnector,
  BitcoinWalletConnectors,
  HTTP_STATUS_NOT_FOUND,
  HTTP_STATUS_TOO_MANY_REQUESTS,
  UnisatConnector,
  createPsbtOptions,
  fetchBtcKitConnectors,
  fetchSatsConnectConnectors,
  getMempoolApiUrl,
  hasSatsConnectFeature,
  isBitcoinWallet,
  satoshisToBtc
};
/*! Bundled license information:

@noble/secp256k1/lib/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

bitcoin-address-validation/lib/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

bowser/src/bowser.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=@dynamic-labs_bitcoin.js.map
