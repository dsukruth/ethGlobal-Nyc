"use client";
import {
  require_events
} from "./chunk-2YULO2GZ.js";
import {
  DynamicError,
  Wallet,
  WalletConnectorBase,
  assertPackageVersion,
  isMobile,
  logger,
  require_buffer
} from "./chunk-3OCKXW2Z.js";
import "./chunk-7KMCIXGS.js";
import "./chunk-ASWLBWKD.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@onflow/transport-http/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/@onflow/transport-http/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = (function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    })();
    (function(globalThis2) {
      var irrelevant = (function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && (function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          })(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve2, reject) {
            reader.onload = function() {
              resolve2(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise2 = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise2;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise2 = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise2;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || (function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          })();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response2 = new Response2(null, { status: 200, statusText: "" });
          response2.ok = false;
          response2.status = 0;
          response2.type = "error";
          return response2;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve2, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve2(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers2;
          g.Request = Request;
          g.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    var { AbortController: AbortController3, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController3;
    module.exports.AbortSignal = AbortSignal;
    module.exports.default = AbortController3;
  }
});

// node_modules/sha3/sponge/permute/copy/index.js
var require_copy = __commonJS({
  "node_modules/sha3/sponge/permute/copy/index.js"(exports, module) {
    "use strict";
    var copy = function copy2(I, i) {
      return function(O, o) {
        var oi = o * 2;
        var ii = i * 2;
        O[oi] = I[ii];
        O[oi + 1] = I[ii + 1];
      };
    };
    module.exports = copy;
  }
});

// node_modules/sha3/sponge/permute/chi/index.js
var require_chi = __commonJS({
  "node_modules/sha3/sponge/permute/chi/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _copy = _interopRequireDefault(require_copy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var chi = function chi2(_ref) {
      var A = _ref.A, C = _ref.C;
      for (var y = 0; y < 25; y += 5) {
        for (var x = 0; x < 5; x++) {
          (0, _copy["default"])(A, y + x)(C, x);
        }
        for (var _x = 0; _x < 5; _x++) {
          var xy = (y + _x) * 2;
          var x1 = (_x + 1) % 5 * 2;
          var x2 = (_x + 2) % 5 * 2;
          A[xy] ^= ~C[x1] & C[x2];
          A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];
        }
      }
    };
    var _default = chi;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/iota/round-constants/index.js
var require_round_constants = __commonJS({
  "node_modules/sha3/sponge/permute/iota/round-constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);
    var _default = ROUND_CONSTANTS;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/iota/index.js
var require_iota = __commonJS({
  "node_modules/sha3/sponge/permute/iota/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _roundConstants = _interopRequireDefault(require_round_constants());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var iota = function iota2(_ref) {
      var A = _ref.A, roundIndex = _ref.roundIndex;
      var i = roundIndex * 2;
      A[0] ^= _roundConstants["default"][i];
      A[1] ^= _roundConstants["default"][i + 1];
    };
    var _default = iota;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js
var require_pi_shuffles = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
    var _default = PI_SHUFFLES;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js
var require_rho_offsets = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
    var _default = RHO_OFFSETS;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/index.js
var require_rho_pi = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _piShuffles = _interopRequireDefault(require_pi_shuffles());
    var _rhoOffsets = _interopRequireDefault(require_rho_offsets());
    var _copy = _interopRequireDefault(require_copy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var rhoPi = function rhoPi2(_ref) {
      var A = _ref.A, C = _ref.C, W = _ref.W;
      (0, _copy["default"])(A, 1)(W, 0);
      var H = 0;
      var L = 0;
      var Wi = 0;
      var ri = 32;
      for (var i = 0; i < 24; i++) {
        var j = _piShuffles["default"][i];
        var r = _rhoOffsets["default"][i];
        (0, _copy["default"])(A, j)(C, 0);
        H = W[0];
        L = W[1];
        ri = 32 - r;
        Wi = r < 32 ? 0 : 1;
        W[Wi] = H << r | L >>> ri;
        W[(Wi + 1) % 2] = L << r | H >>> ri;
        (0, _copy["default"])(W, 0)(A, j);
        (0, _copy["default"])(C, 0)(W, 0);
      }
    };
    var _default = rhoPi;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/theta/index.js
var require_theta = __commonJS({
  "node_modules/sha3/sponge/permute/theta/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _copy = _interopRequireDefault(require_copy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var theta = function theta2(_ref) {
      var A = _ref.A, C = _ref.C, D = _ref.D, W = _ref.W;
      var H = 0;
      var L = 0;
      for (var x = 0; x < 5; x++) {
        var x20 = x * 2;
        var x21 = (x + 5) * 2;
        var x22 = (x + 10) * 2;
        var x23 = (x + 15) * 2;
        var x24 = (x + 20) * 2;
        C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];
        C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];
      }
      for (var _x = 0; _x < 5; _x++) {
        (0, _copy["default"])(C, (_x + 1) % 5)(W, 0);
        H = W[0];
        L = W[1];
        W[0] = H << 1 | L >>> 31;
        W[1] = L << 1 | H >>> 31;
        D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];
        D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];
        for (var y = 0; y < 25; y += 5) {
          A[(y + _x) * 2] ^= D[_x * 2];
          A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];
        }
      }
    };
    var _default = theta;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/index.js
var require_permute = __commonJS({
  "node_modules/sha3/sponge/permute/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _chi = _interopRequireDefault(require_chi());
    var _iota = _interopRequireDefault(require_iota());
    var _rhoPi = _interopRequireDefault(require_rho_pi());
    var _theta = _interopRequireDefault(require_theta());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var permute = function permute2() {
      var C = new Uint32Array(10);
      var D = new Uint32Array(10);
      var W = new Uint32Array(2);
      return function(A) {
        for (var roundIndex = 0; roundIndex < 24; roundIndex++) {
          (0, _theta["default"])({ A, C, D, W });
          (0, _rhoPi["default"])({ A, C, W });
          (0, _chi["default"])({ A, C });
          (0, _iota["default"])({ A, roundIndex });
        }
        C.fill(0);
        D.fill(0);
        W.fill(0);
      };
    };
    var _default = permute;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/index.js
var require_sponge = __commonJS({
  "node_modules/sha3/sponge/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _buffer = require_buffer();
    var _permute = _interopRequireDefault(require_permute());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var xorWords = function xorWords2(I, O) {
      for (var i = 0; i < I.length; i += 8) {
        var o = i / 4;
        O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];
        O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];
      }
      return O;
    };
    var readWords = function readWords2(I, O) {
      for (var o = 0; o < O.length; o += 8) {
        var i = o / 4;
        O[o] = I[i + 1];
        O[o + 1] = I[i + 1] >>> 8;
        O[o + 2] = I[i + 1] >>> 16;
        O[o + 3] = I[i + 1] >>> 24;
        O[o + 4] = I[i];
        O[o + 5] = I[i] >>> 8;
        O[o + 6] = I[i] >>> 16;
        O[o + 7] = I[i] >>> 24;
      }
      return O;
    };
    var Sponge = function Sponge2(_ref) {
      var _this = this;
      var capacity = _ref.capacity, padding = _ref.padding;
      var keccak = (0, _permute["default"])();
      var stateSize = 200;
      var blockSize = capacity / 8;
      var queueSize = stateSize - capacity / 4;
      var queueOffset = 0;
      var state = new Uint32Array(stateSize / 4);
      var queue = _buffer.Buffer.allocUnsafe(queueSize);
      this.absorb = function(buffer) {
        for (var i = 0; i < buffer.length; i++) {
          queue[queueOffset] = buffer[i];
          queueOffset += 1;
          if (queueOffset >= queueSize) {
            xorWords(queue, state);
            keccak(state);
            queueOffset = 0;
          }
        }
        return _this;
      };
      this.squeeze = function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var output = { buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize), padding: options.padding || padding, queue: _buffer.Buffer.allocUnsafe(queue.length), state: new Uint32Array(state.length) };
        queue.copy(output.queue);
        for (var i = 0; i < state.length; i++) {
          output.state[i] = state[i];
        }
        output.queue.fill(0, queueOffset);
        output.queue[queueOffset] |= output.padding;
        output.queue[queueSize - 1] |= 128;
        xorWords(output.queue, output.state);
        for (var offset = 0; offset < output.buffer.length; offset += queueSize) {
          keccak(output.state);
          readWords(output.state, output.buffer.slice(offset, offset + queueSize));
        }
        return output.buffer;
      };
      this.reset = function() {
        queue.fill(0);
        state.fill(0);
        queueOffset = 0;
        return _this;
      };
      return this;
    };
    var _default = Sponge;
    exports["default"] = _default;
  }
});

// node_modules/sha3/index.js
var require_sha3 = __commonJS({
  "node_modules/sha3/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;
    var _buffer = require_buffer();
    var _sponge = _interopRequireDefault(require_sponge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var createHash = function createHash2(_ref) {
      var allowedSizes = _ref.allowedSizes, defaultSize = _ref.defaultSize, padding = _ref.padding;
      return function Hash() {
        var _this = this;
        var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultSize;
        if (!this || this.constructor !== Hash) {
          return new Hash(size);
        }
        if (allowedSizes && !allowedSizes.includes(size)) {
          throw new Error("Unsupported hash length");
        }
        var sponge = new _sponge["default"]({ capacity: size });
        this.update = function(input) {
          var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf8";
          if (_buffer.Buffer.isBuffer(input)) {
            sponge.absorb(input);
            return _this;
          }
          if (typeof input === "string") {
            return _this.update(_buffer.Buffer.from(input, encoding));
          }
          throw new TypeError("Not a string or buffer");
        };
        this.digest = function() {
          var formatOrOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "binary";
          var options = typeof formatOrOptions === "string" ? { format: formatOrOptions } : formatOrOptions;
          var buffer = sponge.squeeze({ buffer: options.buffer, padding: options.padding || padding });
          if (options.format && options.format !== "binary") {
            return buffer.toString(options.format);
          }
          return buffer;
        };
        this.reset = function() {
          sponge.reset();
          return _this;
        };
        return this;
      };
    };
    var Keccak = createHash({ allowedSizes: [224, 256, 384, 512], defaultSize: 512, padding: 1 });
    exports.Keccak = Keccak;
    var SHA33 = createHash({ allowedSizes: [224, 256, 384, 512], defaultSize: 512, padding: 6 });
    exports.SHA3 = SHA33;
    var SHAKE = createHash({ allowedSizes: [128, 256], defaultSize: 256, padding: 31 });
    exports.SHAKE = SHAKE;
    var SHA3Hash = Keccak;
    exports.SHA3Hash = SHA3Hash;
    SHA33.SHA3Hash = SHA3Hash;
    var _default = SHA33;
    exports["default"] = _default;
  }
});

// node_modules/@onflow/fcl-core/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill2 = __commonJS({
  "node_modules/@onflow/fcl-core/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = (function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    })();
    (function(globalThis2) {
      var irrelevant = (function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && (function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          })(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve2, reject) {
            reader.onload = function() {
              resolve2(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise2 = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise2;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise2 = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise2;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || (function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          })();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response2 = new Response2(null, { status: 200, statusText: "" });
          response2.ok = false;
          response2.status = 0;
          response2.type = "error";
          return response2;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve2, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve2(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers2;
          g.Request = Request;
          g.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js
var require_grpc_web_client_umd = __commonJS({
  "node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js"(exports, module) {
    !(function(e, t) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = t();
      else if ("function" == typeof define && define.amd) define([], t);
      else {
        var r = t();
        for (var n in r) ("object" == typeof exports ? exports : e)[n] = r[n];
      }
    })(exports, (function() {
      return e = { 418: function(e2, t2) {
        !(function(e3, t3) {
          for (var r in t3) e3[r] = t3[r];
        })(t2, (function(e3) {
          var t3 = {};
          function r(n) {
            if (t3[n]) return t3[n].exports;
            var o = t3[n] = { i: n, l: false, exports: {} };
            return e3[n].call(o.exports, o, o.exports, r), o.l = true, o.exports;
          }
          return r.m = e3, r.c = t3, r.i = function(e4) {
            return e4;
          }, r.d = function(e4, t4, n) {
            r.o(e4, t4) || Object.defineProperty(e4, t4, { configurable: false, enumerable: true, get: n });
          }, r.n = function(e4) {
            var t4 = e4 && e4.__esModule ? function() {
              return e4.default;
            } : function() {
              return e4;
            };
            return r.d(t4, "a", t4), t4;
          }, r.o = function(e4, t4) {
            return Object.prototype.hasOwnProperty.call(e4, t4);
          }, r.p = "", r(r.s = 1);
        })([function(e3, t3, r) {
          "use strict";
          Object.defineProperty(t3, "__esModule", { value: true });
          var n = r(3), o = (function() {
            function e4(e5, t4) {
              void 0 === e5 && (e5 = {}), void 0 === t4 && (t4 = { splitValues: false });
              var r2, o2 = this;
              this.headersMap = {}, e5 && ("undefined" != typeof Headers && e5 instanceof Headers ? n.getHeaderKeys(e5).forEach((function(r3) {
                n.getHeaderValues(e5, r3).forEach((function(e6) {
                  t4.splitValues ? o2.append(r3, n.splitHeaderValue(e6)) : o2.append(r3, e6);
                }));
              })) : "object" == typeof (r2 = e5) && "object" == typeof r2.headersMap && "function" == typeof r2.forEach ? e5.forEach((function(e6, t5) {
                o2.append(e6, t5);
              })) : "undefined" != typeof Map && e5 instanceof Map ? e5.forEach((function(e6, t5) {
                o2.append(t5, e6);
              })) : "string" == typeof e5 ? this.appendFromString(e5) : "object" == typeof e5 && Object.getOwnPropertyNames(e5).forEach((function(t5) {
                var r3 = e5[t5];
                Array.isArray(r3) ? r3.forEach((function(e6) {
                  o2.append(t5, e6);
                })) : o2.append(t5, r3);
              })));
            }
            return e4.prototype.appendFromString = function(e5) {
              for (var t4 = e5.split("\r\n"), r2 = 0; r2 < t4.length; r2++) {
                var n2 = t4[r2], o2 = n2.indexOf(":");
                if (o2 > 0) {
                  var s = n2.substring(0, o2).trim(), i = n2.substring(o2 + 1).trim();
                  this.append(s, i);
                }
              }
            }, e4.prototype.delete = function(e5, t4) {
              var r2 = n.normalizeName(e5);
              if (void 0 === t4) delete this.headersMap[r2];
              else {
                var o2 = this.headersMap[r2];
                if (o2) {
                  var s = o2.indexOf(t4);
                  s >= 0 && o2.splice(s, 1), 0 === o2.length && delete this.headersMap[r2];
                }
              }
            }, e4.prototype.append = function(e5, t4) {
              var r2 = this, o2 = n.normalizeName(e5);
              Array.isArray(this.headersMap[o2]) || (this.headersMap[o2] = []), Array.isArray(t4) ? t4.forEach((function(e6) {
                r2.headersMap[o2].push(n.normalizeValue(e6));
              })) : this.headersMap[o2].push(n.normalizeValue(t4));
            }, e4.prototype.set = function(e5, t4) {
              var r2 = n.normalizeName(e5);
              if (Array.isArray(t4)) {
                var o2 = [];
                t4.forEach((function(e6) {
                  o2.push(n.normalizeValue(e6));
                })), this.headersMap[r2] = o2;
              } else this.headersMap[r2] = [n.normalizeValue(t4)];
            }, e4.prototype.has = function(e5, t4) {
              var r2 = this.headersMap[n.normalizeName(e5)];
              if (!Array.isArray(r2)) return false;
              if (void 0 !== t4) {
                var o2 = n.normalizeValue(t4);
                return r2.indexOf(o2) >= 0;
              }
              return true;
            }, e4.prototype.get = function(e5) {
              var t4 = this.headersMap[n.normalizeName(e5)];
              return void 0 !== t4 ? t4.concat() : [];
            }, e4.prototype.forEach = function(e5) {
              var t4 = this;
              Object.getOwnPropertyNames(this.headersMap).forEach((function(r2) {
                e5(r2, t4.headersMap[r2]);
              }), this);
            }, e4.prototype.toHeaders = function() {
              if ("undefined" != typeof Headers) {
                var e5 = new Headers();
                return this.forEach((function(t4, r2) {
                  r2.forEach((function(r3) {
                    e5.append(t4, r3);
                  }));
                })), e5;
              }
              throw new Error("Headers class is not defined");
            }, e4;
          })();
          t3.BrowserHeaders = o;
        }, function(e3, t3, r) {
          "use strict";
          Object.defineProperty(t3, "__esModule", { value: true });
          var n = r(0);
          t3.BrowserHeaders = n.BrowserHeaders;
        }, function(e3, t3, r) {
          "use strict";
          Object.defineProperty(t3, "__esModule", { value: true }), t3.iterateHeaders = function(e4, t4) {
            for (var r2 = e4[Symbol.iterator](), n = r2.next(); !n.done; ) t4(n.value[0]), n = r2.next();
          }, t3.iterateHeadersKeys = function(e4, t4) {
            for (var r2 = e4.keys(), n = r2.next(); !n.done; ) t4(n.value), n = r2.next();
          };
        }, function(e3, t3, r) {
          "use strict";
          Object.defineProperty(t3, "__esModule", { value: true });
          var n = r(2);
          t3.normalizeName = function(e4) {
            if ("string" != typeof e4 && (e4 = String(e4)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e4)) throw new TypeError("Invalid character in header field name");
            return e4.toLowerCase();
          }, t3.normalizeValue = function(e4) {
            return "string" != typeof e4 && (e4 = String(e4)), e4;
          }, t3.getHeaderValues = function(e4, t4) {
            var r2 = e4;
            if (r2 instanceof Headers && r2.getAll) return r2.getAll(t4);
            var n2 = r2.get(t4);
            return n2 && "string" == typeof n2 ? [n2] : n2;
          }, t3.getHeaderKeys = function(e4) {
            var t4 = e4, r2 = {}, o = [];
            return t4.keys ? n.iterateHeadersKeys(t4, (function(e5) {
              r2[e5] || (r2[e5] = true, o.push(e5));
            })) : t4.forEach ? t4.forEach((function(e5, t5) {
              r2[t5] || (r2[t5] = true, o.push(t5));
            })) : n.iterateHeaders(t4, (function(e5) {
              var t5 = e5[0];
              r2[t5] || (r2[t5] = true, o.push(t5));
            })), o;
          }, t3.splitHeaderValue = function(e4) {
            var t4 = [];
            return e4.split(", ").forEach((function(e5) {
              e5.split(",").forEach((function(e6) {
                t4.push(e6);
              }));
            })), t4;
          };
        }]));
      }, 617: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ChunkParser = t2.ChunkType = t2.encodeASCII = t2.decodeASCII = void 0;
        var n, o = r(65);
        function s(e3) {
          return 9 === (t3 = e3) || 10 === t3 || 13 === t3 || e3 >= 32 && e3 <= 126;
          var t3;
        }
        function i(e3) {
          for (var t3 = 0; t3 !== e3.length; ++t3) if (!s(e3[t3])) throw new Error("Metadata is not valid (printable) ASCII");
          return String.fromCharCode.apply(String, Array.prototype.slice.call(e3));
        }
        function a(e3) {
          return 128 == (128 & e3.getUint8(0));
        }
        function u(e3) {
          return e3.getUint32(1, false);
        }
        function d(e3, t3, r2) {
          return e3.byteLength - t3 >= r2;
        }
        function c(e3, t3, r2) {
          if (e3.slice) return e3.slice(t3, r2);
          var n2 = e3.length;
          void 0 !== r2 && (n2 = r2);
          for (var o2 = new Uint8Array(n2 - t3), s2 = 0, i2 = t3; i2 < n2; i2++) o2[s2++] = e3[i2];
          return o2;
        }
        t2.decodeASCII = i, t2.encodeASCII = function(e3) {
          for (var t3 = new Uint8Array(e3.length), r2 = 0; r2 !== e3.length; ++r2) {
            var n2 = e3.charCodeAt(r2);
            if (!s(n2)) throw new Error("Metadata contains invalid ASCII");
            t3[r2] = n2;
          }
          return t3;
        }, (function(e3) {
          e3[e3.MESSAGE = 1] = "MESSAGE", e3[e3.TRAILERS = 2] = "TRAILERS";
        })(n = t2.ChunkType || (t2.ChunkType = {}));
        var p = (function() {
          function e3() {
            this.buffer = null, this.position = 0;
          }
          return e3.prototype.parse = function(e4, t3) {
            if (0 === e4.length && t3) return [];
            var r2, s2 = [];
            if (null == this.buffer) this.buffer = e4, this.position = 0;
            else if (this.position === this.buffer.byteLength) this.buffer = e4, this.position = 0;
            else {
              var p2 = this.buffer.byteLength - this.position, h = new Uint8Array(p2 + e4.byteLength), f2 = c(this.buffer, this.position);
              h.set(f2, 0);
              var l = new Uint8Array(e4);
              h.set(l, p2), this.buffer = h, this.position = 0;
            }
            for (; ; ) {
              if (!d(this.buffer, this.position, 5)) return s2;
              var g = c(this.buffer, this.position, this.position + 5), b = new DataView(g.buffer, g.byteOffset, g.byteLength), y = u(b);
              if (!d(this.buffer, this.position, 5 + y)) return s2;
              var v = c(this.buffer, this.position + 5, this.position + 5 + y);
              if (this.position += 5 + y, a(b)) return s2.push({ chunkType: n.TRAILERS, trailers: (r2 = v, new o.Metadata(i(r2))) }), s2;
              s2.push({ chunkType: n.MESSAGE, data: v });
            }
          }, e3;
        })();
        t2.ChunkParser = p;
      }, 8: function(e2, t2) {
        "use strict";
        var r;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.httpStatusToCode = t2.Code = void 0, (function(e3) {
          e3[e3.OK = 0] = "OK", e3[e3.Canceled = 1] = "Canceled", e3[e3.Unknown = 2] = "Unknown", e3[e3.InvalidArgument = 3] = "InvalidArgument", e3[e3.DeadlineExceeded = 4] = "DeadlineExceeded", e3[e3.NotFound = 5] = "NotFound", e3[e3.AlreadyExists = 6] = "AlreadyExists", e3[e3.PermissionDenied = 7] = "PermissionDenied", e3[e3.ResourceExhausted = 8] = "ResourceExhausted", e3[e3.FailedPrecondition = 9] = "FailedPrecondition", e3[e3.Aborted = 10] = "Aborted", e3[e3.OutOfRange = 11] = "OutOfRange", e3[e3.Unimplemented = 12] = "Unimplemented", e3[e3.Internal = 13] = "Internal", e3[e3.Unavailable = 14] = "Unavailable", e3[e3.DataLoss = 15] = "DataLoss", e3[e3.Unauthenticated = 16] = "Unauthenticated";
        })(r = t2.Code || (t2.Code = {})), t2.httpStatusToCode = function(e3) {
          switch (e3) {
            case 0:
              return r.Internal;
            case 200:
              return r.OK;
            case 400:
              return r.InvalidArgument;
            case 401:
              return r.Unauthenticated;
            case 403:
              return r.PermissionDenied;
            case 404:
              return r.NotFound;
            case 409:
              return r.Aborted;
            case 412:
              return r.FailedPrecondition;
            case 429:
              return r.ResourceExhausted;
            case 499:
              return r.Canceled;
            case 500:
              return r.Unknown;
            case 501:
              return r.Unimplemented;
            case 503:
              return r.Unavailable;
            case 504:
              return r.DeadlineExceeded;
            default:
              return r.Unknown;
          }
        };
      }, 934: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.client = void 0;
        var n = r(65), o = r(617), s = r(8), i = r(346), a = r(57), u = r(882);
        t2.client = function(e3, t3) {
          return new d(e3, t3);
        };
        var d = (function() {
          function e3(e4, t3) {
            this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o.ChunkParser(), this.methodDefinition = e4, this.props = t3, this.createTransport();
          }
          return e3.prototype.createTransport = function() {
            var e4 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t3 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e4, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
            this.props.transport ? this.transport = this.props.transport(t3) : this.transport = a.makeDefaultTransport(t3);
          }, e3.prototype.onTransportHeaders = function(e4, t3) {
            if (this.props.debug && i.debug("onHeaders", e4, t3), this.closed) this.props.debug && i.debug("grpc.onHeaders received after request was closed - ignoring");
            else if (0 === t3) ;
            else {
              this.responseHeaders = e4, this.props.debug && i.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
              var r2 = c(e4);
              this.props.debug && i.debug("onHeaders.gRPCStatus", r2);
              var n2 = r2 && r2 >= 0 ? r2 : s.httpStatusToCode(t3);
              this.props.debug && i.debug("onHeaders.code", n2);
              var o2 = e4.get("grpc-message") || [];
              if (this.props.debug && i.debug("onHeaders.gRPCMessage", o2), this.rawOnHeaders(e4), n2 !== s.Code.OK) {
                var a2 = this.decodeGRPCStatus(o2[0]);
                this.rawOnError(n2, a2, e4);
              }
            }
          }, e3.prototype.onTransportChunk = function(e4) {
            var t3 = this;
            if (this.closed) this.props.debug && i.debug("grpc.onChunk received after request was closed - ignoring");
            else {
              var r2 = [];
              try {
                r2 = this.parser.parse(e4);
              } catch (e5) {
                return this.props.debug && i.debug("onChunk.parsing error", e5, e5.message), void this.rawOnError(s.Code.Internal, "parsing error: " + e5.message);
              }
              r2.forEach((function(e5) {
                if (e5.chunkType === o.ChunkType.MESSAGE) {
                  var r3 = t3.methodDefinition.responseType.deserializeBinary(e5.data);
                  t3.rawOnMessage(r3);
                } else e5.chunkType === o.ChunkType.TRAILERS && (t3.responseHeaders ? (t3.responseTrailers = new n.Metadata(e5.trailers), t3.props.debug && i.debug("onChunk.trailers", t3.responseTrailers)) : (t3.responseHeaders = new n.Metadata(e5.trailers), t3.rawOnHeaders(t3.responseHeaders)));
              }));
            }
          }, e3.prototype.onTransportEnd = function() {
            if (this.props.debug && i.debug("grpc.onEnd"), this.closed) this.props.debug && i.debug("grpc.onEnd received after request was closed - ignoring");
            else if (void 0 !== this.responseTrailers) {
              var e4 = c(this.responseTrailers);
              if (null !== e4) {
                var t3 = this.responseTrailers.get("grpc-message"), r2 = this.decodeGRPCStatus(t3[0]);
                this.rawOnEnd(e4, r2, this.responseTrailers);
              } else this.rawOnError(s.Code.Internal, "Response closed without grpc-status (Trailers provided)");
            } else {
              if (void 0 === this.responseHeaders) return void this.rawOnError(s.Code.Unknown, "Response closed without headers");
              var n2 = c(this.responseHeaders), o2 = this.responseHeaders.get("grpc-message");
              if (this.props.debug && i.debug("grpc.headers only response ", n2, o2), null === n2) return void this.rawOnEnd(s.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
              var a2 = this.decodeGRPCStatus(o2[0]);
              this.rawOnEnd(n2, a2, this.responseHeaders);
            }
          }, e3.prototype.decodeGRPCStatus = function(e4) {
            if (!e4) return "";
            try {
              return decodeURIComponent(e4);
            } catch (t3) {
              return e4;
            }
          }, e3.prototype.rawOnEnd = function(e4, t3, r2) {
            var n2 = this;
            this.props.debug && i.debug("rawOnEnd", e4, t3, r2), this.completed || (this.completed = true, this.onEndCallbacks.forEach((function(o2) {
              if (!n2.closed) try {
                o2(e4, t3, r2);
              } catch (e5) {
                setTimeout((function() {
                  throw e5;
                }), 0);
              }
            })));
          }, e3.prototype.rawOnHeaders = function(e4) {
            this.props.debug && i.debug("rawOnHeaders", e4), this.completed || this.onHeadersCallbacks.forEach((function(t3) {
              try {
                t3(e4);
              } catch (e5) {
                setTimeout((function() {
                  throw e5;
                }), 0);
              }
            }));
          }, e3.prototype.rawOnError = function(e4, t3, r2) {
            var o2 = this;
            void 0 === r2 && (r2 = new n.Metadata()), this.props.debug && i.debug("rawOnError", e4, t3), this.completed || (this.completed = true, this.onEndCallbacks.forEach((function(n2) {
              if (!o2.closed) try {
                n2(e4, t3, r2);
              } catch (e5) {
                setTimeout((function() {
                  throw e5;
                }), 0);
              }
            })));
          }, e3.prototype.rawOnMessage = function(e4) {
            var t3 = this;
            this.props.debug && i.debug("rawOnMessage", e4.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach((function(r2) {
              if (!t3.closed) try {
                r2(e4);
              } catch (e5) {
                setTimeout((function() {
                  throw e5;
                }), 0);
              }
            }));
          }, e3.prototype.onHeaders = function(e4) {
            this.onHeadersCallbacks.push(e4);
          }, e3.prototype.onMessage = function(e4) {
            this.onMessageCallbacks.push(e4);
          }, e3.prototype.onEnd = function(e4) {
            this.onEndCallbacks.push(e4);
          }, e3.prototype.start = function(e4) {
            if (this.started) throw new Error("Client already started - cannot .start()");
            this.started = true;
            var t3 = new n.Metadata(e4 || {});
            t3.set("content-type", "application/grpc-web+proto"), t3.set("x-grpc-web", "1"), this.transport.start(t3);
          }, e3.prototype.send = function(e4) {
            if (!this.started) throw new Error("Client not started - .start() must be called before .send()");
            if (this.closed) throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending) throw new Error("Client already finished sending - cannot .send()");
            if (!this.methodDefinition.requestStream && this.sentFirstMessage) throw new Error("Message already sent for non-client-streaming method - cannot .send()");
            this.sentFirstMessage = true;
            var t3 = u.frameRequest(e4);
            this.transport.sendMessage(t3);
          }, e3.prototype.finishSend = function() {
            if (!this.started) throw new Error("Client not started - .finishSend() must be called before .close()");
            if (this.closed) throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending) throw new Error("Client already finished sending - cannot .finishSend()");
            this.finishedSending = true, this.transport.finishSend();
          }, e3.prototype.close = function() {
            if (!this.started) throw new Error("Client not started - .start() must be called before .close()");
            if (this.closed) throw new Error("Client already closed - cannot .close()");
            this.closed = true, this.props.debug && i.debug("request.abort aborting request"), this.transport.cancel();
          }, e3;
        })();
        function c(e3) {
          var t3 = e3.get("grpc-status") || [];
          if (t3.length > 0) try {
            var r2 = t3[0];
            return parseInt(r2, 10);
          } catch (e4) {
            return null;
          }
          return null;
        }
      }, 346: function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.debug = void 0, t2.debug = function() {
          for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
          console.debug ? console.debug.apply(null, e3) : console.log.apply(null, e3);
        };
      }, 607: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.grpc = void 0;
        var n, o = r(418), s = r(57), i = r(229), a = r(540), u = r(210), d = r(859), c = r(8), p = r(938), h = r(35), f2 = r(934);
        (n = t2.grpc || (t2.grpc = {})).setDefaultTransport = s.setDefaultTransportFactory, n.CrossBrowserHttpTransport = d.CrossBrowserHttpTransport, n.FetchReadableStreamTransport = i.FetchReadableStreamTransport, n.XhrTransport = u.XhrTransport, n.WebsocketTransport = a.WebsocketTransport, n.Code = c.Code, n.Metadata = o.BrowserHeaders, n.client = function(e3, t3) {
          return f2.client(e3, t3);
        }, n.invoke = p.invoke, n.unary = h.unary;
      }, 938: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.invoke = void 0;
        var n = r(934);
        t2.invoke = function(e3, t3) {
          if (e3.requestStream) throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
          var r2 = n.client(e3, { host: t3.host, transport: t3.transport, debug: t3.debug });
          return t3.onHeaders && r2.onHeaders(t3.onHeaders), t3.onMessage && r2.onMessage(t3.onMessage), t3.onEnd && r2.onEnd(t3.onEnd), r2.start(t3.metadata), r2.send(t3.request), r2.finishSend(), { close: function() {
            r2.close();
          } };
        };
      }, 65: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Metadata = void 0;
        var n = r(418);
        Object.defineProperty(t2, "Metadata", { enumerable: true, get: function() {
          return n.BrowserHeaders;
        } });
      }, 57: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.makeDefaultTransport = t2.setDefaultTransportFactory = void 0;
        var n = r(859), o = function(e3) {
          return n.CrossBrowserHttpTransport({ withCredentials: false })(e3);
        };
        t2.setDefaultTransportFactory = function(e3) {
          o = e3;
        }, t2.makeDefaultTransport = function(e3) {
          return o(e3);
        };
      }, 229: function(e2, t2, r) {
        "use strict";
        var n = this && this.__assign || function() {
          return (n = Object.assign || function(e3) {
            for (var t3, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in t3 = arguments[r2]) Object.prototype.hasOwnProperty.call(t3, o2) && (e3[o2] = t3[o2]);
            return e3;
          }).apply(this, arguments);
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.detectFetchSupport = t2.FetchReadableStreamTransport = void 0;
        var o = r(65), s = r(346);
        t2.FetchReadableStreamTransport = function(e3) {
          return function(t3) {
            return (function(e4, t4) {
              return e4.debug && s.debug("fetchRequest", e4), new i(e4, t4);
            })(t3, e3);
          };
        };
        var i = (function() {
          function e3(e4, t3) {
            this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e4, this.init = t3;
          }
          return e3.prototype.pump = function(e4, t3) {
            var r2 = this;
            if (this.reader = e4, this.cancelled) return this.options.debug && s.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch((function(e5) {
              r2.options.debug && s.debug("Fetch.pump.reader.cancel exception", e5);
            }));
            this.reader.read().then((function(e5) {
              if (e5.done) return r2.options.onEnd(), t3;
              r2.options.onChunk(e5.value), r2.pump(r2.reader, t3);
            })).catch((function(e5) {
              r2.cancelled ? r2.options.debug && s.debug("Fetch.catch - request cancelled") : (r2.cancelled = true, r2.options.debug && s.debug("Fetch.catch", e5.message), r2.options.onEnd(e5));
            }));
          }, e3.prototype.send = function(e4) {
            var t3 = this;
            fetch(this.options.url, n(n({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e4, signal: this.controller && this.controller.signal })).then((function(e5) {
              if (t3.options.debug && s.debug("Fetch.response", e5), t3.options.onHeaders(new o.Metadata(e5.headers), e5.status), !e5.body) return e5;
              t3.pump(e5.body.getReader(), e5);
            })).catch((function(e5) {
              t3.cancelled ? t3.options.debug && s.debug("Fetch.catch - request cancelled") : (t3.cancelled = true, t3.options.debug && s.debug("Fetch.catch", e5.message), t3.options.onEnd(e5));
            }));
          }, e3.prototype.sendMessage = function(e4) {
            this.send(e4);
          }, e3.prototype.finishSend = function() {
          }, e3.prototype.start = function(e4) {
            this.metadata = e4;
          }, e3.prototype.cancel = function() {
            var e4 = this;
            this.cancelled ? this.options.debug && s.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch((function(t3) {
              e4.options.debug && s.debug("Fetch.cancel.reader.cancel exception", t3);
            }))) : this.options.debug && s.debug("Fetch.cancel before reader"));
          }, e3;
        })();
        t2.detectFetchSupport = function() {
          return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
        };
      }, 859: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CrossBrowserHttpTransport = void 0;
        var n = r(229), o = r(210);
        t2.CrossBrowserHttpTransport = function(e3) {
          if (n.detectFetchSupport()) {
            var t3 = { credentials: e3.withCredentials ? "include" : "same-origin" };
            return n.FetchReadableStreamTransport(t3);
          }
          return o.XhrTransport({ withCredentials: e3.withCredentials });
        };
      }, 210: function(e2, t2, r) {
        "use strict";
        var n, o = this && this.__extends || (n = function(e3, t3) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
            e4.__proto__ = t4;
          } || function(e4, t4) {
            for (var r2 in t4) Object.prototype.hasOwnProperty.call(t4, r2) && (e4[r2] = t4[r2]);
          })(e3, t3);
        }, function(e3, t3) {
          function r2() {
            this.constructor = e3;
          }
          n(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (r2.prototype = t3.prototype, new r2());
        });
        Object.defineProperty(t2, "__esModule", { value: true }), t2.stringToArrayBuffer = t2.MozChunkedArrayBufferXHR = t2.XHR = t2.XhrTransport = void 0;
        var s = r(65), i = r(346), a = r(849);
        t2.XhrTransport = function(e3) {
          return function(t3) {
            if (a.detectMozXHRSupport()) return new d(t3, e3);
            if (a.detectXHROverrideMimeTypeSupport()) return new u(t3, e3);
            throw new Error("This environment's XHR implementation cannot support binary transfer.");
          };
        };
        var u = (function() {
          function e3(e4, t3) {
            this.options = e4, this.init = t3;
          }
          return e3.prototype.onProgressEvent = function() {
            this.options.debug && i.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
            var e4 = this.xhr.response.substr(this.index);
            this.index = this.xhr.response.length;
            var t3 = p(e4);
            this.options.onChunk(t3);
          }, e3.prototype.onLoadEvent = function() {
            this.options.debug && i.debug("XHR.onLoadEvent"), this.options.onEnd();
          }, e3.prototype.onStateChange = function() {
            this.options.debug && i.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
          }, e3.prototype.sendMessage = function(e4) {
            this.xhr.send(e4);
          }, e3.prototype.finishSend = function() {
          }, e3.prototype.start = function(e4) {
            var t3 = this;
            this.metadata = e4;
            var r2 = new XMLHttpRequest();
            this.xhr = r2, r2.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach((function(e5, t4) {
              r2.setRequestHeader(e5, t4.join(", "));
            })), r2.withCredentials = Boolean(this.init.withCredentials), r2.addEventListener("readystatechange", this.onStateChange.bind(this)), r2.addEventListener("progress", this.onProgressEvent.bind(this)), r2.addEventListener("loadend", this.onLoadEvent.bind(this)), r2.addEventListener("error", (function(e5) {
              t3.options.debug && i.debug("XHR.error", e5), t3.options.onEnd(e5.error);
            }));
          }, e3.prototype.configureXhr = function() {
            this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
          }, e3.prototype.cancel = function() {
            this.options.debug && i.debug("XHR.abort"), this.xhr.abort();
          }, e3;
        })();
        t2.XHR = u;
        var d = (function(e3) {
          function t3() {
            return null !== e3 && e3.apply(this, arguments) || this;
          }
          return o(t3, e3), t3.prototype.configureXhr = function() {
            this.options.debug && i.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
          }, t3.prototype.onProgressEvent = function() {
            var e4 = this.xhr.response;
            this.options.debug && i.debug("MozXHR.onProgressEvent: ", new Uint8Array(e4)), this.options.onChunk(new Uint8Array(e4));
          }, t3;
        })(u);
        function c(e3, t3) {
          var r2 = e3.charCodeAt(t3);
          if (r2 >= 55296 && r2 <= 56319) {
            var n2 = e3.charCodeAt(t3 + 1);
            n2 >= 56320 && n2 <= 57343 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320));
          }
          return r2;
        }
        function p(e3) {
          for (var t3 = new Uint8Array(e3.length), r2 = 0, n2 = 0; n2 < e3.length; n2++) {
            var o2 = String.prototype.codePointAt ? e3.codePointAt(n2) : c(e3, n2);
            t3[r2++] = 255 & o2;
          }
          return t3;
        }
        t2.MozChunkedArrayBufferXHR = d, t2.stringToArrayBuffer = p;
      }, 849: function(e2, t2) {
        "use strict";
        var r;
        function n() {
          if (void 0 !== r) return r;
          if (XMLHttpRequest) {
            r = new XMLHttpRequest();
            try {
              r.open("GET", "https://localhost");
            } catch (e3) {
            }
          }
          return r;
        }
        function o(e3) {
          var t3 = n();
          if (!t3) return false;
          try {
            return t3.responseType = e3, t3.responseType === e3;
          } catch (e4) {
          }
          return false;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.detectXHROverrideMimeTypeSupport = t2.detectMozXHRSupport = t2.xhrSupportsResponseType = void 0, t2.xhrSupportsResponseType = o, t2.detectMozXHRSupport = function() {
          return "undefined" != typeof XMLHttpRequest && o("moz-chunked-arraybuffer");
        }, t2.detectXHROverrideMimeTypeSupport = function() {
          return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
        };
      }, 540: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WebsocketTransport = void 0;
        var n, o = r(346), s = r(617);
        !(function(e3) {
          e3[e3.FINISH_SEND = 1] = "FINISH_SEND";
        })(n || (n = {}));
        var i = new Uint8Array([1]);
        t2.WebsocketTransport = function() {
          return function(e3) {
            return (function(e4) {
              e4.debug && o.debug("websocketRequest", e4);
              var t3, r2 = (function(e5) {
                if ("https://" === e5.substr(0, 8)) return "wss://" + e5.substr(8);
                if ("http://" === e5.substr(0, 7)) return "ws://" + e5.substr(7);
                throw new Error("Websocket transport constructed with non-https:// or http:// host.");
              })(e4.url), a = [];
              function u(e5) {
                if (e5 === n.FINISH_SEND) t3.send(i);
                else {
                  var r3 = e5, o2 = new Int8Array(r3.byteLength + 1);
                  o2.set(new Uint8Array([0])), o2.set(r3, 1), t3.send(o2);
                }
              }
              return { sendMessage: function(e5) {
                t3 && t3.readyState !== t3.CONNECTING ? u(e5) : a.push(e5);
              }, finishSend: function() {
                t3 && t3.readyState !== t3.CONNECTING ? u(n.FINISH_SEND) : a.push(n.FINISH_SEND);
              }, start: function(n2) {
                (t3 = new WebSocket(r2, ["grpc-websockets"])).binaryType = "arraybuffer", t3.onopen = function() {
                  var r3;
                  e4.debug && o.debug("websocketRequest.onopen"), t3.send((r3 = "", n2.forEach((function(e5, t4) {
                    r3 += e5 + ": " + t4.join(", ") + "\r\n";
                  })), s.encodeASCII(r3))), a.forEach((function(e5) {
                    u(e5);
                  }));
                }, t3.onclose = function(t4) {
                  e4.debug && o.debug("websocketRequest.onclose", t4), e4.onEnd();
                }, t3.onerror = function(t4) {
                  e4.debug && o.debug("websocketRequest.onerror", t4);
                }, t3.onmessage = function(t4) {
                  e4.onChunk(new Uint8Array(t4.data));
                };
              }, cancel: function() {
                e4.debug && o.debug("websocket.abort"), t3.close();
              } };
            })(e3);
          };
        };
      }, 35: function(e2, t2, r) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.unary = void 0;
        var n = r(65), o = r(934);
        t2.unary = function(e3, t3) {
          if (e3.responseStream) throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
          if (e3.requestStream) throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
          var r2 = null, s = null, i = o.client(e3, { host: t3.host, transport: t3.transport, debug: t3.debug });
          return i.onHeaders((function(e4) {
            r2 = e4;
          })), i.onMessage((function(e4) {
            s = e4;
          })), i.onEnd((function(e4, o2, i2) {
            t3.onEnd({ status: e4, statusMessage: o2, headers: r2 || new n.Metadata(), message: s, trailers: i2 });
          })), i.start(t3.metadata), i.send(t3.request), i.finishSend(), { close: function() {
            i.close();
          } };
        };
      }, 882: function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.frameRequest = void 0, t2.frameRequest = function(e3) {
          var t3 = e3.serializeBinary(), r = new ArrayBuffer(t3.byteLength + 5);
          return new DataView(r, 1, 4).setUint32(0, t3.length, false), new Uint8Array(r, 5).set(t3), new Uint8Array(r);
        };
      } }, t = {}, (function r(n) {
        if (t[n]) return t[n].exports;
        var o = t[n] = { exports: {} };
        return e[n].call(o.exports, o, o.exports, r), o.exports;
      })(607);
      var e, t;
    }));
  }
});

// node_modules/@dynamic-labs/flow/package.js
var version = "4.26.0";

// node_modules/@dynamic-labs/flow/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@onflow/util-logger/dist/util-logger.module.js
var config = null;
var setConfig = (_config) => {
  config = _config;
};
var LEVELS = (function(LEVELS2) {
  LEVELS2[LEVELS2["debug"] = 5] = "debug";
  LEVELS2[LEVELS2["info"] = 4] = "info";
  LEVELS2[LEVELS2["log"] = 3] = "log";
  LEVELS2[LEVELS2["warn"] = 2] = "warn";
  LEVELS2[LEVELS2["error"] = 1] = "error";
  return LEVELS2;
})({});
var buildLoggerMessageArgs = (options) => {
  const {
    title,
    message
  } = options;
  return [`
    %c${title}
    ============================

    ${message}

    ============================
    `.replace(/\n[^\S\r\n]+/g, "\n").trim(), "font-weight:bold;font-family:monospace;"];
};
var log = async (options) => {
  const {
    title,
    message,
    level,
    always
  } = options;
  const configLoggerLevel = await config?.()?.get("logger.level") ?? LEVELS.warn;
  if (!always && configLoggerLevel < level) return;
  const loggerMessageArgs = buildLoggerMessageArgs({
    title,
    message
  });
  switch (level) {
    case LEVELS.debug:
      console.debug(...loggerMessageArgs);
      break;
    case LEVELS.info:
      console.info(...loggerMessageArgs);
      break;
    case LEVELS.warn:
      console.warn(...loggerMessageArgs);
      break;
    case LEVELS.error:
      console.error(...loggerMessageArgs);
      break;
    default:
      console.log(...loggerMessageArgs);
  }
};
log.deprecate = (options) => {
  const {
    pkg,
    subject,
    transition,
    level = LEVELS.warn,
    message = "",
    callback = null
  } = options;
  const capitalizeFirstLetter = (str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  const logMessage = () => log({
    title: `${pkg ? pkg + " " : ""}Deprecation Notice`,
    message: `
      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? " of " + pkg : ""}.` : ""}${message ? "\n" + message : ""}${transition ? `
You can learn more (including a guide on common transition paths) here: ${transition}` : ""}
    `.trim(),
    level
  });
  if (typeof callback === "function") {
    return async function() {
      await logMessage();
      return await callback(...arguments);
    };
  }
  return logMessage();
};

// node_modules/@onflow/util-invariant/dist/util-invariant.module.js
function invariant(fact, msg) {
  if (!fact) {
    const error = new Error(`INVARIANT ${msg}`);
    error.stack = error.stack?.split("\n")?.filter((d) => !/at invariant/.test(d))?.join("\n");
    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }
    console.error("\n\n---\n\n", error, "\n\n", ...rest, "\n\n---\n\n");
    throw error;
  }
}

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T2 = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T2;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/@onflow/sdk/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@onflow/typedefs/dist/typedefs.module.js
var InteractionTag = (function(InteractionTag2) {
  InteractionTag2["UNKNOWN"] = "UNKNOWN";
  InteractionTag2["SCRIPT"] = "SCRIPT";
  InteractionTag2["TRANSACTION"] = "TRANSACTION";
  InteractionTag2["GET_TRANSACTION_STATUS"] = "GET_TRANSACTION_STATUS";
  InteractionTag2["GET_ACCOUNT"] = "GET_ACCOUNT";
  InteractionTag2["GET_EVENTS"] = "GET_EVENTS";
  InteractionTag2["PING"] = "PING";
  InteractionTag2["GET_TRANSACTION"] = "GET_TRANSACTION";
  InteractionTag2["GET_BLOCK"] = "GET_BLOCK";
  InteractionTag2["GET_BLOCK_HEADER"] = "GET_BLOCK_HEADER";
  InteractionTag2["GET_COLLECTION"] = "GET_COLLECTION";
  InteractionTag2["GET_NETWORK_PARAMETERS"] = "GET_NETWORK_PARAMETERS";
  InteractionTag2["SUBSCRIBE_EVENTS"] = "SUBSCRIBE_EVENTS";
  InteractionTag2["GET_NODE_VERSION_INFO"] = "GET_NODE_VERSION_INFO";
  return InteractionTag2;
})({});
var InteractionStatus = (function(InteractionStatus2) {
  InteractionStatus2["BAD"] = "BAD";
  InteractionStatus2["OK"] = "OK";
  return InteractionStatus2;
})({});
var TransactionRole = (function(TransactionRole2) {
  TransactionRole2["AUTHORIZER"] = "authorizer";
  TransactionRole2["PAYER"] = "payer";
  TransactionRole2["PROPOSER"] = "proposer";
  return TransactionRole2;
})({});
var InteractionResolverKind = (function(InteractionResolverKind2) {
  InteractionResolverKind2["ARGUMENT"] = "ARGUMENT";
  InteractionResolverKind2["ACCOUNT"] = "ACCOUNT";
  return InteractionResolverKind2;
})({});
var SignatureAlgorithm = (function(SignatureAlgorithm2) {
  SignatureAlgorithm2[SignatureAlgorithm2["ECDSA_P256"] = 1] = "ECDSA_P256";
  SignatureAlgorithm2[SignatureAlgorithm2["ECDSA_secp256k1"] = 2] = "ECDSA_secp256k1";
  SignatureAlgorithm2[SignatureAlgorithm2["BLS_BLS12_381"] = 3] = "BLS_BLS12_381";
  return SignatureAlgorithm2;
})({});
var HashAlgorithm = (function(HashAlgorithm2) {
  HashAlgorithm2[HashAlgorithm2["SHA2_256"] = 1] = "SHA2_256";
  HashAlgorithm2[HashAlgorithm2["SHA2_384"] = 2] = "SHA2_384";
  HashAlgorithm2[HashAlgorithm2["SHA3_256"] = 3] = "SHA3_256";
  HashAlgorithm2[HashAlgorithm2["SHA3_384"] = 4] = "SHA3_384";
  HashAlgorithm2[HashAlgorithm2["KMAC128_BLS_BLS12_381"] = 5] = "KMAC128_BLS_BLS12_381";
  return HashAlgorithm2;
})({});

// node_modules/@onflow/util-actor/dist/actor.module.js
var mailbox = () => {
  const queue = [];
  let next;
  return {
    async deliver(msg) {
      queue.push(msg);
      if (next) {
        next(queue.shift());
        next = void 0;
      }
    },
    receive() {
      return new Promise(function innerReceive(resolve2) {
        const msg = queue.shift();
        if (msg) return resolve2(msg);
        next = resolve2;
      });
    }
  };
};
var promise;
var _queueMicrotask = (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
  throw err;
}, 0));
var INIT = "INIT";
var SUBSCRIBE = "SUBSCRIBE";
var UNSUBSCRIBE = "UNSUBSCRIBE";
var UPDATED = "UPDATED";
var SNAPSHOT = "SNAPSHOT";
var EXIT = "EXIT";
var TERMINATE = "TERMINATE";
var root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window || {
  FCL_REGISTRY: null
};
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
var FCL_REGISTRY = root.FCL_REGISTRY;
var pid = 0;
var DEFAULT_TIMEOUT = 5e3;
function send(addr, tag, data) {
  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
    expectReply: false
  };
  return new Promise((resolve2, reject) => {
    const expectReply = opts.expectReply || false;
    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;
    if (expectReply && timeout) {
      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);
    }
    const payload = {
      to: addr,
      from: opts.from,
      tag,
      data,
      timeout,
      reply: resolve2,
      reject
    };
    try {
      if (FCL_REGISTRY[addr]) {
        FCL_REGISTRY[addr].mailbox.deliver(payload);
      }
      if (!expectReply) {
        resolve2(true);
      }
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, FCL_REGISTRY[addr], error);
      reject(error);
    }
  });
}
var kill = (addr) => {
  delete FCL_REGISTRY[addr];
};
var fromHandlers = (handlers) => async (ctx) => {
  if (typeof handlers[INIT] === "function") await handlers[INIT](ctx);
  __loop: while (1) {
    const letter = await ctx.receive();
    try {
      if (letter.tag === EXIT) {
        if (typeof handlers[TERMINATE] === "function") {
          await handlers[TERMINATE](ctx, letter, letter.data || {});
        }
        break __loop;
      }
      await handlers[letter.tag]?.(ctx, letter, letter.data || {});
    } catch (error) {
      console.error(`${ctx.self()} Error`, letter, error);
    } finally {
      continue __loop;
    }
  }
};
var parseAddr = (addr) => {
  if (addr == null) {
    return String(++pid);
  }
  return String(addr);
};
var spawn = function(fnOrHandlers) {
  let rawAddr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  const addr = parseAddr(rawAddr);
  if (FCL_REGISTRY[addr] != null) return addr;
  FCL_REGISTRY[addr] = {
    addr,
    mailbox: mailbox(),
    subs: /* @__PURE__ */ new Set(),
    kvs: {},
    error: null
  };
  const ctx = createCtx(addr);
  let fn;
  if (typeof fnOrHandlers === "object") fn = fromHandlers(fnOrHandlers);
  else fn = fnOrHandlers;
  _queueMicrotask(async () => {
    await fn(ctx);
    kill(addr);
  });
  return addr;
};
var createCtx = (addr) => ({
  self: () => addr,
  receive: () => FCL_REGISTRY[addr].mailbox.receive(),
  send: function(to, tag, data) {
    let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (to == null) return;
    opts.from = addr;
    return send(to, tag, data, opts);
  },
  sendSelf: function(tag, data) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (FCL_REGISTRY[addr]) send(addr, tag, data, opts);
  },
  broadcast: function(tag, data) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    opts.from = addr;
    for (const to of FCL_REGISTRY[addr].subs) send(to, tag, data, opts);
  },
  subscribe: (sub) => sub != null && FCL_REGISTRY[addr].subs.add(sub),
  unsubscribe: (sub) => sub != null && FCL_REGISTRY[addr].subs.delete(sub),
  subscriberCount: () => FCL_REGISTRY[addr].subs.size,
  hasSubs: () => !!FCL_REGISTRY[addr].subs.size,
  put: (key, value) => {
    if (key != null) FCL_REGISTRY[addr].kvs[key] = value;
  },
  get: function(key) {
    let fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    const value = FCL_REGISTRY[addr].kvs[key];
    return value == null ? fallback : value;
  },
  delete: (key) => {
    delete FCL_REGISTRY[addr].kvs[key];
  },
  update: (key, fn) => {
    if (key != null) FCL_REGISTRY[addr].kvs[key] = fn(FCL_REGISTRY[addr].kvs[key]);
  },
  keys: () => {
    return Object.keys(FCL_REGISTRY[addr].kvs);
  },
  all: () => {
    return FCL_REGISTRY[addr].kvs;
  },
  where: (pattern) => {
    return Object.keys(FCL_REGISTRY[addr].kvs).reduce((acc, key) => {
      return pattern.test(key) ? {
        ...acc,
        [key]: FCL_REGISTRY[addr].kvs[key]
      } : acc;
    }, {});
  },
  merge: function() {
    let data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.keys(data).forEach((key) => FCL_REGISTRY[addr].kvs[key] = data[key]);
  },
  fatalError: (error) => {
    FCL_REGISTRY[addr].error = error;
    for (const to of FCL_REGISTRY[addr].subs) send(to, UPDATED);
  }
});
function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  const self2 = spawn(async (ctx) => {
    ctx.send(address, SUBSCRIBE);
    while (1) {
      const letter = await ctx.receive();
      const error = FCL_REGISTRY[address].error;
      if (letter.tag === EXIT) {
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      if (error) {
        callback(null, error);
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      callback(letter.data, null);
    }
  });
  return () => send(self2, EXIT);
}
function snapshoter(address, spawnFn) {
  spawnFn(address);
  return send(address, SNAPSHOT, null, {
    expectReply: true,
    timeout: 0
  });
}

// node_modules/@onflow/config/dist/config.module.js
var pipe = function() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  return (v) => {
    return funcs.reduce((res, func) => {
      return func(res);
    }, v);
  };
};
var mergePipe = function() {
  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    funcs[_key2] = arguments[_key2];
  }
  return (v) => {
    return funcs.reduce((res, func) => {
      return {
        ...res,
        ...func(v)
      };
    }, {});
  };
};
var isObject = (value) => value && typeof value === "object" && !Array.isArray(value);
var mergeDeep = function(target) {
  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    sources[_key3 - 1] = arguments[_key3];
  }
  if (!sources.length) return target;
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, {
          [key]: {}
        });
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, {
          [key]: source[key]
        });
      }
    }
  }
  return mergeDeep(target, ...sources);
};
var mergeFlowJSONs = (value) => Array.isArray(value) ? mergeDeep({}, ...value) : value;
var filterContracts = (obj) => obj.contracts ? obj.contracts : {};
var filterDependencies = (obj) => obj.dependencies ? obj.dependencies : {};
var mapContractAliasesToNetworkAddress = (network) => (contracts) => {
  return Object.entries(contracts).reduce((c, _ref) => {
    let [key, value] = _ref;
    const networkContractAlias = value?.aliases?.[network];
    if (networkContractAlias) {
      c[key] = networkContractAlias;
    }
    return c;
  }, {});
};
var mapDependencyAliasesToNetworkAddress = (network) => (dependencies) => {
  return Object.entries(dependencies).reduce((c, _ref2) => {
    let [key, value] = _ref2;
    const networkDependencyAlias = value?.aliases?.[network];
    if (networkDependencyAlias) {
      c[key] = networkDependencyAlias;
    }
    return c;
  }, {});
};
var mapDeploymentsToNetworkAddress = (network) => (_ref3) => {
  let {
    deployments = {},
    accounts = {}
  } = _ref3;
  const networkDeployment = deployments?.[network];
  if (!networkDeployment) return {};
  return Object.entries(networkDeployment).reduce((c, _ref4) => {
    let [key, value] = _ref4;
    const accountAddress = accounts[key]?.address;
    if (!accountAddress) return c;
    return value.reduce((c2, contract) => {
      return {
        ...c2,
        [contract]: accountAddress
      };
    }, {});
  }, {});
};
var getContracts = (jsons, network) => {
  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network)), pipe(filterDependencies, mapDependencyAliasesToNetworkAddress(network))))(jsons);
};
var isHexidecimal = (str) => {
  if (typeof str !== "string") return false;
  return /^[0-9A-Fa-f]+$/.test(str);
};
var hasPrivateKeys = (flowJSON) => {
  return Object.entries(flowJSON?.accounts ?? []).reduce((hasPrivateKey, _ref5) => {
    let [, value] = _ref5;
    if (hasPrivateKey) return true;
    return value && Object.prototype.hasOwnProperty.call(value, "key") && isHexidecimal(value?.key);
  }, false);
};
var anyHasPrivateKeys = (value) => {
  if (Array.isArray(value)) return value.some(hasPrivateKeys);
  return hasPrivateKeys(value);
};
var cleanNetwork = (network) => {
  const cleanedNetwork = network?.toLowerCase() === "local" ? "emulator" : network?.toLowerCase();
  if (cleanedNetwork === "emulator" || cleanedNetwork === "testnet" || cleanedNetwork === "mainnet") return cleanedNetwork;
  throw new Error(`Invalid network "${network}". Must be one of "emulator", "local", "testnet", or "mainnet"`);
};
setConfig(config2);
var NAME = "config";
var PUT = "PUT_CONFIG";
var GET = "GET_CONFIG";
var GET_ALL = "GET_ALL_CONFIG";
var UPDATE = "UPDATE_CONFIG";
var DELETE = "DELETE_CONFIG";
var CLEAR = "CLEAR_CONFIG";
var WHERE = "WHERE_CONFIG";
var UPDATED2 = "CONFIG/UPDATED";
var identity = (v) => v;
var HANDLERS = {
  [PUT]: (ctx, _letter, _ref) => {
    let {
      key,
      value
    } = _ref;
    if (key == null) throw new Error("Missing 'key' for config/put.");
    ctx.put(key, value);
    ctx.broadcast(UPDATED2, {
      ...ctx.all()
    });
  },
  [GET]: (ctx, letter, _ref2) => {
    let {
      key,
      fallback
    } = _ref2;
    if (key == null) throw new Error("Missing 'key' for config/get");
    letter.reply(ctx.get(key, fallback));
  },
  [GET_ALL]: (ctx, letter) => {
    letter.reply({
      ...ctx.all()
    });
  },
  [UPDATE]: (ctx, letter, _ref3) => {
    let {
      key,
      fn
    } = _ref3;
    if (key == null) throw new Error("Missing 'key' for config/update");
    ctx.update(key, fn || identity);
    ctx.broadcast(UPDATED2, {
      ...ctx.all()
    });
  },
  [DELETE]: (ctx, letter, _ref4) => {
    let {
      key
    } = _ref4;
    if (key == null) throw new Error("Missing 'key' for config/delete");
    ctx.delete(key);
    ctx.broadcast(UPDATED2, {
      ...ctx.all()
    });
  },
  [CLEAR]: (ctx) => {
    const keys = Object.keys(ctx.all());
    for (const key of keys) ctx.delete(key);
    ctx.broadcast(UPDATED2, {
      ...ctx.all()
    });
  },
  [WHERE]: (ctx, letter, _ref5) => {
    let {
      pattern
    } = _ref5;
    if (pattern == null) throw new Error("Missing 'pattern' for config/where");
    letter.reply(ctx.where(pattern));
  },
  [SUBSCRIBE]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED2, {
      ...ctx.all()
    });
  },
  [UNSUBSCRIBE]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
  }
};
spawn(HANDLERS, NAME);
function put(key, value) {
  send(NAME, PUT, {
    key,
    value
  });
  return config2();
}
function get(key, fallback) {
  return send(NAME, GET, {
    key,
    fallback
  }, {
    expectReply: true,
    timeout: 10
  });
}
async function first() {
  let wants = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let fallback = arguments.length > 1 ? arguments[1] : void 0;
  if (!wants.length) return fallback;
  const [head, ...rest] = wants;
  const ret = await get(head);
  if (ret == null) return first(rest, fallback);
  return ret;
}
function all() {
  return send(NAME, GET_ALL, null, {
    expectReply: true,
    timeout: 10
  });
}
function update(key) {
  let fn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : identity;
  send(NAME, UPDATE, {
    key,
    fn
  });
  return config2();
}
function _delete(key) {
  send(NAME, DELETE, {
    key
  });
  return config2();
}
function where(pattern) {
  return send(NAME, WHERE, {
    pattern
  }, {
    expectReply: true,
    timeout: 10
  });
}
function subscribe(callback) {
  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);
}
async function clearConfig() {
  await send(NAME, CLEAR);
}
async function resetConfig(oldConfig) {
  return clearConfig().then(() => config2(oldConfig));
}
async function load(data) {
  const network = await get("flow.network");
  const cleanedNetwork = cleanNetwork(network);
  const {
    flowJSON
  } = data;
  invariant(Boolean(flowJSON), "config.load -- 'flowJSON' must be defined");
  invariant(!!cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define "flow.network" to "emulator", "local", "testnet", or "mainnet" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);
  if (anyHasPrivateKeys(flowJSON)) {
    const isEmulator = cleanedNetwork === "emulator";
    log({
      title: "Private Keys Detected",
      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,
      level: isEmulator ? LEVELS.warn : LEVELS.error
    });
    invariant(isEmulator, `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`);
  }
  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {
    const contractConfigKey = `0x${key}`;
    const existingContractConfigKey = await get(contractConfigKey);
    if (existingContractConfigKey && existingContractConfigKey !== value) {
      log({
        title: "Contract Placeholder Conflict Detected",
        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,
        level: LEVELS.warn
      });
    } else {
      put(contractConfigKey, value);
    }
    const systemContractConfigKey = `system.contracts.${key}`;
    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);
    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {
      log({
        title: "Contract Placeholder Conflict Detected",
        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,
        level: LEVELS.warn
      });
    } else {
      put(systemContractConfigKey, value);
    }
  }
}
function config2(values) {
  if (values != null && typeof values === "object") {
    Object.keys(values).map((d) => put(d, values[d]));
  }
  return {
    put,
    get,
    all,
    first,
    update,
    delete: _delete,
    where,
    subscribe,
    overload,
    load
  };
}
config2.put = put;
config2.get = get;
config2.all = all;
config2.first = first;
config2.update = update;
config2.delete = _delete;
config2.where = where;
config2.subscribe = subscribe;
config2.overload = overload;
config2.load = load;
async function overload(values, callback) {
  const oldConfig = await all();
  try {
    config2(values);
    const result = await callback(await all());
    return result;
  } finally {
    await resetConfig(oldConfig);
  }
}

// node_modules/@onflow/rlp/dist/rlp.module.js
var import_buffer = __toESM(require_buffer());
var import_buffer2 = __toESM(require_buffer());
function encode(input) {
  if (Array.isArray(input)) {
    const output = [];
    for (let i = 0; i < input.length; i++) {
      output.push(encode(input[i]));
    }
    const buf = import_buffer.Buffer.concat(output);
    return import_buffer.Buffer.concat([encodeLength(buf.length, 192), buf]);
  } else {
    const inputBuf = toBuffer(input);
    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : import_buffer.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
  }
}
function encodeLength(len, offset) {
  if (len < 56) {
    return import_buffer.Buffer.from([len + offset]);
  } else {
    const hexLength = intToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = intToHex(offset + 55 + lLength);
    return import_buffer.Buffer.from(firstByte + hexLength, "hex");
  }
}
function isHexPrefixed(str) {
  return str.slice(0, 2) === "0x";
}
function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed(str) ? str.slice(2) : str;
}
function intToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  const hex = integer.toString(16);
  return hex.length % 2 ? "0" + hex : hex;
}
function padToEven(a) {
  return a.length % 2 ? "0" + a : a;
}
function intToBuffer(integer) {
  const hex = intToHex(integer);
  return import_buffer.Buffer.from(hex, "hex");
}
function toBuffer(v) {
  if (!import_buffer.Buffer.isBuffer(v)) {
    if (typeof v === "string") {
      if (isHexPrefixed(v)) {
        return import_buffer.Buffer.from(padToEven(stripHexPrefix(v)), "hex");
      } else {
        return import_buffer.Buffer.from(v);
      }
    } else if (typeof v === "number") {
      if (!v) {
        return import_buffer.Buffer.from([]);
      } else {
        return intToBuffer(v);
      }
    } else if (v === null || v === void 0) {
      return import_buffer.Buffer.from([]);
    } else if (v instanceof Uint8Array) {
      return import_buffer.Buffer.from(v);
    } else {
      throw new Error("invalid type");
    }
  }
  return v;
}

// node_modules/@onflow/transport-http/dist/sdk-send-http.module.js
var import_cross_fetch = __toESM(require_browser_ponyfill());

// node_modules/@onflow/util-address/dist/util-address.module.js
function sansPrefix(address) {
  if (address == null) return null;
  return address.replace(/^0x/, "").replace(/^Fx/, "");
}
function withPrefix2(address) {
  if (address == null) return null;
  return "0x" + sansPrefix(address);
}

// node_modules/@onflow/transport-http/dist/sdk-send-http.module.js
var import_events = __toESM(require_events());

// node_modules/isomorphic-ws/browser.js
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof global !== "undefined") {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/@onflow/transport-http/dist/sdk-send-http.module.js
function safeParseJSON(data) {
  try {
    return JSON.parse(data);
  } catch {
    return null;
  }
}
var AbortController2 = globalThis.AbortController || require_browser();
var HTTPRequestError = class extends Error {
  constructor(_ref) {
    let {
      error,
      hostname,
      path,
      method,
      requestBody,
      responseBody,
      responseStatusText,
      statusCode
    } = _ref;
    const msg = `
      HTTP Request Error: An error occurred when interacting with the Access API.
      ${error ? `error=${error}` : ""}
      ${hostname ? `hostname=${hostname}` : ""}
      ${path ? `path=${path}` : ""}
      ${method ? `method=${method}` : ""}
      ${requestBody ? `requestBody=${requestBody}` : ""}
      ${responseBody ? `responseBody=${responseBody}` : ""}
      ${responseStatusText ? `responseStatusText=${responseStatusText}` : ""}
      ${statusCode ? `statusCode=${statusCode}` : ""}
    `;
    super(msg);
    this.name = "HTTP Request Error";
    this.statusCode = statusCode;
    this.errorMessage = error;
  }
};
async function httpRequest(_ref2) {
  let {
    hostname,
    path,
    method,
    body,
    headers,
    retryLimit = 5,
    retryIntervalMs = 1e3,
    timeoutLimit = 3e4,
    enableRequestLogging = true
  } = _ref2;
  const bodyJSON = body ? JSON.stringify(body) : null;
  function makeRequest() {
    const controller = new AbortController2();
    const fetchTimeout = setTimeout(() => {
      controller.abort();
    }, timeoutLimit);
    return (0, import_cross_fetch.default)(new URL(path, hostname).toString(), {
      method,
      body: bodyJSON,
      headers,
      signal: controller.signal
    }).then(async (res) => {
      if (res.ok) {
        return res.json();
      }
      const responseText = await res.text().catch(() => null);
      const response2 = safeParseJSON(responseText);
      throw new HTTPRequestError({
        error: response2?.message,
        hostname,
        path,
        method,
        requestBody: bodyJSON,
        responseBody: responseText,
        responseStatusText: res.statusText,
        statusCode: res.status
      });
    }).catch(async (e) => {
      if (e instanceof HTTPRequestError) {
        throw e;
      }
      if (e.name === "AbortError") {
        throw e;
      }
      if (enableRequestLogging) {
        await log({
          title: "Access Node Error",
          message: `The provided access node ${hostname} does not appear to be a valid REST/HTTP access node.
  Please verify that you are not unintentionally using a GRPC access node.
  See more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect`,
          level: LEVELS.error
        });
      }
      throw new HTTPRequestError({
        error: e?.message,
        hostname,
        path,
        method,
        requestBody: bodyJSON
      });
    }).finally(() => {
      clearTimeout(fetchTimeout);
    });
  }
  async function requestLoop() {
    let retryAttempt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    try {
      const resp = await makeRequest();
      return resp;
    } catch (error) {
      const retryStatusCodes = [408, 429, 500, 502, 503, 504];
      if (error.name === "AbortError" || retryStatusCodes.includes(error.statusCode)) {
        return await new Promise((resolve2, reject) => {
          if (retryAttempt < retryLimit) {
            if (enableRequestLogging) {
              console.warn(`Access node unavailable, retrying in ${retryIntervalMs} ms...`);
            }
            setTimeout(() => {
              resolve2(requestLoop(retryAttempt + 1));
            }, retryIntervalMs);
          } else {
            reject(error);
          }
        });
      } else {
        throw error;
      }
    }
  }
  return await requestLoop();
}
async function sendExecuteScriptAtBlockIDRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/scripts?block_id=${ix.block.id}`,
    method: "POST",
    body: {
      script: context.Buffer.from(ix.message.cadence).toString("base64"),
      arguments: ix.message.arguments.map((arg2) => context.Buffer.from(JSON.stringify(ix.arguments[arg2].asArgument)).toString("base64"))
    }
  });
  return constructResponse$5(ix, context, res);
}
async function sendExecuteScriptAtBlockHeightRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/scripts?block_height=${ix.block.height}`,
    method: "POST",
    body: {
      script: context.Buffer.from(ix.message.cadence).toString("base64"),
      arguments: ix.message.arguments.map((arg2) => context.Buffer.from(JSON.stringify(ix.arguments[arg2].asArgument)).toString("base64"))
    }
  });
  return constructResponse$5(ix, context, res);
}
async function sendExecuteScriptAtLatestBlockRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/scripts?block_height=sealed`,
    method: "POST",
    body: {
      script: context.Buffer.from(ix.message.cadence).toString("base64"),
      arguments: ix.message.arguments.map((arg2) => context.Buffer.from(JSON.stringify(ix.arguments[arg2].asArgument)).toString("base64"))
    }
  });
  return constructResponse$5(ix, context, res);
}
function constructResponse$5(ix, context, res) {
  let ret = context.response();
  ret.tag = ix.tag;
  ret.encodedData = JSON.parse(context.Buffer.from(res, "base64").toString());
  return ret;
}
async function sendExecuteScript(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Execute Script Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Execute Script Error: context.response must be defined.`);
  invariant(context.Buffer, `SDK Send Execute Script Error: context.Buffer must be defined.`);
  ix = await ix;
  if (ix.block.id) {
    return await sendExecuteScriptAtBlockIDRequest(ix, context, opts);
  } else if (ix.block.height) {
    return await sendExecuteScriptAtBlockHeightRequest(ix, context, opts);
  } else {
    return await sendExecuteScriptAtLatestBlockRequest(ix, context, opts);
  }
}
var HashAlgorithmIDs = {
  SHA2_256: 1,
  SHA2_384: 2,
  SHA3_256: 3,
  SHA3_384: 4,
  KMAC128_BLS_BLS12_381: 5
};
var SignatureAlgorithmIDs = {
  ECDSA_P256: 1,
  ECDSA_secp256k1: 2,
  BLS_BLS12_381: 3
};
async function sendGetAccountAtBlockHeightRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/accounts/${ix.account.addr}?block_height=${ix.block.height}&expand=contracts,keys`,
    method: "GET",
    body: null
  });
  return constructResponse$4(ix, context, res);
}
async function sendGetAccountAtLatestBlockRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/accounts/${ix.account.addr}?block_height=sealed&expand=contracts,keys`,
    method: "GET",
    body: null
  });
  return constructResponse$4(ix, context, res);
}
function constructResponse$4(ix, context, res) {
  let ret = context.response();
  ret.tag = ix.tag;
  const unwrapContracts = (contracts) => {
    const c = {};
    if (!contracts) return c;
    for (let key of Object.keys(contracts)) {
      c[key] = context.Buffer.from(contracts[key], "base64").toString();
    }
    return c;
  };
  ret.account = {
    address: res.address,
    balance: Number(res.balance),
    code: "",
    contracts: unwrapContracts(res.contracts),
    keys: res.keys?.map((key) => ({
      index: Number(key.index),
      publicKey: key.public_key.replace(/^0x/, ""),
      signAlgo: SignatureAlgorithmIDs[key.signing_algorithm],
      signAlgoString: key.signing_algorithm,
      hashAlgo: HashAlgorithmIDs[key.hashing_algorithm],
      hashAlgoString: key.hashing_algorithm,
      sequenceNumber: Number(key.sequence_number),
      weight: Number(key.weight),
      revoked: key.revoked
    })) ?? []
  };
  return ret;
}
async function sendGetAccount(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Account Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Account Error: context.response must be defined.`);
  invariant(context.Buffer, `SDK Send Get Account Error: context.Buffer must be defined.`);
  ix = await ix;
  if (ix.block.height !== null) {
    return await sendGetAccountAtBlockHeightRequest(ix, context, opts);
  } else {
    return await sendGetAccountAtLatestBlockRequest(ix, context, opts);
  }
}
async function sendGetBlockHeaderByIDRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/blocks/${ix.block.id}`,
    method: "GET",
    body: null
  });
  return constructResponse$3(ix, context, res);
}
async function sendGetBlockHeaderByHeightRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/blocks?height=${ix.block.height}`,
    method: "GET",
    body: null
  });
  return constructResponse$3(ix, context, res);
}
async function sendGetLatestBlockHeaderRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const height = ix.block?.isSealed ? "sealed" : "final";
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/blocks?height=${height}`,
    method: "GET",
    body: null
  });
  return constructResponse$3(ix, context, res);
}
function constructResponse$3(ix, context, res) {
  const block2 = res.length ? res[0] : null;
  const ret = context.response();
  ret.tag = ix.tag;
  ret.blockHeader = {
    id: block2.header.id,
    parentId: block2.header.parent_id,
    height: Number(block2.header.height),
    timestamp: block2.header.timestamp
  };
  return ret;
}
async function sendGetBlockHeader(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Block Header Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Block Header Error: context.response must be defined.`);
  ix = await ix;
  const interactionHasBlockID = ix.block.id !== null;
  const interactionHasBlockHeight = ix.block.height !== null;
  if (interactionHasBlockID) {
    return await sendGetBlockHeaderByIDRequest(ix, context, opts);
  } else if (interactionHasBlockHeight) {
    return await sendGetBlockHeaderByHeightRequest(ix, context, opts);
  } else {
    return await sendGetLatestBlockHeaderRequest(ix, context, opts);
  }
}
async function sendGetBlockByIDRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/blocks/${ix.block.id}?expand=payload`,
    method: "GET",
    body: null
  });
  return constructResponse$2(ix, context, res);
}
async function sendGetBlockByHeightRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/blocks?height=${ix.block.height}&expand=payload`,
    method: "GET",
    body: null
  });
  return constructResponse$2(ix, context, res);
}
async function sendGetBlockRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const height = ix.block?.isSealed ? "sealed" : "final";
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/blocks?height=${height}&expand=payload`,
    method: "GET",
    body: null
  });
  return constructResponse$2(ix, context, res);
}
function constructResponse$2(ix, context, res) {
  const block2 = res.length ? res[0] : null;
  const ret = context.response();
  ret.tag = ix.tag;
  ret.block = {
    id: block2.header.id,
    parentId: block2.header.parent_id,
    height: Number(block2.header.height),
    timestamp: block2.header.timestamp,
    collectionGuarantees: block2.payload.collection_guarantees.map((collectionGuarantee) => ({
      collectionId: collectionGuarantee.collection_id,
      signerIds: collectionGuarantee.signer_ids
    })),
    blockSeals: block2.payload.block_seals.map((blockSeal) => ({
      blockId: blockSeal.block_id,
      executionReceiptId: blockSeal.result_id
    }))
  };
  return ret;
}
async function sendGetBlock(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Block Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Block Error: context.response must be defined.`);
  ix = await ix;
  const interactionHasBlockID = ix.block.id !== null;
  const interactionHasBlockHeight = ix.block.height !== null;
  if (interactionHasBlockID) {
    return await sendGetBlockByIDRequest(ix, context, opts);
  } else if (interactionHasBlockHeight) {
    return await sendGetBlockByHeightRequest(ix, context, opts);
  } else {
    return await sendGetBlockRequest(ix, context, opts);
  }
}
async function sendGetCollection(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Collection Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Collection Error: context.response must be defined.`);
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/collections/${ix.collection.id}?expand=transactions`,
    method: "GET",
    body: null
  });
  const ret = context.response();
  ret.tag = ix.tag;
  ret.collection = {
    id: res.id,
    transactionIds: res.transactions.map((transaction3) => transaction3.id)
  };
  return ret;
}
async function sendGetEventsForHeightRangeRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/events?type=${ix.events.eventType}&start_height=${ix.events.start}&end_height=${ix.events.end}`,
    method: "GET",
    body: null
  });
  return constructResponse$1(ix, context, res);
}
async function sendGetEventsForBlockIDsRequest(ix, context, opts) {
  const httpRequest$1 = opts.httpRequest || httpRequest;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/events?type=${ix.events.eventType}&block_ids=${ix.events.blockIds.join(",")}`,
    method: "GET",
    body: null
  });
  return constructResponse$1(ix, context, res);
}
function constructResponse$1(ix, context, res) {
  let ret = context.response();
  ret.tag = ix.tag;
  ret.events = [];
  res.forEach((block2) => block2.events ? block2.events.forEach((event) => ret.events.push({
    blockId: block2.block_id,
    blockHeight: Number(block2.block_height),
    blockTimestamp: block2.block_timestamp,
    type: event.type,
    transactionId: event.transaction_id,
    transactionIndex: Number(event.transaction_index),
    eventIndex: Number(event.event_index),
    payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
  })) : null);
  return ret;
}
async function sendGetEvents(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Events Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Events Error: context.response must be defined.`);
  invariant(context.Buffer, `SDK Send Get Events Error: context.Buffer must be defined.`);
  ix = await ix;
  const interactionContainsBlockHeightRange = ix.events.start !== null;
  const interactionContainsBlockIDsList = Array.isArray(ix.events.blockIds) && ix.events.blockIds.length > 0;
  invariant(interactionContainsBlockHeightRange || interactionContainsBlockIDsList, "SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified.");
  if (interactionContainsBlockHeightRange) {
    return await sendGetEventsForHeightRangeRequest(ix, context, opts);
  } else {
    return await sendGetEventsForBlockIDsRequest(ix, context, opts);
  }
}
async function sendGetTransaction(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Transaction Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Transaction Error: context.response must be defined.`);
  invariant(context.Buffer, `SDK Send Get Transaction Error: context.Buffer must be defined.`);
  const httpRequest$1 = opts.httpRequest || httpRequest;
  ix = await ix;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/transactions/${ix.transaction.id}`,
    method: "GET",
    body: null
  });
  const unwrapKey = (key) => ({
    address: key.address,
    keyId: Number(key.key_id),
    sequenceNumber: Number(key.sequence_number)
  });
  const unwrapSignature = (sig2) => ({
    address: sig2.address,
    keyId: Number(sig2.key_index),
    signature: sig2.signature
  });
  const unwrapArg = (arg2) => JSON.parse(context.Buffer.from(arg2, "base64").toString());
  let ret = context.response();
  ret.tag = ix.tag;
  ret.transaction = {
    script: context.Buffer.from(res.script, "base64").toString(),
    args: [...res.arguments.map(unwrapArg)],
    referenceBlockId: res.reference_block_id,
    gasLimit: Number(res.gas_limit),
    payer: res.payer,
    proposalKey: res.proposal_key ? unwrapKey(res.proposal_key) : res.proposal_key,
    authorizers: res.authorizers,
    payloadSignatures: [...res.payload_signatures.map(unwrapSignature)],
    envelopeSignatures: [...res.envelope_signatures.map(unwrapSignature)]
  };
  return ret;
}
var STATUS_MAP = {
  UNKNOWN: 0,
  PENDING: 1,
  FINALIZED: 2,
  EXECUTED: 3,
  SEALED: 4,
  EXPIRED: 5
};
async function sendGetTransactionStatus(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Transaction Status Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Transaction Status Error: context.response must be defined.`);
  invariant(context.Buffer, `SDK Send Get Transaction Status Error: context.Buffer must be defined.`);
  const httpRequest$1 = opts.httpRequest || httpRequest;
  ix = await ix;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/transaction_results/${ix.transaction.id}`,
    method: "GET",
    body: null
  });
  let ret = context.response();
  ret.tag = ix.tag;
  ret.transactionStatus = {
    blockId: res.block_id,
    status: STATUS_MAP[res.status.toUpperCase()] || "",
    statusString: res.status.toUpperCase(),
    statusCode: res.status_code,
    errorMessage: res.error_message,
    events: res.events.map((event) => ({
      type: event.type,
      transactionId: event.transaction_id,
      transactionIndex: Number(event.transaction_index),
      eventIndex: Number(event.event_index),
      payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
    }))
  };
  return ret;
}
async function sendPing(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(Boolean(opts.node), `SDK Send Ping Error: opts.node must be defined.`);
  invariant(Boolean(context.response), `SDK Send Ping Error: context.response must be defined.`);
  const httpRequest$1 = opts.httpRequest || httpRequest;
  await httpRequest$1({
    hostname: opts.node,
    path: "/v1/blocks?height=sealed",
    method: "GET",
    body: null
  });
  let ret = typeof context?.response === "function" ? context.response() : {};
  ret.tag = ix.tag;
  return ret;
}
var idof = (acct) => `${withPrefix(acct.addr)}-${acct.keyId}`;
async function sendTransaction(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Transaction Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Transaction Error: context.response must be defined.`);
  invariant(context.Buffer, `SDK Send Transaction Error: context.Buffer must be defined.`);
  const httpRequest$1 = opts.httpRequest || httpRequest;
  ix = await ix;
  let payloadSignatures = [];
  for (let acct of Object.values(ix.accounts)) {
    try {
      if (!acct.role.payer && acct.signature != null) {
        const signature = {
          address: sansPrefix(acct.addr),
          key_index: String(acct.keyId),
          signature: context.Buffer.from(acct.signature, "hex").toString("base64")
        };
        if (!payloadSignatures.find((existingSignature) => existingSignature.address === signature.address && existingSignature.key_index === signature.key_index && existingSignature.signature === signature.signature)) {
          payloadSignatures.push(signature);
        }
      }
    } catch (error) {
      console.error("SDK HTTP Send Error: Trouble applying payload signature", {
        acct,
        ix
      });
      throw error;
    }
  }
  let envelopeSignatures = {};
  for (let acct of Object.values(ix.accounts)) {
    try {
      if (acct.role.payer && acct.signature != null) {
        let id = acct.tempId || idof(acct);
        envelopeSignatures[id] = envelopeSignatures[id] || {
          address: sansPrefix(acct.addr),
          key_index: String(acct.keyId),
          signature: context.Buffer.from(acct.signature, "hex").toString("base64")
        };
      }
    } catch (error) {
      console.error("SDK HTTP Send Error: Trouble applying envelope signature", {
        acct,
        ix
      });
      throw error;
    }
  }
  envelopeSignatures = Object.values(envelopeSignatures);
  var t1 = Date.now();
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/transactions`,
    method: "POST",
    body: {
      script: context.Buffer.from(ix.message.cadence).toString("base64"),
      arguments: [...ix.message.arguments.map((arg2) => context.Buffer.from(JSON.stringify(ix.arguments[arg2].asArgument)).toString("base64"))],
      reference_block_id: ix.message.refBlock ? ix.message.refBlock : null,
      gas_limit: String(ix.message.computeLimit),
      payer: sansPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
      proposal_key: {
        address: sansPrefix(ix.accounts[ix.proposer].addr),
        key_index: String(ix.accounts[ix.proposer].keyId),
        sequence_number: String(ix.accounts[ix.proposer].sequenceNum)
      },
      authorizers: ix.authorizations.map((tempId) => ix.accounts[tempId].addr).reduce((prev, current) => {
        return prev.find((item) => item === current) ? prev : [...prev, current];
      }, []).map(sansPrefix),
      payload_signatures: payloadSignatures,
      envelope_signatures: envelopeSignatures
    }
  });
  var t2 = Date.now();
  let ret = context.response();
  ret.tag = ix.tag;
  ret.transactionId = res.id;
  if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") {
    window.dispatchEvent(new CustomEvent("FLOW::TX", {
      detail: {
        txId: ret.transactionId,
        delta: t2 - t1
      }
    }));
  }
  return ret;
}
async function sendGetNetworkParameters(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Network Parameters Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Network Parameters Error: context.response must be defined.`);
  const httpRequest$1 = opts.httpRequest || httpRequest;
  ix = await ix;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/network/parameters`,
    method: "GET",
    body: null,
    enableRequestLogging: opts.enableRequestLogging ?? true
  });
  let ret = context.response();
  ret.tag = ix.tag;
  ret.networkParameters = {
    chainId: res.chain_id
  };
  return ret;
}
async function sendGetNodeVersionInfo(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Node Version Info Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Node Verison Info Error: context.response must be defined.`);
  const httpRequest$1 = opts.httpRequest || httpRequest;
  ix = await ix;
  const res = await httpRequest$1({
    hostname: opts.node,
    path: `/v1/node_version_info`,
    method: "GET"
  });
  let ret = context.response();
  ret.tag = ix.tag;
  ret.nodeVersionInfo = {
    semver: res.semver,
    commit: res.commit,
    sporkId: res.spork_id,
    protocolVersion: parseInt(res.protocol_version),
    sporkRootBlockHeight: parseInt(res.spork_root_block_height),
    nodeRootBlockHeight: parseInt(res.node_root_block_height)
  };
  return ret;
}
var WebSocket2 = browser_default;
var WebsocketError = class extends Error {
  constructor(_ref) {
    let {
      code,
      reason,
      message,
      wasClean
    } = _ref;
    const msg = `
      connectWs: connection closed with error${message ? `: ${message}` : ""}
      ${code ? `code: ${code}` : ""}
      ${reason ? `reason: ${reason}` : ""}
      ${wasClean ? `wasClean: ${wasClean}` : ""}
    `;
    super(msg);
    this.name = "WebsocketError";
    this.code = code;
    this.reason = reason;
    this.wasClean = false;
  }
};
function connectWs(_ref2) {
  let {
    hostname,
    path,
    params: params2,
    getParams,
    retryLimit = 5,
    retryIntervalMs = 1e3
  } = _ref2;
  if (getParams && params2) {
    throw new Error("connectWs: cannot specify both params and getParams");
  }
  let outputEmitter = new import_events.EventEmitter();
  let retryCount = 0;
  const resolveParams = getParams || (() => params2);
  let close2 = () => {
  };
  (function connect() {
    let userClosed = false;
    let hasOpened = false;
    const url = buildConnectionUrl(hostname, path, resolveParams());
    const ws2 = new WebSocket2(url);
    ws2.onmessage = function(e) {
      const data = safeParseJSON(e.data);
      if (data) {
        outputEmitter.emit("data", data);
      } else {
        outputEmitter.emit("error", new WebsocketError({
          message: "invalid JSON data"
        }));
        this.close();
      }
    };
    ws2.onclose = function(e) {
      if (userClosed) {
        outputEmitter.emit("close");
        outputEmitter.removeAllListeners();
        return;
      }
      if (!hasOpened) {
        if (retryCount < retryLimit) {
          retryCount++;
          setTimeout(connect, retryIntervalMs);
        } else {
          outputEmitter.emit("error", new WebsocketError({
            wasClean: e.wasClean,
            code: e.code,
            reason: e.reason,
            message: "failed to connect"
          }));
          setTimeout(() => {
            outputEmitter.emit("close");
            outputEmitter.removeAllListeners();
          });
        }
      } else {
        setTimeout(connect, retryIntervalMs);
      }
    };
    ws2.onopen = function() {
      hasOpened = true;
      retryCount = 0;
    };
    close2 = () => {
      userClosed = true;
      ws2.close();
    };
  })();
  return {
    on(event, listener) {
      outputEmitter.on(event, listener);
      return this;
    },
    off(event, listener) {
      outputEmitter.off(event, listener);
      return this;
    },
    close() {
      close2();
    }
  };
}
function buildConnectionUrl(hostname, path, params2) {
  const url = new URL(path || "", hostname);
  if (url.protocol === "https:") {
    url.protocol = "wss:";
  } else if (url.protocol === "http:") {
    url.protocol = "ws:";
  }
  Object.entries(params2 || {}).forEach((_ref3) => {
    let [key, value] = _ref3;
    if (value) {
      let formattedValue;
      if (Array.isArray(value)) {
        formattedValue = value.join(",");
      } else {
        formattedValue = value.toString();
      }
      url.searchParams.append(key, formattedValue);
    }
  });
  return url.toString();
}
function constructData(ix, context, data) {
  const response2 = context.response();
  response2.tag = ix.tag;
  response2.events = data.Events?.length > 0 ? data.Events.map((event) => ({
    blockId: data.BlockID,
    blockHeight: Number(data.Height),
    blockTimestamp: data.Timestamp,
    type: event.Type,
    transactionId: event.TransactionID,
    transactionIndex: Number(event.TransactionIndex),
    eventIndex: Number(event.EventIndex),
    payload: JSON.parse(context.Buffer.from(event.Payload, "base64").toString())
  })) : null;
  response2.heartbeat = {
    blockId: data.BlockID,
    blockHeight: Number(data.Height),
    blockTimestamp: data.Timestamp
  };
  return response2;
}
function constructResponse(ix, context, stream) {
  const response2 = context.response();
  response2.tag = ix.tag;
  response2.streamConnection = stream;
  return response2;
}
async function connectSubscribeEvents(ix) {
  let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(opts.node, `SDK Send Get Events Error: opts.node must be defined.`);
  invariant(context.response, `SDK Send Get Events Error: context.response must be defined.`);
  invariant(context.Buffer, `SDK Send Get Events Error: context.Buffer must be defined.`);
  const resolvedIx = await ix;
  const connectWs$1 = opts.connectWs || connectWs;
  const outputEmitter = new import_events.EventEmitter();
  let lastBlockHeight = null;
  const connection = connectWs$1({
    hostname: opts.node,
    path: `/v1/subscribe_events`,
    getParams: () => {
      const params2 = {
        event_types: resolvedIx.subscribeEvents?.eventTypes,
        addresses: resolvedIx.subscribeEvents?.addresses,
        contracts: resolvedIx.subscribeEvents?.contracts,
        heartbeat_interval: resolvedIx.subscribeEvents?.heartbeatInterval
      };
      if (lastBlockHeight) {
        params2.start_height = lastBlockHeight + 1;
      } else {
        params2.start_block_id = resolvedIx.subscribeEvents?.startBlockId;
        params2.start_height = resolvedIx.subscribeEvents?.startHeight;
      }
      return params2;
    }
  });
  connection.on("data", (data) => {
    const responseData = constructData(resolvedIx, context, data);
    lastBlockHeight = responseData.heartbeat.blockHeight;
    outputEmitter.emit("data", responseData);
  });
  connection.on("error", (error) => {
    outputEmitter.emit("error", error);
  });
  connection.on("close", () => {
    outputEmitter.emit("close");
  });
  const responseStream = {
    on(event, listener) {
      outputEmitter.on(event, listener);
      return this;
    },
    off(event, listener) {
      outputEmitter.off(event, listener);
      return this;
    },
    close() {
      connection.close();
    }
  };
  return constructResponse(resolvedIx, context, responseStream);
}
var send2 = async function(ix, context) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  invariant(Boolean(opts?.node), `SDK Send Error: Either opts.node or "accessNode.api" in config must be defined.`);
  invariant(Boolean(context.ix), `SDK Send Error: context.ix must be defined.`);
  ix = await ix;
  switch (true) {
    case context.ix.isTransaction(ix):
      return opts.sendTransaction ? opts.sendTransaction(ix, context, opts) : sendTransaction(ix, context, opts);
    case context.ix.isGetTransactionStatus(ix):
      return opts.sendGetTransactionStatus ? opts.sendGetTransactionStatus(ix, context, opts) : sendGetTransactionStatus(ix, context, opts);
    case context.ix.isGetTransaction(ix):
      return opts.sendGetTransaction ? opts.sendGetTransaction(ix, context, opts) : sendGetTransaction(ix, context, opts);
    case context.ix.isScript(ix):
      return opts.sendExecuteScript ? opts.sendExecuteScript(ix, context, opts) : sendExecuteScript(ix, context, opts);
    case context.ix.isGetAccount(ix):
      return opts.sendGetAccount ? opts.sendGetAccount(ix, context, opts) : sendGetAccount(ix, context, opts);
    case context.ix.isGetEvents(ix):
      return opts.sendGetEvents ? opts.sendGetEvents(ix, context, opts) : sendGetEvents(ix, context, opts);
    case context.ix.isSubscribeEvents?.(ix):
      return opts.connectSubscribeEvents ? opts.connectSubscribeEvents(ix, context, opts) : connectSubscribeEvents(ix, context, opts);
    case context.ix.isGetBlock(ix):
      return opts.sendGetBlock ? opts.sendGetBlock(ix, context, opts) : sendGetBlock(ix, context, opts);
    case context.ix.isGetBlockHeader(ix):
      return opts.sendGetBlockHeader ? opts.sendGetBlockHeader(ix, context, opts) : sendGetBlockHeader(ix, context, opts);
    case context.ix.isGetCollection(ix):
      return opts.sendGetCollection ? opts.sendGetCollection(ix, context, opts) : sendGetCollection(ix, context, opts);
    case context.ix.isPing(ix):
      return opts.sendPing ? opts.sendPing(ix, context, opts) : sendPing(ix, context, opts);
    case context.ix.isGetNetworkParameters(ix):
      return opts.sendGetNetworkParameters ? opts.sendGetNetworkParameters(ix, context, opts) : sendGetNetworkParameters(ix, context, opts);
    case context.ix.isGetNodeVersionInfo?.(ix):
      return opts.sendGetNodeVersionInfo ? opts.sendGetNodeVersionInfo(ix, context, opts) : sendGetNodeVersionInfo(ix, context, opts);
    default:
      return ix;
  }
};

// node_modules/@onflow/sdk/dist/sdk.module.js
var import_events2 = __toESM(require_events());
var import_sha3 = __toESM(require_sha3());

// node_modules/@onflow/util-template/dist/template.module.js
function interleave() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  if (!a.length && !b.length) return c;
  if (!a.length) return c;
  if (!b.length) {
    c.push(...a);
    return c;
  }
  const [aHead, ...aRest] = a;
  const [bHead, ...bRest] = b;
  if (aHead !== void 0) c.push(aHead);
  if (bHead !== void 0) c.push(bHead);
  return interleave(aRest, bRest, c);
}
function recApply(d) {
  return function(arg1) {
    if (typeof arg1 === "function") {
      log.deprecate({
        pkg: "FCL/SDK",
        subject: "Interopolation of functions into template literals",
        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
      });
      return recApply(d)(arg1(d));
    }
    return String(arg1);
  };
}
function template(head) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }
  if (typeof head === "string") return () => head;
  if (typeof head === "function") return head;
  return (x) => interleave([...head], rest.map(recApply(x))).join("").trim();
}

// node_modules/@onflow/sdk/dist/sdk.module.js
var ACCT = `{
  "kind":"${InteractionResolverKind.ACCOUNT}",
  "tempId":null,
  "addr":null,
  "keyId":null,
  "sequenceNum":null,
  "signature":null,
  "signingFunction":null,
  "resolve":null,
  "role": {
    "proposer":false,
    "authorizer":false,
    "payer":false,
    "param":false
  }
}`;
var ARG = `{
  "kind":"${InteractionResolverKind.ARGUMENT}",
  "tempId":null,
  "value":null,
  "asArgument":null,
  "xform":null,
  "resolve": null,
  "resolveArgument": null
}`;
var IX = `{
  "tag":"${InteractionTag.UNKNOWN}",
  "assigns":{},
  "status":"${InteractionStatus.OK}",
  "reason":null,
  "accounts":{},
  "params":{},
  "arguments":{},
  "message": {
    "cadence":null,
    "refBlock":null,
    "computeLimit":null,
    "proposer":null,
    "payer":null,
    "authorizations":[],
    "params":[],
    "arguments":[]
  },
  "proposer":null,
  "authorizations":[],
  "payer":[],
  "events": {
    "eventType":null,
    "start":null,
    "end":null,
    "blockIds":[]
  },
  "subscribeEvents": {
    "startBlockId":null,
    "startHeight":null,
    "eventTypes":null,
    "addresses":null,
    "contracts":null,
    "heartbeatInterval":null
  },
  "transaction": {
    "id":null
  },
  "block": {
    "id":null,
    "height":null,
    "isSealed":null
  },
  "account": {
    "addr":null
  },
  "collection": {
    "id":null
  }
}`;
var KEYS = new Set(Object.keys(JSON.parse(IX)));
var initInteraction = () => JSON.parse(IX);
var interaction = () => {
  log.deprecate({
    pkg: "FCL/SDK",
    message: `The interaction been deprecated from the Flow JS-SDK/FCL. use initInteraction instead`,
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0010-deprecate-interaction",
    level: LEVELS.warn
  });
  return initInteraction();
};
var isNumber$1 = (d) => typeof d === "number";
var isArray$1 = (d) => Array.isArray(d);
var isObj = (d) => d !== null && typeof d === "object";
var isNull = (d) => d == null;
var isFn$3 = (d) => typeof d === "function";
var isInteraction = (ix) => {
  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;
  for (let key of KEYS) if (!ix.hasOwnProperty(key)) return false;
  return true;
};
var Ok = (ix) => {
  ix.status = InteractionStatus.OK;
  return ix;
};
var Bad = (ix, reason) => {
  ix.status = InteractionStatus.BAD;
  ix.reason = reason;
  return ix;
};
var makeIx = (wat) => (ix) => {
  ix.tag = wat;
  return Ok(ix);
};
var prepAccountKeyId = (acct) => {
  if (acct.keyId == null) return acct;
  invariant(!isNaN(parseInt(acct.keyId.toString())), "account.keyId must be an integer");
  return {
    ...acct,
    keyId: parseInt(acct.keyId.toString())
  };
};
var initAccount = () => JSON.parse(ACCT);
var prepAccount = function(acct) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return (ix) => {
    invariant(typeof acct === "function" || typeof acct === "object", "prepAccount must be passed an authorization function or an account object");
    invariant(opts.role != null, "Account must have a role");
    const ACCOUNT = initAccount();
    const role = opts.role;
    const tempId = v4_default();
    let account2 = {
      ...acct
    };
    if (acct.authorization && isFn$3(acct.authorization)) account2 = {
      resolve: acct.authorization
    };
    if (!acct.authorization && isFn$3(acct)) account2 = {
      resolve: acct
    };
    const resolve2 = account2.resolve;
    if (resolve2) {
      account2.resolve = function(acct2) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        return [resolve2, prepAccountKeyId].reduce(async (d, fn) => fn(await d, ...rest), acct2);
      };
    }
    account2 = prepAccountKeyId(account2);
    ix.accounts[tempId] = {
      ...ACCOUNT,
      tempId,
      ...account2,
      role: {
        ...ACCOUNT.role,
        ...typeof acct.role === "object" ? acct.role : {},
        ...role ? {
          [role]: true
        } : {}
      }
    };
    if (role === TransactionRole.AUTHORIZER) {
      ix.authorizations.push(tempId);
    } else if (role === TransactionRole.PAYER) {
      ix.payer.push(tempId);
    } else if (role) {
      ix[role] = tempId;
    }
    return ix;
  };
};
var makeArgument = (arg2) => (ix) => {
  let tempId = v4_default();
  ix.message.arguments.push(tempId);
  ix.arguments[tempId] = JSON.parse(ARG);
  ix.arguments[tempId].tempId = tempId;
  ix.arguments[tempId].value = arg2.value;
  ix.arguments[tempId].asArgument = arg2.asArgument;
  ix.arguments[tempId].xform = arg2.xform;
  ix.arguments[tempId].resolve = arg2.resolve;
  ix.arguments[tempId].resolveArgument = isFn$3(arg2.resolveArgument) ? arg2.resolveArgument.bind(arg2) : arg2.resolveArgument;
  return Ok(ix);
};
var makeUnknown = makeIx(InteractionTag.UNKNOWN);
var makeScript = makeIx(InteractionTag.SCRIPT);
var makeTransaction = makeIx(InteractionTag.TRANSACTION);
var makeGetTransactionStatus = makeIx(InteractionTag.GET_TRANSACTION_STATUS);
var makeGetTransaction = makeIx(InteractionTag.GET_TRANSACTION);
var makeGetAccount = makeIx(InteractionTag.GET_ACCOUNT);
var makeGetEvents = makeIx(InteractionTag.GET_EVENTS);
var makePing = makeIx(InteractionTag.PING);
var makeGetBlock = makeIx(InteractionTag.GET_BLOCK);
var makeGetBlockHeader = makeIx(InteractionTag.GET_BLOCK_HEADER);
var makeGetCollection = makeIx(InteractionTag.GET_COLLECTION);
var makeGetNetworkParameters = makeIx(InteractionTag.GET_NETWORK_PARAMETERS);
var makeSubscribeEvents = makeIx(InteractionTag.SUBSCRIBE_EVENTS);
var makeGetNodeVerionInfo = makeIx(InteractionTag.GET_NODE_VERSION_INFO);
var is = (wat) => (ix) => ix.tag === wat;
var isUnknown = is(InteractionTag.UNKNOWN);
var isScript = is(InteractionTag.SCRIPT);
var isTransaction = is(InteractionTag.TRANSACTION);
var isGetTransactionStatus = is(InteractionTag.GET_TRANSACTION_STATUS);
var isGetTransaction = is(InteractionTag.GET_TRANSACTION);
var isGetAccount = is(InteractionTag.GET_ACCOUNT);
var isGetEvents = is(InteractionTag.GET_EVENTS);
var isPing = is(InteractionTag.PING);
var isGetBlock = is(InteractionTag.GET_BLOCK);
var isGetBlockHeader = is(InteractionTag.GET_BLOCK_HEADER);
var isGetCollection = is(InteractionTag.GET_COLLECTION);
var isGetNetworkParameters = is(InteractionTag.GET_NETWORK_PARAMETERS);
var isGetNodeVersionInfo = is(InteractionTag.GET_NODE_VERSION_INFO);
var isSubscribeEvents = is(InteractionTag.SUBSCRIBE_EVENTS);
var isOk = (ix) => ix.status === InteractionStatus.OK;
var isBad = (ix) => ix.status === InteractionStatus.BAD;
var why = (ix) => ix.reason;
var isAccount = (account2) => account2.kind === InteractionResolverKind.ACCOUNT;
var isArgument = (argument) => argument.kind === InteractionResolverKind.ARGUMENT;
var hardMode = (ix) => {
  for (let key of Object.keys(ix)) {
    if (!KEYS.has(key)) throw new Error(`"${key}" is an invalid root level Interaction property.`);
  }
  return ix;
};
var recPipe = async function(ix) {
  let fns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  try {
    ix = hardMode(await ix);
    if (isBad(ix)) throw new Error(`Interaction Error: ${ix.reason}`);
    if (!fns.length) return ix;
    const [hd, ...rest] = fns;
    const cur = await hd;
    if (isFn$3(cur)) return recPipe(cur(ix), rest);
    if (isNull(cur) || !cur) return recPipe(ix, rest);
    if (isInteraction(cur)) return recPipe(cur, rest);
    throw new Error("Invalid Interaction Composition");
  } catch (e) {
    throw e;
  }
};
function pipe2() {
  for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args2[_key2] = arguments[_key2];
  }
  const [arg1, arg2] = args2;
  if (isArray$1(arg1)) return (d) => pipe2(d, arg1);
  const ix = arg1;
  const fns = arg2;
  return recPipe(ix, fns);
}
var identity$1 = function(v) {
  return v;
};
var get2 = (ix, key, fallback) => {
  return ix.assigns[key] == null ? fallback : ix.assigns[key];
};
var put2 = (key, value) => (ix) => {
  ix.assigns[key] = value;
  return Ok(ix);
};
var update2 = function(key) {
  let fn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : identity$1;
  return (ix) => {
    ix.assigns[key] = fn(ix.assigns[key], ix);
    return Ok(ix);
  };
};
var destroy = (key) => (ix) => {
  delete ix.assigns[key];
  return Ok(ix);
};
var ixModule = Object.freeze({
  __proto__: null,
  initInteraction,
  interaction,
  isNumber: isNumber$1,
  isArray: isArray$1,
  isObj,
  isNull,
  isFn: isFn$3,
  isInteraction,
  Ok,
  Bad,
  initAccount,
  prepAccount,
  makeArgument,
  makeUnknown,
  makeScript,
  makeTransaction,
  makeGetTransactionStatus,
  makeGetTransaction,
  makeGetAccount,
  makeGetEvents,
  makePing,
  makeGetBlock,
  makeGetBlockHeader,
  makeGetCollection,
  makeGetNetworkParameters,
  makeSubscribeEvents,
  makeGetNodeVerionInfo,
  isUnknown,
  isScript,
  isTransaction,
  isGetTransactionStatus,
  isGetTransaction,
  isGetAccount,
  isGetEvents,
  isPing,
  isGetBlock,
  isGetBlockHeader,
  isGetCollection,
  isGetNetworkParameters,
  isGetNodeVersionInfo,
  isSubscribeEvents,
  isOk,
  isBad,
  why,
  isAccount,
  isArgument,
  pipe: pipe2,
  get: get2,
  put: put2,
  update: update2,
  destroy
});
function build() {
  let fns = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return pipe2(initInteraction(), fns);
}
var DEFAULT_RESPONSE = {
  "tag": null,
  "transaction": null,
  "transactionStatus": null,
  "transactionId": null,
  "encodedData": null,
  "events": null,
  "account": null,
  "block": null,
  "blockHeader": null,
  "latestBlock": null,
  "collection": null,
  "networkParameters": null,
  "streamConnection": null,
  "heartbeat": null,
  "nodeVersionInfo": null
};
var response = () => ({
  ...DEFAULT_RESPONSE
});
function getBlock() {
  let isSealed2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  return pipe2([makeGetBlock, (ix) => {
    ix.block.isSealed = isSealed2;
    return Ok(ix);
  }]);
}
function getAccount(addr) {
  return pipe2([makeGetAccount, (ix) => {
    ix.account.addr = sansPrefix(addr);
    return Ok(ix);
  }]);
}
var decodeStream = (stream, decodeResponse2, customDecoders) => {
  const newStream = new import_events2.default();
  let queue = taskQueue();
  stream.on("data", async (data) => {
    const topics = Object.keys(data).filter((key) => data[key] != null && key !== "tag");
    let newDataPromise = Promise.all(topics.map(async (channel) => {
      const partialResponse = {
        [channel]: data[channel]
      };
      const message = await decodeResponse2(partialResponse, customDecoders);
      return {
        channel,
        message
      };
    }));
    queue.push(async () => {
      const newData = await newDataPromise;
      newData.forEach((_ref) => {
        let {
          channel,
          message
        } = _ref;
        newStream.emit(channel, message);
      });
    });
  });
  function relayEvent(event) {
    stream.on(event, (message) => {
      queue.push(async () => {
        newStream.emit(event, message);
      });
    });
  }
  relayEvent("close");
  relayEvent("error");
  return {
    on(channel, callback) {
      newStream.on(channel, callback);
      return this;
    },
    off(channel, callback) {
      newStream.off(channel, callback);
      return this;
    },
    close: () => {
      stream.close();
    }
  };
};
function taskQueue() {
  let queue = [];
  let running = false;
  async function run2() {
    if (running) return;
    running = true;
    while (queue.length > 0) {
      const task = queue.shift();
      await task?.();
    }
    running = false;
  }
  return {
    push: (task) => {
      queue.push(task);
      run2();
    }
  };
}
var latestBlockDeprecationNotice = () => {
  log.deprecate({
    pkg: "@onflow/decode",
    subject: "Operating upon data of the latestBlock field of the response object",
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
  });
};
var decodeImplicit = async (i) => i;
var decodeVoid = async () => null;
var decodeType = async (type) => {
  return type.staticType;
};
var decodePath = async (path) => {
  return {
    domain: path.domain,
    identifier: path.identifier
  };
};
var decodeCapability = async (cap) => {
  return {
    path: cap.path,
    address: cap.address,
    borrowType: cap.borrowType
  };
};
var decodeOptional = async (optional, decoders, stack) => optional ? await recurseDecode(optional, decoders, stack) : null;
var decodeReference = async (v) => ({
  address: v.address,
  type: v.type
});
var decodeArray = async (array, decoders, stack) => await Promise.all(array.map((v) => new Promise(async (res) => res(await recurseDecode(v, decoders, [...stack, v.type])))));
var decodeDictionary = async (dictionary, decoders, stack) => await dictionary.reduce(async (acc, v) => {
  acc = await acc;
  acc[await recurseDecode(v.key, decoders, [...stack, v.key])] = await recurseDecode(v.value, decoders, [...stack, v.key]);
  return acc;
}, Promise.resolve({}));
var decodeComposite = async (composite, decoders, stack) => {
  const decoded = await composite.fields.reduce(async (acc, v) => {
    acc = await acc;
    acc[v.name] = await recurseDecode(v.value, decoders, [...stack, v.name]);
    return acc;
  }, Promise.resolve({}));
  const decoder = composite.id && decoderLookup(decoders, composite.id);
  return decoder ? await decoder(decoded) : decoded;
};
var defaultDecoders = {
  UInt: decodeImplicit,
  Int: decodeImplicit,
  UInt8: decodeImplicit,
  Int8: decodeImplicit,
  UInt16: decodeImplicit,
  Int16: decodeImplicit,
  UInt32: decodeImplicit,
  Int32: decodeImplicit,
  UInt64: decodeImplicit,
  Int64: decodeImplicit,
  UInt128: decodeImplicit,
  Int128: decodeImplicit,
  UInt256: decodeImplicit,
  Int256: decodeImplicit,
  Word8: decodeImplicit,
  Word16: decodeImplicit,
  Word32: decodeImplicit,
  Word64: decodeImplicit,
  UFix64: decodeImplicit,
  Fix64: decodeImplicit,
  String: decodeImplicit,
  Character: decodeImplicit,
  Bool: decodeImplicit,
  Address: decodeImplicit,
  Void: decodeVoid,
  Optional: decodeOptional,
  Reference: decodeReference,
  Array: decodeArray,
  Dictionary: decodeDictionary,
  Event: decodeComposite,
  Resource: decodeComposite,
  Struct: decodeComposite,
  Enum: decodeComposite,
  Type: decodeType,
  Path: decodePath,
  Capability: decodeCapability
};
var decoderLookup = (decoders, lookup) => {
  const found = Object.keys(decoders).find((decoder) => {
    if (/^\/.*\/$/.test(decoder)) {
      const reg = new RegExp(decoder.substring(1, decoder.length - 1));
      return reg.test(lookup);
    }
    return decoder === lookup;
  });
  return lookup && found && decoders[found];
};
var recurseDecode = async (decodeInstructions, decoders, stack) => {
  let decoder = decoderLookup(decoders, decodeInstructions.type);
  if (!decoder) throw new Error(`Undefined Decoder Error: ${decodeInstructions.type}@${stack.join(".")}`);
  return await decoder(decodeInstructions.value, decoders, stack);
};
var decode$1 = async function(decodeInstructions) {
  let customDecoders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let stack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const filteredDecoders = Object.keys(defaultDecoders).filter((decoder) => !Object.keys(customDecoders).find((customDecoder) => new RegExp(customDecoder).test(decoder))).reduce((decoders2, decoderKey) => {
    decoders2[decoderKey] = defaultDecoders[decoderKey];
    return decoders2;
  }, customDecoders);
  const decoders = {
    ...filteredDecoders,
    ...customDecoders
  };
  return recurseDecode(decodeInstructions, decoders, stack);
};
var decodeResponse = async function(response2) {
  let customDecoders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (response2.encodedData) {
    return decode$1(response2.encodedData, customDecoders);
  } else if (response2.transactionStatus) {
    return {
      ...response2.transactionStatus,
      events: await Promise.all(response2.transactionStatus.events.map(async function decodeEvents(e) {
        return {
          type: e.type,
          transactionId: e.transactionId,
          transactionIndex: e.transactionIndex,
          eventIndex: e.eventIndex,
          data: await decode$1(e.payload, customDecoders)
        };
      }))
    };
  } else if (response2.transaction) {
    return response2.transaction;
  } else if (response2.events) {
    return await Promise.all(response2.events.map(async function decodeEvents(e) {
      return {
        blockId: e.blockId,
        blockHeight: e.blockHeight,
        blockTimestamp: e.blockTimestamp,
        type: e.type,
        transactionId: e.transactionId,
        transactionIndex: e.transactionIndex,
        eventIndex: e.eventIndex,
        data: await decode$1(e.payload, customDecoders)
      };
    }));
  } else if (response2.account) {
    return response2.account;
  } else if (response2.block) {
    return response2.block;
  } else if (response2.blockHeader) {
    return response2.blockHeader;
  } else if (response2.latestBlock) {
    latestBlockDeprecationNotice();
    return response2.latestBlock;
  } else if (response2.transactionId) {
    return response2.transactionId;
  } else if (response2.collection) {
    return response2.collection;
  } else if (response2.networkParameters) {
    const prefixRegex = /^flow-/;
    const rawChainId = response2.networkParameters.chainId;
    let formattedChainId;
    if (rawChainId === "flow-emulator") {
      formattedChainId = "local";
    } else if (prefixRegex.test(rawChainId)) {
      formattedChainId = rawChainId.replace(prefixRegex, "");
    } else {
      formattedChainId = rawChainId;
    }
    return {
      chainId: formattedChainId
    };
  } else if (response2.streamConnection) {
    return decodeStream(response2.streamConnection, decodeResponse, customDecoders);
  } else if (response2.heartbeat) {
    return response2.heartbeat;
  } else if (response2.nodeVersionInfo) {
    return response2.nodeVersionInfo;
  }
  return null;
};
var isFn$2 = (v) => typeof v === "function";
var isString$1 = (v) => typeof v === "string";
var oldIdentifierPatternFn = () => /\b(0x\w+)\b/g;
function isOldIdentifierSyntax(cadence) {
  return oldIdentifierPatternFn().test(cadence);
}
var newIdentifierPatternFn = () => /import\s+"(\w+)"/g;
function isNewIdentifierSyntax(cadence) {
  return newIdentifierPatternFn().test(cadence);
}
function getContractIdentifierSyntaxMatches(cadence) {
  return cadence.matchAll(newIdentifierPatternFn());
}
async function resolveCadence(ix) {
  if (!isTransaction(ix) && !isScript(ix)) return ix;
  var cadence = get2(ix, "ix.cadence");
  invariant(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");
  if (isFn$2(cadence)) cadence = await cadence({});
  invariant(isString$1(cadence), "Cadence needs to be a string at this point.");
  invariant(!isOldIdentifierSyntax(cadence) || !isNewIdentifierSyntax(cadence), "Both account identifier and contract identifier syntax not simultaneously supported.");
  if (isOldIdentifierSyntax(cadence)) {
    cadence = await config2().where(/^0x/).then((d) => Object.entries(d).reduce((cadence2, _ref) => {
      let [key, value] = _ref;
      const regex = new RegExp("(\\b" + key + "\\b)", "g");
      return cadence2.replace(regex, value);
    }, cadence));
  }
  if (isNewIdentifierSyntax(cadence)) {
    for (const [fullMatch, contractName] of getContractIdentifierSyntaxMatches(cadence)) {
      const address = await config2().get(`system.contracts.${contractName}`);
      if (address) {
        cadence = cadence.replace(fullMatch, `import ${contractName} from ${withPrefix2(address)}`);
      } else {
        log({
          title: "Contract Placeholder not found",
          message: `Cannot find a value for contract placeholder ${contractName}. Please add to your flow.json or explicitly add it to the config 'contracts.*' namespace.`,
          level: LEVELS.warn
        });
      }
    }
  }
  ix.message.cadence = cadence;
  return ix;
}
var isFn$1 = (v) => typeof v === "function";
function cast(arg2) {
  invariant(typeof arg2.xform != null, `No type specified for argument: ${arg2.value}`);
  if (isFn$1(arg2.xform)) return arg2.xform(arg2.value);
  if (isFn$1(arg2.xform.asArgument)) return arg2.xform.asArgument(arg2.value);
  invariant(false, `Invalid Argument`, arg2);
}
async function handleArgResolution(arg2) {
  let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  invariant(depth > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${arg2.tempId}`);
  if (isFn$1(arg2.resolveArgument)) {
    const resolvedArg = await arg2.resolveArgument();
    return handleArgResolution(resolvedArg, depth - 1);
  } else {
    return arg2;
  }
}
async function resolveArguments(ix) {
  if (isTransaction(ix) || isScript(ix)) {
    for (let [id, arg2] of Object.entries(ix.arguments)) {
      const res = await handleArgResolution(arg2);
      ix.arguments[id].asArgument = cast(res);
    }
  }
  return ix;
}
var encodeTransactionPayload = (tx) => prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
var encodeTransactionEnvelope = (tx) => prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
var rightPaddedHexBuffer = (value, pad) => import_buffer2.Buffer.from(value.padEnd(pad * 2, "0"), "hex");
var leftPaddedHexBuffer = (value, pad) => import_buffer2.Buffer.from(value.padStart(pad * 2, "0"), "hex");
var TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(import_buffer2.Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");
var prependTransactionDomainTag = (tx) => TRANSACTION_DOMAIN_TAG + tx;
var addressBuffer = (addr) => leftPaddedHexBuffer(addr, 8);
var blockBuffer = (block2) => leftPaddedHexBuffer(block2, 32);
var argumentToString = (arg2) => import_buffer2.Buffer.from(JSON.stringify(arg2), "utf8");
var scriptBuffer = (script2) => import_buffer2.Buffer.from(script2, "utf8");
var signatureBuffer = (signature) => import_buffer2.Buffer.from(signature, "hex");
var rlpEncode = (v) => {
  return encode(v).toString("hex");
};
var preparePayload = (tx) => {
  validatePayload(tx);
  return [scriptBuffer(tx.cadence || ""), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock || ""), tx.computeLimit, addressBuffer(sansPrefix(tx.proposalKey.address || "")), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(sansPrefix(tx.payer)), tx.authorizers.map((authorizer) => addressBuffer(sansPrefix(authorizer)))];
};
var prepareEnvelope = (tx) => {
  validateEnvelope(tx);
  return [preparePayload(tx), preparePayloadSignatures(tx)];
};
var preparePayloadSignatures = (tx) => {
  const signers = collectSigners(tx);
  return tx.payloadSigs?.map((sig2) => {
    return {
      signerIndex: signers.get(sig2.address) || "",
      keyId: sig2.keyId,
      sig: sig2.sig
    };
  }).sort((a, b) => {
    if (a.signerIndex > b.signerIndex) return 1;
    if (a.signerIndex < b.signerIndex) return -1;
    if (a.keyId > b.keyId) return 1;
    if (a.keyId < b.keyId) return -1;
    return 0;
  }).map((sig2) => {
    return [sig2.signerIndex, sig2.keyId, signatureBuffer(sig2.sig)];
  });
};
var collectSigners = (tx) => {
  const signers = /* @__PURE__ */ new Map();
  let i = 0;
  const addSigner = (addr) => {
    if (!signers.has(addr)) {
      signers.set(addr, i);
      i++;
    }
  };
  if (tx.proposalKey.address) {
    addSigner(tx.proposalKey.address);
  }
  addSigner(tx.payer);
  tx.authorizers.forEach(addSigner);
  return signers;
};
var validatePayload = (tx) => {
  payloadFields.forEach((field) => checkField(tx, field));
  proposalKeyFields.forEach((field) => checkField(tx.proposalKey, field, "proposalKey"));
};
var validateEnvelope = (tx) => {
  payloadSigsFields.forEach((field) => checkField(tx, field));
  tx.payloadSigs?.forEach((sig2, index3) => {
    payloadSigFields.forEach((field) => checkField(sig2, field, "payloadSigs", index3));
  });
};
var isNumber = (v) => typeof v === "number";
var isString = (v) => typeof v === "string";
var isObject2 = (v) => v !== null && typeof v === "object";
var isArray = (v) => isObject2(v) && v instanceof Array;
var payloadFields = [{
  name: "cadence",
  check: isString
}, {
  name: "arguments",
  check: isArray
}, {
  name: "refBlock",
  check: isString,
  defaultVal: "0"
}, {
  name: "computeLimit",
  check: isNumber
}, {
  name: "proposalKey",
  check: isObject2
}, {
  name: "payer",
  check: isString
}, {
  name: "authorizers",
  check: isArray
}];
var proposalKeyFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sequenceNum",
  check: isNumber
}];
var payloadSigsFields = [{
  name: "payloadSigs",
  check: isArray
}];
var payloadSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
var checkField = (obj, field, base, index3) => {
  const {
    name,
    check,
    defaultVal
  } = field;
  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
  if (obj[name] == null) throw missingFieldError(name, base, index3);
  if (!check(obj[name])) throw invalidFieldError(name, base, index3);
};
var printFieldName = (field, base, index3) => {
  if (!!base) return index3 == null ? `${base}.${field}` : `${base}.${index3}.${field}`;
  return field;
};
var missingFieldError = (field, base, index3) => new Error(`Missing field ${printFieldName(field, base, index3)}`);
var invalidFieldError = (field, base, index3) => new Error(`Invalid field ${printFieldName(field, base, index3)}`);
function findInsideSigners(ix) {
  let inside = new Set(ix.authorizations);
  if (ix.proposer) {
    inside.add(ix.proposer);
  }
  if (Array.isArray(ix.payer)) {
    ix.payer.forEach((p) => inside.delete(p));
  } else {
    inside.delete(ix.payer);
  }
  return Array.from(inside);
}
function findOutsideSigners(ix) {
  let outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
  return Array.from(outside);
}
var createSignableVoucher = (ix) => {
  const buildAuthorizers = () => {
    const authorizations2 = ix.authorizations.map((cid) => withPrefix2(ix.accounts[cid].addr)).reduce((prev, current) => {
      return prev.find((item) => item === current) ? prev : [...prev, current];
    }, []);
    return authorizations2?.[0] ? authorizations2 : [];
  };
  const buildInsideSigners = () => findInsideSigners(ix).map((id) => ({
    address: withPrefix2(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));
  const buildOutsideSigners = () => findOutsideSigners(ix).map((id) => ({
    address: withPrefix2(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));
  const proposalKey = ix.proposer ? {
    address: withPrefix2(ix.accounts[ix.proposer].addr),
    keyId: ix.accounts[ix.proposer].keyId,
    sequenceNum: ix.accounts[ix.proposer].sequenceNum
  } : {};
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map((id) => ix.arguments[id].asArgument),
    proposalKey,
    payer: withPrefix2(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
    authorizers: buildAuthorizers(),
    payloadSigs: buildInsideSigners(),
    envelopeSigs: buildOutsideSigners()
  };
};
var MAX_DEPTH_LIMIT = 5;
var idof$1 = (acct) => `${withPrefix2(acct.addr)}-${acct.keyId}`;
var isFn = (v) => v && (Object.prototype.toString.call(v) === "[object Function]" || "function" === typeof v || v instanceof Function);
var genAccountId = function() {
  for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
    ids[_key] = arguments[_key];
  }
  return ids.join("-");
};
var ROLES = (function(ROLES2) {
  ROLES2["PAYER"] = "payer";
  ROLES2["PROPOSER"] = "proposer";
  ROLES2["AUTHORIZATIONS"] = "authorizations";
  return ROLES2;
})(ROLES || {});
function debug$1() {
  const SPACE = " ";
  const SPACE_COUNT_PER_INDENT = 4;
  const DEBUG_MESSAGE = [];
  return [function() {
    let msg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    DEBUG_MESSAGE.push(Array(indent * SPACE_COUNT_PER_INDENT).fill(SPACE).join("-") + msg);
  }, function() {
    return DEBUG_MESSAGE.reduce((prev, curr) => prev + "\n" + curr);
  }];
}
function recurseFlatMap(el) {
  let depthLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  if (depthLimit <= 0) return el;
  if (!Array.isArray(el)) return el;
  return recurseFlatMap(el.flatMap((e) => e), depthLimit - 1);
}
function buildPreSignable(acct, ix) {
  try {
    return {
      f_type: "PreSignable",
      f_vsn: "1.0.1",
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map((d) => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildPreSignable", error);
    throw error;
  }
}
async function removeUnusedIxAccounts(ix, opts) {
  const payerTempIds = Array.isArray(ix.payer) ? ix.payer : [ix.payer];
  const authorizersTempIds = Array.isArray(ix.authorizations) ? ix.authorizations : [ix.authorizations];
  const proposerTempIds = ix.proposer === null ? [] : Array.isArray(ix.proposer) ? ix.proposer : [ix.proposer];
  const ixAccountKeys = Object.keys(ix.accounts);
  const uniqueTempIds = [...new Set(payerTempIds.concat(authorizersTempIds, proposerTempIds))];
  for (const ixAccountKey of ixAccountKeys) {
    if (!uniqueTempIds.find((id) => id === ixAccountKey)) {
      delete ix.accounts[ixAccountKey];
    }
  }
}
function addAccountToIx(ix, newAccount) {
  if (typeof newAccount.addr === "string" && (typeof newAccount.keyId === "number" || typeof newAccount.keyId === "string")) {
    newAccount.tempId = idof$1(newAccount);
  } else {
    newAccount.tempId = newAccount.tempId || v4_default();
  }
  const existingAccount = ix.accounts[newAccount.tempId] || newAccount;
  if (!ix.accounts[newAccount.tempId]) {
    ix.accounts[newAccount.tempId] = newAccount;
  }
  ix.accounts[newAccount.tempId].role.proposer = existingAccount.role.proposer || newAccount.role.proposer;
  ix.accounts[newAccount.tempId].role.payer = existingAccount.role.payer || newAccount.role.payer;
  ix.accounts[newAccount.tempId].role.authorizer = existingAccount.role.authorizer || newAccount.role.authorizer;
  return ix.accounts[newAccount.tempId];
}
function uniqueAccountsFlatMap(accounts) {
  const flatMapped = recurseFlatMap(accounts);
  const seen = /* @__PURE__ */ new Set();
  const uniqueAccountsFlatMapped = flatMapped.map((account2) => {
    const accountId = genAccountId(account2.tempId, account2.role.payer, account2.role.proposer, account2.role.authorizer, account2.role.param);
    if (seen.has(accountId)) return null;
    seen.add(accountId);
    return account2;
  }).filter((e) => e !== null);
  return uniqueAccountsFlatMapped;
}
async function recurseResolveAccount(ix, currentAccountTempId) {
  let depthLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : MAX_DEPTH_LIMIT;
  let {
    debugLogger
  } = arguments.length > 3 ? arguments[3] : void 0;
  if (depthLimit <= 0) {
    throw new Error(`recurseResolveAccount Error: Depth limit (${MAX_DEPTH_LIMIT}) reached. Ensure your authorization functions resolve to an account after ${MAX_DEPTH_LIMIT} resolves.`);
  }
  let account2 = ix.accounts[currentAccountTempId];
  if (!account2) return null;
  debugLogger(`account: ${account2.tempId}`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
  if (account2?.resolve) {
    if (isFn(account2?.resolve)) {
      debugLogger(`account: ${account2.tempId} -- cache MISS`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
      const {
        resolve: resolve2,
        ...accountWithoutResolve
      } = account2;
      let resolvedAccounts = await resolve2(accountWithoutResolve, buildPreSignable(accountWithoutResolve, ix));
      resolvedAccounts = Array.isArray(resolvedAccounts) ? resolvedAccounts : [resolvedAccounts];
      let flatResolvedAccounts = recurseFlatMap(resolvedAccounts);
      flatResolvedAccounts = flatResolvedAccounts.map((flatResolvedAccount) => addAccountToIx(ix, flatResolvedAccount));
      account2.resolve = flatResolvedAccounts.map((flatResolvedAccount) => flatResolvedAccount.tempId);
      account2 = addAccountToIx(ix, account2);
      const recursedAccounts = await Promise.all(flatResolvedAccounts.map(async (resolvedAccount) => {
        return await recurseResolveAccount(ix, resolvedAccount.tempId, depthLimit - 1, {
          debugLogger
        });
      }));
      return recursedAccounts ? recurseFlatMap(recursedAccounts) : account2.tempId;
    } else {
      debugLogger(`account: ${account2.tempId} -- cache HIT`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
      return account2.resolve;
    }
  }
  return account2.tempId;
}
var getAccountTempIDs = (rawTempIds) => {
  if (rawTempIds === null) {
    return [];
  }
  return Array.isArray(rawTempIds) ? rawTempIds : [rawTempIds];
};
async function resolveAccountType(ix, type, _ref) {
  let {
    debugLogger
  } = _ref;
  invariant(ix && typeof ix === "object", "resolveAccountType Error: ix not defined");
  invariant(type === ROLES.PAYER || type === ROLES.PROPOSER || type === ROLES.AUTHORIZATIONS, "resolveAccountType Error: type must be 'payer', 'proposer' or 'authorizations'");
  let accountTempIDs = getAccountTempIDs(ix[type]);
  let allResolvedAccounts = [];
  for (let accountId of accountTempIDs) {
    let account2 = ix.accounts[accountId];
    invariant(Boolean(account2), `resolveAccountType Error: account not found`);
    let resolvedAccountTempIds = await recurseResolveAccount(ix, accountId, MAX_DEPTH_LIMIT, {
      debugLogger
    });
    resolvedAccountTempIds = Array.isArray(resolvedAccountTempIds) ? resolvedAccountTempIds : [resolvedAccountTempIds];
    let resolvedAccounts = resolvedAccountTempIds.map((resolvedAccountTempId) => ix.accounts[resolvedAccountTempId]);
    let flatResolvedAccounts = uniqueAccountsFlatMap(resolvedAccounts);
    allResolvedAccounts = allResolvedAccounts.concat(flatResolvedAccounts);
  }
  invariant(allResolvedAccounts.length > 0, "resolveAccountType Error: failed to resolve any accounts");
  if (type === ROLES.PAYER) {
    allResolvedAccounts = allResolvedAccounts.filter((acct) => acct.role.payer === true);
  }
  if (type === ROLES.PROPOSER) {
    allResolvedAccounts = allResolvedAccounts.filter((acct) => acct.role.proposer === true);
  }
  if (type === ROLES.AUTHORIZATIONS) {
    allResolvedAccounts = allResolvedAccounts.filter((acct) => acct.role.authorizer === true);
  }
  ix[type] = Array.isArray(ix[type]) ? [...new Set(allResolvedAccounts.map((acct) => acct.tempId))] : allResolvedAccounts[0].tempId;
  if (type === ROLES.PAYER) {
    let address;
    for (const payerTempID of ix[ROLES.PAYER]) {
      let pAcct = ix.accounts[payerTempID];
      if (!address) address = pAcct.addr;
      else if (address !== pAcct.addr) {
        throw new Error("resolveAccountType Error: payers from different accounts detected");
      }
    }
  }
}
async function resolveAccounts(ix) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (isTransaction(ix)) {
    if (!Array.isArray(ix.payer)) {
      log.deprecate({
        pkg: "FCL",
        subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
        message: "See changelog for more info."
      });
    }
    let [debugLogger, getDebugMessage] = debug$1();
    try {
      await resolveAccountType(ix, ROLES.PROPOSER, {
        debugLogger
      });
      await resolveAccountType(ix, ROLES.AUTHORIZATIONS, {
        debugLogger
      });
      await resolveAccountType(ix, ROLES.PAYER, {
        debugLogger
      });
      await removeUnusedIxAccounts(ix, {
        debugLogger
      });
      if (opts.enableDebug) {
        console.debug(getDebugMessage());
      }
    } catch (error) {
      console.error("=== SAD PANDA ===\n\n", error, "\n\n=== SAD PANDA ===");
      throw error;
    }
  }
  return ix;
}
async function resolveSignatures(ix) {
  if (isTransaction(ix)) {
    try {
      let insideSigners = findInsideSigners(ix);
      const insidePayload = encodeTransactionPayload(prepForEncoding(ix));
      await Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));
      let outsideSigners = findOutsideSigners(ix);
      const outsidePayload = encodeTransactionEnvelope({
        ...prepForEncoding(ix),
        payloadSigs: insideSigners.map((id) => ({
          address: ix.accounts[id].addr || "",
          keyId: ix.accounts[id].keyId || 0,
          sig: ix.accounts[id].signature || ""
        }))
      });
      await Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));
    } catch (error) {
      console.error("Signatures", error, {
        ix
      });
      throw error;
    }
  }
  return ix;
}
function fetchSignature(ix, payload) {
  return async function innerFetchSignature(id) {
    const acct = ix.accounts[id];
    if (acct.signature != null && acct.signature !== void 0) return;
    const {
      signature
    } = await acct.signingFunction(buildSignable(acct, payload, ix));
    ix.accounts[id].signature = signature;
  };
}
function buildSignable(acct, message, ix) {
  try {
    return {
      f_type: "Signable",
      f_vsn: "1.0.1",
      message,
      addr: sansPrefix(acct.addr),
      keyId: acct.keyId,
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map((d) => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildSignable", error);
    throw error;
  }
}
function prepForEncoding(ix) {
  const payerAddress = sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr || "");
  const proposalKey = ix.proposer ? {
    address: sansPrefix(ix.accounts[ix.proposer].addr) || "",
    keyId: ix.accounts[ix.proposer].keyId || 0,
    sequenceNum: ix.accounts[ix.proposer].sequenceNum || 0
  } : {};
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map((id) => ix.arguments[id].asArgument),
    proposalKey,
    payer: payerAddress,
    authorizers: ix.authorizations.map((cid) => sansPrefix(ix.accounts[cid].addr) || "").reduce((prev, current) => {
      return prev.find((item) => item === current) ? prev : [...prev, current];
    }, [])
  };
}
async function resolveValidators(ix) {
  const validators = get2(ix, "ix.validators", []);
  return pipe2(ix, validators.map((cb) => (ix2) => cb(ix2, {
    Ok,
    Bad
  })));
}
async function resolveFinalNormalization(ix) {
  for (let key of Object.keys(ix.accounts)) {
    ix.accounts[key].addr = sansPrefix(ix.accounts[key].addr);
  }
  return ix;
}
async function resolveVoucherIntercept(ix) {
  const fn = get2(ix, "ix.voucher-intercept");
  if (isFn$3(fn)) {
    await fn(createSignableVoucher(ix));
  }
  return ix;
}
var DEFAULT_COMPUTE_LIMIT = 100;
async function resolveComputeLimit(ix) {
  if (isTransaction(ix)) {
    ix.message.computeLimit = ix.message.computeLimit || await config2.get("fcl.limit");
    if (!ix.message.computeLimit) {
      log.deprecate({
        pkg: "FCL/SDK",
        subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
      });
      ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;
    }
  }
  return ix;
}
var noop = (v) => v;
var debug = function(key) {
  let fn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
  return async (ix) => {
    const accts = (ix2) => ["\nAccounts:", {
      proposer: ix2.proposer,
      authorizations: ix2.authorizations,
      payer: ix2.payer
    }, "\n\nDetails:", ix2.accounts].filter(Boolean);
    const log2 = function() {
      for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
        msg[_key] = arguments[_key];
      }
      console.log(`debug[${key}] ---
`, ...msg, "\n\n\n---");
    };
    if (await config2.get(`debug.${key}`)) await fn(ix, log2, accts);
    return ix;
  };
};
var resolve = pipe2([
  resolveCadence,
  debug("cadence", (ix, log2) => log2(ix.message.cadence)),
  resolveComputeLimit,
  debug("compute limit", (ix, log2) => log2(ix.message.computeLimit)),
  resolveArguments,
  debug("arguments", (ix, log2) => log2(ix.message.arguments, ix.message)),
  resolveAccounts,
  debug("accounts", (ix, log2, accts) => log2(...accts(ix))),
  /* special */
  execFetchRef,
  /* special */
  execFetchSequenceNumber,
  resolveSignatures,
  debug("signatures", (ix, log2, accts) => log2(...accts(ix))),
  resolveFinalNormalization,
  resolveValidators,
  resolveVoucherIntercept,
  debug("resolved", (ix, log2) => log2(ix))
]);
async function execFetchRef(ix) {
  if (isTransaction(ix) && ix.message.refBlock == null) {
    const node = await config2().get("accessNode.api");
    const sendFn = await config2.first(["sdk.transport", "sdk.send"], send2);
    invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    ix.message.refBlock = (await sendFn(build([getBlock()]), {
      config: config2,
      response,
      Buffer: import_buffer2.Buffer,
      ix: ixModule
    }, {
      node
    }).then(decodeResponse)).id;
  }
  return ix;
}
async function execFetchSequenceNumber(ix) {
  if (isTransaction(ix)) {
    var acct = Object.values(ix.accounts).find((a) => a.role.proposer);
    invariant(acct, `Transactions require a proposer`);
    if (acct.sequenceNum == null) {
      const node = await config2().get("accessNode.api");
      const sendFn = await config2.first(["sdk.transport", "sdk.send"], send2);
      invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
      ix.accounts[acct.tempId].sequenceNum = await sendFn(await build([getAccount(acct.addr)]), {
        config: config2,
        response,
        Buffer: import_buffer2.Buffer,
        ix: ixModule
      }, {
        node
      }).then(decodeResponse).then((acct2) => acct2.keys).then((keys) => keys.find((key) => key.index === acct.keyId)).then((key) => key.sequenceNumber);
    }
  }
  return ix;
}
function invariant2() {
  for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
    args2[_key] = arguments[_key];
  }
  if (args2.length > 1) {
    const [predicate, message] = args2;
    return invariant2((ix, _ref) => {
      let {
        Ok: Ok2,
        Bad: Bad2
      } = _ref;
      return predicate ? Ok2(ix) : Bad2(ix, message);
    });
  }
  const [fn] = args2;
  return (ix) => fn(ix, {
    Ok,
    Bad
  });
}
var send3 = async function() {
  let args2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const sendFn = await config2.first(["sdk.transport", "sdk.send"], opts.send || send2);
  invariant2(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
  const resolveFn = await config2.first(["sdk.resolve"], opts.resolve || resolve);
  opts.node = opts.node || await config2().get("accessNode.api");
  if (Array.isArray(args2)) args2 = pipe2(initInteraction(), args2);
  return sendFn(await resolveFn(args2), {
    config: config2,
    response,
    ix: ixModule,
    Buffer: import_buffer2.Buffer
  }, opts);
};
async function decode(response2) {
  const decodersFromConfig = await config2().where(/^decoder\./);
  const decoders = Object.entries(decodersFromConfig).map((_ref) => {
    let [pattern, xform] = _ref;
    pattern = `/${pattern.replace(/^decoder\./, "")}$/`;
    return [pattern, xform];
  });
  return decodeResponse(response2, Object.fromEntries(decoders));
}
var findPayloadSigners = (voucher) => {
  let payload = new Set(voucher.authorizers);
  payload.add(voucher.proposalKey.address);
  payload.delete(voucher.payer);
  return Array.from(payload).map(withPrefix2);
};
var findEnvelopeSigners = (voucher) => {
  let envelope = /* @__PURE__ */ new Set([voucher.payer]);
  return Array.from(envelope).map(withPrefix2);
};
var UnableToDetermineMessageEncodingTypeForSignerAddress = class extends Error {
  constructor(signerAddress) {
    const msg = `
        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${signerAddress}. 
        Please ensure the address: ${signerAddress} is intended to sign the given transaction as specified by the transaction signable.
      `.trim();
    super(msg);
    this.name = "Unable To Determine Message Encoding For Signer Addresss";
  }
};
var encodeMessageFromSignable = (signable, signerAddress) => {
  let payloadSigners = findPayloadSigners(signable.voucher);
  let envelopeSigners = findEnvelopeSigners(signable.voucher);
  const isPayloadSigner = payloadSigners.includes(withPrefix2(signerAddress));
  const isEnvelopeSigner = envelopeSigners.includes(withPrefix2(signerAddress));
  if (!isPayloadSigner && !isEnvelopeSigner) {
    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
  }
  const message = {
    cadence: signable.voucher.cadence,
    refBlock: signable.voucher.refBlock,
    computeLimit: signable.voucher.computeLimit,
    arguments: signable.voucher.arguments,
    proposalKey: {
      ...signable.voucher.proposalKey,
      address: sansPrefix(signable.voucher.proposalKey.address)
    },
    payer: sansPrefix(signable.voucher.payer),
    authorizers: signable.voucher.authorizers.map(sansPrefix),
    payloadSigs: signable.voucher.payloadSigs.map((ps) => ({
      ...ps,
      address: sansPrefix(ps.address)
    }))
  };
  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
};
function validator(cb) {
  return update2("ix.validators", (validators) => Array.isArray(validators) ? validators.push(cb) : [cb]);
}
function atBlockHeight(height) {
  return pipe2([(ix) => {
    ix.block.height = height;
    return ix;
  }, validator((ix) => {
    if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
    if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
    return ix;
  })]);
}
function atBlockId(id) {
  return pipe2([(ix) => {
    ix.block.id = id;
    return Ok(ix);
  }, validator((ix, _ref) => {
    let {
      Ok: Ok2,
      Bad: Bad2
    } = _ref;
    if (isGetAccount(ix)) return Bad2(ix, "Unable to specify a block id with a Get Account interaction.");
    if (typeof ix.block.isSealed === "boolean") return Bad2(ix, "Unable to specify both block id and isSealed.");
    if (ix.block.height) return Bad2(ix, "Unable to specify both block id and block height.");
    return Ok2(ix);
  })]);
}
function block() {
  let {
    sealed = false,
    id,
    height
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  invariant(!(sealed && id || sealed && height), `Method: block -- Cannot pass "sealed" with "id" or "height"`);
  invariant(!(id && height), `Method: block -- Cannot pass "id" and "height" simultaneously`);
  if (id) return send3([getBlock(), atBlockId(id)], opts).then(decodeResponse);
  if (height) return send3([getBlock(), atBlockHeight(height)], opts).then(decodeResponse);
  return send3([getBlock(sealed)], opts).then(decodeResponse);
}
function authorizations() {
  let ax = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return pipe2(ax.map((authz2) => {
    return prepAccount(authz2, {
      role: TransactionRole.AUTHORIZER
    });
  }));
}
function getEventsAtBlockHeightRange(eventName, fromBlockHeight, toBlockHeight) {
  return pipe2([makeGetEvents, (ix) => {
    ix.events.eventType = eventName;
    ix.events.start = fromBlockHeight;
    ix.events.end = toBlockHeight;
    return Ok(ix);
  }]);
}
function getTransactionStatus(transactionId) {
  return pipe2([makeGetTransactionStatus, (ix) => {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}
function getNetworkParameters() {
  return pipe2([makeGetNetworkParameters, (ix) => {
    return Ok(ix);
  }]);
}
function limit(computeLimit) {
  return (ix) => {
    ix.message.computeLimit = computeLimit;
    return ix;
  };
}
function args(ax) {
  return pipe2(ax.map(makeArgument));
}
function arg(value, xform) {
  return {
    value,
    xform
  };
}
function proposer(authz2) {
  return prepAccount(authz2, {
    role: TransactionRole.PROPOSER
  });
}
function payer() {
  let ax = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  if (!Array.isArray(ax)) ax = [ax];
  return pipe2(ax.map((authz2) => {
    return prepAccount(authz2, {
      role: TransactionRole.PAYER
    });
  }));
}
function ref(refBlock) {
  return pipe2([(ix) => {
    ix.message.refBlock = refBlock;
    return Ok(ix);
  }]);
}
function script() {
  return pipe2([makeScript, put2("ix.cadence", template(...arguments))]);
}
var DEFAULT_SCRIPT_ACCOUNTS = [];
var DEFUALT_REF = null;
function transaction() {
  return pipe2([makeTransaction, put2("ix.cadence", template(...arguments)), (ix) => {
    ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;
    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
    return Ok(ix);
  }]);
}
function mockAccountResponse(ix) {
  let numberOfKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  invariant(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix);
  invariant(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
  const address = ix.account.addr;
  return {
    account: {
      addr: address,
      keys: Array.from({
        length: numberOfKeys
      }, (_2, i) => ({
        index: i,
        sequenceNumber: 42
      }))
    }
  };
}
function mockGetBlockResponse(ix) {
  return {
    tag: "GET_BLOCK",
    block: {
      id: "32"
    }
  };
}
var identity2 = (v) => v;
function mockSend() {
  let fallback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : identity2;
  return async function execSend(ix) {
    ix = await ix;
    switch (true) {
      case isGetAccount(ix):
        return mockAccountResponse(ix);
      case isGetBlock(ix):
        return mockGetBlockResponse();
      default:
        return fallback(ix);
    }
  };
}
var idof2 = (acct) => `${withPrefix2(acct.addr)}-${acct.keyId}`;
function sig(opts) {
  return ["SIGNATURE", opts.addr, opts.keyId].join(".");
}
function authzFn() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return function(account2) {
    const acct = {
      ...account2,
      ...opts,
      resolve: null,
      signingFunction: opts.signingFunction || account2.signingFunction || fallbackSigningFunction
    };
    return acct;
    function fallbackSigningFunction(_signable) {
      return {
        addr: acct.addr,
        keyId: acct.keyId,
        signature: sig(acct)
      };
    }
  };
}
function authzResolve() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return function(account2) {
    const {
      tempId,
      ...rest
    } = opts;
    return {
      ...account2,
      tempId: tempId || "WITH_RESOLVE",
      resolve: authzFn(rest)
    };
  };
}
var ROLE = {
  proposer: false,
  authorizer: false,
  payer: false
};
function authzResolveMany() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    authorizations: []
  };
  return function(account2) {
    const tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
    return {
      ...account2,
      tempId,
      resolve: () => [opts.proposer && authzFn(opts.proposer)({
        role: {
          ...ROLE,
          proposer: true
        }
      }), ...opts.authorizations.map(authzFn).map((d) => d({
        role: {
          ...ROLE,
          authorizer: true
        }
      })), opts.payer && authzFn(opts.payer)({
        role: {
          ...ROLE,
          payer: true
        }
      })].filter(Boolean)
    };
  };
}
function authzDeepResolveMany() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    authorizations: []
  };
  let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return function(account2) {
    const tempId = opts.tempId || "AUTHZ_DEEP_RESOLVE_MANY";
    return {
      ...account2,
      tempId,
      resolve: depth > 0 ? authzDeepResolveMany(opts, depth - 1)(account2).resolve : authzResolveMany(opts)(account2).resolve
    };
  };
}
var run = function() {
  let fns = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return build([ref("123"), ...fns]).then(resolve);
};
var index = Object.freeze({
  __proto__: null,
  mockSend,
  authzFn,
  authzResolve,
  authzResolveMany,
  authzDeepResolveMany,
  sig,
  idof: idof2,
  run
});

// node_modules/@onflow/types/dist/types.module.js
var types_module_exports = {};
__export(types_module_exports, {
  Address: () => Address,
  Array: () => _Array,
  Bool: () => Bool,
  Character: () => Character,
  Dictionary: () => Dictionary,
  Enum: () => Enum,
  Event: () => Event,
  Fix64: () => Fix64,
  Identity: () => Identity,
  Int: () => Int,
  Int128: () => Int128,
  Int16: () => Int16,
  Int256: () => Int256,
  Int32: () => Int32,
  Int64: () => Int64,
  Int8: () => Int8,
  Optional: () => Optional,
  Path: () => Path,
  Reference: () => Reference,
  Resource: () => Resource,
  String: () => String2,
  Struct: () => Struct,
  UFix64: () => UFix64,
  UInt: () => UInt,
  UInt128: () => UInt128,
  UInt16: () => UInt16,
  UInt256: () => UInt256,
  UInt32: () => UInt32,
  UInt64: () => UInt64,
  UInt8: () => UInt8,
  Void: () => Void,
  Word16: () => Word16,
  Word32: () => Word32,
  Word64: () => Word64,
  Word8: () => Word8,
  _Array: () => _Array
});
var typedef = (label, asArgument, asInjection) => ({
  label,
  asArgument,
  asInjection: (x) => {
    log.deprecate({
      pkg: "@onflow/types",
      subject: `Passing in ${label} as value for ${label}`,
      message: `Going forward, use ${label} as value for ${label}.`
    });
    return asInjection(x);
  }
});
var isArray2 = (d) => Array.isArray(d);
var isObj2 = (d) => typeof d === "object";
var isNull2 = (d) => d == null;
var isBoolean = (d) => typeof d === "boolean";
var isNumber2 = (d) => typeof d === "number";
var isInteger = (d) => Number.isInteger(d);
var isString2 = (d) => typeof d === "string";
var throwTypeError = (msg) => {
  throw new Error("Type Error: " + msg);
};
var numberValuesDeprecationNotice = (type) => {
  log.deprecate({
    pkg: "@onflow/types",
    subject: `Passing in Number as value for ${type}`,
    message: `Going forward, use String as value for ${type}.`,
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number"
  });
};
var identityDeprecationShown = false;
var Identity = {
  label: "Identity",
  asArgument: (v) => {
    if (!identityDeprecationShown) {
      log.deprecate({
        pkg: "@onflow/types",
        subject: "Identity",
        message: "Identity type is deprecated and will be removed in v2.0.0.  Please remove it from your code."
      });
      identityDeprecationShown = true;
    }
    return v;
  },
  asInjection: (v) => v
};
var UInt = typedef("UInt", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("UInt");
    return {
      type: "UInt",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "UInt",
      value: v
    };
  }
  return throwTypeError("Expected Positive Integer for type Unsigned Int");
}, (v) => v);
var Int = typedef("Int", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Int");
    return {
      type: "Int",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Int",
      value: v
    };
  }
  return throwTypeError("Expected Integer for type Int");
}, (v) => v);
var UInt8 = typedef("UInt8", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("UInt8");
    return {
      type: "UInt8",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "UInt8",
      value: v
    };
  }
  return throwTypeError("Expected integer for UInt8");
}, (v) => v);
var Int8 = typedef("Int8", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Int8");
    return {
      type: "Int8",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Int8",
      value: v
    };
  }
  return throwTypeError("Expected positive integer for Int8");
}, (v) => v);
var UInt16 = typedef("UInt16", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("UInt16");
    return {
      type: "UInt16",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "UInt16",
      value: v
    };
  }
  return throwTypeError("Expected integer for UInt16");
}, (v) => v);
var Int16 = typedef("Int16", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Int16");
    return {
      type: "Int16",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Int16",
      value: v
    };
  }
  return throwTypeError("Expected positive integer for Int16");
}, (v) => v);
var UInt32 = typedef("UInt32", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("UInt32");
    return {
      type: "UInt32",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "UInt32",
      value: v
    };
  }
  return throwTypeError("Expected integer for UInt32");
}, (v) => v);
var Int32 = typedef("Int32", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Int32");
    return {
      type: "Int32",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Int32",
      value: v
    };
  }
  return throwTypeError("Expected positive integer for Int32");
}, (v) => v);
var UInt64 = typedef("UInt64", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("UInt64");
    return {
      type: "UInt64",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "UInt64",
      value: v
    };
  }
  return throwTypeError("Expected integer for UInt64");
}, (v) => v);
var Int64 = typedef("Int64", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Int64");
    return {
      type: "Int64",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Int64",
      value: v
    };
  }
  return throwTypeError("Expected positive integer for Int64");
}, (v) => v);
var UInt128 = typedef("UInt128", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("UInt128");
    return {
      type: "UInt128",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "UInt128",
      value: v
    };
  }
  return throwTypeError("Expected integer for UInt128");
}, (v) => v);
var Int128 = typedef("Int128", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Int128");
    return {
      type: "Int128",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Int128",
      value: v
    };
  }
  return throwTypeError("Expected positive integer for Int128");
}, (v) => v);
var UInt256 = typedef("UInt256", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("UInt256");
    return {
      type: "UInt256",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "UInt256",
      value: v
    };
  }
  return throwTypeError("Expected integer for UInt256");
}, (v) => v);
var Int256 = typedef("Int256", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Int256");
    return {
      type: "Int256",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Int256",
      value: v
    };
  }
  return throwTypeError("Expected integer for Int256");
}, (v) => v);
var Word8 = typedef("Word8", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Word8");
    return {
      type: "Word8",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Word8",
      value: v
    };
  }
  return throwTypeError("Expected positive number for Word8");
}, (v) => v);
var Word16 = typedef("Word16", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Word16");
    return {
      type: "Word16",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Word16",
      value: v
    };
  }
  return throwTypeError("Expected positive number for Word16");
}, (v) => v);
var Word32 = typedef("Word32", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Word32");
    return {
      type: "Word32",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Word32",
      value: v
    };
  }
  return throwTypeError("Expected positive number for Word32");
}, (v) => v);
var Word64 = typedef("Word64", (v) => {
  if (isNumber2(v) && isInteger(v)) {
    numberValuesDeprecationNotice("Word64");
    return {
      type: "Word64",
      value: v.toString()
    };
  }
  if (isString2(v)) {
    return {
      type: "Word64",
      value: v
    };
  }
  return throwTypeError("Expected positive number for Word64");
}, (v) => v);
var UFix64AndFix64NumberDeprecationNotice = () => {
  log.deprecate({
    subject: "Passing in Numbers as values for Fix64 and UFix64 types",
    pkg: "@onflow/types",
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number"
  });
};
var UFix64 = typedef("UFix64", (v) => {
  if (isString2(v)) {
    const vParts = v.split(".");
    if (vParts.length !== 2) {
      return throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
    }
    if (vParts[1].length == 0 || vParts[1].length > 8) {
      return throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
    }
    vParts[1] = vParts[1].padEnd(8, "0");
    v = vParts.join(".");
    return {
      type: "UFix64",
      value: v
    };
  } else if (isNumber2(v)) {
    UFix64AndFix64NumberDeprecationNotice();
    return {
      type: "UFix64",
      value: v.toString()
    };
  }
  return throwTypeError("Expected String for UFix64");
}, (v) => v);
var Fix64 = typedef("Fix64", (v) => {
  if (isString2(v)) {
    const vParts = v.split(".");
    if (vParts.length !== 2) {
      return throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
    }
    if (vParts[1].length == 0 || vParts[1].length > 8) {
      return throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
    }
    vParts[1] = vParts[1].padEnd(8, "0");
    v = vParts.join(".");
    return {
      type: "Fix64",
      value: v
    };
  } else if (isNumber2(v)) {
    UFix64AndFix64NumberDeprecationNotice();
    return {
      type: "Fix64",
      value: v.toString()
    };
  }
  return throwTypeError("Expected String for Fix64");
}, (v) => v);
var String2 = typedef("String", (v) => {
  if (isString2(v)) return {
    type: "String",
    value: v
  };
  return throwTypeError("Expected String for type String");
}, (v) => v);
var Character = typedef("Character", (v) => {
  if (isString2(v)) return {
    type: "Character",
    value: v
  };
  return throwTypeError("Expected Character for type Character");
}, (v) => v);
var Bool = typedef("Bool", (v) => {
  if (isBoolean(v)) return {
    type: "Bool",
    value: v
  };
  return throwTypeError("Expected Boolean for type Bool");
}, (v) => v);
var Address = typedef("Address", (v) => {
  if (isString2(v)) return {
    type: "Address",
    value: v
  };
  return throwTypeError("Expected Address for type Address");
}, (v) => v);
var Void = typedef("Void", (v) => {
  if (!v || isNull2(v)) return {
    type: "Void",
    value: null
  };
  return throwTypeError("Expected Void for type Void");
}, (v) => v);
var Optional = (children) => typedef("Optional", (v) => ({
  type: "Optional",
  value: isNull2(v) ? null : children.asArgument(v)
}), (v) => v);
var Reference = typedef("Reference", (v) => {
  if (isObj2(v)) return {
    type: "Reference",
    value: v
  };
  return throwTypeError("Expected Object for type Reference");
}, (v) => v);
var _Array = function() {
  let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return typedef("Array", (v) => {
    return {
      type: "Array",
      value: isArray2(children) ? children.map((c, i) => c.asArgument(v[i])) : v.map((x) => children.asArgument(x))
    };
  }, (v) => v);
};
var Dictionary = function() {
  let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return typedef("Dictionary", (v) => {
    const vIsArray = isArray2(v);
    const childrenIsArray = isArray2(children);
    if (isObj2(v)) return {
      type: "Dictionary",
      value: childrenIsArray && vIsArray ? children.map((c, i) => ({
        key: c.key.asArgument(v[i].key),
        value: c.value.asArgument(v[i].value)
      })) : vIsArray && !childrenIsArray ? v.map((x) => ({
        key: children.key.asArgument(x.key),
        value: children.value.asArgument(x.value)
      })) : !vIsArray && !childrenIsArray ? [{
        key: children.key.asArgument(v.key),
        value: children.value.asArgument(v.value)
      }] : throwTypeError("Invalid arguments for Dictionary.")
    };
    return throwTypeError("Expected Object for type Dictionary");
  }, (v) => v);
};
var Event = function(id) {
  let fields = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return typedef("Event", (v) => {
    if (isObj2(v)) return {
      type: "Event",
      value: {
        id,
        fields: isArray2(fields) ? fields.map((c, i) => ({
          name: v.fields[i].name,
          value: c.value.asArgument(v.fields[i].value)
        })) : v.fields.map((x) => ({
          name: x.name,
          value: fields.value.asArgument(x.value)
        }))
      }
    };
    return throwTypeError("Expected Object for type Event");
  }, (v) => v);
};
var Resource = function(id) {
  let fields = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return typedef("Resource", (v) => {
    if (isObj2(v)) return {
      type: "Resource",
      value: {
        id,
        fields: isArray2(fields) ? fields.map((c, i) => ({
          name: v.fields[i].name,
          value: c.value.asArgument(v.fields[i].value)
        })) : v.fields.map((x) => ({
          name: x.name,
          value: fields.value.asArgument(x.value)
        }))
      }
    };
    return throwTypeError("Expected Object for type Resource");
  }, (v) => v);
};
var Struct = function(id) {
  let fields = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return typedef("Struct", (v) => {
    if (isObj2(v)) return {
      type: "Struct",
      value: {
        id,
        fields: isArray2(fields) ? fields.map((c, i) => ({
          name: v.fields[i].name,
          value: c.value.asArgument(v.fields[i].value)
        })) : v.fields.map((x) => ({
          name: x.name,
          value: fields.value.asArgument(x.value)
        }))
      }
    };
    return throwTypeError("Expected Object for type Struct");
  }, (v) => v);
};
var Enum = function(id) {
  let fields = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return typedef("Enum", (v) => {
    if (isObj2(v)) return {
      type: "Enum",
      value: {
        id,
        fields: isArray2(fields) ? fields.map((c, i) => ({
          name: v.fields[i].name,
          value: c.value.asArgument(v.fields[i].value)
        })) : v.fields.map((x) => ({
          name: x.name,
          value: fields.value.asArgument(x.value)
        }))
      }
    };
    return throwTypeError("Expected Object for type Enum");
  }, (v) => v);
};
var Path = typedef("Path", (v) => {
  if (isObj2(v)) {
    if (!isString2(v.domain)) {
      return throwTypeError(`Expected a string for the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);
    }
    if (!(v.domain === "storage" || v.domain === "private" || v.domain === "public")) {
      return throwTypeError(`Expected either "storage", "private" or "public" as the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);
    }
    if (!isString2(v.identifier)) {
      return throwTypeError(`Expected a string for the Path identifier but found ${v.identifier}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);
    }
    return {
      type: "Path",
      value: {
        domain: v.domain,
        identifier: v.identifier
      }
    };
  }
  return throwTypeError("Expected Object for type Path");
}, (v) => v);

// node_modules/@onflow/fcl-core/dist/fcl-core.module.js
var import_cross_fetch2 = __toESM(require_browser_ponyfill2());
var import_grpc_web = __toESM(require_grpc_web_client_umd());
var import_sha32 = __toESM(require_sha3());

// node_modules/@onflow/util-semver/dist/index.module.js
var numeric = /^[0-9]+$/;
var compareIdentifiers = function compareIdentifiers2(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
var VERSION_REGEX = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
var compare = function compare2(a, b) {
  if (typeof a !== "string" || typeof b !== "string") throw new Error("Invalid input");
  var vsnA = a.match(VERSION_REGEX);
  var vsnB = b.match(VERSION_REGEX);
  if (!vsnA || !vsnB) throw new Error("Invalid input");
  for (var i = 1; i <= 3; i++) {
    if (parseInt(vsnA[i]) > parseInt(vsnB[i])) return 1;
    if (parseInt(vsnA[i]) < parseInt(vsnB[i])) return -1;
  }
  if (vsnA[4] && vsnB[4]) {
    var prereleaseA = (vsnA[4] || "").split(".");
    var prereleaseB = (vsnB[4] || "").split(".");
    for (var _i = 0; _i < Math.max(prereleaseA.length, prereleaseB.length); _i++) {
      if (prereleaseA[_i] === void 0) return -1;
      if (prereleaseB[_i] === void 0) return 1;
      var cmp = compareIdentifiers(prereleaseA[_i], prereleaseB[_i]);
      if (cmp !== 0) return cmp;
    }
  }
  return 0;
};

// node_modules/@onflow/fcl-core/dist/fcl-core.module.js
var VERSION = "1.9.0";
var is2 = (type) => (d) => typeof d === type;
var isRequired = (d) => d != null;
var isObject3 = is2("object");
var isString3 = is2("string");
var isFunc = is2("function");
var isNumber3 = is2("number");
function normalizeArgs(ax) {
  if (isFunc(ax)) return ax(arg, types_module_exports);
  return [];
}
async function httpDocumentResolver(_ref) {
  let {
    url
  } = _ref;
  invariant(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
  let res;
  try {
    res = await (0, import_cross_fetch2.default)(url);
  } catch (e) {
    throw new Error("httpDocumentResolver Error: Failed to retrieve document.");
  }
  let document2 = res.ok ? await res.json() : null;
  return document2;
}
var DOCUMENT_RESOLVERS = /* @__PURE__ */ new Map([["http", httpDocumentResolver], ["https", httpDocumentResolver]]);
async function retrieve(_ref2) {
  let {
    url
  } = _ref2;
  invariant(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
  invariant(typeof url === "string", "retrieve({ url }) -- url must be a string");
  const documentResolversFromConfig = await config2().where(/^document\.resolver\./);
  Object.keys(documentResolversFromConfig).map((key) => {
    const resolverFromConfig = documentResolversFromConfig[key];
    const resolverProtocol = key.replace(/^document\.resolver\./, "");
    DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig);
  });
  const urlParts = /^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(url);
  invariant(urlParts, "Failed to parse URL");
  const protocol = urlParts[1];
  invariant(urlParts, "Failed to parse URL protocol");
  const resolver = DOCUMENT_RESOLVERS.get(protocol);
  invariant(resolver, `No resolver found for protcol=${protocol}`);
  let document2 = await resolver({
    url
  });
  return document2;
}
function normalize(_ref) {
  let {
    template: template2
  } = _ref;
  invariant2(template2 != void 0, "generateTemplateId({ template }) -- template must be defined");
  invariant2(typeof template2 === "object", "generateTemplateId({ template }) -- template must be an object");
  invariant2(template2.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  invariant2(template2.f_version === "1.0.0", "generateTemplateId({ template }) -- template object must be version 1.0.0");
  const templateData = template2.data;
  const messages = Object.keys(templateData.messages).map((messageKey) => ({
    key: messageKey,
    i18n: templateData.messages[messageKey]?.i18n.map((messageKeyTranslationTag) => ({
      tag: messageKeyTranslationTag,
      translation: templateData.messages[messageKey]?.i18n?.[messageKeyTranslationTag]
    }))
  }));
  const _args = Object.keys(templateData?.["arguments"]).map(async (argumentKey, i) => ({
    ...templateData?.["arguments"]?.[argumentKey],
    label: argumentKey,
    index: i,
    type: templateData?.["arguments"]?.[argumentKey]?.type,
    messages: Object.keys(templateData?.["arguments"]?.[argumentKey].messages).map((argumentMessageKey) => ({
      key: argumentMessageKey,
      i18n: Object.keys(templateData?.["arguments"]?.[argumentKey].messages?.[argumentMessageKey]).map((argumentMessageTag) => ({
        tag: argumentMessageTag,
        translation: templateData?.["arguments"]?.[argumentKey].messages?.[argumentMessageKey]?.[argumentMessageTag]
      }))
    }))
  }));
  const newTemplate = {
    ...template2,
    f_version: "1.1.0",
    data: {
      ...template2.data,
      messages,
      parameters: _args
    }
  };
  return newTemplate;
}
async function normalizeInteractionTemplate(template2) {
  if (template2 == null) return null;
  switch (template2["f_version"]) {
    case "1.0.0":
      return normalizeInteractionTemplate(normalize({
        template: template2
      }));
    case "1.1.0":
      return template2;
    default:
      throw new Error("normalizeInteractionTemplate Error: Invalid InteractionTemplate");
  }
}
async function deriveCadenceByNetwork100(_ref) {
  let {
    network,
    template: template2
  } = _ref;
  invariant(template2.f_version === "1.0.0", "deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0");
  const networkDependencies = Object.keys(template2?.data?.dependencies).map((dependencyPlaceholder) => {
    const dependencyNetworkContracts = Object.values(template2?.data?.dependencies?.[dependencyPlaceholder]);
    invariant(dependencyNetworkContracts !== void 0, `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);
    invariant(dependencyNetworkContracts.length > 0, `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);
    const dependencyContract = dependencyNetworkContracts[0];
    const dependencyContractForNetwork = dependencyContract?.[network];
    invariant(dependencyContractForNetwork, `deriveCadenceByNetwork100 -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`);
    return [dependencyPlaceholder, dependencyContractForNetwork?.address];
  });
  return networkDependencies.reduce((cadence, _ref2) => {
    let [placeholder, address] = _ref2;
    const regex = new RegExp("(\\b" + placeholder + "\\b)", "g");
    return cadence.replace(regex, address);
  }, template2.data.cadence);
}
function replaceStringImports(_ref) {
  let {
    cadence,
    networkDependencies
  } = _ref;
  return Object.keys(networkDependencies).reduce((c, contractName) => {
    const address = networkDependencies[contractName];
    const regex = new RegExp(`import "\\b${contractName}\\b"`, "g");
    return c.replace(regex, `import ${contractName} from ${address}`);
  }, cadence);
}
async function deriveCadenceByNetwork110(_ref) {
  let {
    network,
    template: template2
  } = _ref;
  invariant(template2.f_version === "1.1.0", "deriveCadenceByNetwork110({ template }) -- template must be version 1.0.0");
  const networkDependencies = {};
  template2?.data?.dependencies.forEach((dependency) => {
    dependency.contracts.forEach((contract) => {
      const contractName = contract.contract;
      contract.networks.forEach((net) => {
        if (net.network === network) {
          networkDependencies[contractName] = net.address;
        }
      });
      invariant(networkDependencies[contractName] !== void 0, `deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${network} ${contractName}`);
    });
  });
  invariant(Object.keys(networkDependencies).length === template2?.data?.dependencies.length, `deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${networkDependencies}`);
  invariant(Object.keys(networkDependencies).length === Object.values(networkDependencies).length, `deriveCadenceByNetwork110 -- Could not find all addresses for network ${network} dependencies:  ${networkDependencies}`);
  invariant(template2?.data?.cadence?.body, `no cadence found -- Could not replace import dependencies: ${networkDependencies}`);
  return replaceStringImports({
    cadence: template2?.data?.cadence?.body,
    networkDependencies
  });
}
async function deriveCadenceByNetwork(_ref) {
  let {
    network,
    template: template2
  } = _ref;
  invariant(network != void 0, "deriveCadenceByNetwork({ network }) -- network must be defined");
  invariant(typeof network === "string", "deriveCadenceByNetwork({ network }) -- network must be a string");
  invariant(template2 != void 0, "deriveCadenceByNetwork({ template }) -- template must be defined");
  invariant(typeof template2 === "object", "deriveCadenceByNetwork({ template }) -- template must be an object");
  invariant(template2.f_type === "InteractionTemplate", "deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate");
  switch (template2.f_version) {
    case "1.1.0":
      return await deriveCadenceByNetwork110({
        network,
        template: template2
      });
    case "1.0.0":
      return await deriveCadenceByNetwork100({
        network,
        template: template2
      });
    default:
      throw new Error("deriveCadenceByNetwork Error: Unsupported template version");
  }
}
async function fetchChainId() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const response2 = await send3([getNetworkParameters()], opts).then(decode);
  return response2.chainId;
}
var chainIdCache = {};
var hasWarnedEnv = false;
async function getChainId() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let flowNetworkCfg = await config2.get("flow.network");
  let envCfg = await config2.get("env");
  if (envCfg && !hasWarnedEnv) {
    log.deprecate({
      pkg: "FCL",
      subject: 'Using the "env" configuration key for specifying the flow network',
      message: "Configuring to specify flow network is no longer required",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"
    });
    hasWarnedEnv = true;
  }
  const accessNode = opts.node || await config2.get("accessNode.api");
  if (!accessNode) {
    if (flowNetworkCfg) {
      return flowNetworkCfg;
    } else if (envCfg) {
      return envCfg;
    }
    throw new Error(`Either the "accessNode.api" config key or opts.node must be set`);
  }
  if (chainIdCache[accessNode]) {
    try {
      return await chainIdCache[accessNode];
    } catch {
    }
  }
  if (!chainIdCache[accessNode]) {
    chainIdCache[accessNode] = fetchChainId(opts).catch((error) => {
      chainIdCache[accessNode] = null;
      throw error;
    });
  }
  try {
    return await chainIdCache[accessNode];
  } catch (e) {
    if (flowNetworkCfg) {
      return flowNetworkCfg;
    } else if (envCfg) {
      return envCfg;
    }
    throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`);
  }
}
function watchForChainIdChanges() {
  return config2.subscribe(() => {
    getChainId({
      enableRequestLogging: false
    }).catch(() => {
    });
  });
}
function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile2() {
  return isAndroid() || isIOS();
}
async function deriveDependencies() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const template2 = opts.template;
  const network = await getChainId(opts);
  const derivedDependencies = {};
  switch (template2["f_version"]) {
    case "1.0.0":
      const dependencyPlaceholderKeys = Object.keys(template2?.data?.dependencies);
      for (let dependencyPlaceholderKey of dependencyPlaceholderKeys) {
        let dependencyPlaceholder = template2?.data?.dependencies[dependencyPlaceholderKey];
        const dependencyPlaceholderContractsKeys = Object.keys(dependencyPlaceholder);
        invariant(dependencyPlaceholderContractsKeys.length > 0, `FCL configureDependencies Error: No contracts found in template for placeholder=${dependencyPlaceholderKey}`);
        const dependencyPlaceholderContract = dependencyPlaceholder[dependencyPlaceholderContractsKeys[0]];
        const dependency = dependencyPlaceholderContract[network];
        invariant(dependency, `FCL configureDependencies Error: No dependency information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);
        invariant(dependency?.address, `FCL configureDependencies Error: No address information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);
        derivedDependencies[dependencyPlaceholderKey] = withPrefix2(dependency?.address);
      }
      return derivedDependencies;
    case "1.1.0":
      template2?.data?.dependencies?.forEach((dependency) => {
        dependency.contracts.forEach((contract) => {
          const contractName = contract.contract;
          contract.networks.forEach((net) => {
            if (net.network === network) {
              derivedDependencies[contractName] = withPrefix2(net?.address);
            }
          });
          invariant(derivedDependencies[contractName], `networkAddress -- Could not find contracts Network Address: ${network} ${contractName}`);
        });
      });
      return derivedDependencies;
    default:
      throw new Error("FCL configureDependencies Error: Unsupported template version");
  }
}
async function prepTemplateOpts(opts) {
  if (isString3(opts?.template)) {
    opts.template = await retrieve({
      url: opts?.template
    });
  }
  let dependencies = {};
  if (opts?.template) {
    opts.template = normalizeInteractionTemplate(opts?.template);
    dependencies = await deriveDependencies({
      template: opts.template
    });
  }
  const cadence = opts.cadence || deriveCadenceByNetwork({
    template: opts.template,
    network: await getChainId(opts)
  });
  opts.cadence = cadence;
  opts.dependencies = dependencies;
  return opts;
}
async function pre(type, opts) {
  invariant(isRequired(opts), `${type}(opts) -- opts is required`);
  invariant(isObject3(opts), `${type}(opts) -- opts must be an object`);
  invariant(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`);
  invariant(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`);
  invariant(isString3(opts.cadence) || opts?.template, `${type}({ cadence }) -- cadence must be a string`);
  invariant(await config2().get("accessNode.api"), `${type}(opts) -- Required value for "accessNode.api" not defined in config. See: ${"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration"}`);
}
async function preMutate(opts) {
  return pre("mutate", opts);
}
async function preQuery(opts) {
  return pre("query", opts);
}
async function query() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  await preQuery(opts);
  opts = await prepTemplateOpts(opts);
  return config2().overload(opts.dependencies || {}, async () => (
    // prettier-ignore
    send3([script(opts.cadence), args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === "number" && limit(opts.limit)]).then(decode)
  ));
}
var FCL_REDIRECT_URL_PARAM_NAME = "fcl_redirect_url";
var FCL_RESPONSE_PARAM_NAME = "fclResponseJson";
var CORE_STRATEGIES = {
  "HTTP/RPC": "HTTP/RPC",
  "HTTP/POST": "HTTP/POST",
  "IFRAME/RPC": "IFRAME/RPC",
  "POP/RPC": "POP/RPC",
  "TAB/RPC": "TAB/RPC",
  "EXT/RPC": "EXT/RPC",
  "DEEPLINK/RPC": "DEEPLINK/RPC"
};
var onMessageFromFCL = function(messageType) {
  let cb = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => {
  };
  const buildData = (data) => {
    if (data.deprecated) console.warn("DEPRECATION NOTICE", data.deprecated.message);
    delete data?.body?.interaction;
    return data;
  };
  const internal = (e) => {
    const {
      data
    } = e;
    if (typeof data !== "object") return;
    if (typeof data == null) return;
    if (data.type !== messageType) return;
    cb(buildData(data));
  };
  window.addEventListener("message", internal);
  return () => window.removeEventListener("message", internal);
};
var _isReactNative = false;
function isReactNative() {
  return _isReactNative;
}
var _URL = globalThis.URL;
var URL3 = class extends _URL {
  constructor(url, base) {
    for (var _len = arguments.length, args2 = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args2[_key - 2] = arguments[_key];
    }
    super(url, base, ...args2);
    if (!isReactNative()) {
      return;
    }
    if (this._url && !url.endsWith("/") && this._url.endsWith("/")) {
      this._url = this._url.slice(0, -1);
    }
  }
};
var sendMsgToFCL = function(type) {
  let msg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const data = {
    ...msg,
    type
  };
  const urlParams = new URLSearchParams(window.location.search);
  const redirectUrl = urlParams.get(FCL_REDIRECT_URL_PARAM_NAME);
  if (redirectUrl) {
    const url = new URL3(redirectUrl);
    url.searchParams.append(FCL_RESPONSE_PARAM_NAME, JSON.stringify(data));
    window.location.href = url.href;
  } else if (window.location !== window.parent.location) {
    window.parent.postMessage({
      ...msg,
      type
    }, "*");
  } else if (window.opener) {
    window.opener.postMessage({
      ...msg,
      type
    }, "*");
  } else {
    throw new Error("Unable to communicate with parent FCL instance");
  }
};
var ready = function(cb) {
  onMessageFromFCL("FCL:VIEW:READY:RESPONSE", cb);
  sendMsgToFCL("FCL:VIEW:READY");
};
var close = () => {
  sendMsgToFCL("FCL:VIEW:CLOSE");
};
var approve = (data) => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "APPROVED",
    reason: null,
    data
  });
};
var decline = (reason) => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "DECLINED",
    reason,
    data: null
  });
};
var redirect = (data) => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "REDIRECT",
    reason: null,
    data
  });
};
var SERVICE_PRAGMA = {
  f_type: "Service",
  f_vsn: "1.0.0"
};
var IDENTITY_PRAGMA = {
  f_type: "Identity",
  f_vsn: "1.0.0"
};
var USER_PRAGMA = {
  f_type: "USER",
  f_vsn: "1.0.0"
};
var POLLING_RESPONSE_PRAGMA = {
  f_type: "PollingResponse",
  f_vsn: "1.0.0"
};
var COMPOSITE_SIGNATURE_PRAGMA = {
  f_type: "CompositeSignature",
  f_vsn: "1.0.0"
};
function CompositeSignature(addr, keyId, signature) {
  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;
  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;
  this.addr = withPrefix2(addr);
  this.keyId = Number(keyId);
  this.signature = signature;
}
var rightPaddedHexBuffer2 = (value, pad) => import_buffer2.Buffer.from(value.padEnd(pad * 2, "0"), "hex");
var leftPaddedHexBuffer2 = (value, pad) => import_buffer2.Buffer.from(value.padStart(pad * 2, "0"), "hex");
var addressBuffer2 = (addr) => leftPaddedHexBuffer2(addr, 8);
var nonceBuffer = (nonce) => import_buffer2.Buffer.from(nonce, "hex");
var encodeAccountProof = function(_ref) {
  let {
    address,
    nonce,
    appIdentifier
  } = _ref;
  let includeDomainTag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  invariant(address, "Encode Message For Provable Authn Error: address must be defined");
  invariant(nonce, "Encode Message For Provable Authn Error: nonce must be defined");
  invariant(appIdentifier, "Encode Message For Provable Authn Error: appIdentifier must be defined");
  invariant(nonce.length >= 64, "Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");
  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer2(import_buffer2.Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"), 32);
  if (includeDomainTag) {
    return import_buffer2.Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, encode([appIdentifier, addressBuffer2(sansPrefix(address)), nonceBuffer(nonce)])]).toString("hex");
  }
  return encode([appIdentifier, addressBuffer2(sansPrefix(address)), nonceBuffer(nonce)]).toString("hex");
};
function injectExtService(service) {
  if (service.type === "authn" && service.endpoint != null) {
    if (!Array.isArray(window.fcl_extensions)) {
      window.fcl_extensions = [];
    }
    window.fcl_extensions.push(service);
  } else {
    console.warn("Authn service is required");
  }
}
var index$2 = Object.freeze({
  __proto__: null,
  sendMsgToFCL,
  ready,
  close,
  approve,
  decline,
  redirect,
  onMessageFromFCL,
  encodeMessageFromSignable,
  CompositeSignature,
  encodeAccountProof,
  injectExtService
});
var ACCOUNT_PROOF = "ACCOUNT_PROOF";
var USER_SIGNATURE = "USER_SIGNATURE";
var validateArgs = (args2) => {
  if (args2.appIdentifier) {
    const {
      appIdentifier,
      address,
      nonce,
      signatures
    } = args2;
    invariant(isString3(appIdentifier), "verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string");
    invariant(isString3(address) && sansPrefix(address).length === 16, "verifyAccountProof({ address }) -- address must be a valid address");
    invariant(/^[0-9a-f]+$/i.test(nonce), "nonce must be a hex string");
    invariant(Array.isArray(signatures) && signatures.every((sig2, i, arr) => sig2.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    invariant(signatures.map((cs) => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  } else {
    const {
      message,
      address,
      compSigs
    } = args2;
    invariant(/^[0-9a-f]+$/i.test(message), "Signed message must be a hex string");
    invariant(isString3(address) && sansPrefix(address).length === 16, "verifyUserSignatures({ address }) -- address must be a valid address");
    invariant(Array.isArray(compSigs) && compSigs.every((sig2, i, arr) => sig2.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    invariant(compSigs.map((cs) => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  }
};
var getVerifySignaturesScript = async (sig2, opts) => {
  const verifyFunction = sig2 === "ACCOUNT_PROOF" ? "verifyAccountProofSignatures" : "verifyUserSignatures";
  let network = await getChainId(opts);
  const contractAddresses = {
    testnet: "0x74daa6f9c7ef24b1",
    mainnet: "0xb4b82a1c9d21d284",
    previewnet: "0x40b5b8b2ce81ea4a"
  };
  const fclCryptoContract = opts.fclCryptoContract || contractAddresses[network];
  invariant(fclCryptoContract, `${verifyFunction}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${network}. Please manually specify the FCLCrypto contract address.`);
  return `
      import FCLCrypto from ${fclCryptoContract}

      access(all) fun main(
          address: Address, 
          message: String, 
          keyIndices: [Int], 
          signatures: [String]
      ): Bool {
        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)
      }
    `;
};
async function verifyAccountProof(appIdentifier, _ref) {
  let {
    address,
    nonce,
    signatures
  } = _ref;
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  validateArgs({
    appIdentifier,
    address,
    nonce,
    signatures
  });
  const message = encodeAccountProof({
    address,
    nonce,
    appIdentifier
  }, false);
  let signaturesArr = [];
  let keyIndices = [];
  for (const el of signatures) {
    signaturesArr.push(el.signature);
    keyIndices.push(el.keyId.toString());
  }
  return query({
    cadence: await getVerifySignaturesScript(ACCOUNT_PROOF, opts),
    args: (arg2, t) => [arg2(withPrefix2(address), t.Address), arg2(message, t.String), arg2(keyIndices, t.Array(t.Int)), arg2(signaturesArr, t.Array(t.String))]
  });
}
async function verifyUserSignatures$1(message, compSigs) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const address = withPrefix2(compSigs[0].addr);
  validateArgs({
    message,
    address,
    compSigs
  });
  let signaturesArr = [];
  let keyIndices = [];
  for (const el of compSigs) {
    signaturesArr.push(el.signature);
    keyIndices.push(el.keyId.toString());
  }
  return query({
    cadence: await getVerifySignaturesScript(USER_SIGNATURE, opts),
    args: (arg2, t) => [arg2(address, t.Address), arg2(message, t.String), arg2(keyIndices, t.Array(t.Int)), arg2(signaturesArr, t.Array(t.String))]
  });
}
var index$1 = Object.freeze({
  __proto__: null,
  verifyAccountProof,
  verifyUserSignatures: verifyUserSignatures$1
});
var verifyUserSignatures = log.deprecate({
  pkg: "FCL",
  subject: "fcl.verifyUserSignatures()",
  message: "Please use fcl.AppUtils.verifyUserSignatures()",
  callback: function verifyUserSignatures2(message, compSigs) {
    return verifyUserSignatures$1(message, compSigs);
  }
});
async function configLens(regex) {
  return Object.fromEntries(Object.entries(await config2().where(regex)).map((_ref) => {
    let [key, value] = _ref;
    return [key.replace(regex, ""), value];
  }));
}
var TXID_REGEXP = /^[0-9a-fA-F]{64}$/;
var POLL = "POLL";
var TIMEOUT = "TIMEOUT";
var fetchTxStatus = async (transactionId) => {
  return send3([getTransactionStatus(transactionId)]).then(decode);
};
var isExpired = (tx) => tx.status === 5;
var isSealed = (tx) => tx.status >= 4;
var isExecuted = (tx) => tx.status >= 3;
var isFinalized = (tx) => tx.status >= 2;
var isPending = (tx) => tx.status >= 1;
var isUnknown2 = (tx) => tx.status >= 0;
var isDiff = (cur, next) => {
  return JSON.stringify(cur) !== JSON.stringify(next);
};
var makeHandlers = function() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    [INIT]: async (ctx) => {
      setTimeout(() => ctx.sendSelf(TIMEOUT), opts.txNotFoundTimeout);
      ctx.sendSelf(POLL);
    },
    [SUBSCRIBE]: (ctx, letter) => {
      ctx.subscribe(letter.from);
      ctx.send(letter.from, UPDATED, ctx.all());
    },
    [UNSUBSCRIBE]: (ctx, letter) => {
      ctx.unsubscribe(letter.from);
    },
    [SNAPSHOT]: async (ctx, letter) => {
      letter.reply(ctx.all());
    },
    [TIMEOUT]: async (ctx) => {
      if (Object.keys(ctx.all()).length === 0) {
        ctx.fatalError(new Error(`TX status polling failed: no transaction was found within timeout interval (${opts.txNotFoundTimeout}ms)`));
      }
    },
    [POLL]: async (ctx) => {
      const poll2 = () => setTimeout(() => ctx.sendSelf(POLL), opts.pollRate);
      let tx;
      const prevTx = ctx.all();
      try {
        tx = await fetchTxStatus(ctx.self());
      } catch (e) {
        const isHttpNotFound = e instanceof HTTPRequestError && e.statusCode === 404;
        const isGrpcNotFound = e.code === import_grpc_web.grpc.Code.NotFound;
        if (isHttpNotFound || isGrpcNotFound) {
          return poll2();
        }
        return ctx.fatalError(e);
      }
      if (!isSealed(tx)) poll2();
      if (isDiff(prevTx, tx)) ctx.broadcast(UPDATED, tx);
      ctx.merge(tx);
    }
  };
};
var scoped = (transactionId) => {
  if (typeof transactionId === "object") transactionId = transactionId.transactionId;
  if (transactionId == null) throw new Error("transactionId required");
  return transactionId;
};
var spawnTransaction = function() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return (transactionId) => {
    return spawn(makeHandlers(opts), scoped(transactionId));
  };
};
function transaction2(transactionId) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    txNotFoundTimeout: 12500,
    pollRate: 2500
  };
  if (!TXID_REGEXP.test(scoped(transactionId))) throw new Error("Invalid transactionId");
  function snapshot2() {
    return snapshoter(transactionId, spawnTransaction(opts));
  }
  function subscribe3(callback) {
    return subscriber(scoped(transactionId), spawnTransaction(opts), callback);
  }
  function once(predicate) {
    return function innerOnce() {
      let opts2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const suppress = opts2.suppress || false;
      return new Promise((resolve2, reject) => {
        const unsub = subscribe3((txStatus, error) => {
          if ((error || txStatus.statusCode) && !suppress) {
            reject(error || txStatus.errorMessage);
            unsub();
          } else if (predicate(txStatus)) {
            resolve2(txStatus);
            unsub();
          }
        });
      });
    };
  }
  return {
    snapshot: snapshot2,
    subscribe: subscribe3,
    onceFinalized: once(isFinalized),
    onceExecuted: once(isExecuted),
    onceSealed: once(isSealed)
  };
}
transaction2.isUnknown = isUnknown2;
transaction2.isPending = isPending;
transaction2.isFinalized = isFinalized;
transaction2.isExecuted = isExecuted;
transaction2.isSealed = isSealed;
transaction2.isExpired = isExpired;
var RATE = 1e4;
var UPDATED$1 = "UPDATED";
var TICK = "TICK";
var HIGH_WATER_MARK = "hwm";
var scheduleTick = async (ctx) => {
  return setTimeout(() => ctx.sendSelf(TICK), await config2().get("fcl.eventPollRate", RATE));
};
var HANDLERS$2 = {
  [TICK]: async (ctx) => {
    if (!ctx.hasSubs()) return;
    let hwm = ctx.get(HIGH_WATER_MARK);
    if (hwm == null) {
      ctx.put(HIGH_WATER_MARK, await block());
      ctx.put(TICK, await scheduleTick(ctx));
    } else {
      let next = await block();
      ctx.put(HIGH_WATER_MARK, next);
      if (hwm.height < next.height) {
        const data = await send3([getEventsAtBlockHeightRange(ctx.self(), hwm.height + 1, next.height)]).then(decode);
        for (let d of data) ctx.broadcast(UPDATED$1, d.data);
      }
      ctx.put(TICK, await scheduleTick(ctx));
    }
  },
  [SUBSCRIBE]: async (ctx, letter) => {
    if (!ctx.hasSubs()) {
      ctx.put(TICK, await scheduleTick(ctx));
    }
    ctx.subscribe(letter.from);
  },
  [UNSUBSCRIBE]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
    if (!ctx.hasSubs()) {
      clearTimeout(ctx.get(TICK));
      ctx.delete(TICK);
      ctx.delete(HIGH_WATER_MARK);
    }
  }
};
var stub = () => {
  throw new Error(`Platform specific Core Strategies are not initialized`);
};
var stubCoreStrategies = {
  [CORE_STRATEGIES["EXT/RPC"]]: stub,
  [CORE_STRATEGIES["HTTP/POST"]]: stub,
  [CORE_STRATEGIES["IFRAME/RPC"]]: stub,
  [CORE_STRATEGIES["POP/RPC"]]: stub,
  [CORE_STRATEGIES["TAB/RPC"]]: stub,
  [CORE_STRATEGIES["EXT/RPC"]]: stub
};
var supportedPlugins = ["ServicePlugin"];
var supportedServicePlugins = ["discovery-service"];
var validateDiscoveryPlugin = (servicePlugin) => {
  const {
    services,
    serviceStrategy
  } = servicePlugin;
  invariant(Array.isArray(services) && services.length, "Array of Discovery Services is required");
  for (const ds of services) {
    invariant(isRequired(ds.f_type) && ds.f_type === "Service", "Service is required");
    invariant(isRequired(ds.type) && ds.type === "authn", `Service must be type authn. Received ${ds.type}`);
    invariant(ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method, `Service method ${ds.method} is not supported`);
  }
  invariant(isRequired(serviceStrategy), "Service strategy is required");
  invariant(isRequired(serviceStrategy.method) && isString3(serviceStrategy.method), "Service strategy method is required");
  invariant(isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec), "Service strategy exec function is required");
  return {
    discoveryServices: services,
    serviceStrategy
  };
};
var ServiceRegistry = (_ref) => {
  let {
    coreStrategies: coreStrategies2
  } = _ref;
  let services = /* @__PURE__ */ new Set();
  let strategies = new Map(Object.entries(coreStrategies2));
  const add = (servicePlugin) => {
    invariant(supportedServicePlugins.includes(servicePlugin.type), `Service Plugin type ${servicePlugin.type} is not supported`);
    if (servicePlugin.type === "discovery-service") {
      const {
        discoveryServices,
        serviceStrategy
      } = validateDiscoveryPlugin(servicePlugin);
      setServices(discoveryServices);
      if (!strategies.has(serviceStrategy.method)) {
        strategies.set(serviceStrategy.method, serviceStrategy.exec);
      } else {
        log({
          title: `Add Service Plugin`,
          message: `Service strategy for ${serviceStrategy.method} already exists`,
          level: LEVELS.warn
        });
      }
    }
  };
  const setServices = (discoveryServices) => services = /* @__PURE__ */ new Set([...discoveryServices]);
  const getServices2 = () => [...services];
  const getStrategy = (method) => strategies.get(method);
  const getStrategies = () => [...strategies.keys()];
  return Object.freeze({
    add,
    getServices: getServices2,
    getStrategy,
    getStrategies
  });
};
var validatePlugins = (plugins) => {
  let pluginsArray;
  invariant(plugins, "No plugins supplied");
  if (!Array.isArray(plugins)) {
    pluginsArray = [plugins];
  } else {
    pluginsArray = [...plugins];
  }
  for (const p of pluginsArray) {
    invariant(isRequired(p.name), "Plugin name is required");
    invariant(isRequired(p.f_type), "Plugin f_type is required");
    invariant(supportedPlugins.includes(p.f_type), `Plugin type ${p.f_type} is not supported`);
  }
  return pluginsArray;
};
var PluginRegistry = () => {
  const pluginsMap = /* @__PURE__ */ new Map();
  const getPlugins = () => pluginsMap;
  const add = (plugins) => {
    const pluginsArray = validatePlugins(plugins);
    for (const p of pluginsArray) {
      pluginsMap.set(p.name, p);
      if (p.f_type === "ServicePlugin") {
        serviceRegistry.add(p);
      }
    }
  };
  return Object.freeze({
    add,
    getPlugins
  });
};
var serviceRegistry;
var getIsServiceRegistryInitialized = () => typeof serviceRegistry !== "undefined";
var initServiceRegistry = (_ref2) => {
  let {
    coreStrategies: coreStrategies2
  } = _ref2;
  if (getIsServiceRegistryInitialized()) {
    return serviceRegistry;
  }
  const _serviceRegistry = ServiceRegistry({
    coreStrategies: coreStrategies2
  });
  serviceRegistry = _serviceRegistry;
  return _serviceRegistry;
};
var getServiceRegistry = () => {
  if (!getIsServiceRegistryInitialized()) {
    console.warn("Registry is not initalized, it will be initialized with stub core strategies");
    return initServiceRegistry({
      coreStrategies: stubCoreStrategies
    });
  }
  return serviceRegistry;
};
var pluginRegistry = PluginRegistry();
var makeDiscoveryServices = async () => {
  const extensionServices = window?.fcl_extensions || [];
  return [...extensionServices, ...getServiceRegistry().getServices()];
};
async function getDiscoveryService(service) {
  const discoveryAuthnInclude = await config2.get("discovery.authn.include", []);
  const discoveryFeaturesSuggested = await config2.get("discovery.features.suggested", []);
  const discoveryWalletMethod = await config2.first(["discovery.wallet.method", "discovery.wallet.method.default"]);
  const method = service?.method ? service.method : discoveryWalletMethod;
  const endpoint = service?.endpoint ?? await config2.first(["discovery.wallet", "challenge.handshake"]);
  invariant(endpoint, `
    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.
    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"
    `);
  return {
    ...service,
    type: "authn",
    endpoint,
    method,
    discoveryAuthnInclude,
    discoveryFeaturesSuggested
  };
}
async function getServices(_ref) {
  let {
    types
  } = _ref;
  const endpoint = await config2.get("discovery.authn.endpoint");
  invariant(Boolean(endpoint), `"discovery.authn.endpoint" in config must be defined.`);
  const include = await config2.get("discovery.authn.include", []);
  const url = new URL3(endpoint);
  return fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      type: types,
      fclVersion: VERSION,
      include,
      features: {
        suggested: await config2.get("discovery.features.suggested", [])
      },
      clientServices: await makeDiscoveryServices(),
      supportedStrategies: getServiceRegistry().getStrategies(),
      userAgent: window?.navigator?.userAgent,
      network: await getChainId()
    })
  }).then((d) => d.json());
}
var SERVICE_ACTOR_KEYS = {
  AUTHN: "authn",
  RESULTS: "results",
  SNAPSHOT: "SNAPSHOT",
  UPDATED: "UPDATED",
  UPDATE_RESULTS: "UPDATE_RESULTS"
};
var warn = (fact, msg) => {
  if (fact) {
    console.warn(`
      %cFCL Warning
      ============================
      ${msg}
      For more info, please see the docs: https://docs.onflow.org/fcl/
      ============================
      `, "font-weight:bold;font-family:monospace;");
  }
};
var fetchServicesFromDiscovery = async () => {
  try {
    const services = await getServices({
      types: [SERVICE_ACTOR_KEYS.AUTHN]
    });
    send(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {
      results: services
    });
  } catch (error) {
    log({
      title: `${error.name} Error fetching Discovery API services.`,
      message: error.message,
      level: LEVELS.error
    });
  }
};
var HANDLERS$1 = {
  [INIT]: async (ctx) => {
    warn(typeof window === "undefined", '"fcl.discovery" is only available in the browser.');
    if (document.readyState === "complete") {
      fetchServicesFromDiscovery();
    } else {
      window.onload = async () => {
        fetchServicesFromDiscovery();
      };
    }
  },
  [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (ctx, _letter, data) => {
    ctx.merge(data);
    ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {
      ...ctx.all()
    });
  },
  [SUBSCRIBE]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, {
      ...ctx.all()
    });
  },
  [UNSUBSCRIBE]: (ctx, letter) => ctx.unsubscribe(letter.from),
  [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (ctx, letter) => letter.reply({
    ...ctx.all()
  })
};
function genHash(utf8String) {
  const sha = new import_sha32.SHA3(256);
  sha.update(import_buffer2.Buffer.from(utf8String, "utf8"));
  return sha.digest("hex");
}
async function generateTemplateId$2(_ref) {
  let {
    template: template2
  } = _ref;
  invariant2(template2 != void 0, "generateTemplateId({ template }) -- template must be defined");
  invariant2(typeof template2 === "object", "generateTemplateId({ template }) -- template must be an object");
  invariant2(template2.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  invariant2(template2.f_version === "1.0.0", "generateTemplateId({ template }) -- template object must be an version 1.0.0");
  const templateData = template2.data;
  const messages = await Promise.all(Object.keys(templateData.messages).map(async (messageKey) => [genHash(messageKey), await Promise.all(Object.keys(templateData.messages?.[messageKey]?.i18n).map(async (i18nkeylanguage) => [genHash(i18nkeylanguage), genHash(templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage])]))]));
  const dependencies = await Promise.all(Object.keys(templateData?.dependencies).map(async (dependencyAddressPlaceholder) => [genHash(dependencyAddressPlaceholder), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]).map(async (dependencyContract) => [genHash(dependencyContract), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]).map(async (dependencyContractNetwork) => [genHash(dependencyContractNetwork), [genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].address), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].contract), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].fq_address), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin), genHash(String(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin_block_height))]]))]))]));
  const _arguments = await Promise.all(Object.keys(templateData?.["arguments"]).map(async (argumentLabel) => [genHash(argumentLabel), [genHash(String(templateData?.["arguments"]?.[argumentLabel].index)), genHash(templateData?.["arguments"]?.[argumentLabel].type), genHash(templateData?.["arguments"]?.[argumentLabel].balance || ""), await Promise.all(Object.keys(templateData?.["arguments"]?.[argumentLabel].messages).map(async (argumentMessageKey) => [genHash(argumentMessageKey), await Promise.all(Object.keys(templateData?.["arguments"]?.[argumentLabel].messages?.[argumentMessageKey].i18n).map(async (i18nkeylanguage) => [genHash(i18nkeylanguage), genHash(templateData?.["arguments"]?.[argumentLabel].messages?.[argumentMessageKey].i18n?.[i18nkeylanguage])]))]))]]));
  const encodedHex = encode([genHash("InteractionTemplate"), genHash("1.0.0"), genHash(templateData?.type), genHash(templateData?.interface), messages, genHash(templateData?.cadence), dependencies, _arguments]).toString("hex");
  return genHash(encodedHex);
}
function generateImport(_ref) {
  let {
    contractName,
    address
  } = _ref;
  return {
    contractName,
    address,
    contract: ""
  };
}
function findImports(cadence) {
  const imports = [];
  const importsReg = /import ((\w|,| )+)* from 0x\w+/g;
  const fileImports = cadence.match(importsReg) || [];
  for (const fileImport of fileImports) {
    const importLineReg = /import ((\w+|, |)*) from (0x\w+)/g;
    const importLine = importLineReg.exec(fileImport);
    const contractsReg = /((?:\w+)+),?/g;
    const contracts = importLine[1].match(contractsReg) || [];
    for (const contract of contracts) {
      imports.push(generateImport({
        address: importLine[3],
        contractName: contract.replace(/,/g, "")
      }));
    }
  }
  return imports;
}
async function generateDependencyPin110(_ref) {
  let {
    address,
    contractName
  } = _ref;
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  invariant2(address != void 0, "generateDependencyPin({ address }) -- address must be defined");
  invariant2(contractName != void 0, "generateDependencyPin({ contractName }) -- contractName must be defined");
  invariant2(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
  invariant2(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
  const horizon = [generateImport({
    contractName,
    address
  })];
  for (const horizonImport of horizon) {
    const account2 = await send3([getAccount(await config2().get(horizonImport.address, horizonImport.address))], opts).then(decode);
    horizonImport.contract = account2.contracts?.[horizonImport.contractName];
    if (!horizonImport.contract) {
      console.error("Did not find expected contract", horizonImport, account2);
      throw new Error("Did not find expected contract");
    }
    const contractImports = findImports(horizonImport.contract);
    horizon.push(...contractImports);
  }
  const contractPinSelfHashesPromises = horizon.map((iport) => genHash(iport.contract));
  const contractPinSelfHashes = await Promise.all(contractPinSelfHashesPromises);
  const contractPinHashes = contractPinSelfHashes.join("");
  return genHash(contractPinHashes);
}
async function generateContractNetworks(contractName, networks) {
  const values = [];
  for (const net of networks) {
    const networkHashes = [genHash(net.network)];
    const {
      address,
      dependency_pin_block_height
    } = net;
    if (net.dependency_pin) {
      const hash = await generateDependencyPin110({
        address,
        contractName,
        blockHeight: dependency_pin_block_height
      });
      networkHashes.push(genHash(hash));
    }
    values.push(networkHashes);
  }
  return values;
}
async function generateContractDependencies(dependencies) {
  const values = [];
  for (let i = 0; i < dependencies.length; i++) {
    const dependency = dependencies[i];
    const contracts = [];
    for (let j = 0; j < dependency?.contracts.length; j++) {
      const c = dependency?.contracts[j];
      const contractName = c?.contract;
      contracts.push(genHash(contractName));
      const contractHashes = await generateContractNetworks(contractName, c?.networks);
      contracts.push(contractHashes);
    }
    values.push(contracts);
  }
  return values;
}
async function generateTemplateId$1(_ref) {
  let {
    template: template2
  } = _ref;
  invariant(template2, "generateTemplateId({ template }) -- template must be defined");
  invariant(typeof template2 === "object", "generateTemplateId({ template }) -- template must be an object");
  invariant(template2.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  invariant(template2.f_version === "1.1.0", "generateTemplateId({ template }) -- template object must be an version 1.1.0");
  const templateData = template2.data;
  const messages = await Promise.all(templateData.messages.map(async (templateMessage) => [genHash(templateMessage.key), await Promise.all(templateMessage.i18n.map(async (templateMessagei18n) => [genHash(templateMessagei18n.tag), genHash(templateMessagei18n.translation)]))]));
  const params2 = await Promise.all(templateData?.["parameters"].sort((a, b) => a.index - b.index).map(async (arg2) => [genHash(arg2.label), [genHash(String(arg2.index)), genHash(arg2.type), await Promise.all(arg2.messages.map(async (argumentMessage) => [genHash(argumentMessage.key), await Promise.all(argumentMessage.i18n.map(async (argumentMessagei18n) => [genHash(argumentMessagei18n.tag), genHash(argumentMessagei18n.translation)]))]))]]));
  const dependencies = [await generateContractDependencies(templateData?.dependencies)];
  const encodedHex = encode([genHash(template2?.f_type), genHash(template2?.f_version), genHash(templateData?.type), genHash(templateData?.interface), messages, genHash(templateData?.cadence?.body), [dependencies], params2]).toString("hex");
  return genHash(encodedHex);
}
async function generateTemplateId(_ref) {
  let {
    template: template2
  } = _ref;
  invariant(template2, "generateTemplateId({ template }) -- template must be defined");
  invariant(typeof template2 === "object", "generateTemplateId({ template }) -- template must be an object");
  invariant(template2.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  switch (template2.f_version) {
    case "1.1.0":
      return await generateTemplateId$1({
        template: template2
      });
    case "1.0.0":
      return await generateTemplateId$2({
        template: template2
      });
    default:
      throw new Error("generateTemplateId Error: Unsupported template version");
  }
}
async function verifyGeneratedTemplateId(_ref2) {
  let {
    template: template2
  } = _ref2;
  return template2.id === await generateTemplateId({
    template: template2
  });
}
async function getInteractionTemplateAudits(_ref) {
  let {
    template: template2,
    auditors
  } = _ref;
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  invariant2(template2 != void 0, "getInteractionTemplateAudits({ template }) -- template must be defined");
  invariant2(template2.f_type === "InteractionTemplate", "getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate");
  let recomputedTemplateID = await generateTemplateId({
    template: template2
  });
  if (recomputedTemplateID !== template2.id) {
    log({
      title: "getInteractionTemplateAudits Debug Error",
      message: `Could not recompute and match template ID
                computed: ${recomputedTemplateID}
                template: ${template2.id}
            `,
      level: LEVELS.debug
    });
    throw new Error("getInteractionTemplateAudits Error: Could not recompute and match template ID");
  }
  switch (template2.f_version) {
    case "1.1.0":
    case "1.0.0":
      const _auditors = auditors || await config2().get("flow.auditors");
      invariant2(_auditors, "getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set");
      invariant2(Array.isArray(_auditors), "getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array");
      let FlowInteractionAuditContract = opts.flowInteractionAuditContract;
      if (!FlowInteractionAuditContract) {
        const fclNetwork = await getChainId(opts);
        invariant2(fclNetwork === "mainnet" || fclNetwork === "testnet", "getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'");
        if (fclNetwork === "mainnet") {
          FlowInteractionAuditContract = "0xfd100e39d50a13e6";
        } else {
          FlowInteractionAuditContract = "0xf78bfc12d0a786dc";
        }
      }
      const audits = await query({
        cadence: `
        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}
        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {
          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)
        }
        `,
        args: (arg2, t) => [arg2(recomputedTemplateID, t.String), arg2(_auditors, t.Array(t.Address))]
      });
      return audits;
    default:
      throw new Error("getInteractionTemplateAudits Error: Unsupported template version");
  }
}
async function generateDependencyPin100(_ref) {
  let {
    address,
    contractName
  } = _ref;
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  invariant2(address != void 0, "generateDependencyPin({ address }) -- address must be defined");
  invariant2(contractName != void 0, "generateDependencyPin({ contractName }) -- contractName must be defined");
  invariant2(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
  invariant2(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
  const horizon = [generateImport({
    contractName,
    address
  })];
  for (const horizonImport of horizon) {
    const account2 = await send3([getAccount(await config2().get(horizonImport.address, horizonImport.address))], opts).then(decode);
    horizonImport.contract = account2.contracts?.[horizonImport.contractName];
    if (!horizonImport.contract) {
      console.error("Did not find expected contract", horizonImport, account2);
      throw new Error("Did not find expected contract");
    }
    const contractImports = findImports(horizonImport.contract);
    horizon.push(...contractImports);
  }
  const contractHashes = horizon.map((iport) => genHash(iport.contract));
  const contractHashesJoined = contractHashes.join("");
  return genHash(contractHashesJoined);
}
async function generateDependencyPin(_ref) {
  let {
    version: version2,
    address,
    contractName
  } = _ref;
  invariant2(address != void 0, "generateDependencyPin({ address }) -- address must be defined");
  invariant2(contractName != void 0, "generateDependencyPin({ contractName }) -- contractName must be defined");
  invariant2(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
  invariant2(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
  switch (version2) {
    case "1.1.0":
      return await generateDependencyPin110({
        address,
        contractName
      });
    case "1.0.0":
      return await generateDependencyPin100({
        address,
        contractName
      });
    default:
      throw new Error("deriveCadenceByNetwork Error: Unsupported template version");
  }
}
async function generateDependencyPinAtLatestSealedBlock(_ref2) {
  let {
    version: version2,
    address,
    contractName
  } = _ref2;
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const latestSealedBlock = await block({
    sealed: true
  }, opts);
  const latestSealedBlockHeight = latestSealedBlock?.height;
  return generateDependencyPin({
    version: version2,
    address,
    contractName,
    blockHeight: latestSealedBlockHeight
  });
}
async function verifyDependencyPinsSame(_ref) {
  let {
    template: template2,
    blockHeight,
    network
  } = _ref;
  invariant2(template2 != void 0, "generateDependencyPin({ template }) -- template must be defined");
  invariant2(typeof template2 === "object", "generateDependencyPin({ template }) -- template must be an object");
  invariant2(template2.f_type === "InteractionTemplate", "generateDependencyPin({ template }) -- template must be an InteractionTemplate");
  invariant2(network != void 0, "generateDependencyPin({ network }) network must be defined");
  invariant2(blockHeight != void 0, "generateDependencyPin({ blockHeight }) blockHeight must be defined");
  invariant2(typeof blockHeight === "number", "generateDependencyPin({ blockHeight }) blockHeight must be a number");
  switch (template2.f_version) {
    case "1.0.0":
      const templateDependenciesPlaceholderKeys = Object.keys(template2.data.dependencies);
      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {
        const templateDependencyPlaceholder = template2.data.dependencies[templateDependencyPlaceholderKey];
        const templateDependencyPlaceholderContractNames = Object.keys(templateDependencyPlaceholder);
        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {
          const templateDependencyPlaceholderContractNetworks = template2.data.dependencies[templateDependencyPlaceholderKey][templateDependencyPlaceholderContractName];
          const templateDependency = templateDependencyPlaceholderContractNetworks[network];
          if (typeof templateDependency === "undefined") continue;
          const pin = await generateDependencyPin({
            address: templateDependency.address,
            contractName: templateDependency.contract,
            blockHeight
          });
          if (pin !== templateDependency.pin) {
            log({
              title: "verifyDependencyPinsSame Debug Error",
              message: `Could not recompute and match dependency pin.
                                address: ${templateDependency.address} | contract: ${templateDependency.contract}
                                computed: ${pin}
                                template: ${templateDependency.pin}
                            `,
              level: LEVELS.debug
            });
            return false;
          }
        }
      }
      return true;
    case "1.1.0":
      let isVerified = false;
      for (let i = 0; i < template2.data?.dependencies.length; i++) {
        const dependency = template2.data?.dependencies[i];
        for (let j = 0; j < dependency?.contracts.length; j++) {
          const contract = dependency?.contracts[j];
          for (let k = 0; k < contract?.networks.length; k++) {
            const net = contract?.networks[k];
            if (net.network === network) {
              const pin = await generateDependencyPin({
                version: template2.f_version,
                address: net.address,
                contractName: contract.contract,
                blockHeight
              });
              if (pin !== net.dependency_pin.pin) {
                log({
                  title: "verifyDependencyPinsSame Debug Error",
                  message: `Could not recompute and match dependency pin.
                                    address: ${net.address} | contract: ${contract.contract}
                                    computed: ${pin}
                                    template: ${net.pin}
                                `,
                  level: LEVELS.debug
                });
                return false;
              } else {
                isVerified = true;
              }
            }
          }
        }
      }
      return isVerified;
    default:
      throw new Error("verifyDependencyPinsSame Error: Unsupported template version");
  }
}
async function verifyDependencyPinsSameAtLatestSealedBlock(_ref2) {
  let {
    template: template2,
    network
  } = _ref2;
  const latestSealedBlock = await block({
    sealed: true
  });
  const latestSealedBlockHeight = latestSealedBlock?.height;
  return verifyDependencyPinsSame({
    template: template2,
    network,
    blockHeight: latestSealedBlockHeight
  });
}
function getTemplateMessage(_ref) {
  let {
    localization = "en-US",
    messageKey,
    template: template2
  } = _ref;
  invariant2(messageKey, "getTemplateMessage({ messageKey }) -- messageKey must be defined");
  invariant2(typeof messageKey === "string", "getTemplateMessage({ messageKey }) -- messageKey must be a string");
  invariant2(localization, "getTemplateMessage({ localization }) -- localization must be defined");
  invariant2(typeof localization === "string", "getTemplateMessage({ localization }) -- localization must be a string");
  invariant2(template2 != void 0, "getTemplateMessage({ template }) -- template must be defined");
  invariant2(typeof template2 === "object", "getTemplateMessage({ template }) -- template must be an object");
  invariant2(typeof template2.f_type === "InteractionTemplate", "getTemplateMessage({ template }) -- template object must be an InteractionTemplate");
  switch (template2.f_version) {
    case "1.1.0":
      const msg = template2?.data?.messages?.find((a) => a.key === messageKey);
      if (!msg) return void 0;
      const lzn = msg?.i18n?.find((a) => a.tag === localization);
      if (!lzn) return void 0;
      return lzn.translation;
    case "1.0.0":
      return template2?.data?.messages?.[messageKey]?.i18n?.[localization];
    default:
      throw new Error("getTemplateArgumentMessage Error: Unsupported template version");
  }
}
function getTemplateArgumentMessage(_ref) {
  let {
    localization = "en-US",
    argumentLabel,
    messageKey,
    template: template2
  } = _ref;
  invariant2(messageKey, "getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined");
  invariant2(typeof messageKey === "string", "getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string");
  invariant2(argumentLabel, "getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined");
  invariant2(typeof messageKey === "string", "getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string");
  invariant2(localization, "getTemplateArgumentMessage({ localization }) -- localization must be defined");
  invariant2(typeof localization === "string", "getTemplateArgumentMessage({ localization }) -- localization must be a string");
  invariant2(template2 != void 0, "getTemplateArgumentMessage({ template }) -- template must be defined");
  invariant2(typeof template2 === "object", "getTemplateArgumentMessage({ template }) -- template must be an object");
  invariant2(typeof template2.f_type === "InteractionTemplate", "getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate");
  switch (template2.f_version) {
    case "1.1.0":
      const param2 = template2?.data?.parameters?.find((a) => a.label === argumentLabel);
      if (!param2) return void 0;
      const message = param2?.messages?.find((a) => a.key === messageKey);
      if (!message) return void 0;
      const lzn = message?.i18n?.find((a) => a.tag === localization);
      if (!lzn) return void 0;
      return lzn.translation;
    case "1.0.0":
      return template2?.data?.arguments?.[argumentLabel]?.messages?.[messageKey]?.i18n?.[localization];
    default:
      throw new Error("getTemplateArgumentMessage Error: Unsupported template version");
  }
}
var index2 = Object.freeze({
  __proto__: null,
  getInteractionTemplateAudits,
  generateDependencyPin,
  generateDependencyPinAtLatestSealedBlock,
  generateTemplateId,
  verifyGeneratedTemplateId,
  verifyDependencyPinsSame,
  verifyDependencyPinsSameAtLatestSealedBlock,
  deriveCadenceByNetwork,
  getTemplateMessage,
  getTemplateArgumentMessage
});
async function fetchServices(servicesURL, code) {
  if (servicesURL == null || code == null) return [];
  const url = new URL3(servicesURL);
  url.searchParams.append("code", code);
  const resp = await fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  }).then((d) => d.json());
  if (Array.isArray(resp)) return resp;
  const services = [];
  if (Array.isArray(resp.authorizations)) {
    for (let service of resp.authorizations) {
      services.push({
        type: "authz",
        keyId: resp.keyId,
        ...service
      });
    }
  }
  if (resp.provider != null) {
    services.push({
      type: "authn",
      id: "wallet-provider#authn",
      ...resp.provider
    });
  }
  return services;
}
function mergeServices() {
  let sx1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let sx2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return [...sx1, ...sx2];
}
function normalizeAuthn(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.authn,
      id: service.pid,
      provider: {
        address: withPrefix2(service.addr),
        name: service.name,
        icon: service.icon
      }
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeAuthz(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.endpoint,
      method: service.method,
      identity: {
        ...IDENTITY_PRAGMA,
        address: withPrefix2(service.addr),
        keyId: service.keyId
      },
      params: service.params,
      data: service.data
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizePreAuthz(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.endpoint,
      method: service.method,
      identity: {
        ...IDENTITY_PRAGMA,
        address: withPrefix2(service.addr),
        keyId: service.keyId
      },
      params: service.params,
      data: service.data
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeFrame(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      old: service,
      ...SERVICE_PRAGMA,
      type: "frame",
      endpoint: service.endpoint,
      params: service.params || {},
      data: service.data || {}
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeBackChannelRpc(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: "back-channel-rpc",
      endpoint: service.endpoint,
      method: service.method,
      params: service.params || {},
      data: service.data || {}
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeOpenId(service) {
  if (service == null) return null;
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeUserSignature(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error("Invalid user-signature service");
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeLocalView(resp) {
  if (resp == null) return null;
  if (resp.method == null) {
    resp = {
      ...resp,
      type: "local-view",
      method: "VIEW/IFRAME"
    };
  }
  if (!resp["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: resp.type || "local-view",
      method: resp.method,
      endpoint: resp.endpoint,
      data: resp.data || {},
      params: resp.params || {}
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}
function normalizeAccountProof(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error(`FCL Normalizer Error: Invalid account-proof service`);
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeAuthnRefresh(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error("Invalid authn-refresh service");
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}
function normalizeServices(services, data) {
  return services.map((service) => normalizeService(service, data)).filter(Boolean);
}
var serviceNormalizers = {
  "back-channel-rpc": normalizeBackChannelRpc,
  "pre-authz": normalizePreAuthz,
  authz: normalizeAuthz,
  authn: normalizeAuthn,
  frame: normalizeFrame,
  "open-id": normalizeOpenId,
  "user-signature": normalizeUserSignature,
  "local-view": normalizeLocalView,
  "account-proof": normalizeAccountProof,
  "authn-refresh": normalizeAuthnRefresh
};
function normalizeService(service, data) {
  try {
    var normalized = serviceNormalizers[service.type](service, data);
    return normalized;
  } catch (error) {
    console.error(`Unrecognized FCL Service Type [${service.type}]`, service, error);
    return service;
  }
}
function serviceOfType() {
  let services = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let type = arguments.length > 1 ? arguments[1] : void 0;
  return services.reduce((mostRecent, service) => service.type === type ? !mostRecent || compare(service.f_vsn, mostRecent.f_vsn) > 0 ? service : mostRecent : mostRecent, null);
}
function deriveCompositeId(authn) {
  return encode([authn.provider.address || authn.provider.name || "UNSPECIFIED", authn.id]).toString("hex");
}
function normalizeData(data) {
  data.addr = data.addr ? withPrefix2(data.addr) : null;
  data.paddr = data.paddr ? withPrefix2(data.paddr) : null;
  return data;
}
async function buildUser(data) {
  data = normalizeData(data);
  var services = normalizeServices(mergeServices(data.services || [], await fetchServices(data.hks, data.code)));
  const authn = serviceOfType(services, "authn");
  return {
    ...USER_PRAGMA,
    addr: withPrefix2(data.addr),
    cid: deriveCompositeId(authn),
    loggedIn: true,
    services,
    expiresAt: data.expires
  };
}
var execStrategy = async (_ref) => {
  let {
    service,
    body,
    config: config3,
    opts
  } = _ref;
  const strategy = getServiceRegistry().getStrategy(service.method);
  return strategy({
    service,
    body,
    config: config3,
    opts
  });
};
async function execService(_ref2) {
  let {
    service,
    msg = {},
    config: config3 = {},
    opts = {},
    platform
  } = _ref2;
  msg.data = service.data;
  const execConfig = {
    services: await configLens(/^service\./),
    app: await configLens(/^app\.detail\./),
    client: {
      ...config3.client,
      platform,
      fclVersion: VERSION,
      fclLibrary: "https://github.com/onflow/fcl-js",
      hostname: window?.location?.hostname ?? null,
      network: await getChainId(opts)
    }
  };
  try {
    const res = await execStrategy({
      service,
      body: msg,
      config: execConfig,
      opts
    });
    if (res.status === "REDIRECT") {
      invariant(service.type === res.data.type, "Cannot shift recursive service type in execService");
      return await execService({
        service: res.data,
        msg,
        config: execConfig,
        opts
      });
    } else {
      return res;
    }
  } catch (error) {
    log({
      title: `Error on execService ${service?.type}`,
      message: error,
      level: LEVELS.error
    });
    throw error;
  }
}
function normalizeCompositeSignature(resp) {
  if (resp == null) return null;
  if (!resp["f_vsn"]) {
    return {
      ...COMPOSITE_SIGNATURE_PRAGMA,
      addr: sansPrefix(resp.addr || resp.address),
      signature: resp.signature || resp.sig,
      keyId: resp.keyId
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}
var isFn2 = (d) => typeof d === "function";
var NAME2 = "CURRENT_USER";
var UPDATED3 = "CURRENT_USER/UPDATED";
var SNAPSHOT2 = "SNAPSHOT";
var SET_CURRENT_USER = "SET_CURRENT_USER";
var DEL_CURRENT_USER = "DEL_CURRENT_USER";
var DATA = `{
  "f_type": "User",
  "f_vsn": "1.0.0",
  "addr":null,
  "cid":null,
  "loggedIn":null,
  "expiresAt":null,
  "services":[]
}`;
var getStoredUser = async (storage) => {
  const fallback = JSON.parse(DATA);
  const stored = await storage.get(NAME2);
  if (stored != null && fallback["f_vsn"] !== stored["f_vsn"]) {
    storage.removeItem(NAME2);
    return fallback;
  }
  return stored || fallback;
};
var HANDLERS2 = {
  [INIT]: async (ctx) => {
    if (typeof window === "undefined") {
      console.warn(`
        %cFCL Warning
        ============================
        "currentUser" is only available in the browser.
        For more info, please see the docs: https://docs.onflow.org/fcl/
        ============================
        `, "font-weight:bold;font-family:monospace;");
    }
    ctx.merge(JSON.parse(DATA));
    const storage = await config2.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) {
      const user = await getStoredUser(storage);
      if (notExpired(user)) ctx.merge(user);
    }
  },
  [SUBSCRIBE]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED3, {
      ...ctx.all()
    });
  },
  [UNSUBSCRIBE]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
  },
  [SNAPSHOT2]: async (ctx, letter) => {
    letter.reply({
      ...ctx.all()
    });
  },
  [SET_CURRENT_USER]: async (ctx, letter, data) => {
    ctx.merge(data);
    const storage = await config2.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) storage.put(NAME2, ctx.all());
    ctx.broadcast(UPDATED3, {
      ...ctx.all()
    });
  },
  [DEL_CURRENT_USER]: async (ctx, letter) => {
    ctx.merge(JSON.parse(DATA));
    const storage = await config2.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) storage.put(NAME2, ctx.all());
    ctx.broadcast(UPDATED3, {
      ...ctx.all()
    });
  }
};
var spawnCurrentUser = () => spawn(HANDLERS2, NAME2);
function notExpired(user) {
  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();
}
async function getAccountProofData() {
  let accountProofDataResolver = await config2.get("fcl.accountProof.resolver");
  if (accountProofDataResolver == null) return;
  if (!isFn2(accountProofDataResolver)) {
    log({
      title: "Account Proof Data Resolver must be a function",
      message: `Check fcl.accountProof.resolver configuration.
                Expected: fcl.accountProof.resolver: async () => { ... }
                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}
                `,
      level: LEVELS.warn
    });
    return;
  }
  const accountProofData = await accountProofDataResolver();
  if (accountProofData == null) return;
  invariant(typeof accountProofData.appIdentifier === "string", "appIdentifier must be a string");
  invariant(/^[0-9a-f]+$/i.test(accountProofData.nonce), "Nonce must be a hex string");
  return accountProofData;
}
var makeConfig = async (_ref) => {
  let {
    discoveryAuthnInclude,
    discoveryFeaturesSuggested
  } = _ref;
  return {
    client: {
      discoveryAuthnInclude,
      discoveryFeaturesSuggested,
      clientServices: await makeDiscoveryServices(),
      supportedStrategies: getServiceRegistry().getStrategies()
    }
  };
};
var getAuthenticate = (_ref2) => {
  let {
    platform
  } = _ref2;
  return async function() {
    let {
      service,
      redir = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (service && !service?.provider?.is_installed && service?.provider?.requires_install) {
      window.location.href = service?.provider?.install_link;
      return;
    }
    return new Promise(async (resolve2, reject) => {
      spawnCurrentUser();
      const opts = {
        redir
      };
      const user = await snapshot();
      const discoveryService = await getDiscoveryService(service);
      const refreshService = serviceOfType(user.services, "authn-refresh");
      let accountProofData;
      if (user.loggedIn) {
        if (refreshService) {
          try {
            const response2 = await execService({
              service: refreshService,
              msg: accountProofData,
              opts,
              platform
            });
            send(NAME2, SET_CURRENT_USER, await buildUser(response2));
          } catch (error) {
            log({
              title: `${error.name} Could not refresh wallet authentication.`,
              message: error.message,
              level: LEVELS.error
            });
          } finally {
            return resolve2(await snapshot());
          }
        } else {
          return resolve2(user);
        }
      }
      try {
        accountProofData = await getAccountProofData();
      } catch (error) {
        log({
          title: `${error.name} On Authentication: Could not resolve account proof data.`,
          message: error.message,
          level: LEVELS.error
        });
        return reject(error);
      }
      try {
        const response2 = await execService({
          service: discoveryService,
          msg: accountProofData,
          config: await makeConfig(discoveryService),
          opts,
          platform
        });
        send(NAME2, SET_CURRENT_USER, await buildUser(response2));
      } catch (error) {
        log({
          title: `${error} On Authentication`,
          message: error,
          level: LEVELS.error
        });
      } finally {
        resolve2(await snapshot());
      }
    });
  };
};
function unauthenticate() {
  spawnCurrentUser();
  send(NAME2, DEL_CURRENT_USER);
}
var normalizePreAuthzResponse = (authz2) => ({
  f_type: "PreAuthzResponse",
  f_vsn: "1.0.0",
  proposer: (authz2 || {}).proposer,
  payer: (authz2 || {}).payer || [],
  authorization: (authz2 || {}).authorization || []
});
var getResolvePreAuthz = (_ref3) => {
  let {
    platform
  } = _ref3;
  return (authz2) => {
    const resp = normalizePreAuthzResponse(authz2);
    const axs = [];
    if (resp.proposer != null) axs.push(["PROPOSER", resp.proposer]);
    for (let az of resp.payer || []) axs.push(["PAYER", az]);
    for (let az of resp.authorization || []) axs.push(["AUTHORIZER", az]);
    var result = axs.map((_ref4) => {
      let [role, az] = _ref4;
      return {
        tempId: [az.identity.address, az.identity.keyId].join("|"),
        addr: az.identity.address,
        keyId: az.identity.keyId,
        signingFunction(signable) {
          return execService({
            service: az,
            msg: signable,
            platform
          });
        },
        role: {
          proposer: role === "PROPOSER",
          payer: role === "PAYER",
          authorizer: role === "AUTHORIZER"
        }
      };
    });
    return result;
  };
};
var getAuthorization = (_ref5) => {
  let {
    platform
  } = _ref5;
  return async (account2) => {
    spawnCurrentUser();
    return {
      ...account2,
      tempId: "CURRENT_USER",
      async resolve(account3, preSignable) {
        const user = await getAuthenticate({
          platform
        })({
          redir: true
        });
        const authz2 = serviceOfType(user.services, "authz");
        const preAuthz = serviceOfType(user.services, "pre-authz");
        if (preAuthz) return getResolvePreAuthz({
          platform
        })(await execService({
          service: preAuthz,
          msg: preSignable,
          platform
        }));
        if (authz2) {
          let windowRef;
          if (isMobile2() && authz2.method === "WC/RPC") {
            windowRef = window.open("", "_blank");
          }
          return {
            ...account3,
            tempId: "CURRENT_USER",
            resolve: null,
            addr: sansPrefix(authz2.identity.address),
            keyId: authz2.identity.keyId,
            sequenceNum: null,
            signature: null,
            async signingFunction(signable) {
              return normalizeCompositeSignature(await execService({
                service: authz2,
                msg: signable,
                opts: {
                  includeOlderJsonRpcCall: true,
                  windowRef
                },
                platform
              }));
            }
          };
        }
        throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER");
      }
    };
  };
};
function subscribe2(callback) {
  spawnCurrentUser();
  const EXIT2 = "@EXIT";
  const self2 = spawn(async (ctx) => {
    ctx.send(NAME2, SUBSCRIBE);
    while (1) {
      const letter = await ctx.receive();
      if (letter.tag === EXIT2) {
        ctx.send(NAME2, UNSUBSCRIBE);
        return;
      }
      callback(letter.data);
    }
  });
  return () => send(self2, EXIT2);
}
function snapshot() {
  spawnCurrentUser();
  return send(NAME2, SNAPSHOT2, null, {
    expectReply: true,
    timeout: 0
  });
}
var getResolveArgument = (_ref6) => {
  let {
    platform
  } = _ref6;
  return async () => {
    const {
      addr
    } = await getAuthenticate({
      platform
    })();
    return arg(withPrefix2(addr), Address);
  };
};
var makeSignable = (msg) => {
  invariant(/^[0-9a-f]+$/i.test(msg), "Message must be a hex string");
  return {
    message: msg
  };
};
var getSignUserMessage = (_ref7) => {
  let {
    platform
  } = _ref7;
  return async (msg) => {
    spawnCurrentUser();
    const user = await getAuthenticate({
      platform
    })({
      redir: true
    });
    const signingService = serviceOfType(user.services, "user-signature");
    invariant(signingService, "Current user must have authorized a signing service.");
    try {
      const response2 = await execService({
        service: signingService,
        msg: makeSignable(msg),
        platform
      });
      if (Array.isArray(response2)) {
        return response2.map((compSigs) => normalizeCompositeSignature(compSigs));
      } else {
        return [normalizeCompositeSignature(response2)];
      }
    } catch (error) {
      return error;
    }
  };
};
var getCurrentUser = (_ref8) => {
  let {
    platform
  } = _ref8;
  let currentUser2 = () => {
    return {
      authenticate: getAuthenticate({
        platform
      }),
      unauthenticate,
      authorization: getAuthorization({
        platform
      }),
      signUserMessage: getSignUserMessage({
        platform
      }),
      subscribe: subscribe2,
      snapshot,
      resolveArgument: getResolveArgument({
        platform
      })
    };
  };
  currentUser2.authenticate = getAuthenticate({
    platform
  });
  currentUser2.unauthenticate = unauthenticate;
  currentUser2.authorization = getAuthorization({
    platform
  });
  currentUser2.signUserMessage = getSignUserMessage({
    platform
  });
  currentUser2.subscribe = subscribe2;
  currentUser2.snapshot = snapshot;
  currentUser2.resolveArgument = getResolveArgument({
    platform
  });
  return currentUser2;
};
var getMutate = (_ref) => {
  let {
    platform
  } = _ref;
  const mutate2 = async function() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var txid;
    try {
      await preMutate(opts);
      opts = await prepTemplateOpts(opts);
      const currentUser2 = getCurrentUser({
        platform
      });
      const authz2 = await config2().get("fcl.authz", currentUser2().authorization);
      txid = config2().overload(opts.dependencies || {}, async () => (
        // prettier-ignore
        send3([
          transaction(opts.cadence),
          args(normalizeArgs(opts.args || [])),
          opts.limit && isNumber3(opts.limit) && limit(opts.limit),
          // opts.proposer > opts.authz > authz
          proposer(opts.proposer || opts.authz || authz2),
          // opts.payer > opts.authz > authz
          payer(opts.payer || opts.authz || authz2),
          // opts.authorizations > [opts.authz > authz]
          authorizations(opts.authorizations || [opts.authz || authz2])
        ]).then(decode)
      ));
      return txid;
    } catch (error) {
      throw error;
    }
  };
  return mutate2;
};
function serviceEndpoint(service) {
  const url = new URL3(service.endpoint);
  if (window?.location?.origin) {
    url.searchParams.append("l6n", window.location.origin);
  }
  if (service.params != null) {
    for (let [key, value] of Object.entries(service.params || {})) {
      url.searchParams.append(key, value);
    }
  }
  return url;
}
function fetchService(service) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const method = opts.method || "POST";
  const body = method === "GET" ? void 0 : JSON.stringify(opts.data || service.data || {});
  return fetch(serviceEndpoint(service), {
    method,
    headers: {
      ...service.headers || {},
      ...opts.headers || {},
      "Content-Type": "application/json"
    },
    body
  }).then((d) => d.json());
}
function normalizePollingResponse(resp) {
  if (resp == null) return null;
  if (!resp["f_vsn"]) {
    return {
      ...POLLING_RESPONSE_PRAGMA,
      status: resp.status ?? "APPROVED",
      reason: resp.reason ?? null,
      data: resp.compositeSignature || resp.data || {
        ...resp
      },
      updates: normalizeBackChannelRpc(resp.authorizationUpdates),
      local: normalizeFrame((resp.local || [])[0])
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}
var OPTIONS = {
  "HTTP/GET": "GET",
  "HTTP/POST": "POST"
};
var serviceMethod = (service) => {
  invariant(OPTIONS[service.method], "Invalid Service Method for type back-channel-rpc", {
    service
  });
  return OPTIONS[service.method];
};
async function poll(service) {
  let checkCanContinue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => true;
  invariant(service, "Missing Polling Service", {
    service
  });
  const canContinue = checkCanContinue();
  if (!canContinue) throw new Error("Externally Halted");
  let resp;
  try {
    if (typeof document !== "undefined" && document.visibilityState === "hidden") {
      await new Promise((r) => setTimeout(r, 500));
      return poll(service, checkCanContinue);
    }
    resp = await fetchService(service, {
      method: serviceMethod(service)
    }).then(normalizePollingResponse);
  } catch (error) {
    throw error;
  }
  switch (resp.status) {
    case "APPROVED":
      return resp.data;
    case "DECLINED":
      throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);
    default:
      await new Promise((r) => setTimeout(r, 500));
      return poll(resp.updates, checkCanContinue);
  }
}
var getExecHttpPost = (execLocal2) => async (_ref) => {
  let {
    service,
    body,
    config: config3,
    opts
  } = _ref;
  const resp = await fetchService(service, {
    data: {
      fclVersion: VERSION,
      service: {
        params: service.params,
        data: service.data,
        type: service.type
      },
      config: config3,
      ...body
    }
  }).then(normalizePollingResponse);
  if (resp.status === "APPROVED") {
    return resp.data;
  } else if (resp.status === "DECLINED") {
    throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);
  } else if (resp.status === "REDIRECT") {
    return resp;
  } else if (resp.status === "PENDING") {
    var canContinue = true;
    var shouldContinue = true;
    const [_2, unmount] = await execLocal2(normalizeLocalView(resp.local), {
      serviceEndpoint,
      onClose: () => shouldContinue = false
    });
    const close2 = () => {
      try {
        unmount();
        shouldContinue = false;
      } catch (error) {
        console.error("Frame Close Error", error);
      }
    };
    const checkCanContinue = () => {
      const offsetCanContinue = canContinue;
      canContinue = shouldContinue;
      return offsetCanContinue;
    };
    return poll(resp.updates, checkCanContinue).then((serviceResponse) => {
      close2();
      return serviceResponse;
    }).catch((error) => {
      console.error(error);
      close2();
      throw error;
    });
  } else {
    console.error(`Auto Decline: Invalid Response`, {
      service,
      resp
    });
    throw new Error(`Auto Decline: Invalid Response`);
  }
};
var CLOSE_EVENT = "FCL:VIEW:CLOSE";
var READY_EVENT = "FCL:VIEW:READY";
var RESPONSE_EVENT = "FCL:VIEW:RESPONSE";
var _ = (e) => typeof e === "string" && e.toLowerCase();
var IGNORE = /* @__PURE__ */ new Set(["monetizationstart", "monetizationpending", "monetizationprogress", "monetizationstop"]);
var deprecate = (was, want) => console.warn("DEPRECATION NOTICE", `Received ${was}, please use ${want} for this and future versions of FCL`);
var buildMessageHandler = (_ref) => {
  let {
    close: close2,
    send: send4,
    onReady,
    onResponse,
    onMessage
  } = _ref;
  return (e) => {
    try {
      if (typeof e.data !== "object") return;
      if (IGNORE.has(e.data.type)) return;
      if (_(e.data.type) === _(CLOSE_EVENT)) close2();
      if (_(e.data.type) === _(READY_EVENT)) onReady(e, {
        send: send4,
        close: close2
      });
      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {
        send: send4,
        close: close2
      });
      onMessage(e, {
        send: send4,
        close: close2
      });
      if (_(e.data.type) === _("FCL:FRAME:READY")) {
        deprecate(e.data.type, READY_EVENT);
        onReady(e, {
          send: send4,
          close: close2
        });
      }
      if (_(e.data.type) === _("FCL:FRAME:RESPONSE")) {
        deprecate(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send: send4,
          close: close2
        });
      }
      if (_(e.data.type) === _("FCL:FRAME:CLOSE")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close2();
      }
      if (_(e.data.type) === _("FCL::CHALLENGE::RESPONSE")) {
        deprecate(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send: send4,
          close: close2
        });
      }
      if (_(e.data.type) === _("FCL::AUTHZ_READY")) {
        deprecate(e.data.type, READY_EVENT);
        onReady(e, {
          send: send4,
          close: close2
        });
      }
      if (_(e.data.type) === _("FCL::CHALLENGE::CANCEL")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close2();
      }
      if (_(e.data.type) === _("FCL::CANCEL")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close2();
      }
    } catch (error) {
      console.error("Frame Callback Error", error);
      close2();
    }
  };
};
watchForChainIdChanges();

// node_modules/@onflow/util-uid/dist/util-uid.module.js
var HEX = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
var T = HEX.length;
function uid() {
  let str = "", num = 32;
  while (num--) str += HEX[Math.random() * T | 0];
  return str;
}

// node_modules/@onflow/fcl/dist/fcl.module.js
var FRAME = "FCL_IFRAME";
var FRAME_STYLES = `
  position:fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  height: 100%;
  width: 100vw;
  display:block;
  background:rgba(0,0,0,0.25);
  z-index: 2147483647;
  box-sizing: border-box;
  color-scheme: light;
`;
function renderFrame(src) {
  invariant(!document.getElementById(FRAME), "Attempt at triggering multiple Frames", {
    src
  });
  const $frame = document.createElement("iframe");
  $frame.src = src;
  $frame.id = FRAME;
  $frame.allow = "usb *; hid *";
  $frame.frameBorder = "0";
  $frame.style.cssText = FRAME_STYLES;
  document.body.append($frame);
  const unmount = () => {
    if (document.getElementById(FRAME)) {
      document.getElementById(FRAME).remove();
    }
  };
  return [$frame.contentWindow, unmount];
}
var POP = "FCL_POP";
var popup = null;
var previousUrl$1 = null;
function popupWindow(url, windowName, win, w, h) {
  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;
  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;
  const popup2 = win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);
  if (!popup2) throw new Error("Popup failed to open (was it blocked by a popup blocker?)");
  return popup2;
}
function renderPop(src) {
  if (popup == null || popup?.closed) {
    popup = popupWindow(src, POP, window, 640, 770);
  } else if (previousUrl$1 !== src) {
    popup.location.replace(src);
    popup.focus();
  } else {
    popup.focus();
  }
  previousUrl$1 = src;
  const unmount = () => {
    if (popup && !popup.closed) {
      popup.close();
    }
    popup = null;
  };
  return [popup, unmount];
}
var tab$1 = null;
var previousUrl = null;
function renderTab(src) {
  if (tab$1 == null || tab$1?.closed) {
    tab$1 = window.open(src, "_blank");
    if (!tab$1) throw new Error("Tab failed to open (was it blocked by the browser?)");
  } else if (previousUrl !== src) {
    tab$1.location.replace(src);
    tab$1.focus();
  } else {
    tab$1.focus();
  }
  previousUrl = src;
  const unmount = () => {
    if (tab$1 && !tab$1.closed) {
      tab$1.close();
    }
    tab$1 = null;
  };
  return [tab$1, unmount];
}
var isServerSide = () => typeof window === "undefined";
var getSessionStorage = () => {
  try {
    const SESSION_STORAGE = {
      can: !isServerSide(),
      get: async (key) => JSON.parse(sessionStorage.getItem(key)),
      put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))
    };
    return SESSION_STORAGE;
  } catch (error) {
    return null;
  }
};
var getDefaultConfig = () => {
  return {
    "discovery.wallet.method.default": "IFRAME/RPC",
    "fcl.storage.default": getSessionStorage()
  };
};
var noop$3 = () => {
};
function frame(service) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (service == null) return {
    send: noop$3,
    close: noop$3
  };
  const onClose = opts.onClose || noop$3;
  const onMessage = opts.onMessage || noop$3;
  const onReady = opts.onReady || noop$3;
  const onResponse = opts.onResponse || noop$3;
  const handler = buildMessageHandler({
    close: close2,
    send: send4,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  const [$frame, unmount] = renderFrame(serviceEndpoint(service));
  return {
    send: send4,
    close: close2
  };
  function close2() {
    try {
      window.removeEventListener("message", handler);
      unmount();
      onClose();
    } catch (error) {
      console.error("Frame Close Error", error);
    }
  }
  function send4(msg) {
    try {
      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Frame Send Error", msg, error);
    }
  }
}
var VERSION2 = "1.10.0";
function execIframeRPC(_ref) {
  let {
    service,
    body,
    config: config3,
    opts
  } = _ref;
  return new Promise((resolve2, reject) => {
    const id = uid();
    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    frame(service, {
      async onReady(_2, _ref2) {
        let {
          send: send4
        } = _ref2;
        try {
          send4({
            type: "FCL:VIEW:READY:RESPONSE",
            fclVersion: VERSION2,
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config: config3
          });
          send4({
            fclVersion: VERSION2,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config: config3,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send4({
              jsonrpc: "2.0",
              id,
              method: "fcl:sign",
              params: [body, service.params],
              deprecated: {
                message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });
          }
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close: close2
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve2(resp.data);
              close2();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close2();
              break;
            case "REDIRECT":
              resolve2(resp);
              close2();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close2();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close: close2
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve2(resp.data);
              close2();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close2();
              break;
            case "REDIRECT":
              resolve2(resp);
              close2();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close2();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}
var noop$2 = () => {
};
function pop(service) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (service == null) return {
    send: noop$2,
    close: noop$2
  };
  const onClose = opts.onClose || noop$2;
  const onMessage = opts.onMessage || noop$2;
  const onReady = opts.onReady || noop$2;
  const onResponse = opts.onResponse || noop$2;
  const handler = buildMessageHandler({
    close: close2,
    send: send4,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  const [$pop, unmount] = renderPop(serviceEndpoint(service));
  const timer = setInterval(function() {
    if ($pop && $pop.closed) {
      close2();
    }
  }, 500);
  return {
    send: send4,
    close: close2
  };
  function close2() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Popup Close Error", error);
    }
  }
  function send4(msg) {
    try {
      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Popup Send Error", msg, error);
    }
  }
}
function execPopRPC(_ref) {
  let {
    service,
    body,
    config: config3,
    opts
  } = _ref;
  return new Promise((resolve2, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    pop(service, {
      async onReady(_2, _ref2) {
        let {
          send: send4
        } = _ref2;
        try {
          send4({
            fclVersion: VERSION2,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config: config3
          });
          send4({
            fclVersion: VERSION2,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config: config3,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send4({
              jsonrpc: "2.0",
              id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close: close2
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve2(resp.data);
              !redir && close2();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close2();
              break;
            case "REDIRECT":
              resolve2(resp);
              close2();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close2();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close: close2
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve2(resp.data);
              !redir && close2();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close2();
              break;
            case "REDIRECT":
              resolve2(resp);
              close2();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close2();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}
var noop$1 = () => {
};
function tab(service) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (service == null) return {
    send: noop$1,
    close: noop$1
  };
  const onClose = opts.onClose || noop$1;
  const onMessage = opts.onMessage || noop$1;
  const onReady = opts.onReady || noop$1;
  const onResponse = opts.onResponse || noop$1;
  const handler = buildMessageHandler({
    close: close2,
    send: send4,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  const [$tab, unmount] = renderTab(serviceEndpoint(service));
  const timer = setInterval(function() {
    if ($tab && $tab.closed) {
      close2();
    }
  }, 500);
  return {
    send: send4,
    close: close2
  };
  function close2() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Tab Close Error", error);
    }
  }
  function send4(msg) {
    try {
      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Tab Send Error", msg, error);
    }
  }
}
function execTabRPC(_ref) {
  let {
    service,
    body,
    config: config3,
    opts
  } = _ref;
  return new Promise((resolve2, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    tab(service, {
      async onReady(_2, _ref2) {
        let {
          send: send4
        } = _ref2;
        try {
          send4({
            fclVersion: VERSION2,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config: config3
          });
          send4({
            fclVersion: VERSION2,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config: config3,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send4({
              jsonrpc: "2.0",
              id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close: close2
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve2(resp.data);
              !redir && close2();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close2();
              break;
            case "REDIRECT":
              resolve2(resp);
              close2();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close2();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close: close2
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve2(resp.data);
              !redir && close2();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close2();
              break;
            case "REDIRECT":
              resolve2(resp);
              close2();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close2();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}
var noop2 = () => {
};
function extension(service) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (service == null) return {
    send: noop2,
    close: noop2
  };
  const onClose = opts.onClose || noop2;
  const onMessage = opts.onMessage || noop2;
  const onReady = opts.onReady || noop2;
  const onResponse = opts.onResponse || noop2;
  const handler = buildMessageHandler({
    close: close2,
    send: send4,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  send4({
    service
  });
  return {
    send: send4,
    close: close2
  };
  function close2() {
    try {
      window.removeEventListener("message", handler);
      onClose();
    } catch (error) {
      console.error("Ext Close Error", error);
    }
  }
  function send4(msg) {
    try {
      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Ext Send Error", msg, error);
    }
  }
}
function execExtRPC(_ref) {
  let {
    service,
    body,
    config: config3,
    opts
  } = _ref;
  return new Promise((resolve2, reject) => {
    extension(service, {
      async onReady(_2, _ref2) {
        let {
          send: send4
        } = _ref2;
        try {
          send4({
            fclVersion: VERSION2,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config: config3
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close: close2
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve2(resp.data);
              close2();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close2();
              break;
            case "REDIRECT":
              resolve2(resp);
              close2();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close2();
              break;
          }
        } catch (error) {
          console.error("execExtRPC onResponse error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}
var NOT_IMPLEMENTED = () => {
  throw new Error("Strategy util has not been implemented on this platform");
};
var VIEWS = {
  "VIEW/IFRAME": renderFrame,
  "VIEW/POP": renderPop,
  "VIEW/TAB": renderTab,
  "VIEW/MOBILE_BROWSER": NOT_IMPLEMENTED,
  "VIEW/DEEPLINK": NOT_IMPLEMENTED
};
async function execLocal(service) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    serviceEndpoint: () => {
    }
  };
  const {
    serviceEndpoint: serviceEndpoint2
  } = opts;
  try {
    return VIEWS[service.method](serviceEndpoint2(service), opts);
  } catch (error) {
    console.error("execLocal({service, opts = {}})", error, {
      service,
      opts
    });
    throw error;
  }
}
var coreStrategies = {
  [CORE_STRATEGIES["HTTP/RPC"]]: getExecHttpPost(execLocal),
  [CORE_STRATEGIES["HTTP/POST"]]: getExecHttpPost(execLocal),
  [CORE_STRATEGIES["IFRAME/RPC"]]: execIframeRPC,
  [CORE_STRATEGIES["POP/RPC"]]: execPopRPC,
  [CORE_STRATEGIES["TAB/RPC"]]: execTabRPC,
  [CORE_STRATEGIES["EXT/RPC"]]: execExtRPC
};
var mutate = getMutate({
  platform: "web"
});
var currentUser = getCurrentUser({
  platform: "web"
});
var authz = currentUser().authorization;
config2(getDefaultConfig());
initServiceRegistry({
  coreStrategies
});

// node_modules/@dynamic-labs/flow/src/utils.js
var flowSendBalanceCadence = `
  import FungibleToken from 0xFT
  import FlowToken from 0xFLOW

  transaction(recepient: Address, amount: UFix64){
    prepare(signer: AuthAccount){
      let sender = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
        ?? panic("Could not borrow Provider reference to the Vault")

      let receiverAccount = getAccount(recepient)

      let receiver = receiverAccount.getCapability(/public/flowTokenReceiver)
        .borrow<&FlowToken.Vault{FungibleToken.Receiver}>()
        ?? panic("Could not borrow Receiver reference to the Vault")

              let tempVault <- sender.withdraw(amount: amount)
      receiver.deposit(from: <- tempVault)
    }
  }
`;

// node_modules/@dynamic-labs/flow/src/wallet/FlowWallet.js
var FlowWallet = class extends Wallet {
  /**
   * Sends the native balance of the wallet to the given address.
   * @param amount - The amount of balance to send (in FLOW).
   * @param toAddress - The address to send the balance to.
   * @returns The transaction id of the sent transaction.
   */
  sendBalance(_a) {
    return __awaiter(this, arguments, void 0, function* ({ amount, toAddress }) {
      yield this._connector.connect();
      const args2 = (arg2, t) => [
        arg2(toAddress, t.Address),
        arg2(amount, t.UFix64)
      ];
      const limit2 = 500;
      const txId = yield mutate({ args: args2, cadence: flowSendBalanceCadence, limit: limit2 });
      return txId;
    });
  }
};

// node_modules/@dynamic-labs/flow/src/FlowWalletConnector.js
var FlowWalletConnector = class extends WalletConnectorBase {
  constructor(opts) {
    var _a;
    super(opts);
    this.ChainWallet = FlowWallet;
    this.connectedChain = "FLOW";
    this.supportedChains = ["FLOW"];
    this.appName = opts.appName;
    this.appLogoUrl = opts.appLogoUrl;
    this.network = (_a = opts.flowNetwork) !== null && _a !== void 0 ? _a : "mainnet";
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.setupConfig();
      const { addr } = yield currentUser().authenticate();
      if (addr && addr !== this.currentAccount) {
        this.currentAccount = addr;
        this.emit("accountChange", { accounts: [addr] });
      }
    });
  }
  getNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  setupConfig() {
    return __awaiter(this, void 0, void 0, function* () {
      yield config2().put("app.detail.title", this.appName).put("app.detail.icon", this.appLogoUrl).put("accessNode.api", this.network === "testnet" ? "https://rest-testnet.onflow.org" : "https://rest-mainnet.onflow.org").put("flow.network", this.network);
    });
  }
  getAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.connect();
        const user = yield currentUser().snapshot();
        return user.addr;
      } catch (error) {
        logger.error(error);
        return void 0;
      }
    });
  }
  proveOwnership(address, messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(address);
      try {
        yield this.connect();
        yield this.signDelay();
        const signedMessage = yield this.signMessage(messageToSign);
        if (!signedMessage) {
          return void 0;
        }
        const data = {
          appName: this.appName,
          signedMessage: JSON.parse(signedMessage)
        };
        return JSON.stringify(data);
      } catch (error) {
        logger.error(error);
        return void 0;
      }
    });
  }
  signMessage(messageToSign) {
    return __awaiter(this, void 0, void 0, function* () {
      const message = Buffer.from(messageToSign).toString("hex");
      const signedMessage = yield currentUser().signUserMessage(message);
      if (signedMessage.includes("Declined")) {
        throw new DynamicError("User declined the signature");
      }
      return JSON.stringify(signedMessage);
    });
  }
  getBalance(address) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.setupConfig();
      if (address) {
        const code = `
      pub fun main(): UFix64 {
        let account = getAccount(${address});
        return account.balance;
      }
      `;
        try {
          return yield send3([script(code)]).then(decode);
        } catch (error) {
          logger.error(error);
          return void 0;
        }
      } else {
        return void 0;
      }
    });
  }
  endSession() {
    return __awaiter(this, void 0, void 0, function* () {
      currentUser().unauthenticate();
    });
  }
  switchNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      throw new DynamicError("Not supported");
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const user = yield currentUser().snapshot();
      if (user.addr) {
        return [user.addr];
      }
      return [];
    });
  }
  signDelay() {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      return ["https://flowscan.io/"];
    });
  }
};

// node_modules/@dynamic-labs/flow/src/blocto.js
var Blocto = class extends FlowWalletConnector {
  constructor() {
    super(...arguments);
    this.name = "Blocto";
    this.overrideKey = "blocto";
    this.canConnectViaCustodialService = true;
  }
  setupConfig() {
    const _super = Object.create(null, {
      setupConfig: { get: () => super.setupConfig }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super.setupConfig.call(this);
      yield config2().put("challenge.scope", "email").put("discovery.wallet", this.network === "testnet" ? "https://wallet-v2-dev.blocto.app/api/flow/authn" : "https://wallet-v2.blocto.app/api/flow/authn").put("service.OpenID.scopes", "email!").put("discovery.wallet.method", "HTTP/POST");
    });
  }
};

// node_modules/@dynamic-labs/flow/src/dapper.js
var Dapper = class extends FlowWalletConnector {
  constructor() {
    super(...arguments);
    this.name = "Dapper";
    this.overrideKey = "dapper";
    this.canConnectViaCustodialService = true;
  }
  setupConfig() {
    const _super = Object.create(null, {
      setupConfig: { get: () => super.setupConfig }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super.setupConfig.call(this);
      yield config2().put("challenge.scope", void 0).put("discovery.wallet", this.network === "testnet" ? "https://staging.accounts.meetdapper.com/fcl/authn-restricted" : "https://accounts.meetdapper.com/fcl/authn-restricted").put("service.OpenID.scopes", void 0).put("discovery.wallet.method", "POP/RPC");
    });
  }
};

// node_modules/@dynamic-labs/flow/src/flowWallet.js
var FlowWallet2 = class extends FlowWalletConnector {
  constructor() {
    super(...arguments);
    this.name = "Flow Wallet";
    this.overrideKey = "flowwalletflow";
  }
  setupConfig() {
    const _super = Object.create(null, {
      setupConfig: { get: () => super.setupConfig }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super.setupConfig.call(this);
      config2().put("challenge.scope", void 0).put("discovery.wallet", "chrome-extension://hpclkefagolihohboafpheddmmgdffjm/popup.html").put("service.OpenID.scopes", void 0).put("discovery.wallet.method", "EXT/RPC");
    });
  }
  isInstalledOnBrowser() {
    var _a;
    if (typeof window === "undefined") {
      return false;
    }
    return Boolean((_a = window.fcl_extensions) === null || _a === void 0 ? void 0 : _a.some((ext) => ext.id === "hpclkefagolihohboafpheddmmgdffjm"));
  }
  signDelay() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isMobile()) {
        return Promise.resolve();
      }
      return new Promise((resolve2) => {
        setTimeout(() => {
          resolve2();
        }, 500);
      });
    });
  }
};

// node_modules/@dynamic-labs/flow/src/wallet/isFlowWallet/isFlowWallet.js
var isFlowWallet = (wallet) => wallet.chain === "FLOW";

// node_modules/@dynamic-labs/flow/src/index.js
assertPackageVersion("@dynamic-labs/flow", version);
var FlowWalletConnectors = (props) => [
  Blocto,
  Dapper,
  FlowWallet2
];
export {
  FlowWallet,
  FlowWalletConnector,
  FlowWalletConnectors,
  isFlowWallet
};
//# sourceMappingURL=@dynamic-labs_flow.js.map
