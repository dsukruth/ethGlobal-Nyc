'use strict';

var assertPackageVersion = require('@dynamic-labs-sdk/assert-package-version');
var getNetworkProviderBuilderRegistry = require('./getNetworkProviderBuilderRegistry.cjs.js');
var buffer = require('buffer');
require('@dynamic-labs/sdk-api-core');

class ClientsDoNotMatchError extends getNetworkProviderBuilderRegistry.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'clients_do_not_match_error',
            docsUrl: null,
            name: 'ClientsDoNotMatchError',
            shortMessage: 'Clients do not match'
        });
    }
}

class MethodNotImplementedError extends getNetworkProviderBuilderRegistry.BaseError {
    constructor(methodName){
        super({
            cause: null,
            code: 'method_not_implemented_error',
            docsUrl: null,
            name: 'MethodNotImplementedError',
            shortMessage: `This method is not implemented: ${methodName}`
        });
    }
}

class MultipleClientsFoundError extends getNetworkProviderBuilderRegistry.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'multiple_clients_found_error',
            docsUrl: null,
            name: 'MultipleClientsFoundError',
            shortMessage: 'Multiple Dynamic clients have been initialized. Please provide the intended client for this action explicitly'
        });
    }
}

/**
 * Registers an extension to the client.
 *
 * Other extensions can be aware of which extensions are present,
 * and allows creating dependencies between extensions.
 *
 * @param client - The client instance.
 * @param extensionKey - The key of the extension to register.
 * @returns The client instance.
 */ const registerExtension = ({ extensionKey }, client)=>{
    const core = getNetworkProviderBuilderRegistry.getCore(client);
    core.extensions.add(extensionKey);
};

/**
 * Formats a sign in message to prove ownership of an address.
 */ const formatSignInMessage = async ({ domain, blockchainName, address, uri, chainId, nonce, issuedAt, requestId, statement, resources })=>{
    // This format follows the sign-in with ethereum (SIWE) standard,
    // but we are using it also for non-ethereum wallets for now (eg. Solana)
    // for more context on format and fields, please see:
    // https://docs.login.xyz/general-information/siwe-overview/eip-4361
    const header = `${domain} wants you to sign in with your ${blockchainName} account:`;
    const prefix = [
        header,
        address
    ].join('\n');
    // If there is a statement, we want to add a gap between the prefix and the statement
    // two times '\n', first to move statement to next line and second to add a gap between prefix and statement
    const prefixWithStatementGap = statement ? '\n\n' : '\n';
    const prefixWithStatement = `${[
        prefix,
        statement
    ].join(prefixWithStatementGap)}\n`;
    const suffixFields = [];
    suffixFields.push(`URI: ${uri}`);
    suffixFields.push('Version: 1');
    if (chainId) {
        suffixFields.push(`Chain ID: ${chainId}`);
    }
    suffixFields.push(`Nonce: ${nonce}`);
    suffixFields.push(`Issued At: ${issuedAt}`);
    if (requestId) {
        suffixFields.push(`Request ID: ${requestId}`);
    }
    if (resources == null ? void 0 : resources.length) {
        suffixFields.push(`Resources:${resources.map((resource)=>'\n- ' + resource).join()}`);
    }
    const suffix = suffixFields.join('\n');
    return [
        prefixWithStatement,
        suffix
    ].join('\n');
};

const formatWalletProviderGroupKey = (walletName)=>walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();

/**
 * Format the wallet name and chain to get a wallet provider key.
 */ const formatWalletProviderKey = (walletName, chain)=>{
    const sanitizedWalletName = walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    return `${sanitizedWalletName}${chain.toLocaleLowerCase()}`;
};

// eslint-disable-next-line no-restricted-globals
const getBuffer = ()=>Buffer != null ? Buffer : buffer.Buffer;

const bufferToBase64 = (buf)=>{
    const binstr = Array.prototype.map.call(buf, (ch)=>String.fromCharCode(ch)).join('');
    return getBuffer().from(binstr, 'binary').toString('base64');
};

assertPackageVersion.assertPackageVersion('@dynamic-labs-sdk/client', getNetworkProviderBuilderRegistry.version);

exports.APIError = getNetworkProviderBuilderRegistry.APIError;
exports.CannotTrackError = getNetworkProviderBuilderRegistry.CannotTrackError;
exports.ClientNotFoundError = getNetworkProviderBuilderRegistry.ClientNotFoundError;
exports.InvalidStorageSet = getNetworkProviderBuilderRegistry.InvalidStorageSet;
exports.ValueMustBeDefinedError = getNetworkProviderBuilderRegistry.ValueMustBeDefinedError;
Object.defineProperty(exports, "WalletProviderPriority", {
  enumerable: true,
  get: function () { return getNetworkProviderBuilderRegistry.WalletProviderPriority; }
});
exports.assertDefined = getNetworkProviderBuilderRegistry.assertDefined;
exports.createApiClient = getNetworkProviderBuilderRegistry.createApiClient;
exports.emitEvent = getNetworkProviderBuilderRegistry.emitEvent;
exports.getCore = getNetworkProviderBuilderRegistry.getCore;
exports.getDefaultClient = getNetworkProviderBuilderRegistry.getDefaultClient;
exports.getNetworkProviderBuilderRegistry = getNetworkProviderBuilderRegistry.getNetworkProviderBuilderRegistry;
exports.getWalletProviderFromWalletAccount = getNetworkProviderBuilderRegistry.getWalletProviderFromWalletAccount;
exports.getWalletProviderRegistry = getNetworkProviderBuilderRegistry.getWalletProviderRegistry;
exports.hasExtension = getNetworkProviderBuilderRegistry.hasExtension;
exports.subscribeWithSelector = getNetworkProviderBuilderRegistry.subscribeWithSelector;
exports.ClientsDoNotMatchError = ClientsDoNotMatchError;
exports.MethodNotImplementedError = MethodNotImplementedError;
exports.MultipleClientsFoundError = MultipleClientsFoundError;
exports.bufferToBase64 = bufferToBase64;
exports.formatSignInMessage = formatSignInMessage;
exports.formatWalletProviderGroupKey = formatWalletProviderGroupKey;
exports.formatWalletProviderKey = formatWalletProviderKey;
exports.registerExtension = registerExtension;
