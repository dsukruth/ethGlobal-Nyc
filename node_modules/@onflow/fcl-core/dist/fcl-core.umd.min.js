!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@onflow/sdk"),require("@onflow/types"),require("@onflow/util-invariant"),require("cross-fetch"),require("@onflow/config"),require("@onflow/util-address"),require("@onflow/util-logger"),require("@onflow/rlp"),require("@onflow/util-actor"),require("@onflow/transport-http"),require("@improbable-eng/grpc-web"),require("sha3"),require("@onflow/util-template"),require("@onflow/util-semver")):"function"==typeof define&&define.amd?define(["exports","@onflow/sdk","@onflow/types","@onflow/util-invariant","cross-fetch","@onflow/config","@onflow/util-address","@onflow/util-logger","@onflow/rlp","@onflow/util-actor","@onflow/transport-http","@improbable-eng/grpc-web","sha3","@onflow/util-template","@onflow/util-semver"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["onflowFcl-core"]={},e.sdk,e.t,e.utilInvariant,e.fetchTransport,e.config,e.utilAddress,e.utilLogger,e.rlp,e.utilActor,e.transportHttp,e.grpcWeb,e.sha3,e.utilTemplate,e.semver)}(this,(function(e,t,n,r,a,i,o,s,c,l,d,u,p,f,m){"use strict";function g(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function y(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var v=y(t),h=y(n),b=g(a),w=y(c),E=y(m);const P="1.9.0",S=e=>t=>typeof t===e,I=e=>null!=e,T=S("object"),k=S("string"),A=S("function"),C=S("number");function O(e){return A(e)?e(v.arg,h):[]}async function R(e){let t,{url:n}=e;r.invariant(void 0!==n,"retrieve({ url }) -- url must be defined");try{t=await b.default(n)}catch(e){throw new Error("httpDocumentResolver Error: Failed to retrieve document.")}return t.ok?await t.json():null}const _=new Map([["http",R],["https",R]]);async function j(e){if(null==e)return null;switch(e.f_version){case"1.0.0":return j(function(e){let{template:n}=e;t.invariant(null!=n,"generateTemplateId({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),t.invariant("1.0.0"===n.f_version,"generateTemplateId({ template }) -- template object must be version 1.0.0");const r=n.data,a=Object.keys(r.messages).map((e=>({key:e,i18n:r.messages[e]?.i18n.map((t=>({tag:t,translation:r.messages[e]?.i18n?.[t]})))}))),i=Object.keys(r?.arguments).map((async(e,t)=>({...r?.arguments?.[e],label:e,index:t,type:r?.arguments?.[e]?.type,messages:Object.keys(r?.arguments?.[e].messages).map((t=>({key:t,i18n:Object.keys(r?.arguments?.[e].messages?.[t]).map((n=>({tag:n,translation:r?.arguments?.[e].messages?.[t]?.[n]})))})))})));return{...n,f_version:"1.1.0",data:{...n.data,messages:a,parameters:i}}}({template:e}));case"1.1.0":return e;default:throw new Error("normalizeInteractionTemplate Error: Invalid InteractionTemplate")}}async function N(e){let{network:t,template:n}=e;r.invariant("1.1.0"===n.f_version,"deriveCadenceByNetwork110({ template }) -- template must be version 1.0.0");const a={};return n?.data?.dependencies.forEach((e=>{e.contracts.forEach((e=>{const n=e.contract;e.networks.forEach((e=>{e.network===t&&(a[n]=e.address)})),r.invariant(void 0!==a[n],`deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${t} ${n}`)}))})),r.invariant(Object.keys(a).length===n?.data?.dependencies.length,`deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${a}`),r.invariant(Object.keys(a).length===Object.values(a).length,`deriveCadenceByNetwork110 -- Could not find all addresses for network ${t} dependencies:  ${a}`),r.invariant(n?.data?.cadence?.body,`no cadence found -- Could not replace import dependencies: ${a}`),function(e){let{cadence:t,networkDependencies:n}=e;return Object.keys(n).reduce(((e,t)=>{const r=n[t],a=new RegExp(`import "\\b${t}\\b"`,"g");return e.replace(a,`import ${t} from ${r}`)}),t)}({cadence:n?.data?.cadence?.body,networkDependencies:a})}async function L(e){let{network:t,template:n}=e;switch(r.invariant(null!=t,"deriveCadenceByNetwork({ network }) -- network must be defined"),r.invariant("string"==typeof t,"deriveCadenceByNetwork({ network }) -- network must be a string"),r.invariant(null!=n,"deriveCadenceByNetwork({ template }) -- template must be defined"),r.invariant("object"==typeof n,"deriveCadenceByNetwork({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate"),n.f_version){case"1.1.0":return await N({network:t,template:n});case"1.0.0":return await async function(e){let{network:t,template:n}=e;return r.invariant("1.0.0"===n.f_version,"deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0"),Object.keys(n?.data?.dependencies).map((e=>{const a=Object.values(n?.data?.dependencies?.[e]);r.invariant(void 0!==a,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`),r.invariant(a.length>0,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`);const i=a[0],o=i?.[t];return r.invariant(o,`deriveCadenceByNetwork100 -- Could not find ${t} network information for dependency: ${e}`),[e,o?.address]})).reduce(((e,t)=>{let[n,r]=t;const a=new RegExp("(\\b"+n+"\\b)","g");return e.replace(a,r)}),n.data.cadence)}({network:t,template:n});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}let x={},D=!1;async function U(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=await i.config.get("flow.network"),n=await i.config.get("env");n&&!D&&(s.log.deprecate({pkg:"FCL",subject:'Using the "env" configuration key for specifying the flow network',message:"Configuring to specify flow network is no longer required",transition:"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"}),D=!0);const r=e.node||await i.config.get("accessNode.api");if(!r){if(t)return t;if(n)return n;throw new Error('Either the "accessNode.api" config key or opts.node must be set')}if(x[r])try{return await x[r]}catch{}x[r]||(x[r]=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(await v.send([v.getNetworkParameters()],e).then(v.decode)).chainId}(e).catch((e=>{throw x[r]=null,e})));try{return await x[r]}catch(e){if(t)return t;if(n)return n;throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`)}}function F(){return"undefined"!=typeof navigator&&/iPhone|iPod/.test(navigator.userAgent)||"undefined"!=typeof navigator&&/iPad/.test(navigator.userAgent)}function $(){return"undefined"!=typeof navigator&&/android/i.test(navigator.userAgent)||F()}async function B(e){k(e?.template)&&(e.template=await async function(e){let{url:t}=e;r.invariant(void 0!==t,"retrieve({ url }) -- url must be defined"),r.invariant("string"==typeof t,"retrieve({ url }) -- url must be a string");const n=await i.config().where(/^document\.resolver\./);Object.keys(n).map((e=>{const t=n[e],r=e.replace(/^document\.resolver\./,"");_.set(r,t)}));const a=/^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(t);r.invariant(a,"Failed to parse URL");const o=a[1];r.invariant(a,"Failed to parse URL protocol");const s=_.get(o);return r.invariant(s,`No resolver found for protcol=${o}`),await s({url:t})}({url:e?.template}));let t={};e?.template&&(e.template=j(e?.template),t=await async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e.template,n=await U(e),a={};switch(t.f_version){case"1.0.0":const e=Object.keys(t?.data?.dependencies);for(let i of e){let e=t?.data?.dependencies[i];const s=Object.keys(e);r.invariant(s.length>0,`FCL configureDependencies Error: No contracts found in template for placeholder=${i}`);const c=e[s[0]][n];r.invariant(c,`FCL configureDependencies Error: No dependency information for placeholder=${i} contract=${s[0]} network=${n}`),r.invariant(c?.address,`FCL configureDependencies Error: No address information for placeholder=${i} contract=${s[0]} network=${n}`),a[i]=o.withPrefix(c?.address)}return a;case"1.1.0":return t?.data?.dependencies?.forEach((e=>{e.contracts.forEach((e=>{const t=e.contract;e.networks.forEach((e=>{e.network===n&&(a[t]=o.withPrefix(e?.address))})),r.invariant(a[t],`networkAddress -- Could not find contracts Network Address: ${n} ${t}`)}))})),a;default:throw new Error("FCL configureDependencies Error: Unsupported template version")}}({template:e.template}));const n=e.cadence||L({template:e.template,network:await U(e)});return e.cadence=n,e.dependencies=t,e}async function z(e,t){r.invariant(I(t),`${e}(opts) -- opts is required`),r.invariant(T(t),`${e}(opts) -- opts must be an object`),r.invariant(!(t.cadence&&t.template),`${e}({ template, cadence }) -- cannot pass both cadence and template`),r.invariant(I(t.cadence||t?.template),`${e}({ cadence }) -- cadence is required`),r.invariant(k(t.cadence)||t?.template,`${e}({ cadence }) -- cadence must be a string`),r.invariant(await v.config().get("accessNode.api"),`${e}(opts) -- Required value for "accessNode.api" not defined in config. See: https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration`)}async function M(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await async function(e){return z("query",e)}(e),e=await B(e),v.config().overload(e.dependencies||{},(async()=>v.send([v.script(e.cadence),v.args(O(e.args||[])),e.limit&&"number"==typeof e.limit&&v.limit(e.limit)]).then(v.decode)))}const H="fcl_redirect_url",q="fclResponseJson",V={"HTTP/RPC":"HTTP/RPC","HTTP/POST":"HTTP/POST","IFRAME/RPC":"IFRAME/RPC","POP/RPC":"POP/RPC","TAB/RPC":"TAB/RPC","EXT/RPC":"EXT/RPC","DEEPLINK/RPC":"DEEPLINK/RPC"},W=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{};const n=n=>{const{data:r}=n;"object"==typeof r&&null!=typeof r&&r.type===e&&t((e=>(e.deprecated&&console.warn("DEPRECATION NOTICE",e.deprecated.message),delete e?.body?.interaction,e))(r))};return window.addEventListener("message",n),()=>window.removeEventListener("message",n)};let K=!1;function G(){return K}const J=globalThis.URL;class Y extends J{constructor(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];super(e,t,...r),G()&&this._url&&!e.endsWith("/")&&this._url.endsWith("/")&&(this._url=this._url.slice(0,-1))}}const X=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n={...t,type:e},r=new URLSearchParams(window.location.search).get(H);if(r){const e=new Y(r);e.searchParams.append(q,JSON.stringify(n)),window.location.href=e.href}else if(window.location!==window.parent.location)window.parent.postMessage({...t,type:e},"*");else{if(!window.opener)throw new Error("Unable to communicate with parent FCL instance");window.opener.postMessage({...t,type:e},"*")}},Z={f_type:"Service",f_vsn:"1.0.0"},Q={f_type:"Identity",f_vsn:"1.0.0"},ee={f_type:"USER",f_vsn:"1.0.0"},te={f_type:"PollingResponse",f_vsn:"1.0.0"},ne={f_type:"CompositeSignature",f_vsn:"1.0.0"};const re=e=>{return t=e,n=8,c.Buffer.from(t.padStart(2*n,"0"),"hex");var t,n},ae=e=>c.Buffer.from(e,"hex"),ie=function(e){let{address:t,nonce:n,appIdentifier:a}=e,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];r.invariant(t,"Encode Message For Provable Authn Error: address must be defined"),r.invariant(n,"Encode Message For Provable Authn Error: nonce must be defined"),r.invariant(a,"Encode Message For Provable Authn Error: appIdentifier must be defined"),r.invariant(n.length>=64,"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");const s=(l=c.Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"),d=32,c.Buffer.from(l.padEnd(2*d,"0"),"hex"));var l,d;return i?c.Buffer.concat([s,c.encode([a,re(o.sansPrefix(t)),ae(n)])]).toString("hex"):c.encode([a,re(o.sansPrefix(t)),ae(n)]).toString("hex")};var oe=Object.freeze({__proto__:null,sendMsgToFCL:X,ready:function(e){W("FCL:VIEW:READY:RESPONSE",e),X("FCL:VIEW:READY")},close:()=>{X("FCL:VIEW:CLOSE")},approve:e=>{X("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"APPROVED",reason:null,data:e})},decline:e=>{X("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"DECLINED",reason:e,data:null})},redirect:e=>{X("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"REDIRECT",reason:null,data:e})},onMessageFromFCL:W,encodeMessageFromSignable:t.encodeMessageFromSignable,CompositeSignature:function(e,t,n){this.f_type=ne.f_type,this.f_vsn=ne.f_vsn,this.addr=o.withPrefix(e),this.keyId=Number(t),this.signature=n},encodeAccountProof:ie,injectExtService:function(e){"authn"===e.type&&null!=e.endpoint?(Array.isArray(window.fcl_extensions)||(window.fcl_extensions=[]),window.fcl_extensions.push(e)):console.warn("Authn service is required")}});const se=e=>{if(e.appIdentifier){const{appIdentifier:t,address:n,nonce:a,signatures:i}=e;return r.invariant(k(t),"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string"),r.invariant(k(n)&&16===o.sansPrefix(n).length,"verifyAccountProof({ address }) -- address must be a valid address"),r.invariant(/^[0-9a-f]+$/i.test(a),"nonce must be a hex string"),r.invariant(Array.isArray(i)&&i.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(i.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}{const{message:t,address:n,compSigs:a}=e;return r.invariant(/^[0-9a-f]+$/i.test(t),"Signed message must be a hex string"),r.invariant(k(n)&&16===o.sansPrefix(n).length,"verifyUserSignatures({ address }) -- address must be a valid address"),r.invariant(Array.isArray(a)&&a.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(a.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}},ce=async(e,t)=>{const n="ACCOUNT_PROOF"===e?"verifyAccountProofSignatures":"verifyUserSignatures";let a=await U(t);const i=t.fclCryptoContract||{testnet:"0x74daa6f9c7ef24b1",mainnet:"0xb4b82a1c9d21d284",previewnet:"0x40b5b8b2ce81ea4a"}[a];return r.invariant(i,`${n}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${a}. Please manually specify the FCLCrypto contract address.`),`\n      import FCLCrypto from ${i}\n\n      access(all) fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${n}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `};async function le(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=o.withPrefix(t[0].addr);se({message:e,address:r,compSigs:t});let a=[],i=[];for(const e of t)a.push(e.signature),i.push(e.keyId.toString());return M({cadence:await ce("USER_SIGNATURE",n),args:(t,n)=>[t(r,n.Address),t(e,n.String),t(i,n.Array(n.Int)),t(a,n.Array(n.String))]})}var de=Object.freeze({__proto__:null,verifyAccountProof:async function(e,t){let{address:n,nonce:r,signatures:a}=t,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};se({appIdentifier:e,address:n,nonce:r,signatures:a});const s=ie({address:n,nonce:r,appIdentifier:e},!1);let c=[],l=[];for(const e of a)c.push(e.signature),l.push(e.keyId.toString());return M({cadence:await ce("ACCOUNT_PROOF",i),args:(e,t)=>[e(o.withPrefix(n),t.Address),e(s,t.String),e(l,t.Array(t.Int)),e(c,t.Array(t.String))]})},verifyUserSignatures:le});const ue=s.log.deprecate({pkg:"FCL",subject:"fcl.verifyUserSignatures()",message:"Please use fcl.AppUtils.verifyUserSignatures()",callback:function(e,t){return le(e,t)}});async function pe(e){return Object.fromEntries(Object.entries(await i.config().where(e)).map((t=>{let[n,r]=t;return[n.replace(e,""),r]})))}const fe=/^[0-9a-fA-F]{64}$/,me="POLL",ge="TIMEOUT",ye=e=>e.status>=4,ve=e=>e.status>=3,he=e=>e.status>=2,be=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{[l.INIT]:async t=>{setTimeout((()=>t.sendSelf(ge)),e.txNotFoundTimeout),t.sendSelf(me)},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,l.UPDATED,e.all())},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[l.SNAPSHOT]:async(e,t)=>{t.reply(e.all())},[ge]:async t=>{0===Object.keys(t.all()).length&&t.fatalError(new Error(`TX status polling failed: no transaction was found within timeout interval (${e.txNotFoundTimeout}ms)`))},[me]:async n=>{const r=()=>setTimeout((()=>n.sendSelf(me)),e.pollRate);let a;const i=n.all();try{a=await(async e=>t.send([t.getTransactionStatus(e)]).then(t.decode))(n.self())}catch(e){const t=e instanceof d.HTTPRequestError&&404===e.statusCode,a=e.code===u.grpc.Code.NotFound;return t||a?r():n.fatalError(e)}var o,s;ye(a)||r(),o=i,s=a,JSON.stringify(o)!==JSON.stringify(s)&&n.broadcast(l.UPDATED,a),n.merge(a)}}},we=e=>{if("object"==typeof e&&(e=e.transactionId),null==e)throw new Error("transactionId required");return e},Ee=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>l.spawn(be(e),we(t))};function Pe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{txNotFoundTimeout:12500,pollRate:2500};if(!fe.test(we(e)))throw new Error("Invalid transactionId");function n(n){return l.subscriber(we(e),Ee(t),n)}function r(e){return function(){const t=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).suppress||!1;return new Promise(((r,a)=>{const i=n(((n,o)=>{!o&&!n.statusCode||t?e(n)&&(r(n),i()):(a(o||n.errorMessage),i())}))}))}}return{snapshot:function(){return l.snapshoter(e,Ee(t))},subscribe:n,onceFinalized:r(he),onceExecuted:r(ve),onceSealed:r(ye)}}Pe.isUnknown=e=>e.status>=0,Pe.isPending=e=>e.status>=1,Pe.isFinalized=he,Pe.isExecuted=ve,Pe.isSealed=ye,Pe.isExpired=e=>5===e.status;const Se="TICK",Ie="hwm",Te=async e=>setTimeout((()=>e.sendSelf(Se)),await t.config().get("fcl.eventPollRate",1e4)),ke={[Se]:async e=>{if(!e.hasSubs())return;let n=e.get(Ie);if(null==n)e.put(Ie,await t.block()),e.put(Se,await Te(e));else{let r=await t.block();if(e.put(Ie,r),n.height<r.height){const a=await t.send([t.getEventsAtBlockHeightRange(e.self(),n.height+1,r.height)]).then(t.decode);for(let t of a)e.broadcast("UPDATED",t.data)}e.put(Se,await Te(e))}},[l.SUBSCRIBE]:async(e,t)=>{e.hasSubs()||e.put(Se,await Te(e)),e.subscribe(t.from)},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from),e.hasSubs()||(clearTimeout(e.get(Se)),e.delete(Se),e.delete(Ie))}},Ae=e=>l.spawn(ke,e);const Ce=()=>{throw new Error("Platform specific Core Strategies are not initialized")},Oe={[V["EXT/RPC"]]:Ce,[V["HTTP/POST"]]:Ce,[V["IFRAME/RPC"]]:Ce,[V["POP/RPC"]]:Ce,[V["TAB/RPC"]]:Ce,[V["EXT/RPC"]]:Ce},Re=["ServicePlugin"],_e=["discovery-service"],je=e=>{let{coreStrategies:t}=e,n=new Set,a=new Map(Object.entries(t));const i=e=>n=new Set([...e]);return Object.freeze({add:e=>{if(r.invariant(_e.includes(e.type),`Service Plugin type ${e.type} is not supported`),"discovery-service"===e.type){const{discoveryServices:t,serviceStrategy:n}=(e=>{const{services:t,serviceStrategy:n}=e;r.invariant(Array.isArray(t)&&t.length,"Array of Discovery Services is required");for(const e of t)r.invariant(I(e.f_type)&&"Service"===e.f_type,"Service is required"),r.invariant(I(e.type)&&"authn"===e.type,`Service must be type authn. Received ${e.type}`),r.invariant(e.method in V||n.method===e.method,`Service method ${e.method} is not supported`);return r.invariant(I(n),"Service strategy is required"),r.invariant(I(n.method)&&k(n.method),"Service strategy method is required"),r.invariant(I(n.exec)&&A(n.exec),"Service strategy exec function is required"),{discoveryServices:t,serviceStrategy:n}})(e);i(t),a.has(n.method)?s.log({title:"Add Service Plugin",message:`Service strategy for ${n.method} already exists`,level:s.LEVELS.warn}):a.set(n.method,n.exec)}},getServices:()=>[...n],getStrategy:e=>a.get(e),getStrategies:()=>[...a.keys()]})};let Ne;const Le=()=>void 0!==Ne,xe=e=>{let{coreStrategies:t}=e;if(Le())return Ne;const n=je({coreStrategies:t});return Ne=n,n},De=()=>Le()?Ne:(console.warn("Registry is not initalized, it will be initialized with stub core strategies"),xe({coreStrategies:Oe})),Ue=(()=>{const e=new Map;return Object.freeze({add:t=>{const n=(e=>{let t;r.invariant(e,"No plugins supplied"),t=Array.isArray(e)?[...e]:[e];for(const e of t)r.invariant(I(e.name),"Plugin name is required"),r.invariant(I(e.f_type),"Plugin f_type is required"),r.invariant(Re.includes(e.f_type),`Plugin type ${e.f_type} is not supported`);return t})(t);for(const t of n)e.set(t.name,t),"ServicePlugin"===t.f_type&&Ne.add(t)},getPlugins:()=>e})})(),Fe=async()=>[...window?.fcl_extensions||[],...De().getServices()];const $e="authn",Be="SNAPSHOT",ze="UPDATED",Me="UPDATE_RESULTS",He=async()=>{try{const e=await async function(e){let{types:t}=e;const n=await i.config.get("discovery.authn.endpoint");r.invariant(Boolean(n),'"discovery.authn.endpoint" in config must be defined.');const a=await i.config.get("discovery.authn.include",[]),o=new Y(n);return fetch(o,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:t,fclVersion:P,include:a,features:{suggested:await i.config.get("discovery.features.suggested",[])},clientServices:await Fe(),supportedStrategies:De().getStrategies(),userAgent:window?.navigator?.userAgent,network:await U()})}).then((e=>e.json()))}({types:[$e]});l.send($e,Me,{results:e})}catch(e){s.log({title:`${e.name} Error fetching Discovery API services.`,message:e.message,level:s.LEVELS.error})}},qe={[l.INIT]:async e=>{var t,n;t="undefined"==typeof window,n='"fcl.discovery" is only available in the browser.',t&&console.warn(`\n      %cFCL Warning\n      ============================\n      ${n}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `,"font-weight:bold;font-family:monospace;"),"complete"===document.readyState?He():window.onload=async()=>{He()}},[Me]:(e,t,n)=>{e.merge(n),e.broadcast(ze,{...e.all()})},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,ze,{...e.all()})},[l.UNSUBSCRIBE]:(e,t)=>e.unsubscribe(t.from),[Be]:async(e,t)=>t.reply({...e.all()})},Ve=()=>l.spawn(qe,$e),We={authn:{subscribe:e=>l.subscriber($e,Ve,e),snapshot:()=>l.snapshoter($e,Ve),update:()=>He()}};function Ke(e){const t=new p.SHA3(256);return t.update(c.Buffer.from(e,"utf8")),t.digest("hex")}function Ge(e){let{contractName:t,address:n}=e;return{contractName:t,address:n,contract:""}}function Je(e){const t=[],n=e.match(/import ((\w|,| )+)* from 0x\w+/g)||[];for(const e of n){const n=/import ((\w+|, |)*) from (0x\w+)/g.exec(e),r=/((?:\w+)+),?/g,a=n[1].match(r)||[];for(const e of a)t.push(Ge({address:n[3],contractName:e.replace(/,/g,"")}))}return t}async function Ye(e){let{address:n,contractName:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=r,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof n,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof r,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[Ge({contractName:r,address:n})];for(const e of i){const n=await t.send([t.getAccount(await t.config().get(e.address,e.address))],a).then(t.decode);if(e.contract=n.contracts?.[e.contractName],!e.contract)throw console.error("Did not find expected contract",e,n),new Error("Did not find expected contract");const r=Je(e.contract);i.push(...r)}const o=i.map((e=>Ke(e.contract)));return Ke((await Promise.all(o)).join(""))}async function Xe(e,t){const n=[];for(const r of t){const t=[Ke(r.network)],{address:a,dependency_pin_block_height:i}=r;if(r.dependency_pin){const n=await Ye({address:a,contractName:e,blockHeight:i});t.push(Ke(n))}n.push(t)}return n}async function Ze(e){const t=[];for(let n=0;n<e.length;n++){const r=e[n],a=[];for(let e=0;e<r?.contracts.length;e++){const t=r?.contracts[e],n=t?.contract;a.push(Ke(n));const i=await Xe(n,t?.networks);a.push(i)}t.push(a)}return t}async function Qe(e){let{template:n}=e;switch(r.invariant(n,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),n.f_version){case"1.1.0":return await async function(e){let{template:t}=e;r.invariant(t,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof t,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===t.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),r.invariant("1.1.0"===t.f_version,"generateTemplateId({ template }) -- template object must be an version 1.1.0");const n=t.data,a=await Promise.all(n.messages.map((async e=>[Ke(e.key),await Promise.all(e.i18n.map((async e=>[Ke(e.tag),Ke(e.translation)])))]))),i=await Promise.all(n?.parameters.sort(((e,t)=>e.index-t.index)).map((async e=>[Ke(e.label),[Ke(String(e.index)),Ke(e.type),await Promise.all(e.messages.map((async e=>[Ke(e.key),await Promise.all(e.i18n.map((async e=>[Ke(e.tag),Ke(e.translation)])))])))]]))),o=[await Ze(n?.dependencies)],s=c.encode([Ke(t?.f_type),Ke(t?.f_version),Ke(n?.type),Ke(n?.interface),a,Ke(n?.cadence?.body),[o],i]).toString("hex");return Ke(s)}({template:n});case"1.0.0":return await async function(e){let{template:n}=e;t.invariant(null!=n,"generateTemplateId({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),t.invariant("1.0.0"===n.f_version,"generateTemplateId({ template }) -- template object must be an version 1.0.0");const r=n.data,a=await Promise.all(Object.keys(r.messages).map((async e=>[Ke(e),await Promise.all(Object.keys(r.messages?.[e]?.i18n).map((async t=>[Ke(t),Ke(r.messages?.[e]?.i18n?.[t])])))]))),i=await Promise.all(Object.keys(r?.dependencies).map((async e=>[Ke(e),await Promise.all(Object.keys(r?.dependencies?.[e]).map((async t=>[Ke(t),await Promise.all(Object.keys(r?.dependencies?.[e]?.[t]).map((async n=>[Ke(n),[Ke(r?.dependencies?.[e]?.[t]?.[n].address),Ke(r?.dependencies?.[e]?.[t]?.[n].contract),Ke(r?.dependencies?.[e]?.[t]?.[n].fq_address),Ke(r?.dependencies?.[e]?.[t]?.[n].pin),Ke(String(r?.dependencies?.[e]?.[t]?.[n].pin_block_height))]])))])))]))),o=await Promise.all(Object.keys(r?.arguments).map((async e=>[Ke(e),[Ke(String(r?.arguments?.[e].index)),Ke(r?.arguments?.[e].type),Ke(r?.arguments?.[e].balance||""),await Promise.all(Object.keys(r?.arguments?.[e].messages).map((async t=>[Ke(t),await Promise.all(Object.keys(r?.arguments?.[e].messages?.[t].i18n).map((async n=>[Ke(n),Ke(r?.arguments?.[e].messages?.[t].i18n?.[n])])))])))]]))),s=c.encode([Ke("InteractionTemplate"),Ke("1.0.0"),Ke(r?.type),Ke(r?.interface),a,Ke(r?.cadence),i,o]).toString("hex");return Ke(s)}({template:n});default:throw new Error("generateTemplateId Error: Unsupported template version")}}async function et(e){let{version:n,address:r,contractName:a}=e;switch(t.invariant(null!=r,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=a,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof r,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof a,"generateDependencyPin({ contractName }) -- contractName must be a string"),n){case"1.1.0":return await Ye({address:r,contractName:a});case"1.0.0":return await async function(e){let{address:n,contractName:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=r,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof n,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof r,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[Ge({contractName:r,address:n})];for(const e of i){const n=await t.send([t.getAccount(await t.config().get(e.address,e.address))],a).then(t.decode);if(e.contract=n.contracts?.[e.contractName],!e.contract)throw console.error("Did not find expected contract",e,n),new Error("Did not find expected contract");const r=Je(e.contract);i.push(...r)}const o=i.map((e=>Ke(e.contract)));return Ke(o.join(""))}({address:r,contractName:a});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}async function tt(e){let{template:n,blockHeight:r,network:a}=e;switch(t.invariant(null!=n,"generateDependencyPin({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateDependencyPin({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateDependencyPin({ template }) -- template must be an InteractionTemplate"),t.invariant(null!=a,"generateDependencyPin({ network }) network must be defined"),t.invariant(null!=r,"generateDependencyPin({ blockHeight }) blockHeight must be defined"),t.invariant("number"==typeof r,"generateDependencyPin({ blockHeight }) blockHeight must be a number"),n.f_version){case"1.0.0":const e=Object.keys(n.data.dependencies);for(let t of e){const e=n.data.dependencies[t],i=Object.keys(e);for(let e of i){const i=n.data.dependencies[t][e][a];if(void 0===i)continue;const o=await et({address:i.address,contractName:i.contract,blockHeight:r});if(o!==i.pin)return s.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                address: ${i.address} | contract: ${i.contract}\n                                computed: ${o}\n                                template: ${i.pin}\n                            `,level:s.LEVELS.debug}),!1}}return!0;case"1.1.0":let t=!1;for(let e=0;e<n.data?.dependencies.length;e++){const i=n.data?.dependencies[e];for(let e=0;e<i?.contracts.length;e++){const o=i?.contracts[e];for(let e=0;e<o?.networks.length;e++){const i=o?.networks[e];if(i.network===a){const e=await et({version:n.f_version,address:i.address,contractName:o.contract,blockHeight:r});if(e!==i.dependency_pin.pin)return s.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                    address: ${i.address} | contract: ${o.contract}\n                                    computed: ${e}\n                                    template: ${i.pin}\n                                `,level:s.LEVELS.debug}),!1;t=!0}}}}return t;default:throw new Error("verifyDependencyPinsSame Error: Unsupported template version")}}var nt=Object.freeze({__proto__:null,getInteractionTemplateAudits:async function(e){let{template:n,auditors:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"getInteractionTemplateAudits({ template }) -- template must be defined"),t.invariant("InteractionTemplate"===n.f_type,"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate");let i=await Qe({template:n});if(i!==n.id)throw s.log({title:"getInteractionTemplateAudits Debug Error",message:`Could not recompute and match template ID\n                computed: ${i}\n                template: ${n.id}\n            `,level:s.LEVELS.debug}),new Error("getInteractionTemplateAudits Error: Could not recompute and match template ID");switch(n.f_version){case"1.1.0":case"1.0.0":const e=r||await t.config().get("flow.auditors");t.invariant(e,"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set"),t.invariant(Array.isArray(e),"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array");let n=a.flowInteractionAuditContract;if(!n){const e=await U(a);t.invariant("mainnet"===e||"testnet"===e,"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'"),n="mainnet"===e?"0xfd100e39d50a13e6":"0xf78bfc12d0a786dc"}const o=await M({cadence:`\n        import FlowInteractionTemplateAudit from ${n}\n        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,args:(t,n)=>[t(i,n.String),t(e,n.Array(n.Address))]});return o;default:throw new Error("getInteractionTemplateAudits Error: Unsupported template version")}},generateDependencyPin:et,generateDependencyPinAtLatestSealedBlock:async function(e){let{version:n,address:r,contractName:a}=e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=await t.block({sealed:!0},i),s=o?.height;return et({version:n,address:r,contractName:a,blockHeight:s})},generateTemplateId:Qe,verifyGeneratedTemplateId:async function(e){let{template:t}=e;return t.id===await Qe({template:t})},verifyDependencyPinsSame:tt,verifyDependencyPinsSameAtLatestSealedBlock:async function(e){let{template:n,network:r}=e;const a=await t.block({sealed:!0}),i=a?.height;return tt({template:n,network:r,blockHeight:i})},deriveCadenceByNetwork:L,getTemplateMessage:function(e){let{localization:n="en-US",messageKey:r,template:a}=e;switch(t.invariant(r,"getTemplateMessage({ messageKey }) -- messageKey must be defined"),t.invariant("string"==typeof r,"getTemplateMessage({ messageKey }) -- messageKey must be a string"),t.invariant(n,"getTemplateMessage({ localization }) -- localization must be defined"),t.invariant("string"==typeof n,"getTemplateMessage({ localization }) -- localization must be a string"),t.invariant(null!=a,"getTemplateMessage({ template }) -- template must be defined"),t.invariant("object"==typeof a,"getTemplateMessage({ template }) -- template must be an object"),t.invariant("InteractionTemplate"==typeof a.f_type,"getTemplateMessage({ template }) -- template object must be an InteractionTemplate"),a.f_version){case"1.1.0":const e=a?.data?.messages?.find((e=>e.key===r));if(!e)return;const t=e?.i18n?.find((e=>e.tag===n));if(!t)return;return t.translation;case"1.0.0":return a?.data?.messages?.[r]?.i18n?.[n];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}},getTemplateArgumentMessage:function(e){let{localization:n="en-US",argumentLabel:r,messageKey:a,template:i}=e;switch(t.invariant(a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined"),t.invariant("string"==typeof a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string"),t.invariant(r,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined"),t.invariant("string"==typeof a,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string"),t.invariant(n,"getTemplateArgumentMessage({ localization }) -- localization must be defined"),t.invariant("string"==typeof n,"getTemplateArgumentMessage({ localization }) -- localization must be a string"),t.invariant(null!=i,"getTemplateArgumentMessage({ template }) -- template must be defined"),t.invariant("object"==typeof i,"getTemplateArgumentMessage({ template }) -- template must be an object"),t.invariant("InteractionTemplate"==typeof i.f_type,"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate"),i.f_version){case"1.1.0":const e=i?.data?.parameters?.find((e=>e.label===r));if(!e)return;const t=e?.messages?.find((e=>e.key===a));if(!t)return;const o=t?.i18n?.find((e=>e.tag===n));if(!o)return;return o.translation;case"1.0.0":return i?.data?.arguments?.[r]?.messages?.[a]?.i18n?.[n];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}}});function rt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{old:e,...Z,type:"frame",endpoint:e.endpoint,params:e.params||{},data:e.data||{}}}function at(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Z,type:"back-channel-rpc",endpoint:e.endpoint,method:e.method,params:e.params||{},data:e.data||{}}}function it(e){return null==e?null:(null==e.method&&(e={...e,type:"local-view",method:"VIEW/IFRAME"}),e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Z,type:e.type||"local-view",method:e.method,endpoint:e.endpoint,data:e.data||{},params:e.params||{}})}function ot(e,t){return e.map((e=>function(e,t){try{return st[e.type](e,t)}catch(t){return console.error(`Unrecognized FCL Service Type [${e.type}]`,e,t),e}}(e,t))).filter(Boolean)}const st={"back-channel-rpc":at,"pre-authz":function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Z,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Q,address:o.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authz:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Z,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Q,address:o.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authn:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Z,type:e.type,uid:e.id,endpoint:e.authn,id:e.pid,provider:{address:o.withPrefix(e.addr),name:e.name,icon:e.icon}}},frame:rt,"open-id":function(e){return null==e?null:"1.0.0"===e.f_vsn?e:null},"user-signature":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid user-signature service");return"1.0.0"===e.f_vsn?e:null},"local-view":it,"account-proof":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("FCL Normalizer Error: Invalid account-proof service");return"1.0.0"===e.f_vsn?e:null},"authn-refresh":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid authn-refresh service");return"1.0.0"===e.f_vsn?e:null}};function ct(){let e=arguments.length>1?arguments[1]:void 0;return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).reduce(((t,n)=>n.type===e&&(!t||E.compare(n.f_vsn,t.f_vsn)>0)?n:t),null)}function lt(e){return w.encode([e.provider.address||e.provider.name||"UNSPECIFIED",e.id]).toString("hex")}async function dt(e){var t=ot(function(){return[...arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],...arguments.length>1&&void 0!==arguments[1]?arguments[1]:[]]}((e=function(e){return e.addr=e.addr?o.withPrefix(e.addr):null,e.paddr=e.paddr?o.withPrefix(e.paddr):null,e}(e)).services||[],await async function(e,t){if(null==e||null==t)return[];const n=new Y(e);n.searchParams.append("code",t);const r=await fetch(n,{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>e.json()));if(Array.isArray(r))return r;const a=[];if(Array.isArray(r.authorizations))for(let e of r.authorizations)a.push({type:"authz",keyId:r.keyId,...e});return null!=r.provider&&a.push({type:"authn",id:"wallet-provider#authn",...r.provider}),a}(e.hks,e.code)));const n=ct(t,"authn");return{...ee,addr:o.withPrefix(e.addr),cid:lt(n),loggedIn:!0,services:t,expiresAt:e.expires}}async function ut(e){let{service:t,msg:n={},config:a={},opts:i={},platform:o}=e;n.data=t.data;const c={services:await pe(/^service\./),app:await pe(/^app\.detail\./),client:{...a.client,platform:o,fclVersion:P,fclLibrary:"https://github.com/onflow/fcl-js",hostname:window?.location?.hostname??null,network:await U(i)}};try{const e=await(async e=>{let{service:t,body:n,config:r,opts:a}=e;return De().getStrategy(t.method)({service:t,body:n,config:r,opts:a})})({service:t,body:n,config:c,opts:i});return"REDIRECT"===e.status?(r.invariant(t.type===e.data.type,"Cannot shift recursive service type in execService"),await ut({service:e.data,msg:n,config:c,opts:i})):e}catch(e){throw s.log({title:`Error on execService ${t?.type}`,message:e,level:s.LEVELS.error}),e}}function pt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...ne,addr:o.sansPrefix(e.addr||e.address),signature:e.signature||e.sig,keyId:e.keyId}}const ft="CURRENT_USER",mt="CURRENT_USER/UPDATED",gt="SNAPSHOT",yt="SET_CURRENT_USER",vt="DEL_CURRENT_USER",ht='{\n  "f_type": "User",\n  "f_vsn": "1.0.0",\n  "addr":null,\n  "cid":null,\n  "loggedIn":null,\n  "expiresAt":null,\n  "services":[]\n}',bt={[l.INIT]:async e=>{"undefined"==typeof window&&console.warn('\n        %cFCL Warning\n        ============================\n        "currentUser" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        ',"font-weight:bold;font-family:monospace;"),e.merge(JSON.parse(ht));const t=await i.config.first(["fcl.storage","fcl.storage.default"]);if(t.can){const n=await(async e=>{const t=JSON.parse(ht),n=await e.get(ft);return null!=n&&t.f_vsn!==n.f_vsn?(e.removeItem(ft),t):n||t})(t);(function(e){return null==e.expiresAt||0===e.expiresAt||e.expiresAt>Date.now()})(n)&&e.merge(n)}},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,mt,{...e.all()})},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[gt]:async(e,t)=>{t.reply({...e.all()})},[yt]:async(e,t,n)=>{e.merge(n);const r=await i.config.first(["fcl.storage","fcl.storage.default"]);r.can&&r.put(ft,e.all()),e.broadcast(mt,{...e.all()})},[vt]:async(e,t)=>{e.merge(JSON.parse(ht));const n=await i.config.first(["fcl.storage","fcl.storage.default"]);n.can&&n.put(ft,e.all()),e.broadcast(mt,{...e.all()})}},wt=()=>l.spawn(bt,ft);const Et=async e=>{let{discoveryAuthnInclude:t,discoveryFeaturesSuggested:n}=e;return{client:{discoveryAuthnInclude:t,discoveryFeaturesSuggested:n,clientServices:await Fe(),supportedStrategies:De().getStrategies()}}},Pt=e=>{let{platform:t}=e;return async function(){let{service:e,redir:n=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!e||e?.provider?.is_installed||!e?.provider?.requires_install)return new Promise((async(a,o)=>{wt();const c={redir:n},d=await kt(),u=await async function(e){const t=await i.config.get("discovery.authn.include",[]),n=await i.config.get("discovery.features.suggested",[]),a=await i.config.first(["discovery.wallet.method","discovery.wallet.method.default"]),o=e?.method?e.method:a,s=e?.endpoint??await i.config.first(["discovery.wallet","challenge.handshake"]);return r.invariant(s,'\n    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.\n    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"\n    '),{...e,type:"authn",endpoint:s,method:o,discoveryAuthnInclude:t,discoveryFeaturesSuggested:n}}(e),p=ct(d.services,"authn-refresh");let f;if(d.loggedIn){if(!p)return a(d);try{const e=await ut({service:p,msg:f,opts:c,platform:t});l.send(ft,yt,await dt(e))}catch(e){s.log({title:`${e.name} Could not refresh wallet authentication.`,message:e.message,level:s.LEVELS.error})}finally{return a(await kt())}}try{f=await async function(){let e=await i.config.get("fcl.accountProof.resolver");if(null==e)return;if("function"!=typeof e)return void s.log({title:"Account Proof Data Resolver must be a function",message:`Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof e}\n                `,level:s.LEVELS.warn});const t=await e();return null!=t?(r.invariant("string"==typeof t.appIdentifier,"appIdentifier must be a string"),r.invariant(/^[0-9a-f]+$/i.test(t.nonce),"Nonce must be a hex string"),t):void 0}()}catch(e){return s.log({title:`${e.name} On Authentication: Could not resolve account proof data.`,message:e.message,level:s.LEVELS.error}),o(e)}try{const e=await ut({service:u,msg:f,config:await Et(u),opts:c,platform:t});l.send(ft,yt,await dt(e))}catch(e){s.log({title:`${e} On Authentication`,message:e,level:s.LEVELS.error})}finally{a(await kt())}}));window.location.href=e?.provider?.install_link}};function St(){wt(),l.send(ft,vt)}const It=e=>{let{platform:t}=e;return async e=>(wt(),{...e,tempId:"CURRENT_USER",async resolve(e,n){const r=await Pt({platform:t})({redir:!0}),a=ct(r.services,"authz"),i=ct(r.services,"pre-authz");if(i)return(e=>{let{platform:t}=e;return e=>{const n=(e=>({f_type:"PreAuthzResponse",f_vsn:"1.0.0",proposer:(e||{}).proposer,payer:(e||{}).payer||[],authorization:(e||{}).authorization||[]}))(e),r=[];null!=n.proposer&&r.push(["PROPOSER",n.proposer]);for(let e of n.payer||[])r.push(["PAYER",e]);for(let e of n.authorization||[])r.push(["AUTHORIZER",e]);return r.map((e=>{let[n,r]=e;return{tempId:[r.identity.address,r.identity.keyId].join("|"),addr:r.identity.address,keyId:r.identity.keyId,signingFunction:e=>ut({service:r,msg:e,platform:t}),role:{proposer:"PROPOSER"===n,payer:"PAYER"===n,authorizer:"AUTHORIZER"===n}}}))}})({platform:t})(await ut({service:i,msg:n,platform:t}));if(a){let n;return $()&&"WC/RPC"===a.method&&(n=window.open("","_blank")),{...e,tempId:"CURRENT_USER",resolve:null,addr:o.sansPrefix(a.identity.address),keyId:a.identity.keyId,sequenceNum:null,signature:null,signingFunction:async e=>pt(await ut({service:a,msg:e,opts:{includeOlderJsonRpcCall:!0,windowRef:n},platform:t}))}}throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER")}})};function Tt(e){wt();const t="@EXIT",n=l.spawn((async n=>{for(n.send(ft,l.SUBSCRIBE);;){const r=await n.receive();if(r.tag===t)return void n.send(ft,l.UNSUBSCRIBE);e(r.data)}}));return()=>l.send(n,t)}function kt(){return wt(),l.send(ft,gt,null,{expectReply:!0,timeout:0})}const At=e=>{let{platform:n}=e;return async()=>{const{addr:e}=await Pt({platform:n})();return t.arg(o.withPrefix(e),h.Address)}},Ct=e=>(r.invariant(/^[0-9a-f]+$/i.test(e),"Message must be a hex string"),{message:e}),Ot=e=>{let{platform:t}=e;return async e=>{wt();const n=ct((await Pt({platform:t})({redir:!0})).services,"user-signature");r.invariant(n,"Current user must have authorized a signing service.");try{const r=await ut({service:n,msg:Ct(e),platform:t});return Array.isArray(r)?r.map((e=>pt(e))):[pt(r)]}catch(e){return e}}},Rt=e=>{let{platform:t}=e,n=()=>({authenticate:Pt({platform:t}),unauthenticate:St,authorization:It({platform:t}),signUserMessage:Ot({platform:t}),subscribe:Tt,snapshot:kt,resolveArgument:At({platform:t})});return n.authenticate=Pt({platform:t}),n.unauthenticate=St,n.authorization=It({platform:t}),n.signUserMessage=Ot({platform:t}),n.subscribe=Tt,n.snapshot=kt,n.resolveArgument=At({platform:t}),n};function _t(e){const t=new Y(e.endpoint);if(window?.location?.origin&&t.searchParams.append("l6n",window.location.origin),null!=e.params)for(let[n,r]of Object.entries(e.params||{}))t.searchParams.append(n,r);return t}function jt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=t.method||"POST",r="GET"===n?void 0:JSON.stringify(t.data||e.data||{});return fetch(_t(e),{method:n,headers:{...e.headers||{},...t.headers||{},"Content-Type":"application/json"},body:r}).then((e=>e.json()))}function Nt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...te,status:e.status??"APPROVED",reason:e.reason??null,data:e.compositeSignature||e.data||{...e}||{},updates:at(e.authorizationUpdates),local:rt((e.local||[])[0])}}const Lt={"HTTP/GET":"GET","HTTP/POST":"POST"},xt=e=>(r.invariant(Lt[e.method],"Invalid Service Method for type back-channel-rpc",{service:e}),Lt[e.method]);async function Dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>!0;r.invariant(e,"Missing Polling Service",{service:e});if(!t())throw new Error("Externally Halted");let n;try{if("undefined"!=typeof document&&"hidden"===document.visibilityState)return await new Promise((e=>setTimeout(e,500))),Dt(e,t);n=await jt(e,{method:xt(e)}).then(Nt)}catch(e){throw e}switch(n.status){case"APPROVED":return n.data;case"DECLINED":throw new Error(`Declined: ${n.reason||"No reason supplied."}`);default:return await new Promise((e=>setTimeout(e,500))),Dt(n.updates,t)}}const Ut="FCL:VIEW:CLOSE",Ft="FCL:VIEW:READY",$t="FCL:VIEW:RESPONSE",Bt=e=>"string"==typeof e&&e.toLowerCase(),zt=new Set(["monetizationstart","monetizationpending","monetizationprogress","monetizationstop"]),Mt=(e,t)=>console.warn("DEPRECATION NOTICE",`Received ${e}, please use ${t} for this and future versions of FCL`);i.config.subscribe((()=>{U({enableRequestLogging:!1}).catch((()=>{}))})),Object.defineProperty(e,"TestUtils",{enumerable:!0,get:function(){return t.TestUtils}}),Object.defineProperty(e,"account",{enumerable:!0,get:function(){return t.account}}),Object.defineProperty(e,"arg",{enumerable:!0,get:function(){return t.arg}}),Object.defineProperty(e,"args",{enumerable:!0,get:function(){return t.args}}),Object.defineProperty(e,"atBlockHeight",{enumerable:!0,get:function(){return t.atBlockHeight}}),Object.defineProperty(e,"atBlockId",{enumerable:!0,get:function(){return t.atBlockId}}),Object.defineProperty(e,"authorization",{enumerable:!0,get:function(){return t.authorization}}),Object.defineProperty(e,"authorizations",{enumerable:!0,get:function(){return t.authorizations}}),Object.defineProperty(e,"block",{enumerable:!0,get:function(){return t.block}}),Object.defineProperty(e,"build",{enumerable:!0,get:function(){return t.build}}),Object.defineProperty(e,"createSignableVoucher",{enumerable:!0,get:function(){return t.createSignableVoucher}}),Object.defineProperty(e,"decode",{enumerable:!0,get:function(){return t.decode}}),Object.defineProperty(e,"getAccount",{enumerable:!0,get:function(){return t.getAccount}}),Object.defineProperty(e,"getBlock",{enumerable:!0,get:function(){return t.getBlock}}),Object.defineProperty(e,"getBlockHeader",{enumerable:!0,get:function(){return t.getBlockHeader}}),Object.defineProperty(e,"getCollection",{enumerable:!0,get:function(){return t.getCollection}}),Object.defineProperty(e,"getEvents",{enumerable:!0,get:function(){return t.getEvents}}),Object.defineProperty(e,"getEventsAtBlockHeightRange",{enumerable:!0,get:function(){return t.getEventsAtBlockHeightRange}}),Object.defineProperty(e,"getEventsAtBlockIds",{enumerable:!0,get:function(){return t.getEventsAtBlockIds}}),Object.defineProperty(e,"getNetworkParameters",{enumerable:!0,get:function(){return t.getNetworkParameters}}),Object.defineProperty(e,"getNodeVersionInfo",{enumerable:!0,get:function(){return t.getNodeVersionInfo}}),Object.defineProperty(e,"getTransaction",{enumerable:!0,get:function(){return t.getTransaction}}),Object.defineProperty(e,"getTransactionStatus",{enumerable:!0,get:function(){return t.getTransactionStatus}}),Object.defineProperty(e,"invariant",{enumerable:!0,get:function(){return t.invariant}}),Object.defineProperty(e,"isBad",{enumerable:!0,get:function(){return t.isBad}}),Object.defineProperty(e,"isOk",{enumerable:!0,get:function(){return t.isOk}}),Object.defineProperty(e,"limit",{enumerable:!0,get:function(){return t.limit}}),Object.defineProperty(e,"nodeVersionInfo",{enumerable:!0,get:function(){return t.nodeVersionInfo}}),Object.defineProperty(e,"param",{enumerable:!0,get:function(){return t.param}}),Object.defineProperty(e,"params",{enumerable:!0,get:function(){return t.params}}),Object.defineProperty(e,"payer",{enumerable:!0,get:function(){return t.payer}}),Object.defineProperty(e,"ping",{enumerable:!0,get:function(){return t.ping}}),Object.defineProperty(e,"pipe",{enumerable:!0,get:function(){return t.pipe}}),Object.defineProperty(e,"proposer",{enumerable:!0,get:function(){return t.proposer}}),Object.defineProperty(e,"ref",{enumerable:!0,get:function(){return t.ref}}),Object.defineProperty(e,"script",{enumerable:!0,get:function(){return t.script}}),Object.defineProperty(e,"send",{enumerable:!0,get:function(){return t.send}}),Object.defineProperty(e,"subscribeEvents",{enumerable:!0,get:function(){return t.subscribeEvents}}),Object.defineProperty(e,"transaction",{enumerable:!0,get:function(){return t.transaction}}),Object.defineProperty(e,"validator",{enumerable:!0,get:function(){return t.validator}}),Object.defineProperty(e,"voucherIntercept",{enumerable:!0,get:function(){return t.voucherIntercept}}),Object.defineProperty(e,"voucherToTxId",{enumerable:!0,get:function(){return t.voucherToTxId}}),Object.defineProperty(e,"why",{enumerable:!0,get:function(){return t.why}}),e.t=h,Object.defineProperty(e,"config",{enumerable:!0,get:function(){return i.config}}),Object.defineProperty(e,"display",{enumerable:!0,get:function(){return o.display}}),Object.defineProperty(e,"sansPrefix",{enumerable:!0,get:function(){return o.sansPrefix}}),Object.defineProperty(e,"withPrefix",{enumerable:!0,get:function(){return o.withPrefix}}),Object.defineProperty(e,"cadence",{enumerable:!0,get:function(){return f.template}}),Object.defineProperty(e,"cdc",{enumerable:!0,get:function(){return f.template}}),e.AppUtils=de,e.CORE_STRATEGIES=V,e.FCL_REDIRECT_URL_PARAM_NAME=H,e.FCL_RESPONSE_PARAM_NAME=q,e.InteractionTemplateUtils=nt,e.URL=Y,e.VERSION=P,e.WalletUtils=oe,e.buildMessageHandler=e=>{let{close:t,send:n,onReady:r,onResponse:a,onMessage:i}=e;return e=>{try{if("object"!=typeof e.data)return;if(zt.has(e.data.type))return;Bt(e.data.type)===Bt(Ut)&&t(),Bt(e.data.type)===Bt(Ft)&&r(e,{send:n,close:t}),Bt(e.data.type)===Bt($t)&&a(e,{send:n,close:t}),i(e,{send:n,close:t}),Bt(e.data.type)===Bt("FCL:FRAME:READY")&&(Mt(e.data.type,Ft),r(e,{send:n,close:t})),Bt(e.data.type)===Bt("FCL:FRAME:RESPONSE")&&(Mt(e.data.type,$t),a(e,{send:n,close:t})),Bt(e.data.type)===Bt("FCL:FRAME:CLOSE")&&(Mt(e.data.type,Ut),t()),Bt(e.data.type)===Bt("FCL::CHALLENGE::RESPONSE")&&(Mt(e.data.type,$t),a(e,{send:n,close:t})),Bt(e.data.type)===Bt("FCL::AUTHZ_READY")&&(Mt(e.data.type,Ft),r(e,{send:n,close:t})),Bt(e.data.type)===Bt("FCL::CHALLENGE::CANCEL")&&(Mt(e.data.type,Ut),t()),Bt(e.data.type)===Bt("FCL::CANCEL")&&(Mt(e.data.type,Ut),t())}catch(e){console.error("Frame Callback Error",e),t()}}},e.discovery=We,e.events=function(e){let n;return n="string"==typeof e?{eventTypes:[e]}:e||{},{subscribe:r=>{const a=t.send([t.subscribeEvents(n)]).then(t.decode),i=a.then((()=>null)).catch((t=>{if("SDK Send Error: subscribeEvents is not supported by this transport."!==t.message)throw t;if("string"!=typeof e)throw new Error("GRPC fcl.events fallback only supports string (type) filters");return(n=e,{subscribe:e=>l.subscriber(n,Ae,e)}).subscribe(r);var n}));function o(e){e.forEach((e=>r(e,null)))}function s(e){r(null,e)}return i.then((e=>{e||a.then((e=>e.on("events",o).on("error",s))).catch((e=>{a.then((e=>e.close())),s(e)}))})),()=>{i.then((e=>{e?e():a.then((e=>e.close()))}))}}}},e.getChainId=U,e.getCurrentUser=Rt,e.getExecHttpPost=e=>async t=>{let{service:n,body:r,config:a,opts:i}=t;const o=await jt(n,{data:{fclVersion:P,service:{params:n.params,data:n.data,type:n.type},config:a,...r}}).then(Nt);if("APPROVED"===o.status)return o.data;if("DECLINED"===o.status)throw new Error(`Declined: ${o.reason||"No reason supplied."}`);if("REDIRECT"===o.status)return o;if("PENDING"===o.status){var s=!0,c=!0;const[t,n]=await e(it(o.local),{serviceEndpoint:_t,onClose:()=>c=!1}),r=()=>{try{n(),c=!1}catch(e){console.error("Frame Close Error",e)}},a=()=>{const e=s;return s=c,e};return Dt(o.updates,a).then((e=>(r(),e))).catch((e=>{throw console.error(e),r(),e}))}throw console.error("Auto Decline: Invalid Response",{service:n,resp:o}),new Error("Auto Decline: Invalid Response")},e.getMutate=e=>{let{platform:t}=e;return async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{await async function(e){return z("mutate",e)}(e),e=await B(e);const n=Rt({platform:t}),r=await v.config().get("fcl.authz",n().authorization);return v.config().overload(e.dependencies||{},(async()=>v.send([v.transaction(e.cadence),v.args(O(e.args||[])),e.limit&&C(e.limit)&&v.limit(e.limit),v.proposer(e.proposer||e.authz||r),v.payer(e.payer||e.authz||r),v.authorizations(e.authorizations||[e.authz||r])]).then(v.decode)))}catch(e){throw e}}},e.initServiceRegistry=xe,e.isReactNative=G,e.normalizePollingResponse=Nt,e.pluginRegistry=Ue,e.query=M,e.serialize=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await t.config.first(["sdk.resolve"],n.resolve||t.resolve);return Array.isArray(e)&&(e=await t.pipe(t.interaction(),e)),JSON.stringify(t.createSignableVoucher(await r(e)),null,2)},e.serviceEndpoint=_t,e.setIsReactNative=function(e){K=e},e.tx=Pe,e.verifyUserSignatures=ue,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=fcl-core.umd.min.js.map
