'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { currentUser, config, send, script, decode } from '@onflow/fcl';
import { WalletConnectorBase, logger } from '@dynamic-labs/wallet-connector-core';
import { DynamicError } from '@dynamic-labs/utils';
import { FlowWallet } from './wallet/FlowWallet.js';

class FlowWalletConnector extends WalletConnectorBase {
    constructor(opts) {
        var _a;
        super(opts);
        this.ChainWallet = FlowWallet;
        this.connectedChain = 'FLOW';
        this.supportedChains = ['FLOW'];
        this.appName = opts.appName;
        this.appLogoUrl = opts.appLogoUrl;
        this.network = (_a = opts.flowNetwork) !== null && _a !== void 0 ? _a : 'mainnet';
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setupConfig();
            const { addr } = yield currentUser().authenticate();
            if (addr && addr !== this.currentAccount) {
                this.currentAccount = addr;
                this.emit('accountChange', { accounts: [addr] });
            }
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.network;
        });
    }
    setupConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            yield config()
                .put('app.detail.title', this.appName)
                .put('app.detail.icon', this.appLogoUrl)
                .put('accessNode.api', this.network === 'testnet'
                ? 'https://rest-testnet.onflow.org'
                : 'https://rest-mainnet.onflow.org')
                .put('flow.network', this.network);
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.connect();
                const user = yield currentUser().snapshot();
                return user.addr;
            }
            catch (error) {
                logger.error(error);
                return undefined;
            }
        });
    }
    proveOwnership(address, messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(address);
            try {
                yield this.connect();
                yield this.signDelay();
                const signedMessage = yield this.signMessage(messageToSign);
                if (!signedMessage) {
                    return undefined;
                }
                const data = {
                    appName: this.appName,
                    signedMessage: JSON.parse(signedMessage),
                };
                return JSON.stringify(data);
            }
            catch (error) {
                logger.error(error);
                return undefined;
            }
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = Buffer.from(messageToSign).toString('hex');
            const signedMessage = yield currentUser().signUserMessage(message);
            if (signedMessage.includes('Declined')) {
                throw new DynamicError('User declined the signature');
            }
            return JSON.stringify(signedMessage);
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setupConfig();
            if (address) {
                const code = `
      pub fun main(): UFix64 {
        let account = getAccount(${address});
        return account.balance;
      }
      `;
                try {
                    return yield send([script(code)]).then(decode);
                }
                catch (error) {
                    logger.error(error);
                    return undefined;
                }
            }
            else {
                return undefined;
            }
        });
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            currentUser().unauthenticate();
        });
    }
    switchNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new DynamicError('Not supported');
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield currentUser().snapshot();
            if (user.addr) {
                return [user.addr];
            }
            return [];
        });
    }
    signDelay() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve();
        });
    }
    getBlockExplorerUrlsForCurrentNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return ['https://flowscan.io/'];
        });
    }
}

export { FlowWalletConnector };
