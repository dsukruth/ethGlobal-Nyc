'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var bitcoinjsLib = require('bitcoinjs-lib');
var satsConnect = require('sats-connect');
var utils = require('@dynamic-labs/utils');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var bitcoinNetworkTypeToNetworks = require('../../utils/psbt/bitcoinNetworkTypeToNetworks.cjs');
var BitcoinWalletConnector = require('../BitcoinWalletConnector.cjs');
var createSignPsbtOptions = require('../../utils/psbt/createSignPsbtOptions.cjs');
var _const = require('../../const.cjs');
var getSatsConnectSigningProtocol = require('../../utils/getSatsConnectSigningProtocol/getSatsConnectSigningProtocol.cjs');
var satoshisToBtc = require('../../utils/satoshisToBtc/satoshisToBtc.cjs');

class BitcoinSatsConnectConnector extends BitcoinWalletConnector.BitcoinWalletConnector {
    constructor(opts) {
        var _a, _b, _c;
        super(opts);
        this.isLegacy = false;
        this.currentNetwork = satsConnect.BitcoinNetworkType.Mainnet;
        if ((_b = (_a = opts.walletData) === null || _a === void 0 ? void 0 : _a.injectedConfig) === null || _b === void 0 ? void 0 : _b.length) {
            this.providerId =
                (_c = opts.walletData.injectedConfig[0].walletStandard) === null || _c === void 0 ? void 0 : _c.providerId;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getBalance(address) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const balance = yield satsConnect.request('getBalance', undefined);
            if (balance.status !== 'success') {
                throw balance.error;
            }
            return satoshisToBtc.satoshisToBtc(Number(balance.result.confirmed)).toString();
        });
    }
    getGenericUserCancelledError() {
        const error = new Error();
        error.code = '-32000'; // error code for user cancelled
        return error;
    }
    getAddresses() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const getAddressResponse = yield satsConnect.request('getAddresses', {
                purposes: [satsConnect.AddressPurpose.Payment, satsConnect.AddressPurpose.Ordinals],
            });
            if (getAddressResponse.status !== 'success') {
                throw getAddressResponse.error;
            }
            const { addresses } = getAddressResponse.result;
            const ordinalsAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === satsConnect.AddressPurpose.Ordinals);
            const paymentAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === satsConnect.AddressPurpose.Payment);
            const mainAddress = (_a = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _a !== void 0 ? _a : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
            yield this.setConnectedAccountWithAddresses({
                active: true,
                mainAddress,
                ordinalsAddress: ordinalsAccount,
                paymentAddress: paymentAccount,
            });
            return mainAddress;
        });
    }
    /**
     * If is inAppBrowser experience, redirects to the inAppBrowser template.
     * Returns true if redirection was triggered.
     */
    handleInAppBrowserGetAddress() {
        var _a;
        const inAppBrowserUrl = (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl;
        if (!utils.isMobile() ||
            this.isInstalledOnBrowser() ||
            !inAppBrowserUrl ||
            this.mobileExperience !== 'in-app-browser')
            return false;
        const inAppBrowserTemplate = utils.template(inAppBrowserUrl);
        const deepLink = inAppBrowserTemplate({
            // TODO: use PlatformService
            encodedDappURI: encodeURIComponent(window.location.toString()),
        });
        utils.PlatformService.openURL(deepLink);
        return true;
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.handleInAppBrowserGetAddress())
                return;
            try {
                // requesting permissions on initial connect will avoid connection prompt for other requests
                const permissionResponse = yield satsConnect.request('wallet_requestPermissions', undefined);
                if (permissionResponse.status !== 'success') {
                    throw permissionResponse.error;
                }
                const address = yield this.getAddresses();
                return address;
            }
            catch (_) {
                const error = this.getGenericUserCancelledError();
                throw error;
            }
        });
    }
    signMessage(messageToSign, options) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const { address, protocol } = options;
            try {
                const response = yield satsConnect.request('signMessage', {
                    address,
                    message: messageToSign,
                    protocol: getSatsConnectSigningProtocol.getSatsConnectSigningProtocol(protocol),
                });
                if (response.status !== 'success') {
                    throw response.error;
                }
                if (this.isHardwareWalletEnabled) {
                    return JSON.stringify({
                        signedTransaction: {
                            data: response.result.signature,
                        },
                    });
                }
                return response.result.signature;
            }
            catch (_) {
                const error = this.getGenericUserCancelledError();
                throw error;
            }
        });
    }
    sendBitcoin(transaction) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield satsConnect.request('sendTransfer', {
                    recipients: [
                        {
                            address: transaction.recipientAddress,
                            amount: Number(transaction.amount),
                        },
                    ],
                });
                if (response.status !== 'success') {
                    throw response.error;
                }
                return response.result.txid;
            }
            catch (_) {
                const error = this.getGenericUserCancelledError();
                throw error;
            }
        });
    }
    signTransaction(params) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const { allowedSignHash, psbtBase64, broadcast, inputsToSign } = params;
            const signPbstPayload = {
                allowedSignHash,
                broadcast,
                psbt: psbtBase64,
                // we have to combine signing indexes for like addresses
                signInputs: inputsToSign.reduce((accum, curr) => {
                    if (!accum[curr.address]) {
                        accum[curr.address] = [];
                    }
                    accum[curr.address].push(...curr.signingIndexes);
                    return accum;
                }, {}),
            };
            walletConnectorCore.logger.logVerboseTroubleshootingMessage('[BitcoinSatsConnectConnector] signTransaction', {
                signPbstPayload,
            });
            try {
                const response = yield satsConnect.request('signPsbt', signPbstPayload);
                if (response.status !== 'success') {
                    throw response.error;
                }
                return { psbtBase64: response.result.psbt, txId: response.result.txid };
            }
            catch (_) {
                const error = this.getGenericUserCancelledError();
                throw error;
            }
        });
    }
    signTransactions(transactions) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const { message, psbts, network } = transactions;
            walletConnectorCore.logger.logVerboseTroubleshootingMessage('[BitcoinSatsConnectConnector] signTransactions', {
                transactions,
            });
            return new Promise((resolve, reject) => {
                satsConnect.signMultipleTransactions({
                    getProvider: () => _tslib.__awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[_const.SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = this.getGenericUserCancelledError();
                        reject(error);
                    },
                    onFinish: (response) => {
                        resolve(response);
                    },
                    payload: {
                        message: message || 'Sign Transaction',
                        network,
                        psbts,
                    },
                });
            });
        });
    }
    signPsbt(request) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!((_a = request.allowedSighash) === null || _a === void 0 ? void 0 : _a.length))
                throw new Error('allowedSighash cannot be an empty array');
            const network = bitcoinNetworkTypeToNetworks.convertNetworkTypeForPsbt(this.currentNetwork);
            const psbtFromBase64 = bitcoinjsLib.Psbt.fromBase64(request.unsignedPsbtBase64, {
                network,
            });
            walletConnectorCore.logger.logVerboseTroubleshootingMessage('signPsbt', {
                isLegacy: this.isLegacy,
                psbtFromBase64,
                request,
            });
            const signedPsbt = yield this.signTransaction({
                broadcast: false,
                inputsToSign: createSignPsbtOptions.createSignPsbtOptionsForSatsConnect(psbtFromBase64, request, this.isLegacy),
                psbtBase64: request.unsignedPsbtBase64,
            });
            if (!signedPsbt) {
                throw new Error('Failed to sign transaction with sats-connect');
            }
            return { signedPsbt: signedPsbt.psbtBase64 };
        });
    }
    signPsbts(requests) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const network = bitcoinNetworkTypeToNetworks.convertNetworkTypeForPsbt(this.currentNetwork);
            const signMultipleTransactionPayload = {
                message: 'Sign Transaction',
                network: {
                    type: this.currentNetwork,
                },
                psbts: [],
            };
            for (const request of requests) {
                const psbtFromBase64 = bitcoinjsLib.Psbt.fromBase64(request.unsignedPsbtBase64, {
                    network,
                });
                const inputsToSign = createSignPsbtOptions.createSignPsbtOptionsForSatsConnect(psbtFromBase64, request, this.isLegacy);
                signMultipleTransactionPayload.psbts.push({
                    inputsToSign,
                    psbtBase64: request.unsignedPsbtBase64,
                });
            }
            walletConnectorCore.logger.logVerboseTroubleshootingMessage('signPsbts', signMultipleTransactionPayload);
            const signedPsbts = yield this.signTransactions(signMultipleTransactionPayload);
            return (_a = signedPsbts === null || signedPsbts === void 0 ? void 0 : signedPsbts.map((signedPsbts) => signedPsbts.psbtBase64)) !== null && _a !== void 0 ? _a : [];
        });
    }
    validateActiveWallet(expectedAddress) {
        const _super = Object.create(null, {
            validateActiveWallet: { get: () => super.validateActiveWallet }
        });
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            // TODO: this is a workaround to avoid extra connecting prompt for xverse
            // we should revisit it once xverse releases a new version with bug fixes
            if (this.key !== 'xverse') {
                yield _super.validateActiveWallet.call(this, expectedAddress);
                return;
            }
            walletConnectorCore.logger.debug('validateActiveWallet - skipping validation for xverse', {
                expectedAddress,
            });
        });
    }
    handleXverseAccountChange() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const { handleAccountChange } = walletConnectorCore.eventListenerHandlers(this);
            // xverse doesn't return the new account address, so we need to get it manually
            const accounts = yield this.getAddresses();
            if (!accounts) {
                return;
            }
            const connectedAccounts = [accounts];
            handleAccountChange(connectedAccounts);
        });
    }
    setupEventListeners() {
        // even if we pass a providerId, to addListener, it doesn't work
        // the event fires multiple times, so we're using the default implementation for non xverse wallets
        if (this.key !== 'xverse') {
            super.setupEventListeners();
            return;
        }
        try {
            const removeListener = satsConnect.addListener('accountChange', this.handleXverseAccountChange.bind(this));
            this.teardownEventListeners = () => {
                walletConnectorCore.logger.debug('[BitcoinSatsConnectConnector] teardownEventListeners');
                removeListener();
            };
        }
        catch (error) {
            walletConnectorCore.logger.debug('[BitcoinSatsConnectConnector] setupEventListeners', {
                connector: this.key,
                error,
            });
        }
    }
}

exports.BitcoinSatsConnectConnector = BitcoinSatsConnectConnector;
