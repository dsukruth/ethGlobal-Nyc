'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { createUnsecuredToken } from 'jsontokens';
import { getAddress, AddressPurpose, signMessage, sendBtcTransaction, signTransaction } from 'sats-connect';
import { DynamicError } from '@dynamic-labs/utils';
import { SATSCONNECT_FEATURE } from '../../const.js';
import { BitcoinSatsConnectConnector } from '../BitcoinSatsConnectConnector/BitcoinSatsConnectConnector.js';
import { getSatsConnectSigningProtocol } from '../../utils/getSatsConnectSigningProtocol/getSatsConnectSigningProtocol.js';

class MagicEdenConnector extends BitcoinSatsConnectConnector {
    constructor(opts) {
        super(Object.assign(Object.assign({}, opts), { overrideKey: 'magicedenbtc' }));
        this.name = 'Magic Eden';
        this.overrideKey = 'magicedenbtc';
        this.isLegacy = true;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.handleInAppBrowserGetAddress())
                return;
            return new Promise((resolve, reject) => {
                getAddress({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => __awaiter(this, void 0, void 0, function* () {
                        var _c;
                        const { addresses } = response;
                        const ordinalsAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === AddressPurpose.Ordinals);
                        const paymentAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === AddressPurpose.Payment);
                        const mainAddress = (_c = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _c !== void 0 ? _c : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
                        yield this.setConnectedAccountWithAddresses({
                            active: true,
                            mainAddress,
                            ordinalsAddress: ordinalsAccount,
                            paymentAddress: paymentAccount,
                        });
                        resolve(mainAddress);
                    }),
                    payload: {
                        message: 'Address for receiving Ordinals and payments',
                        network: {
                            type: this.currentNetwork,
                        },
                        purposes: [AddressPurpose.Ordinals, AddressPurpose.Payment],
                    },
                });
            });
        });
    }
    signMessage(messageToSign, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { address, protocol } = options;
            return new Promise((resolve, reject) => {
                signMessage({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => __awaiter(this, void 0, void 0, function* () {
                        if (this.isHardwareWalletEnabled) {
                            return resolve(JSON.stringify({
                                signedTransaction: {
                                    data: response,
                                },
                            }));
                        }
                        resolve(response);
                    }),
                    payload: {
                        address,
                        message: messageToSign,
                        network: {
                            type: this.currentNetwork,
                        },
                        protocol: getSatsConnectSigningProtocol(protocol),
                    },
                });
            });
        });
    }
    sendBitcoin(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const mainAddress = yield this.getAddress();
            const senderAddress = (_a = (yield this.getAdditionalAddresses(mainAddress)).find((address) => address.type === 'payment')) === null || _a === void 0 ? void 0 : _a.address;
            if (!senderAddress) {
                return;
            }
            return new Promise((resolve, reject) => {
                sendBtcTransaction({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => {
                        resolve(response);
                    },
                    payload: {
                        network: {
                            type: this.currentNetwork,
                        },
                        recipients: [
                            {
                                address: transaction.recipientAddress,
                                amountSats: BigInt(transaction.amount),
                            },
                        ],
                        senderAddress,
                    },
                });
            });
        });
    }
    signTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { message, psbtBase64, broadcast, inputsToSign } = params;
            return new Promise((resolve, reject) => {
                signTransaction({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => {
                        resolve(response);
                    },
                    payload: {
                        broadcast,
                        inputsToSign,
                        message: message || 'Sign Transaction',
                        network: {
                            type: this.currentNetwork,
                        },
                        psbtBase64,
                    },
                });
            });
        });
    }
    /**
     * Uses the custom Magic Eden signTransactions feature to sign multiple transactions
     */
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            (_a = transactions.message) !== null && _a !== void 0 ? _a : (transactions.message = 'Sign Transaction');
            const request = createUnsecuredToken(transactions);
            // Magic Eden has implemented their own signTransactions feature, and have requested us
            // to ensure we use it rather than the general Sats Connect API for this method
            const provider = this.getProvider();
            if (!provider)
                throw new DynamicError('signTransactions failed: Magic Eden provider not found');
            return provider.signMultipleTransactions(request);
        });
    }
}

export { MagicEdenConnector };
