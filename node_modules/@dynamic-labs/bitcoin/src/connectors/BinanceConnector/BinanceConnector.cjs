'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var bitcoinjsLib = require('bitcoinjs-lib');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var BitcoinWalletConnector = require('../BitcoinWalletConnector.cjs');
var createSignPsbtOptions = require('../../utils/psbt/createSignPsbtOptions.cjs');

class BinanceConnector extends BitcoinWalletConnector.BitcoinWalletConnector {
    constructor(opts) {
        super(Object.assign(Object.assign({}, opts), { overrideKey: 'binancewalletbtc' }));
        this.name = 'Binance Wallet';
        this.overrideKey = 'binancewalletbtc';
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                return;
            }
            const [address] = yield provider.requestAccounts();
            const bitcoinAddress = {
                address,
                publicKey: yield provider.getPublicKey(),
            };
            yield this.setConnectedAccountWithAddresses({
                active: true,
                mainAddress: address,
                ordinalsAddress: bitcoinAddress,
            });
            return address;
        });
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                return [];
            }
            return provider.getAccounts();
        });
    }
    signMessage(messageToSign, options) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const provider = this.getProvider();
            if (!provider) {
                return;
            }
            // default to ecdsa
            const protocol = (_a = options === null || options === void 0 ? void 0 : options.protocol) !== null && _a !== void 0 ? _a : 'ecdsa';
            if (options === null || options === void 0 ? void 0 : options.address) {
                walletConnectorCore.logger.debug('[OneKeyConnector] signMessage - Not possible to specify address to sign with', {
                    address: options.address,
                });
            }
            return provider.signMessage(messageToSign, protocol);
        });
    }
    signPsbt(request) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                return;
            }
            const psbtFromBase64 = bitcoinjsLib.Psbt.fromBase64(request.unsignedPsbtBase64);
            const psbtOptions = createSignPsbtOptions.createPsbtOptions(psbtFromBase64, request);
            const signedPsbtHex = yield provider.signPsbt(psbtFromBase64.toHex(), {
                autoFinalized: false,
                toSignInputs: psbtOptions.toSignInputs || [],
            });
            return { signedPsbt: bitcoinjsLib.Psbt.fromHex(signedPsbtHex).toBase64() };
        });
    }
}

exports.BinanceConnector = BinanceConnector;
