'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { AddressPurpose } from 'sats-connect';
import { WalletConnectorBase, isConnectorMethodSupported, eventListenerHandlers, logger } from '@dynamic-labs/wallet-connector-core';
import { getWalletBookWallet } from '@dynamic-labs/wallet-book';
import { isLedgerAddressViaVerifiedCredentials, isMobile, template, PlatformService, DynamicError } from '@dynamic-labs/utils';
import { WalletAddressType } from '@dynamic-labs/sdk-api-core';
import { BitcoinLocalStorageCache } from '../BitcoinLocalStorageCache.js';
import { BitcoinProviderHelper } from '../bitcoinProviderHelper.js';
import { getMempoolApiUrl } from '../utils/getMempoolApiUrl.js';
import { HTTP_STATUS_TOO_MANY_REQUESTS, HTTP_STATUS_NOT_FOUND } from '../const.js';
import { satoshisToBtc } from '../utils/satoshisToBtc/satoshisToBtc.js';
import { BitcoinWallet } from '../wallet/BitcoinWallet.js';

class BitcoinWalletConnector extends WalletConnectorBase {
    constructor(opts) {
        var _a;
        super(opts);
        this.ChainWallet = BitcoinWallet;
        this.connectedChain = 'BTC';
        this.supportedChains = ['BTC'];
        // some wallets don't support fetching connected accounts without prompting for a connection
        this.canFetchConnectedAccounts = false;
        this.isHardwareWalletEnabled = false;
        this.verifiedCredentials = [];
        // this is the key from the wallet book entry so that we don't purely rely on the normalized name
        this.overrideKey = (_a = opts.overrideKey) !== null && _a !== void 0 ? _a : this.key;
        const walletBookWallet = opts.walletData || getWalletBookWallet(this.walletBook, this.key);
        this.bitcoinProviderHelper = new BitcoinProviderHelper(walletBookWallet);
        this.wallet = this.bitcoinProviderHelper.findWallet();
        if (this.wallet) {
            this.walletMethods = this.bitcoinProviderHelper.getWalletMethods(this.wallet);
        }
        this.cache = new BitcoinLocalStorageCache(this.overrideKey);
        this.canFetchConnectedAccounts = isConnectorMethodSupported(this, 'getConnectedAccounts', 'desktop');
    }
    isSameAccountChangeRequest(to) {
        return this.lastAccountChange === to;
    }
    setLastAccountChangeRequest(to) {
        this.lastAccountChange = to;
    }
    clearConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cache.clearConnectedAcccounts();
        });
    }
    canConnectWithHardwareWallet() {
        var _a;
        return Boolean((_a = this.metadata.supportedHardwareWallets) === null || _a === void 0 ? void 0 : _a.includes('ledger'));
    }
    isInstalledOnBrowser() {
        var _a;
        return (Boolean(this.wallet) || Boolean((_a = this.bitcoinProviderHelper) === null || _a === void 0 ? void 0 : _a.getProvider()));
    }
    getDeepLink() {
        return undefined;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cache.clearConnectedAcccounts();
        });
    }
    apiGetBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const API_URL = getMempoolApiUrl(address);
            const response = yield fetch(`${API_URL}/address/${address}`);
            if (!response.ok) {
                // if the request fails due to rate limits, return cached value
                if (response.status === HTTP_STATUS_TOO_MANY_REQUESTS) {
                    return '0';
                }
                // new accounts not yet indexed will return a 404
                if (response.status === HTTP_STATUS_NOT_FOUND) {
                    return '0';
                }
                return undefined;
            }
            const addressInfo = yield response.json();
            if (!(addressInfo === null || addressInfo === void 0 ? void 0 : addressInfo.chain_stats) || !(addressInfo === null || addressInfo === void 0 ? void 0 : addressInfo.mempool_stats)) {
                return undefined;
            }
            const confirmedBalanceInSats = Number(addressInfo.chain_stats.funded_txo_sum) -
                Number(addressInfo.chain_stats.spent_txo_sum);
            const unconfirmedBalanceInSats = Number(addressInfo.mempool_stats.funded_txo_sum) -
                Number(addressInfo.mempool_stats.spent_txo_sum);
            const balance = satoshisToBtc(confirmedBalanceInSats + unconfirmedBalanceInSats);
            return balance.toString();
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!(provider === null || provider === void 0 ? void 0 : provider.getBalance)) {
                return this.apiGetBalance(address);
            }
            const balanceResponse = yield provider.getBalance();
            const balance = satoshisToBtc(balanceResponse.total);
            return balance.toString();
        });
    }
    getConnectedAccountsFromCache() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const currentAccount = yield this.cache.getActiveAccount();
            const allAccounts = yield this.cache.getConnectedAccounts();
            const allConnectedAddresses = (_a = Object.keys(allAccounts || {})) !== null && _a !== void 0 ? _a : [];
            if (!(currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.address)) {
                return allConnectedAddresses;
            }
            // return all connected accounts with the current account as the first item
            return [
                currentAccount.address,
                ...allConnectedAddresses.filter((address) => address !== currentAccount.address),
            ];
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            // some wallets like xverse don't support fetching connected accounts
            // without prompting for a connection
            // to avoid this behavior, we cache the connected accounts
            if (!this.canFetchConnectedAccounts) {
                return this.getConnectedAccountsFromCache();
            }
            // if we decide that is ok to prompt for a connection when fetching connected accounts
            // we shouldn't prompt every time we call this method (which is a lot of times)
            // so we just store in a promise and return the same promise every time
            if (!this.getAddressPromise) {
                this.getAddressPromise = this.getAddress();
            }
            let connectedAccount;
            try {
                connectedAccount = yield this.getAddressPromise;
            }
            catch (error) {
                logger.error(`${this.key} getConnectedAccounts - error fetching connected account`, error);
                //don't throw error just return empty array after clearing the promise
            }
            this.getAddressPromise = undefined;
            if (!connectedAccount) {
                return [];
            }
            return [connectedAccount];
        });
    }
    getAdditionalAddresses(mainAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!mainAddress) {
                return [];
            }
            const currentAccount = yield this.cache.getConnectedAccount(mainAddress);
            return (currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.additionalAddresses) || [];
        });
    }
    setAdditionalAddresses(mainAddress, additionalAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cache.setConnectedAccount(mainAddress, {
                additionalAddresses,
            });
        });
    }
    sendRawTransaction(rawTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!rawTransaction) {
                throw new DynamicError('No transaction specified!');
            }
            const [connectedAddress] = yield this.getConnectedAccounts();
            if (!connectedAddress) {
                throw new DynamicError('No connected address found!');
            }
            const API_URL = getMempoolApiUrl(connectedAddress);
            const response = yield fetch(`${API_URL}/tx`, {
                body: rawTransaction,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                method: 'POST',
            });
            if (!response.ok) {
                if (response.status === HTTP_STATUS_TOO_MANY_REQUESTS) {
                    throw new DynamicError('sendRawTransaction - mempool api rate limit exceeded');
                }
                const error = yield response.text();
                logger.debug(`sendRawTransaction - response not ok: ${JSON.stringify(error)}`);
                throw new DynamicError('sendRawTransaction - failed to send transaction');
            }
            // this endpoint returns the transaction ID
            return response.text();
        });
    }
    // not all wallets support sendBitcoin method
    // so we have a default implementation that returns undefined
    sendBitcoin(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('sendBitcoin - function not implemented', transaction);
            return undefined;
        });
    }
    getProvider() {
        var _a;
        return (_a = this.bitcoinProviderHelper) === null || _a === void 0 ? void 0 : _a.getProvider();
    }
    signPsbts(requests) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedPsbtResponses = [];
            for (const request of requests) {
                const signedPsbtResponse = yield this.signPsbt(request);
                if (signedPsbtResponse) {
                    signedPsbtResponses.push(signedPsbtResponse);
                }
            }
            return signedPsbtResponses.map((response) => response.signedPsbt);
        });
    }
    setConnectedAccountWithAddresses(_a) {
        return __awaiter(this, arguments, void 0, function* ({ mainAddress, ordinalsAddress, paymentAddress, active, }) {
            if (!mainAddress) {
                return;
            }
            const additionalAddresses = [];
            if (ordinalsAddress) {
                additionalAddresses.push({
                    address: ordinalsAddress.address,
                    publicKey: ordinalsAddress.publicKey,
                    type: WalletAddressType.Ordinals,
                });
            }
            if (paymentAddress) {
                additionalAddresses.push({
                    address: paymentAddress.address,
                    publicKey: paymentAddress.publicKey,
                    type: WalletAddressType.Payment,
                });
            }
            this.cache.setConnectedAccount(mainAddress, {
                active,
                additionalAddresses,
            });
        });
    }
    setupEventListeners() {
        const provider = this.getProvider();
        if (!(provider === null || provider === void 0 ? void 0 : provider.on)) {
            return;
        }
        const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
        const handleBitcoinAccountChange = (accounts) => __awaiter(this, void 0, void 0, function* () {
            let connectedAccounts = accounts;
            let ordinalsAccount, paymentAccount;
            // if accounts is an array of objects, we need to parse them to return only addresses
            // since ordinals is the main address we use, we should return it as the first address
            if (typeof accounts[0] === 'object') {
                connectedAccounts = accounts
                    .sort((account) => account.purpose === AddressPurpose.Ordinals ? -1 : 1)
                    .map((account) => account.address);
                [ordinalsAccount, paymentAccount] = connectedAccounts;
            }
            const currentConnectedAccounts = yield this.getConnectedAccountsFromCache();
            // don't do anything if the connected accounts haven't changed
            // or if the account change request is the same as previous request
            if (currentConnectedAccounts[0] === connectedAccounts[0] ||
                this.isSameAccountChangeRequest(connectedAccounts[0])) {
                return;
            }
            // set the last account change request with the from and to addresses
            // to ensure that the requests are not duplicated
            this.setLastAccountChangeRequest(connectedAccounts[0]);
            if (ordinalsAccount || paymentAccount) {
                this.setConnectedAccountWithAddresses({
                    active: true,
                    mainAddress: ordinalsAccount !== null && ordinalsAccount !== void 0 ? ordinalsAccount : paymentAccount,
                    ordinalsAddress: ordinalsAccount,
                    paymentAddress: paymentAccount,
                });
            }
            handleAccountChange(connectedAccounts);
        });
        provider.on('accountsChanged', handleBitcoinAccountChange);
        provider.on('networkChanged', handleChainChange);
        provider.on('disconnect', handleDisconnect);
        const tearDownEventListeners = () => {
            const provider = this.getProvider();
            if (!(provider === null || provider === void 0 ? void 0 : provider.removeListener)) {
                return;
            }
            provider.removeListener('accountsChanged', handleBitcoinAccountChange);
            provider.removeListener('networkChanged', handleChainChange);
            provider.removeListener('disconnect', handleDisconnect);
        };
        this.teardownEventListeners = tearDownEventListeners;
    }
    setVerifiedCredentials(verifiedCredentials) {
        this.verifiedCredentials = verifiedCredentials;
    }
    isLedgerAddress(address) {
        return isLedgerAddressViaVerifiedCredentials(address, this.verifiedCredentials);
    }
    // Each wallet has a different supported protocol
    // So we should override this method in each connector
    // and define how to handle the protocol
    signMessage(messageToSign, options) {
        const _super = Object.create(null, {
            signMessage: { get: () => super.signMessage }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (options) {
                logger.debug('[BitcoinWalletConnector] signMessage - Not possible to specify address and/or protocol to sign with', {
                    address: options.address,
                    protocol: options.protocol,
                });
            }
            return _super.signMessage.call(this, messageToSign);
        });
    }
    proveOwnership(address, messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.signMessage(messageToSign, { address });
        });
    }
    getBlockExplorerUrlsForCurrentNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return ['https://btcscan.org/'];
        });
    }
    openInAppBrowserIfRequired() {
        var _a;
        if (this.isInstalledOnBrowser() ||
            !isMobile() ||
            !((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl) ||
            this.mobileExperience === 'redirect') {
            return false;
        }
        const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
        const deepLink = inAppBrowserCompiledTemplate({
            // TODO: use PlatformService
            encodedDappURI: encodeURIComponent(window.location.toString()),
        });
        PlatformService.openURL(deepLink);
        return true;
    }
}

export { BitcoinWalletConnector };
