'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { Wallet } from '@dynamic-labs/wallet-connector-core';
import { getAddressByType } from '../utils/getAddressByType/getAddressByType.js';

class BitcoinWallet extends Wallet {
    /**
     * Sends the native balance of the wallet to the given address.
     * @param amount - The amount of balance to send (in satoshis).
     * @param toAddress - The address to send the balance to.
     * @returns The signature of the sent transaction.
     */
    sendBalance(_a) {
        return __awaiter(this, arguments, void 0, function* ({ amount, toAddress, }) {
            return this.sendBitcoin({
                amount: BigInt(amount),
                recipientAddress: toAddress,
            });
        });
    }
    /**
     * Sends a raw transaction
     * @returns A promise that resolves to the transaction id
     */
    sendRawTransaction(rawTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return this._connector.sendRawTransaction(rawTransaction);
        });
    }
    /**
     * Sends satoshis to a bitcoin address
     * @returns A promise that resolves to the transaction id
     */
    sendBitcoin(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return this._connector.sendBitcoin(transaction);
        });
    }
    /**
     * Signs a message using a specific address type (payment or ordinals).
     * @param messageToSign - The message to sign.
     * @param options - Optional configuration for signing
     * @param options.addressType - The type of address to sign with (e.g. 'payment' or 'ordinals')
     * @param options.protocol - The signing protocol to use (e.g. 'ecdsa' or 'bip322-simple')
     * @returns A promise that resolves to the signature of the message as a string,
     * or undefined if the message cannot be signed.
     */
    signMessage(messageToSign, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            const address = (options === null || options === void 0 ? void 0 : options.addressType)
                ? getAddressByType(this, options.addressType)
                : this.address;
            return this._connector.signMessage(messageToSign, {
                address,
                protocol: options === null || options === void 0 ? void 0 : options.protocol,
            });
        });
    }
    /**
     * Sings a PSBT
     * @returns A promise that resolves to an object with the signed PSBT
     * or undefined if no provider is available
     */
    signPsbt(request) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return this._connector.signPsbt(request);
        });
    }
    /**
     * Sings multiple PSBTs
     * @returns A promise that resolves to an array of signed PSBTs in base64
     * or undefined if no provider is available
     */
    signPsbts(requests) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sync();
            return this._connector.signPsbts(requests);
        });
    }
}

export { BitcoinWallet };
