'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
import { MFAAction } from '@dynamic-labs/sdk-api-core';
import { SuiWalletConnector, SuiUiTransaction } from '@dynamic-labs/sui-core';
import { DynamicError } from '@dynamic-labs/utils';
import { withDynamicWaas } from '@dynamic-labs/waas';
import { isSameAddress } from '@dynamic-labs/wallet-connector-core';
import { WaasSuiWallet } from '../wallet/WaasSuiWallet.js';

class DynamicWaasSuiConnector extends withDynamicWaas(SuiWalletConnector) {
    constructor(props) {
        super('Dynamic Waas', props);
        this.ChainWallet = WaasSuiWallet;
        this.switchNetworkOnlyFromWallet = false;
        this.name = 'Dynamic Waas';
        this.overrideKey = 'dynamicwaas';
        this.isEmbeddedWallet = true;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            yield this.getWaasWalletClient();
            if (!this.activeNetworkId) {
                this.activeNetworkId =
                    ((_c = (_b = (_a = this.suiNetworks) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.networkId) === null || _c === void 0 ? void 0 : _c.toString()) || '501';
            }
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (!this.activeNetworkId) {
                this.activeNetworkId =
                    ((_c = (_b = (_a = this.suiNetworks) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.networkId) === null || _c === void 0 ? void 0 : _c.toString()) || '501';
            }
            return this.activeNetworkId;
        });
    }
    getNetworkName() {
        return __awaiter(this, void 0, void 0, function* () {
            const networkId = yield this.getNetwork();
            if (!networkId) {
                throw new DynamicError('Missing network id');
            }
            switch (networkId) {
                case '501':
                    return 'mainnet';
                case '502':
                    return 'testnet';
                case '503':
                    return 'devnet';
                default:
                    throw new DynamicError(`Unsupported network: ${networkId}`);
            }
        });
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!networkChainId)
                return;
            const networkIdString = networkChainId.toString();
            const isValidNetwork = this.suiNetworks.some((network) => network.networkId === networkIdString);
            if (!isValidNetwork) {
                throw new DynamicError(`Network ${networkIdString} is not supported`);
            }
            this.activeNetworkId = networkIdString;
            this.emit('chainChange', { chain: networkIdString });
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    setActiveAccountAddress(accountAddress) {
        this.activeAccountAddress = accountAddress;
    }
    getActiveAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.activeAccountAddress;
        });
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const targetWallet = yield walletClient.getWallet({
                accountAddress: expectedAddress,
                authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
                signedSessionId,
            });
            if (!targetWallet) {
                throw new DynamicError('Account not found');
            }
            const isWalletActive = isSameAddress(targetWallet.accountAddress, this.activeAccountAddress || '', this.connectedChain);
            if (!isWalletActive) {
                this.activeAccountAddress = targetWallet.accountAddress;
            }
        });
    }
    // Override importPrivateKey to use the proper type casting for SUI
    importPrivateKey(_a) {
        return __awaiter(this, arguments, void 0, function* ({ privateKey, thresholdSignatureScheme = 'TWO_OF_TWO', }) {
            var _b, _c;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            yield walletClient.importPrivateKey({
                authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                privateKey,
                signedSessionId,
                thresholdSignatureScheme: thresholdSignatureScheme,
            });
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const waasSuiClient = yield this.getWaasWalletClient();
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                mfaAction: MFAAction.WalletWaasSign,
            }));
            const signedMessage = yield waasSuiClient.signMessage({
                accountAddress: this.activeAccountAddress,
                authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                message,
                mfaToken,
                signedSessionId,
            });
            return signedMessage;
        });
    }
    createAndSignTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const networkName = yield this.getNetworkName();
            const client = new SuiClient({ url: getFullnodeUrl(networkName) });
            const txBytes = yield transaction.build({ client });
            const txString = Buffer.from(txBytes).toString('hex');
            const walletClient = yield this.getWaasWalletClient();
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                mfaAction: MFAAction.WalletWaasSign,
            }));
            const signedTx = yield walletClient.signTransaction({
                authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                mfaToken,
                senderAddress: this.activeAccountAddress,
                signedSessionId,
                transaction: txString,
            });
            return {
                client,
                signedTx: {
                    bytes: txBytes,
                    signature: signedTx,
                },
            };
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { signedTx } = yield this.createAndSignTransaction(transaction);
                return signedTx;
            }
            catch (error) {
                throw new Error('Failed to sign transaction', {
                    cause: error,
                });
            }
        });
    }
    signAndExecuteTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { signedTx, client } = yield this.createAndSignTransaction(transaction);
                return client.executeTransactionBlock({
                    signature: signedTx.signature,
                    transactionBlock: signedTx.bytes,
                });
            }
            catch (error) {
                throw new Error('Failed to sign and execute transaction', {
                    cause: error,
                });
            }
        });
    }
    getSuiClient() {
        return __awaiter(this, void 0, void 0, function* () {
            const networkName = yield this.getNetworkName();
            return new SuiClient({ url: getFullnodeUrl(networkName) });
        });
    }
    getWalletClientByAddress(_a) {
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, }) {
            this.setActiveAccountAddress(accountAddress);
            const client = yield this.getWaasWalletClient();
            return client;
        });
    }
    getWalletClient() {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getWaasWalletClient();
            return client;
        });
    }
    // Chain-specific override for exportClientKeyshares - SUI needs to handle optional account address
    exportClientKeyshares(_a) {
        const _super = Object.create(null, {
            exportClientKeyshares: { get: () => super.exportClientKeyshares }
        });
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
            const targetAccountAddress = accountAddress || this.activeAccountAddress;
            if (!targetAccountAddress) {
                throw new Error('Account address is required');
            }
            return _super.exportClientKeyshares.call(this, {
                accountAddress: targetAccountAddress,
                password,
            });
        });
    }
    /** Function used to create transactions in the SDK interface */
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const suiClient = yield this.getSuiClient();
            if (!suiClient) {
                throw new DynamicError('No Sui client available');
            }
            return new SuiUiTransaction({
                client: suiClient,
                from,
                onSubmit: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    if (!this.activeAccountAddress || !transaction) {
                        throw new DynamicError('No active account address or transaction found');
                    }
                    const result = yield this.signAndExecuteTransaction(transaction);
                    return result;
                }),
            });
        });
    }
    endSession() {
        const _super = Object.create(null, {
            endSession: { get: () => super.endSession }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.endSession.call(this);
            this.activeAccountAddress = undefined;
        });
    }
    signMessageWithContext() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
}

export { DynamicWaasSuiConnector };
