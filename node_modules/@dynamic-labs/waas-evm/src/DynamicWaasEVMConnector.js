'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { http, serializeTransaction, erc20Abi, parseSignature } from 'viem';
import { toAccount } from 'viem/accounts';
import { hashAuthorization } from 'viem/utils';
import { EthereumWalletConnector, createWalletClientWithUiConfirmation, getOrMapViemChain, ViemUiTransaction } from '@dynamic-labs/ethereum-core';
import { Logger } from '@dynamic-labs/logger';
import { MFAAction } from '@dynamic-labs/sdk-api-core';
import { DynamicError } from '@dynamic-labs/utils';
import { withDynamicWaas, WaasExportHandler } from '@dynamic-labs/waas';
import { isSameAddress } from '@dynamic-labs/wallet-connector-core';

const logger = new Logger('DynamicWaasConnector');
class DynamicWaasEVMConnector extends withDynamicWaas(EthereumWalletConnector) {
    constructor(props) {
        super(props);
        this.name = 'Dynamic Waas';
        this.overrideKey = 'dynamicwaas';
        this.isEmbeddedWallet = true;
        this._selectedChainId = this.getLastUsedChainId();
        this.__exportHandler = new WaasExportHandler();
    }
    getLastUsedChainId() {
        var _a;
        logger.logVerboseTroubleshootingMessage('[DynamicWaasEVMConnector] getLastUsedChainId', {
            evmNetworks: this.evmNetworks,
            lastUsedChainId: this.lastUsedChainId,
        });
        if (this.lastUsedChainId) {
            return this.lastUsedChainId;
        }
        if (!((_a = this.evmNetworks) === null || _a === void 0 ? void 0 : _a.length)) {
            return undefined;
        }
        return this.evmNetworks[0].chainId;
    }
    set verifiedCredentials(verifiedCredentials) {
        this._verifiedCredentials = verifiedCredentials;
    }
    get verifiedCredentials() {
        return this._verifiedCredentials;
    }
    set verifiedCredential(verifiedCredential) {
        this._verifiedCredential = verifiedCredential;
    }
    get verifiedCredential() {
        return this._verifiedCredential;
    }
    setVerifiedCredentials(verifiedCredentials) {
        const dynamicWaasVerifiedCredentials = verifiedCredentials === null || verifiedCredentials === void 0 ? void 0 : verifiedCredentials.reduce((acc, vc) => {
            if (vc.walletName === 'dynamicwaas' && vc.chain === 'eip155') {
                const smartWallet = verifiedCredentials.find((v) => v.signerRefId === vc.id);
                const smartWalletRefId = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.id;
                const smartWalletRefAddress = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.address;
                acc.push(Object.assign(Object.assign({}, vc), { smartWalletRefAddress, smartWalletRefId }));
            }
            return acc;
        }, []);
        const [dynamicWaasVerifiedCredential] = dynamicWaasVerifiedCredentials;
        const didDynamicWaasVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !==
            JSON.stringify(dynamicWaasVerifiedCredentials);
        if (!didDynamicWaasVerifiedCredentialsChanged) {
            return;
        }
        this.verifiedCredential = dynamicWaasVerifiedCredential;
        this.verifiedCredentials = dynamicWaasVerifiedCredentials;
    }
    set lastUsedChainId(chainId) {
        if (chainId === undefined) {
            localStorage.removeItem(DynamicWaasEVMConnector.lastUsedChainIdStorageKey);
        }
        else {
            localStorage.setItem(DynamicWaasEVMConnector.lastUsedChainIdStorageKey, chainId.toString());
        }
        this._selectedChainId = chainId;
    }
    get lastUsedChainId() {
        const lastUsedChainIdLS = localStorage.getItem(DynamicWaasEVMConnector.lastUsedChainIdStorageKey);
        if (!lastUsedChainIdLS)
            return undefined;
        try {
            const chainId = parseInt(lastUsedChainIdLS);
            if (isNaN(chainId)) {
                return undefined;
            }
            const isChainCurrentlyEnabled = this.evmNetworks.some((network) => network.chainId === chainId);
            if (!isChainCurrentlyEnabled) {
                const lastUsedChainId = this.evmNetworks[0].chainId;
                this.lastUsedChainId = lastUsedChainId;
                return lastUsedChainId;
            }
            return chainId;
        }
        catch (err) {
            logger.error(err);
            return undefined;
        }
    }
    get currentChainId() {
        var _a, _b, _c;
        return (_a = this._selectedChainId) !== null && _a !== void 0 ? _a : (_c = (_b = this.evmNetworks) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.chainId;
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.currentChainId;
        });
    }
    getEvmNetworkByChainId(chainId) {
        return this.evmNetworks.find((network) => network.chainId === chainId);
    }
    currentEvmNetwork() {
        const chainId = this.currentChainId;
        if (!chainId) {
            return undefined;
        }
        return this.getEvmNetworkByChainId(chainId);
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!networkChainId) {
                return;
            }
            let networkChainIdInt = networkChainId;
            if (typeof networkChainId === 'string') {
                networkChainIdInt = parseInt(networkChainId);
            }
            this.lastUsedChainId = networkChainIdInt;
            this._selectedChainId = networkChainIdInt;
            this.emit('chainChange', {
                chain: networkChainIdInt.toString(),
            });
        });
    }
    getRpcUrl() {
        var _a;
        const evmNetwork = this.currentEvmNetwork();
        if (!evmNetwork) {
            throw new Error('EVM network not found');
        }
        return ((_a = evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a[0]) || (evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.rpcUrls[0]);
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const targetWallet = yield walletClient.getWallet({
                accountAddress: expectedAddress,
                authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
                signedSessionId,
            });
            if (!targetWallet) {
                throw new DynamicError('Account not found');
            }
            const isWalletActive = isSameAddress(targetWallet.accountAddress, ((_c = this.getActiveAccount()) === null || _c === void 0 ? void 0 : _c.address) || '', this.connectedChain);
            if (!isWalletActive) {
                this.setActiveAccount(targetWallet.accountAddress);
            }
        });
    }
    getActiveAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.getActiveAccount()) === null || _a === void 0 ? void 0 : _a.address;
        });
    }
    getViemAccount(_a) {
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, }) {
            var _b;
            const client = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            return toAccount({
                address: accountAddress,
                signAuthorization: (parameters) => __awaiter(this, void 0, void 0, function* () { return this.signAuthorization(parameters); }),
                signMessage: (_c) => __awaiter(this, [_c], void 0, function* ({ message, }) {
                    var _d, _e;
                    const mfaToken = yield ((_d = this.getMfaToken) === null || _d === void 0 ? void 0 : _d.call(this, {
                        mfaAction: MFAAction.WalletWaasSign,
                    }));
                    return client.signMessage({
                        accountAddress,
                        authToken: (_e = this.getAuthToken) === null || _e === void 0 ? void 0 : _e.call(this),
                        message: message,
                        mfaToken,
                        signedSessionId,
                    });
                }),
                signTransaction: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    var _f, _g;
                    const mfaToken = yield ((_f = this.getMfaToken) === null || _f === void 0 ? void 0 : _f.call(this, {
                        mfaAction: MFAAction.WalletWaasSign,
                    }));
                    return client
                        .signTransaction({
                        authToken: (_g = this.getAuthToken) === null || _g === void 0 ? void 0 : _g.call(this),
                        mfaToken,
                        senderAddress: accountAddress,
                        signedSessionId,
                        transaction: serializeTransaction(transaction),
                    })
                        .then((tx) => tx);
                }),
                signTypedData: (typedData) => __awaiter(this, void 0, void 0, function* () {
                    var _h, _j;
                    const mfaToken = yield ((_h = this.getMfaToken) === null || _h === void 0 ? void 0 : _h.call(this, {
                        mfaAction: MFAAction.WalletWaasSign,
                    }));
                    return client.signTypedData({
                        accountAddress,
                        authToken: (_j = this.getAuthToken) === null || _j === void 0 ? void 0 : _j.call(this),
                        mfaToken,
                        signedSessionId,
                        typedData: typedData,
                    });
                }),
            });
        });
    }
    getWalletClient(chainId) {
        var _a;
        const targetAccountAddress = (_a = this.getActiveAccount()) === null || _a === void 0 ? void 0 : _a.address;
        if (!targetAccountAddress) {
            return this.getPublicClient();
        }
        const rpcUrl = this.getRpcUrl();
        const evmNetwork = chainId
            ? this.getEvmNetworkByChainId(parseInt(chainId))
            : this.currentEvmNetwork();
        if (!evmNetwork) {
            throw new Error('EVM network not found');
        }
        return createWalletClientWithUiConfirmation({
            account: () => __awaiter(this, void 0, void 0, function* () {
                return this.getViemAccount({
                    accountAddress: targetAccountAddress,
                });
            }),
            address: targetAccountAddress,
            chain: getOrMapViemChain(evmNetwork),
            transport: http(rpcUrl, this.providersConfig.httpTransportConfig),
            // TODO: remove this. We should not be passing references to wallet connectors
            walletConnector: this,
            walletUiUtils: this.walletUiUtils,
        });
    }
    signMessage(message) {
        var _a;
        return (_a = this.getWalletClient()) === null || _a === void 0 ? void 0 : _a.signMessage({ message });
    }
    signMessageWithContext(_a) {
        return __awaiter(this, arguments, void 0, function* ({ message, context, }) {
            var _b, _c, _d;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            return walletClient.signMessage({
                accountAddress: (_c = this.getActiveAccount()) === null || _c === void 0 ? void 0 : _c.address,
                authToken: (_d = this.getAuthToken) === null || _d === void 0 ? void 0 : _d.call(this),
                context,
                message,
                signedSessionId,
            });
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getWalletClient();
        });
    }
    getWalletClientByAddress({ accountAddress, }) {
        this.setActiveAccount(accountAddress);
        return this.getWalletClient();
    }
    // Chain-specific override for exportClientKeyshares - EVM needs to set active account first
    exportClientKeyshares(_a) {
        const _super = Object.create(null, {
            exportClientKeyshares: { get: () => super.exportClientKeyshares }
        });
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
            if (!accountAddress) {
                throw new Error('Account address is required');
            }
            // EVM-specific: set active account before exporting
            this.setActiveAccount(accountAddress);
            return _super.exportClientKeyshares.call(this, { accountAddress, password });
        });
    }
    // Chain-specific override for backupKeySharesToGoogleDrive - EVM needs to set active account first
    backupKeySharesToGoogleDrive(_a) {
        const _super = Object.create(null, {
            backupKeySharesToGoogleDrive: { get: () => super.backupKeySharesToGoogleDrive }
        });
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
            if (!accountAddress) {
                throw new Error('Account address is required');
            }
            // EVM-specific: set active account before backing up
            this.setActiveAccount(accountAddress);
            return _super.backupKeySharesToGoogleDrive.call(this, { accountAddress, password });
        });
    }
    // Chain-specific override for refreshWalletAccountShares - EVM needs to set active account first
    refreshWalletAccountShares(_a) {
        const _super = Object.create(null, {
            refreshWalletAccountShares: { get: () => super.refreshWalletAccountShares }
        });
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
            if (!accountAddress) {
                throw new Error('Account address is required');
            }
            // EVM-specific: set active account before refreshing
            this.setActiveAccount(accountAddress);
            return _super.refreshWalletAccountShares.call(this, { accountAddress, password });
        });
    }
    // Chain-specific override for updatePassword - EVM needs to set active account first
    updatePassword(_a) {
        const _super = Object.create(null, {
            updatePassword: { get: () => super.updatePassword }
        });
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, existingPassword, newPassword, }) {
            if (!accountAddress) {
                throw new Error('Account address is required');
            }
            // EVM-specific: set active account before updating password
            this.setActiveAccount(accountAddress);
            return _super.updatePassword.call(this, {
                accountAddress,
                existingPassword,
                newPassword,
            });
        });
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const walletClient = this.getWalletClient();
            const publicClient = yield this.getPublicClient();
            if (!publicClient || !walletClient) {
                throw new DynamicError('No public client available');
            }
            return new ViemUiTransaction({
                account: from,
                onSubmit: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    // Non native token
                    if (transaction.nonNativeAddress) {
                        return walletClient.writeContract({
                            abi: erc20Abi,
                            account: walletClient.account,
                            address: transaction.nonNativeAddress,
                            args: [transaction.to, transaction.nonNativeValue],
                            functionName: 'transfer',
                            maxFeePerGas: transaction.maxFeePerGas,
                            maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
                        });
                    }
                    // Native token
                    return walletClient.sendTransaction({
                        account: walletClient.account,
                        data: '0x',
                        maxFeePerGas: transaction.maxFeePerGas,
                        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
                        to: transaction.to,
                        value: transaction.value,
                    });
                }),
                publicClient,
                transaction: {},
            });
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const verifiedCredentials = this.verifiedCredentials || [];
            const addresses = verifiedCredentials
                .map((vc) => vc === null || vc === void 0 ? void 0 : vc.address)
                .filter((a) => typeof a === 'string');
            if (addresses.length > 0 && ((_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.address)) {
                this.setActiveAccount(this.verifiedCredential.address);
            }
            return addresses;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const activeAccount = this.getActiveAccount();
            if (!activeAccount || !activeAccount.address) {
                // If no active account, try to get one from verified credentials
                if ((_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.address) {
                    const { address } = this.verifiedCredential;
                    this.setActiveAccount(address);
                    return address;
                }
                throw new DynamicError('No active wallet address found');
            }
            return activeAccount.address;
        });
    }
    signAuthorization(parameters, password) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const { address: contractAddress, nonce, chainId } = parameters;
            if (!contractAddress) {
                throw new Error('Contract address not found');
            }
            const [signer, publicClient] = yield Promise.all([
                this.getSigner(),
                this.getPublicClient(),
            ]);
            if (!signer || !publicClient) {
                throw new Error('Required clients not found');
            }
            const { address } = signer.account;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                mfaAction: MFAAction.WalletWaasSign,
            }));
            const authorization = {
                address: contractAddress,
                chainId,
                nonce,
            };
            const signature = yield walletClient.signRawMessage({
                accountAddress: address,
                authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                context: { eip7702Auth: authorization },
                message: hashAuthorization(authorization).slice(2),
                mfaToken,
                password,
                signedSessionId,
            });
            const parsedSignature = parseSignature(signature);
            return {
                address: contractAddress,
                chainId,
                nonce,
                r: parsedSignature.r,
                s: parsedSignature.s,
                v: parsedSignature.v,
                yParity: parsedSignature.yParity,
            };
        });
    }
    isAtomicSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[DynamicWaasEVMConnector] isAtomicSupported - not supported', {
                chainId,
            });
            return false;
        });
    }
    isPaymasterServiceSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[DynamicWaasEVMConnector] isPaymasterServiceSupported - not supported', {
                chainId,
            });
            return false;
        });
    }
    isSignAuthorizationSupported() {
        return true;
    }
    endSession() {
        const _super = Object.create(null, {
            endSession: { get: () => super.endSession }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.endSession.call(this);
        });
    }
}
DynamicWaasEVMConnector.lastUsedChainIdStorageKey = 'dynamic-waas-evm-last-used-chain-id';

export { DynamicWaasEVMConnector };
