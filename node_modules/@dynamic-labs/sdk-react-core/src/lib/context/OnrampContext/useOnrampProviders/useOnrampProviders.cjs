'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../_virtual/_tslib.cjs');
var React = require('react');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var onramp = require('../../../data/api/onramp/onramp.cjs');
var getWalletAdditionalAddressByType = require('../../../utils/functions/getWalletAdditionalAddressByType/getWalletAdditionalAddressByType.cjs');
var usePromise = require('../../../utils/hooks/usePromise/usePromise.cjs');

const useOnrampProviders = ({ primaryWallet, network, environmentId, projectSettingsOnramps, target, includeDisabled, }) => {
    var _a, _b;
    const chainName = (primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.chain)
        ? (_a = walletConnectorCore.getChainInfo(primaryWallet.chain)) === null || _a === void 0 ? void 0 : _a.name
        : undefined;
    const chainNameToUse = (_b = target.chainName) !== null && _b !== void 0 ? _b : chainName;
    const bitcoinAddress = primaryWallet &&
        walletConnectorCore.isBitcoinConnector(primaryWallet.connector) &&
        getWalletAdditionalAddressByType.getWalletAdditionalAddressByType(sdkApiCore.WalletAddressType.Payment, primaryWallet);
    const chainHasNetwork = network && chainNameToUse === 'evm';
    let networkToUse;
    if (target.network) {
        networkToUse = target.network;
    }
    else {
        networkToUse = chainHasNetwork ? network.toString() : undefined;
    }
    const { data: allOnRamps = [] } = usePromise.usePromise(() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        if (!chainNameToUse || (!(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.address) && !target.address))
            return [];
        const walletAddress = target.address || bitcoinAddress || (primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.address);
        if (!walletAddress)
            return [];
        return onramp.getOnrampProviders({
            chain: chainNameToUse,
            environmentId,
            includeDisabled: true,
            networkId: networkToUse,
            token: target.token,
            tokenAmount: target.tokenAmount,
            walletAddress: walletAddress,
        });
    }), {
        deps: [
            environmentId,
            network,
            primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.address,
            target.address,
            target.token,
            target.tokenAmount,
            target.chainName,
            target.network,
        ],
        // no need to fetch onramp providers if there are none enabled
        enabled: includeDisabled || Boolean(projectSettingsOnramps === null || projectSettingsOnramps === void 0 ? void 0 : projectSettingsOnramps.length),
        initialData: [],
    });
    const enabledOnRamps = React.useMemo(() => allOnRamps.filter((p) => projectSettingsOnramps === null || projectSettingsOnramps === void 0 ? void 0 : projectSettingsOnramps.includes(p.provider)), [allOnRamps, projectSettingsOnramps]);
    return React.useMemo(() => ({ allOnRamps, enabledOnRamps }), [allOnRamps, enabledOnRamps]);
};

exports.useOnrampProviders = useOnrampProviders;
