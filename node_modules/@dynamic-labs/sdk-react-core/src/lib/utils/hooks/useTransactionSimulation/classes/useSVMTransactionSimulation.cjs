'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../../_virtual/_tslib.cjs');
var React = require('react');
var bs58 = require('bs58');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var blockaid = require('../../../../data/api/transactions/blockaid.cjs');
var utils = require('../utils/utils.cjs');
var useBaseTransactionSimulation = require('./useBaseTransactionSimulation.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bs58__default = /*#__PURE__*/_interopDefaultLegacy(bs58);

const useSVMTransactionSimulation = () => {
    const { simulationState, setSimulationState, nativeTokenDecimals, handleSimulationError, primaryWallet, environmentId, } = useBaseTransactionSimulation.useBaseTransactionSimulation('useSVMTransactionSimulation');
    const simulateSVMTransaction = React.useCallback((params) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        if (!(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector) || primaryWallet.chain !== sdkApiCore.ChainEnum.Sol) {
            return handleSimulationError(new Error('Solana simulation requires Solana wallet'));
        }
        const transactions = Array.isArray(params.transaction)
            ? params.transaction
            : [params.transaction];
        try {
            setSimulationState({ isLoading: true });
            let isSponsored = false;
            const encodedTransactions = transactions.map((tx) => bs58__default["default"].encode(Uint8Array.from(tx.serialize({ requireAllSignatures: false }))));
            isSponsored = transactions.every((tx) => utils.isSVMTransactionSponsored(tx, primaryWallet.address));
            const compiledMessages = yield Promise.all(transactions.map((tx) => {
                var _a;
                if ('version' in tx) {
                    return tx.message;
                }
                // legacy transactions will have this method
                return (_a = tx.compileMessage) === null || _a === void 0 ? void 0 : _a.call(tx);
            }));
            const connection = yield primaryWallet.getConnection();
            // Calculate fees for all transactions
            const fees = yield Promise.all(compiledMessages.map((tx) => utils.getFeeWithRetry(connection, tx)));
            const fee = fees.reduce((acc, curr) => acc + curr, BigInt(0));
            const result = yield blockaid.simulateBlockaidSVMTransaction({
                accountAddress: primaryWallet.address,
                chain: (yield primaryWallet.connector.getNetwork(true)),
                environmentId,
                transactions: encodedTransactions,
            });
            if (!result) {
                return handleSimulationError(new Error('Simulation failed: No result returned'));
            }
            const finalFee = isSponsored ? BigInt(0) : fee || BigInt(0);
            // For Solana, we need to ensure we have a valid fee
            if (!isSponsored && finalFee === BigInt(0)) {
                return handleSimulationError(new Error('Failed to calculate transaction fee'));
            }
            const resultWithFee = utils.generateAllFeeData(finalFee, nativeTokenDecimals, result);
            // simulations include gas fees in the outAssets, so we need to remove them
            if (!isSponsored) {
                resultWithFee.outAssets = utils.deductSVMFees(resultWithFee);
            }
            setSimulationState({
                isLoading: false,
                result: resultWithFee,
            });
            return;
        }
        catch (error) {
            return handleSimulationError(error);
        }
    }), [
        primaryWallet,
        environmentId,
        nativeTokenDecimals,
        handleSimulationError,
        setSimulationState,
    ]);
    return Object.assign({ simulateSVMTransaction }, simulationState);
};

exports.useSVMTransactionSimulation = useSVMTransactionSimulation;
