'use client'
import { __awaiter } from '../../../../../../_virtual/_tslib.js';
import { useCallback } from 'react';
import bs58 from 'bs58';
import { ChainEnum } from '@dynamic-labs/sdk-api-core';
import { simulateBlockaidSVMTransaction } from '../../../../data/api/transactions/blockaid.js';
import { isSVMTransactionSponsored, getFeeWithRetry, generateAllFeeData, deductSVMFees } from '../utils/utils.js';
import { useBaseTransactionSimulation } from './useBaseTransactionSimulation.js';

const useSVMTransactionSimulation = () => {
    const { simulationState, setSimulationState, nativeTokenDecimals, handleSimulationError, primaryWallet, environmentId, } = useBaseTransactionSimulation('useSVMTransactionSimulation');
    const simulateSVMTransaction = useCallback((params) => __awaiter(void 0, void 0, void 0, function* () {
        if (!(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector) || primaryWallet.chain !== ChainEnum.Sol) {
            return handleSimulationError(new Error('Solana simulation requires Solana wallet'));
        }
        const transactions = Array.isArray(params.transaction)
            ? params.transaction
            : [params.transaction];
        try {
            setSimulationState({ isLoading: true });
            let isSponsored = false;
            const encodedTransactions = transactions.map((tx) => bs58.encode(Uint8Array.from(tx.serialize({ requireAllSignatures: false }))));
            isSponsored = transactions.every((tx) => isSVMTransactionSponsored(tx, primaryWallet.address));
            const compiledMessages = yield Promise.all(transactions.map((tx) => {
                var _a;
                if ('version' in tx) {
                    return tx.message;
                }
                // legacy transactions will have this method
                return (_a = tx.compileMessage) === null || _a === void 0 ? void 0 : _a.call(tx);
            }));
            const connection = yield primaryWallet.getConnection();
            // Calculate fees for all transactions
            const fees = yield Promise.all(compiledMessages.map((tx) => getFeeWithRetry(connection, tx)));
            const fee = fees.reduce((acc, curr) => acc + curr, BigInt(0));
            const result = yield simulateBlockaidSVMTransaction({
                accountAddress: primaryWallet.address,
                chain: (yield primaryWallet.connector.getNetwork(true)),
                environmentId,
                transactions: encodedTransactions,
            });
            if (!result) {
                return handleSimulationError(new Error('Simulation failed: No result returned'));
            }
            const finalFee = isSponsored ? BigInt(0) : fee || BigInt(0);
            // For Solana, we need to ensure we have a valid fee
            if (!isSponsored && finalFee === BigInt(0)) {
                return handleSimulationError(new Error('Failed to calculate transaction fee'));
            }
            const resultWithFee = generateAllFeeData(finalFee, nativeTokenDecimals, result);
            // simulations include gas fees in the outAssets, so we need to remove them
            if (!isSponsored) {
                resultWithFee.outAssets = deductSVMFees(resultWithFee);
            }
            setSimulationState({
                isLoading: false,
                result: resultWithFee,
            });
            return;
        }
        catch (error) {
            return handleSimulationError(error);
        }
    }), [
        primaryWallet,
        environmentId,
        nativeTokenDecimals,
        handleSimulationError,
        setSimulationState,
    ]);
    return Object.assign({ simulateSVMTransaction }, simulationState);
};

export { useSVMTransactionSimulation };
