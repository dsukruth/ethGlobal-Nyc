'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../../_virtual/_tslib.cjs');
var React = require('react');
var blockaid = require('../../../../data/api/transactions/blockaid.cjs');
var utils = require('../utils/utils.cjs');
var useBaseTransactionSimulation = require('./useBaseTransactionSimulation.cjs');

const useEVMTransactionSimulation = () => {
    const { simulationState, setSimulationState, nativeTokenDecimals, handleSimulationError, primaryWallet, environmentId, } = useBaseTransactionSimulation.useBaseTransactionSimulation('useEVMTransactionSimulation');
    const [chainId, setChainId] = React.useState();
    React.useEffect(() => {
        const fetchChainId = () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            if (primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector) {
                const network = yield primaryWallet.connector.getNetwork();
                setChainId(String(network));
            }
        });
        fetchChainId();
    }, [primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector]);
    const simulateEVMTransactionAA = React.useCallback((params) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        if (!(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector) ||
            !utils.isZeroDevConnector(primaryWallet.connector)) {
            return handleSimulationError(new Error('Account abstraction simulation requires ZeroDev connector'), 'AA');
        }
        if (!chainId) {
            return handleSimulationError(new Error('No chain ID found'), 'AA');
        }
        const { transaction } = params;
        try {
            setSimulationState({ isLoading: true });
            const connector = primaryWallet.connector;
            const { userOperation } = yield connector.getCurrentUserOperation(transaction);
            if (!userOperation) {
                return handleSimulationError(new Error('failed to get user operation'), 'AA');
            }
            const formattedUserOperation = yield connector.formatUserOperation(userOperation);
            const entryPoint = (_a = connector.getAccountAbstractionProvider()) === null || _a === void 0 ? void 0 : _a.account.entryPoint;
            if (!entryPoint) {
                return handleSimulationError(new Error('No entry point address found'), 'AA');
            }
            const result = yield blockaid.simulateBlockaidUserOperation({
                chainId,
                entryPoint,
                environmentId,
                userOperation: formattedUserOperation,
                value: ((_b = transaction.value) === null || _b === void 0 ? void 0 : _b.toString()) || '0',
            });
            if (!result) {
                return handleSimulationError(new Error('Simulation failed: No result returned'), 'AA');
            }
            const fee = utils.calculateAAFees(userOperation);
            const isSponsored = yield connector.canSponsorTransactionGas(transaction);
            const finalFee = isSponsored ? BigInt(0) : fee;
            const resultWithFee = utils.generateAllFeeData(finalFee, nativeTokenDecimals, result);
            // Filter out native asset if it's just gas fee (no ETH transfer)
            // this is when its an aa tx but unsponsored
            if (!transaction.value) {
                resultWithFee.outAssets = resultWithFee.outAssets.filter((asset) => asset.asset.type !== 'NATIVE');
            }
            setSimulationState({
                isLoading: false,
                result: resultWithFee,
            });
            return;
        }
        catch (error) {
            return handleSimulationError(error, 'AA');
        }
    }), [
        chainId,
        primaryWallet,
        environmentId,
        nativeTokenDecimals,
        handleSimulationError,
        setSimulationState,
    ]);
    const simulateEVMTransaction = React.useCallback((params) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        var _c;
        const { transaction } = params;
        if (!(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector)) {
            return handleSimulationError(new Error('No wallet connected'), 'EVM');
        }
        if (!chainId) {
            return handleSimulationError(new Error('No chain ID found'), 'EVM');
        }
        try {
            setSimulationState({ isLoading: true });
            if (!utils.isEthereumWallet(primaryWallet)) {
                return handleSimulationError(new Error('EVM simulation requires Ethereum wallet'), 'EVM');
            }
            const publicClient = yield primaryWallet.getPublicClient();
            const totalFee = yield utils.calculateEVMFees(publicClient, transaction);
            const result = yield blockaid.simulateBlockaidEVMTransaction({
                chainId,
                data: transaction.data || '0x',
                environmentId,
                from: transaction.from,
                to: transaction.to,
                value: ((_c = transaction.value) === null || _c === void 0 ? void 0 : _c.toString()) || '0',
            });
            if (!result) {
                return handleSimulationError(new Error('Simulation failed: No result returned'), 'EVM');
            }
            const resultWithFee = utils.generateAllFeeData(totalFee, nativeTokenDecimals, result);
            // Filter out native asset if it's just gas fee (no ETH transfer)
            if (!transaction.value) {
                resultWithFee.outAssets = resultWithFee.outAssets.filter((asset) => asset.asset.type !== 'NATIVE');
            }
            setSimulationState({
                isLoading: false,
                result: resultWithFee,
            });
            return;
        }
        catch (error) {
            return handleSimulationError(error, 'EVM');
        }
    }), [
        chainId,
        primaryWallet,
        environmentId,
        nativeTokenDecimals,
        handleSimulationError,
        setSimulationState,
    ]);
    return Object.assign({ simulateEVMTransaction,
        simulateEVMTransactionAA }, simulationState);
};

exports.useEVMTransactionSimulation = useEVMTransactionSimulation;
