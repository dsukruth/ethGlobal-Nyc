'use client'
import { __awaiter } from '../../../../../../_virtual/_tslib.js';
import { useState, useEffect, useCallback } from 'react';
import { simulateBlockaidUserOperation, simulateBlockaidEVMTransaction } from '../../../../data/api/transactions/blockaid.js';
import { isZeroDevConnector, calculateAAFees, generateAllFeeData, isEthereumWallet, calculateEVMFees } from '../utils/utils.js';
import { useBaseTransactionSimulation } from './useBaseTransactionSimulation.js';

const useEVMTransactionSimulation = () => {
    const { simulationState, setSimulationState, nativeTokenDecimals, handleSimulationError, primaryWallet, environmentId, } = useBaseTransactionSimulation('useEVMTransactionSimulation');
    const [chainId, setChainId] = useState();
    useEffect(() => {
        const fetchChainId = () => __awaiter(void 0, void 0, void 0, function* () {
            if (primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector) {
                const network = yield primaryWallet.connector.getNetwork();
                setChainId(String(network));
            }
        });
        fetchChainId();
    }, [primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector]);
    const simulateEVMTransactionAA = useCallback((params) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        if (!(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector) ||
            !isZeroDevConnector(primaryWallet.connector)) {
            return handleSimulationError(new Error('Account abstraction simulation requires ZeroDev connector'), 'AA');
        }
        if (!chainId) {
            return handleSimulationError(new Error('No chain ID found'), 'AA');
        }
        const { transaction } = params;
        try {
            setSimulationState({ isLoading: true });
            const connector = primaryWallet.connector;
            const { userOperation } = yield connector.getCurrentUserOperation(transaction);
            if (!userOperation) {
                return handleSimulationError(new Error('failed to get user operation'), 'AA');
            }
            const formattedUserOperation = yield connector.formatUserOperation(userOperation);
            const entryPoint = (_a = connector.getAccountAbstractionProvider()) === null || _a === void 0 ? void 0 : _a.account.entryPoint;
            if (!entryPoint) {
                return handleSimulationError(new Error('No entry point address found'), 'AA');
            }
            const result = yield simulateBlockaidUserOperation({
                chainId,
                entryPoint,
                environmentId,
                userOperation: formattedUserOperation,
                value: ((_b = transaction.value) === null || _b === void 0 ? void 0 : _b.toString()) || '0',
            });
            if (!result) {
                return handleSimulationError(new Error('Simulation failed: No result returned'), 'AA');
            }
            const fee = calculateAAFees(userOperation);
            const isSponsored = yield connector.canSponsorTransactionGas(transaction);
            const finalFee = isSponsored ? BigInt(0) : fee;
            const resultWithFee = generateAllFeeData(finalFee, nativeTokenDecimals, result);
            // Filter out native asset if it's just gas fee (no ETH transfer)
            // this is when its an aa tx but unsponsored
            if (!transaction.value) {
                resultWithFee.outAssets = resultWithFee.outAssets.filter((asset) => asset.asset.type !== 'NATIVE');
            }
            setSimulationState({
                isLoading: false,
                result: resultWithFee,
            });
            return;
        }
        catch (error) {
            return handleSimulationError(error, 'AA');
        }
    }), [
        chainId,
        primaryWallet,
        environmentId,
        nativeTokenDecimals,
        handleSimulationError,
        setSimulationState,
    ]);
    const simulateEVMTransaction = useCallback((params) => __awaiter(void 0, void 0, void 0, function* () {
        var _c;
        const { transaction } = params;
        if (!(primaryWallet === null || primaryWallet === void 0 ? void 0 : primaryWallet.connector)) {
            return handleSimulationError(new Error('No wallet connected'), 'EVM');
        }
        if (!chainId) {
            return handleSimulationError(new Error('No chain ID found'), 'EVM');
        }
        try {
            setSimulationState({ isLoading: true });
            if (!isEthereumWallet(primaryWallet)) {
                return handleSimulationError(new Error('EVM simulation requires Ethereum wallet'), 'EVM');
            }
            const publicClient = yield primaryWallet.getPublicClient();
            const totalFee = yield calculateEVMFees(publicClient, transaction);
            const result = yield simulateBlockaidEVMTransaction({
                chainId,
                data: transaction.data || '0x',
                environmentId,
                from: transaction.from,
                to: transaction.to,
                value: ((_c = transaction.value) === null || _c === void 0 ? void 0 : _c.toString()) || '0',
            });
            if (!result) {
                return handleSimulationError(new Error('Simulation failed: No result returned'), 'EVM');
            }
            const resultWithFee = generateAllFeeData(totalFee, nativeTokenDecimals, result);
            // Filter out native asset if it's just gas fee (no ETH transfer)
            if (!transaction.value) {
                resultWithFee.outAssets = resultWithFee.outAssets.filter((asset) => asset.asset.type !== 'NATIVE');
            }
            setSimulationState({
                isLoading: false,
                result: resultWithFee,
            });
            return;
        }
        catch (error) {
            return handleSimulationError(error, 'EVM');
        }
    }), [
        chainId,
        primaryWallet,
        environmentId,
        nativeTokenDecimals,
        handleSimulationError,
        setSimulationState,
    ]);
    return Object.assign({ simulateEVMTransaction,
        simulateEVMTransactionAA }, simulationState);
};

export { useEVMTransactionSimulation };
