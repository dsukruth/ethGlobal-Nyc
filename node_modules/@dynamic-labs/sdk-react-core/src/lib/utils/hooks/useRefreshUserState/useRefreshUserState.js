'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { useState, useRef, useEffect } from 'react';
import { JwtVerifiedCredentialFormatEnum } from '@dynamic-labs/sdk-api-core';
import '@dynamic-labs-sdk/client/core';
import '../../../client/client.js';
import '@dynamic-labs-sdk/client';
import '@dynamic-labs/utils';
import '../../constants/values.js';
import '@dynamic-labs/multi-wallet';
import { getAuthToken } from '../../functions/getAuthToken/getAuthToken.js';
import { logger } from '../../../shared/logger.js';
import '../../constants/colors.js';
import 'react-international-phone';
import '@dynamic-labs/iconic';
import '@dynamic-labs/wallet-connector-core';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import '@dynamic-labs/wallet-book';
import '../../../shared/consts/index.js';
import '../../../store/state/nonce/nonce.js';
import { isCookieEnabled } from '../../functions/isCookieEnabled/isCookieEnabled.js';
import { updatePrimaryWalletId } from '../../functions/updatePrimaryWalletId/updatePrimaryWalletId.js';
import '../../../store/state/connectedWalletsInfo/connectedWalletsInfo.js';
import { useEnvironmentId } from '../../../store/state/dynamicContextProps/dynamicContextProps.js';
import '../../../store/state/primaryWalletId/primaryWalletId.js';
import '../../../events/dynamicEvents.js';
import { useProjectSettings } from '../../../store/state/projectSettings/projectSettings.js';
import { getUserProfile } from '../../../client/extension/user/getUserProfile/getUserProfile.js';
import '../../../config/ApiEndpoint.js';
import '../../../locale/locale.js';
import { refreshUserJwt } from '../../../data/api/user/user.js';
import { useInternalDynamicEvents } from '../events/useDynamicEvents/useDynamicEvents.js';

const useRefreshUserState = () => {
    const [isLoading, setIsLoading] = useState(true);
    const didRefreshUserRef = useRef(false);
    const environmentId = useEnvironmentId();
    const projectSettings = useProjectSettings();
    /**
     * As an extra layer of safety, we must explicitly prevent the refresh from being called
     * after a logout
     */
    const hasLoggedOut = useRef(false);
    useInternalDynamicEvents('logout', () => (hasLoggedOut.current = true));
    /**
     * run this effect every time the user or project settings change
     * but not when the process was already done.
     */
    useEffect(() => {
        /**
         * this method is called on refresh of DynamicContext and attempts to refresh local storage
         * when cookies are enabled for the environment.
         * the use case here is when an end user logs in to sub1.example.com and navigates to sub2.example.com.
         * if they are signed in to sub1.example.com with a cookie for `.example.com`, but the LS is specific
         * to sub1, then navigating to sub2 will mean they are not automatically signed in.
         * this method attempts to fetch the user from the backend using the cookie (if aavailable), and if successful,
         * this will ensure local storage is properly set with the user.
         *
         * this will also attempt to set the primaryWalletId, if the last verified credential is a wallet
         * the user might have signed in with a wallet in the other subdomain, but the primary wallet
         * in local storage does not carry over to other subdomains (LS is subdomain-specific),
         * so attempt to set it here.
         */
        const maybeInitUserRefresh = () => __awaiter(void 0, void 0, void 0, function* () {
            const mustRefreshUser = (() => {
                // if user is present, we dont need to refresh anything
                if (getUserProfile())
                    return false;
                // if the user has logged out, we dont need to refresh anything
                if (hasLoggedOut.current)
                    return false;
                // should run if cookie is enabled and no user is present
                if (projectSettings && isCookieEnabled(projectSettings))
                    return true;
                // should run if auth token is present but no user is present and cookie is not enabled
                return Boolean(getAuthToken());
            })();
            if (mustRefreshUser) {
                // Disable all next calls to this method
                didRefreshUserRef.current = true;
                try {
                    const user = yield refreshUserJwt({ environmentId });
                    /**
                     * attempt to set primary wallet in this subdomain because LS does not
                     * carry over between different subdomains, even if the cookie does
                     */
                    const lastVerifiedWallet = user === null || user === void 0 ? void 0 : user.verifiedCredentials.find((vc) => vc.format === JwtVerifiedCredentialFormatEnum.Blockchain &&
                        vc.id === user.lastVerifiedCredentialId);
                    if (lastVerifiedWallet) {
                        updatePrimaryWalletId(lastVerifiedWallet.id);
                    }
                }
                catch (e) {
                    logger.debug('Ignore failed refreshUserJwt in useRefreshUserState');
                }
            }
            if (projectSettings) {
                // only set to false if projectSettings are available,
                // otherwise isCookieEnabled might be a false negative
                setIsLoading(false);
            }
        });
        // Ensure this effect only runs once projectSettings is available
        if (didRefreshUserRef.current || !projectSettings)
            return;
        maybeInitUserRefresh();
    }, [projectSettings, environmentId]);
    return { isLoading };
};

export { useRefreshUserState };
