'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../../../../_virtual/_tslib.cjs');
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var reactI18next = require('react-i18next');
var Typography = require('../../../../../../components/Typography/Typography.cjs');
var logger = require('../../../../../../shared/logger.cjs');
var getTransactionLink = require('../../../../../../utils/functions/getTransactionLink/getTransactionLink.cjs');
var pixelToRem = require('../../../../../../utils/functions/pixelToRem/pixelToRem.cjs');
var useFundWithWallet = require('../../../../../../utils/hooks/useFundWithWallet/useFundWithWallet.cjs');
var DynamicWidgetContext = require('../../../../context/DynamicWidgetContext.cjs');

const useSubmitWalletFunding = () => {
    const { fund } = useFundWithWallet.useInternalFundWithWallet();
    const { goToInitialDynamicWidgetView, setHeaderAlert } = DynamicWidgetContext.useWidgetContext();
    const { t } = reactI18next.useTranslation();
    return React.useCallback((_a) => _tslib.__awaiter(void 0, [_a], void 0, function* ({ tokenAmount, wallet, tokenSymbol, tokenBalances, toWallet, }) {
        var _b;
        if (!tokenAmount)
            return;
        // This should be defined because if the current token is not in the tokenBalances,
        // the user would not be able to select it in the token select screen,
        // or if it was already selected, the user would see balance as 0 and submit button would be disabled
        const token = (_b = tokenBalances === null || tokenBalances === void 0 ? void 0 : tokenBalances.find(({ symbol }) => symbol === tokenSymbol)) === null || _b === void 0 ? void 0 : _b.token;
        if (!token)
            return;
        try {
            const txId = yield fund({
                amount: parseFloat(tokenAmount),
                fromWallet: wallet,
                toWallet,
                token: token === 'native' ? undefined : token,
            });
            logger.logger.info(`Funding with wallet succeeded with transaction id: ${txId}`);
            let txLink;
            if (txId) {
                txLink = yield getTransactionLink.getTransactionLink({
                    transactionHash: txId,
                    walletConnector: wallet.connector,
                });
            }
            const TxnSuccessAlert = (jsxRuntime.jsxs(Typography.Typography, { variant: 'body_normal', color: 'current-color', children: [t('dyn_wallet_funding.success'), txLink && (jsxRuntime.jsx(Typography.Typography, { as: 'a', href: txLink, target: '_blank', rel: 'noreferrer', style: {
                            marginLeft: pixelToRem.pixelToRem(4),
                            textDecoration: 'underline',
                            textDecorationThickness: pixelToRem.pixelToRem(1),
                            textUnderlineOffset: pixelToRem.pixelToRem(2),
                        }, weight: 'bold', color: 'current-color', children: t('dyn_wallet_funding.success_txn_link') }))] }));
            goToInitialDynamicWidgetView();
            setHeaderAlert({
                content: TxnSuccessAlert,
                variant: 'success',
            });
        }
        catch (error) {
            logger.logger.error('Failed to fund with wallet', error);
        }
    }), [fund, goToInitialDynamicWidgetView, setHeaderAlert, t]);
};

exports.useSubmitWalletFunding = useSubmitWalletFunding;
