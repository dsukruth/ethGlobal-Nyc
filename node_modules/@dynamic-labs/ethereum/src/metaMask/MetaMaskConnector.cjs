'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var sdk = require('@metamask/sdk');
var viem = require('viem');
var ethereumCore = require('@dynamic-labs/ethereum-core');
var utils = require('@dynamic-labs/utils');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var InjectedWalletBase = require('../injected/InjectedWalletBase.cjs');
var logger = require('../utils/logger.cjs');
var isPendingWalletRequestPermissionError = require('./utils/isPendingWalletRequestPermissionError.cjs');
var waitForConnection = require('./utils/waitForConnection.cjs');

/**
 * The MetaMask SDK must be initialized only once, so we store the instance
 * in these variables to avoid initializing it multiple times
 */
let _metaMaskSDK = null;
let _metaMaskDisplayUri = null;
let _metaMaskConnectUri = null;
const eventTimeline = utils.createEventTimeline();
const setMetaMaskDisplayUri = (displayUri) => {
    _metaMaskDisplayUri = displayUri;
};
class MetaMaskConnector extends InjectedWalletBase.InjectedWalletBase {
    constructor(props) {
        super(props);
        this.name = 'MetaMask';
        this.overrideKey = 'metamask';
        this.canConnectViaQrCode = true;
        this.isInAppBrowser = false;
        this.appName = props.appName;
        this.appLogoUrl = props.appLogoUrl;
        /**
         * The isInAppBrowser must be calculated before initializing the MetaMask SDK.
         *
         * The isInAppBrowser is calculated by checking if the window provider is installed
         * in the browser and if it is running on a mobile device.
         *
         * But the MetaMask SDK will inject its own provider to the window if not provider is injected.
         * This means the MetaMask SDK can interfere with the isInAppBrowser calculation.
         *
         * So we need to calculate the isInAppBrowser before initializing the MetaMask SDK
         * to prevent a false negative
         */
        this.isInAppBrowser = this.getIsInAppBrowser();
        /**
         * We can handle multiple connections in MetaMask only when the provider
         * is installed on the browser.
         */
        this.canHandleMultipleConnections = this.isInstalledOnBrowser();
        logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] constructor', {
            hasMetaMaskSDK: Boolean(_metaMaskSDK),
        });
        if (!_metaMaskSDK) {
            this.createMetaMaskSDK();
        }
    }
    isInstalledOnBrowser() {
        var _a;
        const metaMaskEip6963Provider = (_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.eip6963ProviderLookup(this.rdns);
        const isInstalled = Boolean(metaMaskEip6963Provider);
        return isInstalled;
    }
    getSupportedNetworks() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return this.evmNetworks.map((network) => network.chainId.toString());
        });
    }
    get metaMaskSDK() {
        if (!_metaMaskSDK)
            throw new Error('MetaMaskSDK not initialized');
        return _metaMaskSDK;
    }
    set metaMaskSDK(metaMaskSDK) {
        _metaMaskSDK = metaMaskSDK;
    }
    createMetaMaskSDK() {
        const dappMetadata = {
            iconUrl: this.appLogoUrl,
            name: this.appName,
            url: utils.PlatformService.getOrigin(),
        };
        logger.logger.debug('[MetaMaskConnector] createMetaMaskSDK - creating sdk', {
            dappMetadata,
        });
        _metaMaskSDK = new sdk.MetaMaskSDK({
            checkInstallationImmediately: true,
            dappMetadata,
            enableAnalytics: false,
            extensionOnly: this.isInstalledOnBrowser(),
            headless: true,
            injectProvider: false,
            openDeeplink: (url) => {
                if (url.includes('://connect')) {
                    _metaMaskConnectUri = url;
                }
                else {
                    _metaMaskConnectUri = null;
                }
                utils.PlatformService.openURL(url);
            },
            preferDesktop: !utils.isMobile(),
            readonlyRPCMap: getReadonlyRPCMap(this.evmNetworkRpcMap()),
            useDeeplink: true,
        });
        logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] createMetaMaskSDK - created sdk', { _metaMaskSDK });
    }
    endSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            eventTimeline.postEvent('disconnect');
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] endSession - terminating sdk');
            /**
             * The MetaMask SDK must be terminated and reinitialized on mobile
             * to prevent deeplinks not working
             */
            if (utils.isMobile()) {
                return this.metaMaskSDK.terminate().then(() => {
                    _metaMaskSDK = null;
                    _metaMaskConnectUri = null;
                    return this.createMetaMaskSDK();
                });
            }
            /**
             * Just terminate the SDK on desktop
             */
            return this.metaMaskSDK.terminate();
        });
    }
    getAddress(opts) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - waiting for sdk init');
            yield this.metaMaskSDK.sdkInitPromise;
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - sdk init promise resolved');
            // QR Code flow
            const handleDisplayUri = (displayUri) => {
                var _a;
                logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] handleDisplayUri', { displayUri });
                if (!displayUri)
                    return;
                setMetaMaskDisplayUri(displayUri);
                (_a = opts === null || opts === void 0 ? void 0 : opts.onDisplayUri) === null || _a === void 0 ? void 0 : _a.call(opts, displayUri);
            };
            if (!utils.isMobile() && Boolean(opts === null || opts === void 0 ? void 0 : opts.onDisplayUri)) {
                this.metaMaskSDK.on('display_uri', handleDisplayUri);
            }
            try {
                // Deep link to MetaMask app in-app browser
                if (this.shouldDeepLinkToMetaMaskInAppBrowser() &&
                    this.metadata.inAppBrowserUrl) {
                    const inAppBrowserCompiledTemplate = utils.template(this.metadata.inAppBrowserUrl);
                    const { href } = utils.PlatformService.getUrl();
                    const deepLink = inAppBrowserCompiledTemplate({
                        dappURI: href,
                    });
                    // Redirect to the in-app browser and append the current url
                    utils.PlatformService.openURL(deepLink);
                    return;
                }
                logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - getting initial connected accounts');
                // Connect to MetaMask
                const initialConnectedAccounts = yield this.getConnectedAccountsSafely();
                logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - got initial connected accounts', { initialConnectedAccounts });
                if (initialConnectedAccounts.length) {
                    return this.parseAddress(initialConnectedAccounts[0]);
                }
                try {
                    logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - connecting to metaMask');
                    yield this.metaMaskSDK.connect();
                    logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - connected to metaMask');
                }
                catch (error) {
                    logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - error connecting to metaMask', { error });
                    /**
                     * In case of a getAddress call was already made and is pending
                     * and a new getAddress call is made after a endSession call, the
                     * MetaMask SDK will reject the original connect calls in the getAddress
                     * promise.
                     *
                     * In this case we want to cast the error to GetAddressCancelledError
                     * so the SDK knows the original getAddres call is cancelled and
                     * be clear to start the new getAddress flow
                     */
                    if (eventTimeline.isEventRecent('disconnect', 1000)) {
                        throw new utils.GetAddressCancelledError();
                    }
                    const isRequestPendingError = isPendingWalletRequestPermissionError.isPendingWalletRequestPermissionError(error);
                    if (!isRequestPendingError) {
                        throw utils.MetaMaskError.fromError(error);
                    }
                    else {
                        logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - error connection - waiting for connection');
                        yield waitForConnection.waitForConnection(this.getProvider());
                    }
                }
                logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - getting connected accounts');
                const accounts = yield this.getConnectedAccounts();
                logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getAddress - got connected accounts', { accounts });
                return accounts[0];
            }
            finally {
                this.metaMaskSDK.off('display_uri', handleDisplayUri);
            }
        });
    }
    getConnectedAccountsSafely() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const connectedAccounts = yield this.getConnectedAccounts();
                return connectedAccounts;
            }
            catch (err) {
                logger.logger.error(err);
                return [];
            }
        });
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            // Wait for for MetaMask SDK to initialize
            yield this.metaMaskSDK.sdkInitPromise;
            const provider = this.getProvider();
            if (!provider) {
                return [];
            }
            /**
             * The eth_accounts method can hang on mobile devices when
             * the MetaMask SDK has not connected yet. So we use a retryable
             * to ensure the timeout will be respected
             */
            const accounts = yield utils.retryableFn(() => provider.request({
                method: 'eth_accounts',
                params: [],
            }), {
                fallbackValue: [],
                timeoutMs: 1000,
            });
            if (!(accounts === null || accounts === void 0 ? void 0 : accounts.length)) {
                return [];
            }
            return accounts.map(this.parseAddress);
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] signMessage - waiting for sdk init');
            yield this.metaMaskSDK.sdkInitPromise;
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] signMessage - sdk init promise resolved');
            /**
             * Should wait for the window to be focused on mobile
             * to account for the user moving between the MetaMaskApp
             * and the browser
             */
            const windowFocusPromiseForMobile = !this.isInAppBrowser && utils.isMobile()
                ? waitForFocusWindowEvent()
                : Promise.resolve();
            const provider = this.getProvider();
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] signMessage - got provider', { provider });
            if (!provider) {
                return undefined;
            }
            const [selectedAddress] = yield this.getConnectedAccounts();
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] signMessage - got selected address', { selectedAddress });
            if (!selectedAddress) {
                return undefined;
            }
            const walletClient = this.getWalletClientForAddress(selectedAddress);
            if (!walletClient)
                return undefined;
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] signMessage - will sign', { messageToSign });
            const signature = yield walletClient.signMessage({
                message: messageToSign,
            });
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] signMessage - will wait for window focus');
            yield windowFocusPromiseForMobile;
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] signMessage - signed', { signature });
            return signature;
        });
    }
    chooseAccountsToConnect() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getWalletClient(chainId) {
        const provider = this.getProvider();
        logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getWalletClient - got provider', { provider });
        if (!provider) {
            return undefined;
        }
        const selectedAddress = provider.getSelectedAddress();
        return this.getWalletClientForAddress(selectedAddress || undefined, chainId);
    }
    get rdns() {
        const { rdns } = this.metadata;
        if (!rdns) {
            throw new Error('rdns not found in metadata');
        }
        return rdns;
    }
    setupEventListeners() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.metaMaskSDK.sdkInitPromise;
            const metaMaskProvider = this.getProvider();
            if (!metaMaskProvider) {
                return;
            }
            const { handleAccountChange, handleChainChange, handleDisconnect } = walletConnectorCore.eventListenerHandlers(this);
            const handleAccountsChangedFromMetaMask = (accounts) => {
                /**
                 * MetaMask emits an account changed event when the wallet is disconnected
                 * so we ignore the accountsChanged event if the disconnect event was recent
                 */
                if (eventTimeline.isEventRecent('disconnect', 1000)) {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                handleAccountChange(accounts);
            };
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            metaMaskProvider.on('accountsChanged', handleAccountsChangedFromMetaMask);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            metaMaskProvider.on('chainChanged', handleChainChange);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            metaMaskProvider.on('disconnect', handleDisconnect);
            this.teardownEventListeners = () => {
                metaMaskProvider.off('accountsChanged', handleAccountsChangedFromMetaMask);
                metaMaskProvider.off('chainChanged', handleChainChange);
                metaMaskProvider.off('disconnect', handleDisconnect);
            };
        });
    }
    /**
     * This override is necessary to wait for the MetaMask SDK to initialize
     * before calling the super method. Otherwise, the super method may fail
     * to fetch the provider
     */
    getNetwork() {
        const _super = Object.create(null, {
            getNetwork: { get: () => super.getNetwork }
        });
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getNetwork - waiting for sdk init');
            yield this.metaMaskSDK.sdkInitPromise;
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getNetwork - sdk init promise resolved');
            const net = yield _super.getNetwork.call(this);
            logger.logger.logVerboseTroubleshootingMessage('[MetaMaskConnector] getNetwork - got network', { network: net });
            return net;
        });
    }
    // Utils
    getProvider() {
        var _a;
        return ((_a = this.metaMaskSDK.getProvider()) !== null && _a !== void 0 ? _a : this.metaMaskSDK.getMobileProvider());
    }
    evmNetworkByChainId(chainId) {
        return this.evmNetworks.find((network) => network.chainId === chainId);
    }
    getWalletClientForAddress(address, chainId) {
        var _a, _b;
        const provider = this.getProvider();
        if (!provider) {
            return undefined;
        }
        const effectiveChainId = (_b = (_a = this.toInt(chainId)) !== null && _a !== void 0 ? _a : this.getCurrentChainId()) !== null && _b !== void 0 ? _b : '1';
        const network = this.evmNetworkByChainId(effectiveChainId);
        return viem.createWalletClient({
            account: address,
            chain: network ? ethereumCore.getOrMapViemChain(network) : this.getActiveChain(),
            transport: viem.custom(provider, this.providersConfig.httpTransportConfig),
        });
    }
    toInt(chainId) {
        if (!chainId)
            return undefined;
        try {
            return parseInt(chainId);
        }
        catch (err) {
            logger.logger.debug(err);
            return undefined;
        }
    }
    getCurrentChainId() {
        const provider = this.getProvider();
        if (!provider) {
            return undefined;
        }
        const chainId = provider.getChainId();
        if (viem.isHex(chainId)) {
            return parseInt(chainId);
        }
        return chainId;
    }
    /**
     * Checks if the current environment is the MetaMask in-app browser
     * by checking if the MetaMask provider is installed in the window object
     * on a mobile device
     */
    getIsInAppBrowser() {
        var _a, _b;
        if (!utils.isMobile())
            return false;
        const provider = ((_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.eip6963ProviderLookup(this.rdns)) ||
            ((_b = this.ethProviderHelper) === null || _b === void 0 ? void 0 : _b.getInjectedProvider());
        return Boolean(provider);
    }
    shouldDeepLinkToMetaMaskInAppBrowser() {
        // Not in an in-app browser
        if (this.isInAppBrowser)
            return false;
        // Not a mobile device
        if (!utils.isMobile())
            return false;
        // SDK is configured to use the in-app browser
        if (this.mobileExperience !== 'in-app-browser')
            return false;
        // Wallet does not have an in-app browser link
        if (!this.metadata.inAppBrowserUrl)
            return false;
        return true;
    }
    getConnectionUri() {
        return _metaMaskDisplayUri !== null && _metaMaskDisplayUri !== void 0 ? _metaMaskDisplayUri : undefined;
    }
    retryDeeplinkConnection() {
        if (_metaMaskConnectUri) {
            utils.PlatformService.openURL(_metaMaskConnectUri);
        }
    }
}
// Utils
const getReadonlyRPCMap = (evmNetworkRpcMap) => Object.keys(evmNetworkRpcMap).reduce((acc, chainId) => (Object.assign(Object.assign({}, acc), { [viem.toHex(parseInt(chainId))]: evmNetworkRpcMap[chainId] })), {});
/**
 * Waits for the focus page event and await for an extra second
 * This is necessary to ensure the verify call will succeed
 */
const waitForFocusWindowEvent = () => new Promise((resolve) => {
    utils.PlatformEventsService.once('appFocused', resolve);
}).then(() => new Promise((resolve) => setTimeout(resolve, 1000)));

exports.MetaMaskConnector = MetaMaskConnector;
exports.eventTimeline = eventTimeline;
exports.setMetaMaskDisplayUri = setMetaMaskDisplayUri;
