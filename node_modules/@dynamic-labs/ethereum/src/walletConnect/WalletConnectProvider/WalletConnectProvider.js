'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import EthereumProvider from '@walletconnect/ethereum-provider';
import { performPlatformSpecificConnectionMethod } from '@dynamic-labs/wallet-connector-core';
import { parseIntSafe, DynamicError, ErrorCode } from '@dynamic-labs/utils';
import { logger } from '../../utils/logger.js';

var _a;
class WalletConnectProvider {
    constructor() {
        throw new Error('WalletConnectProvider is not instantiable');
    }
    static getMappedChainsByPreferredOrder() {
        const allChains = _a.enabledNetworks.map((network) => `eip155:${network.chainId}`);
        const reorderedChains = _a.preferredChains.filter((chain) => allChains.includes(chain));
        const remainingChains = allChains.filter((chain) => !_a.preferredChains.includes(chain));
        return [...reorderedChains, ...remainingChains].map((chain) => Number(chain.split(':')[1]));
    }
}
_a = WalletConnectProvider;
WalletConnectProvider.isInitializing = false;
WalletConnectProvider.isInitialized = false;
WalletConnectProvider.enabledNetworks = [];
WalletConnectProvider.preferredChains = [];
WalletConnectProvider.evmNetworkRpcMap = {};
WalletConnectProvider.eventListenersSetup = false;
WalletConnectProvider.accountChangedHandler = () => { };
WalletConnectProvider.chainChangedHandler = () => { };
WalletConnectProvider.disconnectHandler = () => { };
/**
 * Initializes the provider. This method should only be called once.
 * Does not start a connection.
 */
WalletConnectProvider.init = (...args_1) => __awaiter(void 0, [...args_1], void 0, function* ({ storePrefix = 'dynamic-wc2', } = {}) {
    logger.debug('[WalletConnectProvider] init', {
        isInitialized: _a.isInitialized,
        isInitializing: _a.isInitializing,
    });
    if (_a.isInitializing ||
        _a.isInitialized) {
        return;
    }
    _a.isInitializing = true;
    logger.debug('[WalletConnectProvider] initializing');
    _a.providerInitPromise = EthereumProvider.init({
        customStoragePrefix: storePrefix,
        disableProviderPing: true,
        optionalChains: _a.getMappedChainsByPreferredOrder(),
        optionalEvents: ['chainChanged', 'accountsChanged'],
        optionalMethods: [
            'eth_chainId',
            'eth_signTypedData',
            'eth_signTransaction',
            'eth_sign',
            'personal_sign',
            'eth_sendTransaction',
            'eth_signTypedData_v4',
            'wallet_switchEthereumChain',
            'wallet_addEthereumChain',
        ],
        projectId: _a.projectId,
        rpcMap: _a.evmNetworkRpcMap,
        showQrModal: false,
    });
    _a.provider =
        yield _a.providerInitPromise;
    _a.isInitialized = true;
    _a.isInitializing = false;
    logger.debug('[WalletConnectProvider] initialized');
});
/**
 * Connects to a wallet. This method should be called whenever a new wallet connection is needed.
 * If the wallet is already connected when the page is refreshed, this method does not need to be called.
 */
WalletConnectProvider.connect = (_b) => __awaiter(void 0, [_b], void 0, function* ({ deepLinks, deepLinkPreference, connectionOpts, }) {
    const handleDisplayURI = (uri) => {
        var _b;
        logger.debug('[WalletConnectProvider] handleDisplayURI', uri);
        _a.connectionUri = uri;
        performPlatformSpecificConnectionMethod(_a.connectionUri, deepLinks, {
            onDesktopUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDesktopUri,
            onDisplayUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDisplayUri,
        }, deepLinkPreference);
        logger.debug('[WalletConnectProvider] removing display_uri event listener');
        (_b = _a.provider) === null || _b === void 0 ? void 0 : _b.off('display_uri', handleDisplayURI);
    };
    if (!_a.provider) {
        logger.error('[WalletConnectProvider] connect - provider is not initialized');
        throw new DynamicError('WalletConnectProvider is not initialized');
    }
    // this is in case the user just cancels the deeplink prompt (i.e. in mobile/Safari)
    // in this case, the connection is not rejected, so the "enable" promise is just pending
    // so on retry, we should just use the same uri to handle that promise
    if (_a.connectionUri) {
        handleDisplayURI(_a.connectionUri);
        return;
    }
    logger.debug('[WalletConnectProvider] adding display_uri event listener');
    _a.provider.on('display_uri', handleDisplayURI);
    try {
        // enable = connect to the provider
        const result = yield _a.provider.enable();
        logger.debug('[WalletConnectProvider] connected to WalletConnect', result);
        return result;
    }
    catch (error) {
        logger.error('[WalletConnectProvider] Failed to connect to WalletConnect', error);
        if (typeof error !== 'object' ||
            error === null ||
            !('message' in error) ||
            typeof error.message !== 'string') {
            throw error;
        }
        const customError = new DynamicError(error.message);
        if (error.message.includes('rejected')) {
            customError.code = ErrorCode.CONNECTION_REJECTED;
        }
        else if (error.message.includes('expired')) {
            customError.code = ErrorCode.CONNECTION_PROPOSAL_EXPIRED;
        }
        throw customError;
    }
    finally {
        // Reset the connection URI after it's been consumed
        _a.connectionUri = undefined;
    }
});
/**
 * Disconnects from a wallet. This method should be called whenever we need to disconnect from a wallet.
 * It will kill the connection, but not the provider.
 */
WalletConnectProvider.disconnect = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!_a.provider) {
        logger.debug('[WalletConnectProvider] disconnect - provider is not initialized');
        return;
    }
    _a.connectionUri = undefined;
    logger.debug('[WalletConnectProvider] disconnecting from WalletConnect');
    try {
        yield _a.provider.disconnect();
    }
    catch (error) {
        logger.error('[WalletConnectProvider] Failed to disconnect from WalletConnect', error);
    }
});
/**
 * Waits for the provider to be initialized and returns the EthereumProvider instance.
 * We should use this wherever possible (async methods), to ensure the provider is initialized.
 */
WalletConnectProvider.awaitAndGetProvider = () => __awaiter(void 0, void 0, void 0, function* () { return _a.providerInitPromise; });
/**
 * Returns the EthereumProvider instance.
 * Used when we need to access the provider synchronously.
 */
WalletConnectProvider.getProvider = () => _a.provider;
WalletConnectProvider.getConnectionUri = () => _a.connectionUri;
WalletConnectProvider.handleChainChangedEvent = (chain, onChainChanged) => {
    logger.debug('[WalletConnectProvider] handling chain change event', {
        chain,
    });
    const chainId = parseIntSafe(chain);
    if (!chainId) {
        return;
    }
    onChainChanged === null || onChainChanged === void 0 ? void 0 : onChainChanged(chainId);
};
WalletConnectProvider.handleAccountChangedEvent = (accounts, onAccountChanged) => {
    logger.debug('[WalletConnectProvider] handling account change event', {
        accounts,
    });
    const [account] = accounts;
    const address = account.includes(':') ? account.split(':').pop() : account;
    if (!address) {
        return;
    }
    onAccountChanged === null || onAccountChanged === void 0 ? void 0 : onAccountChanged(address);
};
/**
 * Sets up event listeners for the provider.
 */
WalletConnectProvider.setupEventListeners = ({ onChainChanged, onAccountChanged, onDisconnect, }) => {
    if (!_a.provider ||
        _a.eventListenersSetup) {
        return;
    }
    _a.chainChangedHandler = (chainId) => {
        _a.handleChainChangedEvent(chainId, onChainChanged);
    };
    _a.accountChangedHandler = (account) => {
        _a.handleAccountChangedEvent(account, onAccountChanged);
    };
    _a.disconnectHandler = () => {
        logger.debug('[WalletConnectProvider] handling disconnect event');
        onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect();
    };
    _a.provider.on('accountsChanged', _a.accountChangedHandler);
    _a.provider.on('chainChanged', _a.chainChangedHandler);
    _a.provider.on('disconnect', _a.disconnectHandler);
    _a.eventListenersSetup = true;
};
/**
 * Tears down event listeners for the provider.
 */
WalletConnectProvider.teardownEventListeners = () => {
    if (!_a.provider ||
        !_a.eventListenersSetup) {
        return;
    }
    _a.provider.off('accountsChanged', _a.accountChangedHandler);
    _a.provider.off('chainChanged', _a.chainChangedHandler);
    _a.provider.off('disconnect', _a.disconnectHandler);
    _a.eventListenersSetup = false;
};

export { WalletConnectProvider };
