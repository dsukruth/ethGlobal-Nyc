'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var viem = require('viem');
var ethereumCore = require('@dynamic-labs/ethereum-core');
var utils = require('@dynamic-labs/utils');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var logger = require('../utils/logger.cjs');
var helpers = require('./helpers.cjs');

class Coinbase extends ethereumCore.EthereumWalletConnector {
    constructor(_a) {
        var { appName, appLogoUrl, evmNetworks, coinbaseWalletPreference } = _a, props = _tslib.__rest(_a, ["appName", "appLogoUrl", "evmNetworks", "coinbaseWalletPreference"]);
        super(Object.assign({ evmNetworks }, props));
        this.name = 'Coinbase';
        this.overrideKey = 'coinbase';
        this.canConnectViaQrCode = false;
        this.canConnectViaCustodialService = !this.isInstalledOnBrowser();
        this.coinbaseProviderOpts = {
            appLogoUrl: appLogoUrl,
            appName: appName,
            evmNetworks: evmNetworks,
            walletPreference: coinbaseWalletPreference,
        };
    }
    get coinbaseProvider() {
        return helpers.getCoinbaseProvider(this.coinbaseProviderOpts);
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const accounts = (yield this.coinbaseProvider.request({
                    method: 'eth_accounts',
                }));
                if (accounts[0]) {
                    this.setActiveAccount(this.parseAddress(accounts[0]));
                }
                return accounts.map(this.parseAddress);
            }
            catch (error) {
                logger.logger.error('Error getting connected accounts', error);
                return [];
            }
        });
    }
    isInstalledOnBrowser() {
        var _a, _b;
        return (Boolean((_a = window === null || window === void 0 ? void 0 : window.coinbaseWalletExtension) === null || _a === void 0 ? void 0 : _a.isCoinbaseWallet) ||
            Boolean((_b = window === null || window === void 0 ? void 0 : window.ethereum) === null || _b === void 0 ? void 0 : _b.isCoinbaseWallet));
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (utils.isMobile() &&
                !this.isInstalledOnBrowser() &&
                ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl) &&
                this.mobileExperience === 'in-app-browser') {
                const inAppBrowserCompiledTemplate = utils.template(this.metadata.inAppBrowserUrl);
                const { href } = utils.PlatformService.getUrl();
                const deepLink = inAppBrowserCompiledTemplate({
                    encodedDappURI: encodeURIComponent(href),
                });
                utils.PlatformService.openURL(deepLink);
                return;
            }
            const [address] = (yield this.coinbaseProvider.request({
                method: 'eth_requestAccounts',
            }));
            const parsedAddress = this.parseAddress(address);
            this.setActiveAccount(parsedAddress);
            return parsedAddress;
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const [address] = (yield this.coinbaseProvider.request({
                method: 'eth_requestAccounts',
            }));
            const parsedAddress = this.parseAddress(address);
            try {
                return (yield this.coinbaseProvider.request({
                    method: 'personal_sign',
                    params: [viem.toHex(viem.toBytes(messageToSign)), parsedAddress],
                }));
            }
            catch (err) {
                logger.logger.error('Error signing message', err);
                return undefined;
            }
        });
    }
    setupEventListeners() {
        const { handleAccountChange, handleChainChange, handleDisconnect } = walletConnectorCore.eventListenerHandlers(this);
        this.coinbaseProvider.on('accountsChanged', handleAccountChange);
        this.coinbaseProvider.on('chainChanged', handleChainChange);
        this.coinbaseProvider.on('disconnect', handleDisconnect);
        this.teardownEventListeners = () => {
            this.coinbaseProvider.removeListener('accountsChanged', handleAccountChange);
            this.coinbaseProvider.removeListener('chainChanged', handleChainChange);
            this.coinbaseProvider.removeListener('disconnect', handleDisconnect);
        };
    }
    getWalletClient(chainId) {
        return viem.createWalletClient({
            account: this.getActiveAccount(),
            chain: chainId ? ethereumCore.chainsMap[chainId] : this.getActiveChain(),
            transport: viem.custom(this.coinbaseProvider, this.providersConfig.httpTransportConfig),
        });
    }
}

exports.Coinbase = Coinbase;
