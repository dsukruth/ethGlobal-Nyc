'use client'
import { __rest, __awaiter } from '../../_virtual/_tslib.js';
import { toHex, toBytes, createWalletClient, custom } from 'viem';
import { EthereumWalletConnector, chainsMap } from '@dynamic-labs/ethereum-core';
import { isMobile, template, PlatformService } from '@dynamic-labs/utils';
import { eventListenerHandlers } from '@dynamic-labs/wallet-connector-core';
import { logger } from '../utils/logger.js';
import { getCoinbaseProvider } from './helpers.js';

class Coinbase extends EthereumWalletConnector {
    constructor(_a) {
        var { appName, appLogoUrl, evmNetworks, coinbaseWalletPreference } = _a, props = __rest(_a, ["appName", "appLogoUrl", "evmNetworks", "coinbaseWalletPreference"]);
        super(Object.assign({ evmNetworks }, props));
        this.name = 'Coinbase';
        this.overrideKey = 'coinbase';
        this.canConnectViaQrCode = false;
        this.canConnectViaCustodialService = !this.isInstalledOnBrowser();
        this.coinbaseProviderOpts = {
            appLogoUrl: appLogoUrl,
            appName: appName,
            evmNetworks: evmNetworks,
            walletPreference: coinbaseWalletPreference,
        };
    }
    get coinbaseProvider() {
        return getCoinbaseProvider(this.coinbaseProviderOpts);
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const accounts = (yield this.coinbaseProvider.request({
                    method: 'eth_accounts',
                }));
                if (accounts[0]) {
                    this.setActiveAccount(this.parseAddress(accounts[0]));
                }
                return accounts.map(this.parseAddress);
            }
            catch (error) {
                logger.error('Error getting connected accounts', error);
                return [];
            }
        });
    }
    isInstalledOnBrowser() {
        var _a, _b;
        return (Boolean((_a = window === null || window === void 0 ? void 0 : window.coinbaseWalletExtension) === null || _a === void 0 ? void 0 : _a.isCoinbaseWallet) ||
            Boolean((_b = window === null || window === void 0 ? void 0 : window.ethereum) === null || _b === void 0 ? void 0 : _b.isCoinbaseWallet));
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (isMobile() &&
                !this.isInstalledOnBrowser() &&
                ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl) &&
                this.mobileExperience === 'in-app-browser') {
                const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
                const { href } = PlatformService.getUrl();
                const deepLink = inAppBrowserCompiledTemplate({
                    encodedDappURI: encodeURIComponent(href),
                });
                PlatformService.openURL(deepLink);
                return;
            }
            const [address] = (yield this.coinbaseProvider.request({
                method: 'eth_requestAccounts',
            }));
            const parsedAddress = this.parseAddress(address);
            this.setActiveAccount(parsedAddress);
            return parsedAddress;
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const [address] = (yield this.coinbaseProvider.request({
                method: 'eth_requestAccounts',
            }));
            const parsedAddress = this.parseAddress(address);
            try {
                return (yield this.coinbaseProvider.request({
                    method: 'personal_sign',
                    params: [toHex(toBytes(messageToSign)), parsedAddress],
                }));
            }
            catch (err) {
                logger.error('Error signing message', err);
                return undefined;
            }
        });
    }
    setupEventListeners() {
        const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
        this.coinbaseProvider.on('accountsChanged', handleAccountChange);
        this.coinbaseProvider.on('chainChanged', handleChainChange);
        this.coinbaseProvider.on('disconnect', handleDisconnect);
        this.teardownEventListeners = () => {
            this.coinbaseProvider.removeListener('accountsChanged', handleAccountChange);
            this.coinbaseProvider.removeListener('chainChanged', handleChainChange);
            this.coinbaseProvider.removeListener('disconnect', handleDisconnect);
        };
    }
    getWalletClient(chainId) {
        return createWalletClient({
            account: this.getActiveAccount(),
            chain: chainId ? chainsMap[chainId] : this.getActiveChain(),
            transport: custom(this.coinbaseProvider, this.providersConfig.httpTransportConfig),
        });
    }
}

export { Coinbase };
