'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var ethereumCore = require('@dynamic-labs/ethereum-core');
var utils = require('@dynamic-labs/utils');
var ethProviderHelper = require('../ethProviderHelper.cjs');
var logger = require('../utils/logger.cjs');
var WalletConnectConnector = require('../walletConnect/WalletConnectConnector/WalletConnectConnector.cjs');

class InjectedWalletBase extends ethereumCore.EthereumWalletConnector {
    constructor() {
        super(...arguments);
        this.walletConnectorFallback = false;
    }
    get ethProviderHelper() {
        if (!this._ethProviderHelper) {
            this._ethProviderHelper = new ethProviderHelper.EthProviderHelper(this);
        }
        return this._ethProviderHelper;
    }
    getMobileOrInstalledWallet() {
        // can use WC if the wallet has WC setting in wallet book and projectId is set
        const canUseWalletConnect = this.walletConnectorFallback && this.constructorProps.projectId;
        logger.logger.logVerboseTroubleshootingMessage('[InjectedWalletBase] getMobileOrInstalledWallet', {
            canUseWalletConnect,
            isInstalledOnBrowser: this.isInstalledOnBrowser(),
            projectId: this.constructorProps.projectId,
            walletConnectorFallback: this.walletConnectorFallback,
        });
        // if the wallet is installed on the browser or WC is not available, return the injected connector
        if (this.isInstalledOnBrowser() || !canUseWalletConnect) {
            return this;
        }
        // if the wallet is not installed on the browser and WC is available, return the WC connector
        return new WalletConnectConnector.WalletConnectConnector(Object.assign(Object.assign({}, this.constructorProps), { walletName: this.name }));
    }
    findProvider() {
        var _a;
        return (_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.getInstalledProvider();
    }
    setupEventListeners() {
        const provider = this.getWalletClient();
        if (!provider)
            return;
        if (!this.ethProviderHelper)
            return;
        const { tearDownEventListeners } = this.ethProviderHelper._setupEventListeners(this);
        this.teardownEventListeners = tearDownEventListeners;
    }
    getWalletClient(chainId) {
        var _a;
        return (_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.findWalletClient(chainId);
    }
    isInstalledOnBrowser() {
        var _a;
        return ((_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.findProvider()) !== undefined;
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this.isInstalledOnBrowser()) {
                return (_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.getAddress();
            }
            if (utils.isMobile() &&
                ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.inAppBrowserUrl) &&
                this.mobileExperience === 'in-app-browser') {
                const inAppBrowserCompiledTemplate = utils.template(this.metadata.inAppBrowserUrl);
                const { href } = utils.PlatformService.getUrl();
                const deepLink = inAppBrowserCompiledTemplate({
                    encodedDappURI: encodeURIComponent(href),
                });
                utils.PlatformService.openURL(deepLink);
            }
            return undefined;
        });
    }
    connect() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.getAddress();
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.signMessage(messageToSign);
        });
    }
    proveOwnership(address, messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(address);
            return this.signMessage(messageToSign);
        });
    }
    endSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const provider = (_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.findProvider();
            if (!provider)
                return;
            void provider
                .request({
                method: 'wallet_revokePermissions',
                params: [
                    {
                        eth_accounts: {},
                    },
                ],
            })
                .catch((err) => {
                logger.logger.error('[InjectedWalletBase] endSession - Error revoking permissions', err);
            });
        });
    }
    providerSwitchNetwork(_a) {
        const _super = Object.create(null, {
            providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
        });
        return _tslib.__awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            return _super.providerSwitchNetwork.call(this, { network, provider });
        });
    }
}

exports.InjectedWalletBase = InjectedWalletBase;
