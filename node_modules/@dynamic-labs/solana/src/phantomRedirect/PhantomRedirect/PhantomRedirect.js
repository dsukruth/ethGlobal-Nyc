'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { PublicKey, Transaction } from '@solana/web3.js';
import bs58 from 'bs58';
import nacl from 'tweetnacl';
import { SolanaWalletConnector } from '@dynamic-labs/solana-core';
import { StorageService, PHANTOM_REDIRECT_CONNECTION_TYPE_KEY, PlatformService } from '@dynamic-labs/utils';
import { buildUrl } from '../buildUrl/buildUrl.js';
import { clearRedirectUrlForPhantom } from '../clearRedirectUrlForPhantom/clearRedirectUrlForPhantom.js';
import { decryptPayload } from '../decryptPayload/decryptPayload.js';
import { encryptPayload } from '../encryptPayload/encryptPayload.js';
import { storage, clearStorage } from '../storage/storage.js';

class PhantomRedirect extends SolanaWalletConnector {
    constructor(props) {
        super(Object.assign({}, props));
        this.name = 'Phantom';
        this.overrideKey = 'phantom';
    }
    getMethod() {
        throw new Error('Method not implemented.');
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = storage.address.get();
            if (address) {
                return address;
            }
            yield this.connect();
            return undefined;
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            // Consume the connection type
            const connectionType = StorageService.getItem(PHANTOM_REDIRECT_CONNECTION_TYPE_KEY);
            if (connectionType) {
                // If this has already been consumed, then we must discard it
                if (connectionType.connectorConsumed) {
                    StorageService.setItem(PHANTOM_REDIRECT_CONNECTION_TYPE_KEY, undefined);
                }
                else {
                    connectionType.connectorConsumed = true;
                    StorageService.setItem(PHANTOM_REDIRECT_CONNECTION_TYPE_KEY, connectionType);
                }
            }
            // Generate a new key pair
            const keyPair = nacl.box.keyPair();
            storage.encryptionPublicKey.set(keyPair.publicKey);
            storage.encryptionSecretKey.set(keyPair.secretKey);
            const { href } = PlatformService.getUrl();
            const isLocalHost = href.includes('localhost') ||
                href.includes('0.0.0.0') ||
                href.includes('127.0.0.1');
            const currentNetwork = this.getSelectedNetwork();
            let cluster = (_a = currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.cluster) !== null && _a !== void 0 ? _a : 'mainnet-beta';
            // According to https://docs.phantom.com/phantom-deeplinks/provider-methods/connect#query-string-parameters
            // mainnet should be "mainnet-beta"
            if (cluster === 'mainnet') {
                cluster = 'mainnet-beta';
            }
            const params = new URLSearchParams({
                app_url: isLocalHost ? 'https://demo.dynamic.xyz' : href,
                cluster,
                dapp_encryption_public_key: bs58.encode(keyPair.publicKey),
                redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl()),
            });
            const url = buildUrl('connect', params);
            PlatformService.openURL(url);
        });
    }
    getSession() {
        return __awaiter(this, void 0, void 0, function* () {
            const { data, nonce, phantom_encryption_public_key: phantomEncryptionPublicKey, encryptionSecretKey, } = this.getInputsOrThrow('getSession', ['data', 'nonce', 'phantom_encryption_public_key'], ['encryptionSecretKey']);
            const sharedSecret = nacl.box.before(bs58.decode(phantomEncryptionPublicKey), encryptionSecretKey);
            storage.sharedSecret.set(sharedSecret);
            const connectData = decryptPayload(data, nonce, sharedSecret);
            storage.session.set(connectData.session);
            storage.address.set(new PublicKey(connectData.public_key));
            return connectData.public_key;
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow('signMessage', [], ['session', 'sharedSecret', 'encryptionPublicKey']);
            storage.message.set(messageToSign);
            const payload = {
                message: bs58.encode(Buffer.from(messageToSign)),
                session,
            };
            const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
            const params = new URLSearchParams({
                dapp_encryption_public_key: bs58.encode(encryptionPublicKey),
                nonce: bs58.encode(nonce),
                payload: bs58.encode(encryptedPayload),
                redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl()),
            });
            const url = buildUrl('signMessage', params);
            storage.method.set('signMessage');
            PlatformService.openURL(url);
            // throwing this to prevent local storage from being cleared.
            // when verifying signature, the SDK calls endSession when no
            // signature is returned. in the case of phantom mobile, a signature
            // is not returned from signMessage, so an error will always be thrown.
            // this is a workaround to prevent the SDK from clearing local storage
            // ideally we would figure out how to:
            //   1. kick off the sign message on one tab
            //   2. resume the process on that tab after the user signs in phantom
            throw new Error('ignore');
        });
    }
    extractSignature() {
        const { data, nonce, sharedSecret, message } = this.getInputsOrThrow('extractSignature', ['data', 'nonce'], ['sharedSecret', 'message']);
        const signMessageData = decryptPayload(data, nonce, sharedSecret);
        return {
            message,
            signature: signMessageData.signature,
        };
    }
    extractTransactions() {
        const { data, nonce, sharedSecret } = this.getInputsOrThrow('extractTransactions', ['data', 'nonce'], ['sharedSecret']);
        const signAllTransactionsData = decryptPayload(data, nonce, sharedSecret);
        const decodedTransactions = signAllTransactionsData.transactions.map((t) => Transaction.from(bs58.decode(t)));
        return decodedTransactions;
    }
    extractTransaction() {
        const { data, nonce, sharedSecret } = this.getInputsOrThrow('extractTransaction', ['data', 'nonce'], ['sharedSecret']);
        const signTransactionData = decryptPayload(data, nonce, sharedSecret);
        const decodedTransaction = Transaction.from(bs58.decode(signTransactionData.transaction));
        return decodedTransaction;
    }
    consumeMethod() {
        const method = storage.method.get();
        storage.method.remove();
        return method;
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = storage.address.get();
            if (!address) {
                return undefined;
            }
            return {
                addListener: () => {
                    throw new Error('Not implemented');
                },
                connect: () => {
                    throw new Error('Not implemented');
                },
                disconnect: () => {
                    throw new Error('Not implemented');
                },
                emit: () => {
                    throw new Error('Not implemented');
                },
                eventNames: () => {
                    throw new Error('Not implemented');
                },
                isBackpack: false,
                isBraveWallet: false,
                isConnected: true,
                isExodus: false,
                isGlow: false,
                isMagicEden: false,
                isPhantom: true,
                isSolflare: false,
                listenerCount: () => {
                    throw new Error('Not implemented');
                },
                listeners: () => {
                    throw new Error('Not implemented');
                },
                off: () => {
                    throw new Error('Not implemented');
                },
                on: () => {
                    throw new Error('Not implemented');
                },
                once: () => {
                    throw new Error('Not implemented');
                },
                providers: [],
                publicKey: new PublicKey(address),
                removeAllListeners: () => {
                    throw new Error('Not implemented');
                },
                removeListener: () => {
                    throw new Error('Not implemented');
                },
                signAllTransactions: (transactions) => __awaiter(this, void 0, void 0, function* () {
                    const serializedTransactions = transactions.map((t) => bs58.encode(t.serialize({
                        requireAllSignatures: false,
                    })));
                    const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow('signAllTransactions', [], ['session', 'sharedSecret', 'encryptionPublicKey']);
                    const payload = {
                        session,
                        transactions: serializedTransactions,
                    };
                    const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
                    const params = new URLSearchParams({
                        dapp_encryption_public_key: bs58.encode(encryptionPublicKey),
                        nonce: bs58.encode(nonce),
                        payload: bs58.encode(encryptedPayload),
                        redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl()),
                    });
                    const url = buildUrl('signAllTransactions', params);
                    PlatformService.openURL(url);
                    // actual signatures will be retrieved upon redirect back to dapp
                    return [];
                }),
                signAndSendTransaction: (transaction, options) => __awaiter(this, void 0, void 0, function* () {
                    const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow('signAndSendTransaction', [], ['session', 'sharedSecret', 'encryptionPublicKey']);
                    const payload = {
                        options,
                        session,
                        transaction: bs58.encode(transaction.serialize({ requireAllSignatures: false })),
                    };
                    const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
                    const params = new URLSearchParams({
                        dapp_encryption_public_key: bs58.encode(encryptionPublicKey),
                        nonce: bs58.encode(nonce),
                        payload: bs58.encode(encryptedPayload),
                        redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl()),
                    });
                    const url = buildUrl('signAndSendTransaction', params);
                    storage.method.set('signAndSendTransaction');
                    PlatformService.openURL(url);
                    // actual signature will be retrived upon redirect back to dapp
                    return { signature: '' };
                }),
                signMessage: (message) => __awaiter(this, void 0, void 0, function* () {
                    const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow('signMessage', [], ['session', 'sharedSecret', 'encryptionPublicKey']);
                    const payload = {
                        message: bs58.encode(Buffer.from(message)),
                        session,
                    };
                    const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
                    const params = new URLSearchParams({
                        dapp_encryption_public_key: bs58.encode(encryptionPublicKey),
                        nonce: bs58.encode(nonce),
                        payload: bs58.encode(encryptedPayload),
                        redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl()),
                    });
                    const url = buildUrl('signMessage', params);
                    PlatformService.openURL(url);
                    // actual signature will be retrived upon redirect back to dapp
                    return { signature: Buffer.from('') };
                }),
                signTransaction: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    const serializedTransaction = bs58.encode(transaction.serialize({
                        requireAllSignatures: false,
                    }));
                    const { session, sharedSecret, encryptionPublicKey } = this.getInputsOrThrow('signTransaction', [], ['session', 'sharedSecret', 'encryptionPublicKey']);
                    const payload = {
                        session,
                        transaction: serializedTransaction,
                    };
                    const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
                    const params = new URLSearchParams({
                        dapp_encryption_public_key: bs58.encode(encryptionPublicKey),
                        nonce: bs58.encode(nonce),
                        payload: bs58.encode(encryptedPayload),
                        redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl()),
                    });
                    const url = buildUrl('signTransaction', params);
                    PlatformService.openURL(url);
                    return transaction;
                }),
            };
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = storage.address.get();
            return address ? [address] : [];
        });
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = storage.address.get();
            const session = storage.session.get();
            const sharedSecret = storage.sharedSecret.get();
            const encryptionPublicKey = storage.encryptionPublicKey.get();
            // Clear all local storage in case of any stale state
            clearStorage();
            // if there is no session/encrytion keys, then we don't need to disconnect
            if (!address || !session || !encryptionPublicKey || !sharedSecret)
                return;
            const payload = { session };
            const [nonce, encryptedPayload] = encryptPayload(payload, sharedSecret);
            const params = new URLSearchParams({
                dapp_encryption_public_key: bs58.encode(encryptionPublicKey),
                nonce: bs58.encode(nonce),
                payload: bs58.encode(encryptedPayload),
                redirect_link: clearRedirectUrlForPhantom(PlatformService.getUrl()),
            });
            const url = buildUrl('disconnect', params);
            PlatformService.openURL(url);
        });
    }
    /**
     * Helper method to get inputs from query params and localstorage
     *
     * The second argument is used to read values from the query string
     *   e.g. ['data', 'nonce'] -> params.get('data') and params.get('nonce')
     *
     * The third argument is used to read values from local storage
     *   e.g. ['address', 'message'] -> storage.address.get() and storage.message.get()
     *
     * Throws an error if any of the inputs are unable to be found in their respective locations
     */
    getInputsOrThrow(methodName, queryParams, storageParams) {
        const inputs = {};
        const queryString = PlatformService.getUrl().searchParams;
        queryParams.forEach((param) => {
            const value = queryString.get(param);
            if (!value) {
                throw new Error(`[PhantomRedirect] ${methodName} called, but required input '${param}' not found in query params`);
            }
            inputs[param] = value;
        });
        storageParams.forEach((storageParam) => {
            const value = storage[storageParam].get();
            if (!value) {
                throw new Error(`[PhantomRedirect] ${methodName} called, but required input '${storageParam}' not found in local storage`);
            }
            inputs[storageParam] = value;
        });
        return inputs;
    }
}

export { PhantomRedirect };
