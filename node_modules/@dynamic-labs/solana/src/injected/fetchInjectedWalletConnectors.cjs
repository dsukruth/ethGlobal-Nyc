'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var walletBook = require('@dynamic-labs/wallet-book');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var utils = require('@dynamic-labs/utils');
var CoinbaseSolana = require('../CoinbaseSolana/CoinbaseSolana.cjs');
var Solflare = require('../Solflare/Solflare.cjs');
var logger = require('../utils/logger.cjs');
var InjectedWalletBase = require('./InjectedWalletBase/InjectedWalletBase.cjs');
var BackpackSol = require('./BackpackSol/BackpackSol.cjs');
var getConnectorConstructorForWalletStandardWallet = require('./walletStandard/getConnectorConstructorForWalletStandardWallet/getConnectorConstructorForWalletStandardWallet.cjs');
var getWalletStandardWallets = require('./walletStandard/getWalletStandardWallets/getWalletStandardWallets.cjs');
var hasAllWalletStandardRequiredFeatures = require('./walletStandard/hasAllWalletStandardRequiredFeatures/hasAllWalletStandardRequiredFeatures.cjs');

const injectedWalletOverrides = [
    CoinbaseSolana.CoinbaseSolana,
    BackpackSol.BackpackSol,
    Solflare.Solflare,
];
const walletsWithCustomConnectors = [
    'coinbasesolana',
    'phantom',
    'phantomledger',
    'backpacksol',
    'solflare',
];
const shouldAddWalletStandardConnector = (wallet, walletBook, authMode) => {
    var _a;
    const { name } = wallet;
    const chain = 'sol';
    const connectorKey = `${utils.sanitizeName(name)}${chain}`;
    logger.logger.logVerboseTroubleshootingMessage('[SOL shouldAddWalletStandardConnector]', name, chain, connectorKey, wallet.features);
    const shouldHandleWalletFromWalletBook = ([key, wallet]) => {
        var _a, _b, _c, _d, _e, _f;
        const hasMatchingKey = key === connectorKey;
        const needsCustomConnector = walletsWithCustomConnectors.includes(connectorKey);
        const hasMatchingNameAndChain = wallet.name === name && ((_b = (_a = wallet.injectedConfig) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.chain) === chain;
        // if the wallet supports wallet standard, we want to add the wallet standard connector
        // and not handle it as a default wallet-book wallet
        const isNotWalletStandard = !((_f = (_e = (_d = (_c = wallet.injectedConfig) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.walletStandard) === null || _e === void 0 ? void 0 : _e.features) === null || _f === void 0 ? void 0 : _f.length);
        return ((hasMatchingKey || needsCustomConnector || hasMatchingNameAndChain) &&
            isNotWalletStandard);
    };
    const shouldHandleFromWalletBook = Object.entries((_a = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a !== void 0 ? _a : {}).find(shouldHandleWalletFromWalletBook);
    const hasAllFeatures = hasAllWalletStandardRequiredFeatures.hasAllWalletStandardRequiredFeatures(wallet, authMode);
    logger.logger.logVerboseTroubleshootingMessage('[SOL shouldAddWalletStandardConnector]', {
        hasAllFeatures,
        shouldAdd: !shouldHandleFromWalletBook && hasAllFeatures,
        shouldHandleFromWalletBook,
    });
    return !shouldHandleFromWalletBook && hasAllFeatures;
};
const fetchInjectedWalletConnectors = ({ walletBook: walletBook$1, authMode, }) => {
    var _a;
    const walletBookConnectors = Object.entries((_a = walletBook$1 === null || walletBook$1 === void 0 ? void 0 : walletBook$1.wallets) !== null && _a !== void 0 ? _a : {})
        .filter(([key, wallet]) => {
        var _a, _b, _c;
        const injectedConfig = (_a = wallet.injectedConfig) === null || _a === void 0 ? void 0 : _a.find((config) => config.chain === 'sol');
        const isSolanaWallet = Boolean(injectedConfig);
        // should filter out wallets that require a custom connector or wallets that support wallet standard,
        // since they are already handled automatically with the wallet standard connector
        const shouldBeFiltered = walletsWithCustomConnectors.includes(key) ||
            ((_c = (_b = injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.walletStandard) === null || _b === void 0 ? void 0 : _b.features) === null || _c === void 0 ? void 0 : _c.length);
        return isSolanaWallet && !shouldBeFiltered;
    })
        .map(([key, wallet]) => {
        const { shortName } = wallet;
        const name = shortName || wallet.name;
        return class extends InjectedWalletBase.InjectedWalletBase {
            constructor() {
                super(...arguments);
                this.name = name;
                // this is the key from the wallet book entry so that we don't purely rely on the normalized name
                this.overrideKey = key;
            }
        };
    });
    const walletStandardWallets = getWalletStandardWallets.getWalletStandardWallets();
    const walletStandardConnectors = walletStandardWallets
        .filter((wallet) => shouldAddWalletStandardConnector(wallet, walletBook$1, authMode))
        .map((wallet) => {
        const walletBookWallet = walletBook.findWalletBookWalletByNameAndChain(walletBook$1, wallet.name, 'sol');
        // if the wallet book wallet is found, we want to use it to get the metadata
        // to merge with the wallet standard metadata, specially the supportedHardwareWallets prop
        const walletBookMetadata = walletBookWallet &&
            walletConnectorCore.getWalletMetadataFromWalletBook({
                walletBook: walletBook$1,
                walletBookWallet,
                walletKey: `sanitizeName(${wallet.name})sol`,
            });
        return getConnectorConstructorForWalletStandardWallet.getConnectorConstructorForWalletStandardWallet(wallet, walletBookMetadata);
    });
    logger.logger.logVerboseTroubleshootingMessage('[SOL fetchInjectedWalletConnectors] walletStandardConnectors', walletStandardConnectors.map((w) => w.name));
    return [...walletBookConnectors, ...walletStandardConnectors];
};

exports.fetchInjectedWalletConnectors = fetchInjectedWalletConnectors;
exports.injectedWalletOverrides = injectedWalletOverrides;
