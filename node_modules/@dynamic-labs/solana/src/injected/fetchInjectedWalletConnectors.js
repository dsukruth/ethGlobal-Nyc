'use client'
import { findWalletBookWalletByNameAndChain } from '@dynamic-labs/wallet-book';
import { getWalletMetadataFromWalletBook } from '@dynamic-labs/wallet-connector-core';
import { sanitizeName } from '@dynamic-labs/utils';
import { CoinbaseSolana } from '../CoinbaseSolana/CoinbaseSolana.js';
import { Solflare } from '../Solflare/Solflare.js';
import { logger } from '../utils/logger.js';
import { InjectedWalletBase } from './InjectedWalletBase/InjectedWalletBase.js';
import { BackpackSol } from './BackpackSol/BackpackSol.js';
import { getConnectorConstructorForWalletStandardWallet } from './walletStandard/getConnectorConstructorForWalletStandardWallet/getConnectorConstructorForWalletStandardWallet.js';
import { getWalletStandardWallets } from './walletStandard/getWalletStandardWallets/getWalletStandardWallets.js';
import { hasAllWalletStandardRequiredFeatures } from './walletStandard/hasAllWalletStandardRequiredFeatures/hasAllWalletStandardRequiredFeatures.js';

const injectedWalletOverrides = [
    CoinbaseSolana,
    BackpackSol,
    Solflare,
];
const walletsWithCustomConnectors = [
    'coinbasesolana',
    'phantom',
    'phantomledger',
    'backpacksol',
    'solflare',
];
const shouldAddWalletStandardConnector = (wallet, walletBook, authMode) => {
    var _a;
    const { name } = wallet;
    const chain = 'sol';
    const connectorKey = `${sanitizeName(name)}${chain}`;
    logger.logVerboseTroubleshootingMessage('[SOL shouldAddWalletStandardConnector]', name, chain, connectorKey, wallet.features);
    const shouldHandleWalletFromWalletBook = ([key, wallet]) => {
        var _a, _b, _c, _d, _e, _f;
        const hasMatchingKey = key === connectorKey;
        const needsCustomConnector = walletsWithCustomConnectors.includes(connectorKey);
        const hasMatchingNameAndChain = wallet.name === name && ((_b = (_a = wallet.injectedConfig) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.chain) === chain;
        // if the wallet supports wallet standard, we want to add the wallet standard connector
        // and not handle it as a default wallet-book wallet
        const isNotWalletStandard = !((_f = (_e = (_d = (_c = wallet.injectedConfig) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.walletStandard) === null || _e === void 0 ? void 0 : _e.features) === null || _f === void 0 ? void 0 : _f.length);
        return ((hasMatchingKey || needsCustomConnector || hasMatchingNameAndChain) &&
            isNotWalletStandard);
    };
    const shouldHandleFromWalletBook = Object.entries((_a = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a !== void 0 ? _a : {}).find(shouldHandleWalletFromWalletBook);
    const hasAllFeatures = hasAllWalletStandardRequiredFeatures(wallet, authMode);
    logger.logVerboseTroubleshootingMessage('[SOL shouldAddWalletStandardConnector]', {
        hasAllFeatures,
        shouldAdd: !shouldHandleFromWalletBook && hasAllFeatures,
        shouldHandleFromWalletBook,
    });
    return !shouldHandleFromWalletBook && hasAllFeatures;
};
const fetchInjectedWalletConnectors = ({ walletBook, authMode, }) => {
    var _a;
    const walletBookConnectors = Object.entries((_a = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a !== void 0 ? _a : {})
        .filter(([key, wallet]) => {
        var _a, _b, _c;
        const injectedConfig = (_a = wallet.injectedConfig) === null || _a === void 0 ? void 0 : _a.find((config) => config.chain === 'sol');
        const isSolanaWallet = Boolean(injectedConfig);
        // should filter out wallets that require a custom connector or wallets that support wallet standard,
        // since they are already handled automatically with the wallet standard connector
        const shouldBeFiltered = walletsWithCustomConnectors.includes(key) ||
            ((_c = (_b = injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.walletStandard) === null || _b === void 0 ? void 0 : _b.features) === null || _c === void 0 ? void 0 : _c.length);
        return isSolanaWallet && !shouldBeFiltered;
    })
        .map(([key, wallet]) => {
        const { shortName } = wallet;
        const name = shortName || wallet.name;
        return class extends InjectedWalletBase {
            constructor() {
                super(...arguments);
                this.name = name;
                // this is the key from the wallet book entry so that we don't purely rely on the normalized name
                this.overrideKey = key;
            }
        };
    });
    const walletStandardWallets = getWalletStandardWallets();
    const walletStandardConnectors = walletStandardWallets
        .filter((wallet) => shouldAddWalletStandardConnector(wallet, walletBook, authMode))
        .map((wallet) => {
        const walletBookWallet = findWalletBookWalletByNameAndChain(walletBook, wallet.name, 'sol');
        // if the wallet book wallet is found, we want to use it to get the metadata
        // to merge with the wallet standard metadata, specially the supportedHardwareWallets prop
        const walletBookMetadata = walletBookWallet &&
            getWalletMetadataFromWalletBook({
                walletBook,
                walletBookWallet,
                walletKey: `sanitizeName(${wallet.name})sol`,
            });
        return getConnectorConstructorForWalletStandardWallet(wallet, walletBookMetadata);
    });
    logger.logVerboseTroubleshootingMessage('[SOL fetchInjectedWalletConnectors] walletStandardConnectors', walletStandardConnectors.map((w) => w.name));
    return [...walletBookConnectors, ...walletStandardConnectors];
};

export { fetchInjectedWalletConnectors, injectedWalletOverrides };
