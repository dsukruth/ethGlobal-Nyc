'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { Transaction, PublicKey } from '@solana/web3.js';
import { MFAAction } from '@dynamic-labs/sdk-api-core';
import { SolanaWalletConnector, SolanaUiTransaction } from '@dynamic-labs/solana-core';
import { DynamicError } from '@dynamic-labs/utils';
import { withDynamicWaas } from '@dynamic-labs/waas';
import { isSameAddress } from '@dynamic-labs/wallet-connector-core';
import { logger } from '../../utils/logger.js';
import { DynamicWaasSVMSigner } from '../signer/DynamicWaasSVMSigner.js';

class DynamicWaasSVMConnector extends withDynamicWaas(SolanaWalletConnector) {
    connect() {
        throw new Error('Method not implemented.');
    }
    constructor(props) {
        super(props);
        this.name = 'Dynamic Waas';
        this.overrideKey = 'dynamicwaas';
        this.isEmbeddedWallet = true;
        this.walletUiUtils = props.walletUiUtils;
    }
    setActiveAccountAddress(accountAddress) {
        this.activeAccountAddress = accountAddress;
    }
    getActiveAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.activeAccountAddress;
        });
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const targetWallet = yield walletClient.getWallet({
                accountAddress: expectedAddress,
                authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
                signedSessionId,
            });
            if (!targetWallet) {
                throw new DynamicError('Account not found');
            }
            const isWalletActive = isSameAddress(targetWallet.accountAddress, this.activeAccountAddress || '', this.connectedChain);
            if (!isWalletActive) {
                this.activeAccountAddress = targetWallet.accountAddress;
            }
        });
    }
    internalSignMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const walletClient = yield this.getWaasWalletClient();
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                mfaAction: MFAAction.WalletWaasSign,
            }));
            const signedMessage = yield walletClient.signMessage({
                accountAddress: this.activeAccountAddress,
                authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                message,
                mfaToken,
                signedSessionId,
            });
            return signedMessage;
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            return this.walletUiUtils.signMessage({
                handler: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignMessage(message); }),
                message,
                walletConnector: this,
            });
        });
    }
    internalSignTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const walletClient = yield this.getWaasWalletClient();
            const signedSessionId = yield ((_a = this.getSignedSessionId) === null || _a === void 0 ? void 0 : _a.call(this));
            if (!signedSessionId) {
                throw new DynamicError('Signed session ID is required');
            }
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const mfaToken = yield ((_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
                mfaAction: MFAAction.WalletWaasSign,
            }));
            const messageBytes = transaction instanceof Transaction
                ? transaction.serializeMessage()
                : transaction.message.serialize();
            const messageToSign = Buffer.from(messageBytes).toString('hex');
            const chainId = yield this.getNetwork(true);
            const signature = yield walletClient.signTransaction({
                authToken: (_c = this.getAuthToken) === null || _c === void 0 ? void 0 : _c.call(this),
                chainId,
                mfaToken,
                senderAddress: this.activeAccountAddress,
                signedSessionId,
                transaction: messageToSign,
            });
            transaction.addSignature(new PublicKey(this.activeAccountAddress), Buffer.from(signature, 'hex'));
            try {
                transaction.serialize({
                    requireAllSignatures: false,
                    verifySignatures: true,
                });
            }
            catch (err) {
                logger.warn('[signTransaction] Error signing transaction', err);
            }
            return transaction;
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from: this.activeAccountAddress,
                multipleTransactions: [transaction],
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignTransaction(transaction); }),
            });
            return this.walletUiUtils.signTransaction(this, uiTransaction);
        });
    }
    internalSignAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const signedTransactions = [];
            for (const transaction of transactions) {
                const signedTx = yield this.internalSignTransaction(transaction);
                signedTransactions.push(signedTx);
            }
            return signedTransactions;
        });
    }
    signAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from: this.activeAccountAddress,
                multipleTransactions: transactions,
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignAllTransactions(transactions); }),
            });
            return this.walletUiUtils.signTransaction(this, uiTransaction);
        });
    }
    internalSignAndSendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const connection = this.getWalletClient();
            const signedTransaction = yield this.internalSignTransaction(transaction);
            const signature = yield connection.sendRawTransaction(signedTransaction.serialize({
                requireAllSignatures: false,
                verifySignatures: true,
            }), options);
            // Listen for transaction confirmation with timeout
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Transaction timed out'));
                }, 60000);
                connection.onSignature(signature, (result) => {
                    clearTimeout(timeout);
                    if (result.err) {
                        reject(new Error(`Transaction failed: ${result.err}`));
                    }
                    else {
                        resolve(signature);
                    }
                }, 'confirmed');
            });
        });
    }
    signAndSendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountAddress) {
                throw new Error('Active account address is required');
            }
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from: this.activeAccountAddress,
                multipleTransactions: [transaction],
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignAndSendTransaction(transaction, options); }),
            });
            return this.walletUiUtils.sendTransaction(this, uiTransaction);
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return new DynamicWaasSVMSigner({
                walletConnector: this,
            });
        });
    }
    getWalletClientByAddress({ accountAddress, }) {
        this.setActiveAccountAddress(accountAddress);
        return this.getWalletClient();
    }
    // Chain-specific override for exportClientKeyshares - SVM needs to handle optional account address
    exportClientKeyshares(_a) {
        const _super = Object.create(null, {
            exportClientKeyshares: { get: () => super.exportClientKeyshares }
        });
        return __awaiter(this, arguments, void 0, function* ({ accountAddress, password, }) {
            const targetAccountAddress = accountAddress || this.activeAccountAddress;
            if (!targetAccountAddress) {
                throw new Error('Account address is required');
            }
            return _super.exportClientKeyshares.call(this, {
                accountAddress: targetAccountAddress,
                password,
            });
        });
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const transaction = new SolanaUiTransaction({
                connection: this.getWalletClient(),
                from,
                onSubmit: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    if (!transaction)
                        return undefined;
                    return this.internalSignAndSendTransaction(transaction);
                }),
            });
            return transaction;
        });
    }
    endSession() {
        const _super = Object.create(null, {
            endSession: { get: () => super.endSession }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.endSession.call(this);
        });
    }
    signMessageWithContext() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
}

export { DynamicWaasSVMConnector };
