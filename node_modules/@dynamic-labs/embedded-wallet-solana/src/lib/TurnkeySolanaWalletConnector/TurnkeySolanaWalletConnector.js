'use client'
import { __awaiter, __rest } from '../../../_virtual/_tslib.js';
import { LAMPORTS_PER_SOL, PublicKey } from '@solana/web3.js';
import { IframeStamper } from '@turnkey/iframe-stamper';
import { TurnkeySigner } from '@turnkey/solana';
import { WebauthnStamper } from '@turnkey/webauthn-stamper';
import { TurnkeyWalletConnectorBase, findTurnkeyVerifiedCredentials, logger, TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS } from '@dynamic-labs/embedded-wallet';
import { SolanaWallet, getBackwardsCompatibleSolNetworks, getOverrideRpcUrlForNetwork, DYNAMIC_SVM_NETWORK_ID_LS_KEY, ProviderChain, SolanaUiTransaction, isTxAlreadySigned } from '@dynamic-labs/solana-core';
import { DynamicError, bufferToBase64 } from '@dynamic-labs/utils';
import { isSameAddress } from '@dynamic-labs/wallet-connector-core';
import { createSolanaConnection } from '../utils/createSolanaConnection/createSolanaConnection.js';
import { optimizeSolanaTransaction } from '../utils/api/api.js';
import { TurnkeySolanaSigner } from './TurnkeySolanaSigner.js';

class TurnkeySolanaWalletConnector extends TurnkeyWalletConnectorBase {
    constructor(nameAndKey, props) {
        var _a;
        super(nameAndKey, props);
        // Public fields
        this.ChainWallet = SolanaWallet;
        this.connectedChain = 'SOL';
        this.supportedChains = ['SOL'];
        this.verifiedCredentialChain = 'solana';
        this.getEnvId = () => {
            const dynamicNonce = localStorage.getItem('dynamic_nonce');
            if (dynamicNonce) {
                const parsed = JSON.parse(dynamicNonce);
                if (parsed && parsed.environmentId) {
                    return parsed.environmentId;
                }
            }
            const dynamicNonceDemo = localStorage.getItem('dynamic_nonce_demo');
            if (dynamicNonceDemo) {
                const parsed = JSON.parse(dynamicNonceDemo);
                if (parsed && parsed.environmentId) {
                    return parsed.environmentId;
                }
            }
            throw new Error('Failed to get environment id');
        };
        this.solNetworks = getBackwardsCompatibleSolNetworks(props.solNetworks, props.connectionConfig);
        this.walletUiUtils = props.walletUiUtils;
        this._turnkeyAccount = undefined;
        this.connectionConfig = props.connectionConfig;
        this.chainRpcProviders = props.chainRpcProviders;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerSolanaProviders(this.connectionConfig);
        this.getTurnkeyClient().then((client) => {
            this.__turnkeyClient = client;
        });
    }
    getRpcUrl() {
        const network = this.getSelectedNetwork();
        if (!network) {
            throw new DynamicError('No enabled networks');
        }
        return getOverrideRpcUrlForNetwork(this.connectionConfig, network);
    }
    getConnection(commitmentOrConfig) {
        const rpcUrl = this.getRpcUrl();
        if (!rpcUrl)
            throw new DynamicError('No rpcUrl');
        const config = typeof commitmentOrConfig === 'string'
            ? Object.assign(Object.assign({}, this.connectionConfig), { commitment: commitmentOrConfig }) : Object.assign(Object.assign({}, this.connectionConfig), commitmentOrConfig);
        return createSolanaConnection(rpcUrl, config);
    }
    getWalletClient() {
        return this.getConnection();
    }
    getNetworkId() {
        var _a;
        const defaultChainId = (_a = this.solNetworks[0]) === null || _a === void 0 ? void 0 : _a.networkId.toString();
        const storedChainId = localStorage.getItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY);
        return storedChainId !== null && storedChainId !== void 0 ? storedChainId : defaultChainId;
    }
    setNetworkId(networkId) {
        if (!networkId) {
            localStorage.removeItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY);
        }
        else {
            localStorage.setItem(DYNAMIC_SVM_NETWORK_ID_LS_KEY, networkId);
        }
    }
    getSelectedNetwork() {
        const selectedNetwork = this.solNetworks.find((network) => network.networkId.toString() === this.getNetworkId());
        return selectedNetwork;
    }
    /**
     * @param returnDynamicNetworkId - If true, the dynamic network ID will be returned instead of the network cluster
     * @returns The network cluster (e.g. 'mainnet', 'testnet', 'devnet') or dynamic network (used for switching networks)
     */
    getNetwork() {
        return __awaiter(this, arguments, void 0, function* (returnDynamicNetworkId = false) {
            const network = this.getSelectedNetwork();
            if (!network) {
                return '';
            }
            const { networkId, genesisHash } = network;
            if (returnDynamicNetworkId) {
                return networkId.toString();
            }
            // to keep backward compatibility with old network values
            if (genesisHash === '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp') {
                return 'mainnet';
            }
            if (genesisHash === '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z') {
                return 'testnet';
            }
            if (genesisHash === 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1') {
                return 'devnet';
            }
            // if it's not one of the main solana networks, return the network id
            // this should be ok because we didn't have support for other SVM networks before
            return networkId.toString();
        });
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!networkChainId)
                return;
            const networkIdString = networkChainId.toString();
            const isNetworkIdValid = this.solNetworks.some((network) => network.networkId.toString() === networkIdString);
            if (!isNetworkIdValid) {
                return;
            }
            this.setNetworkId(networkIdString);
            this.emit('chainChange', { chain: networkIdString });
        });
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const network = this.getSelectedNetwork();
            if (!network) {
                return;
            }
            const networkId = network.networkId.toString();
            const configurations = {
                cosmos: [],
                evm: undefined,
                solana: this.solNetworks,
                starknet: undefined,
            };
            if (!this.chainRpcProviders)
                return undefined;
            const providers = this.chainRpcProviders.getProviders(configurations);
            return (_a = this.chainRpcProviders.getSolanaProviderByChainId(providers, networkId)) === null || _a === void 0 ? void 0 : _a.provider;
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    setVerifiedCredentials(verifiedCredentials) {
        const turnkeyVerifiedCredentials = findTurnkeyVerifiedCredentials(verifiedCredentials, ProviderChain.SOLANA);
        const [turnkeyVerifiedCredential] = turnkeyVerifiedCredentials;
        const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !==
            JSON.stringify(turnkeyVerifiedCredentials);
        if (!didTurnkeyVerifiedCredentialsChanged) {
            return;
        }
        this.verifiedCredential = turnkeyVerifiedCredential;
        this.verifiedCredentials = turnkeyVerifiedCredentials;
        this.refreshTurnkeyAccount();
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const activeAddress = ((_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.address) || '';
            const isWalletActive = isSameAddress(activeAddress, expectedAddress, this.connectedChain);
            if (!isWalletActive) {
                const targetActiveAccount = (_b = this.verifiedCredentials) === null || _b === void 0 ? void 0 : _b.find((vc) => (vc === null || vc === void 0 ? void 0 : vc.address) === expectedAddress);
                if (!targetActiveAccount) {
                    throw new DynamicError('Account not found');
                }
                this.verifiedCredential = targetActiveAccount;
                this.refreshTurnkeyAccount();
            }
        });
    }
    getAccount() {
        return this.turnkeyAddress;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setNetworkId(null);
        });
    }
    refreshTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            this._turnkeyAccount = undefined;
            return this.getTurnkeyAccount();
        });
    }
    createTurnkeyAccount(_a) {
        return __awaiter(this, arguments, void 0, function* ({ organizationId, }) {
            const turnkeyClient = yield this.getTurnkeyClient();
            const signer = new TurnkeySigner({ client: turnkeyClient, organizationId });
            return signer;
        });
    }
    getTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (this._turnkeyAccount &&
                ((this.getAuthenticatorHandler().recoveryType === 'passkey' &&
                    ((_a = this.__turnkeyClient) === null || _a === void 0 ? void 0 : _a.stamper) instanceof WebauthnStamper) ||
                    (this.getAuthenticatorHandler().recoveryType === 'email' &&
                        ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof IframeStamper)) &&
                this.__turnkeyClient === this.getAuthenticatorHandler().client) {
                return this._turnkeyAccount;
            }
            const { turnkeySubOrganizationId } = (_c = this.walletProperties) !== null && _c !== void 0 ? _c : {};
            const { address } = (_d = this.verifiedCredential) !== null && _d !== void 0 ? _d : {};
            if (!turnkeySubOrganizationId || !address) {
                return;
            }
            this._turnkeyAccount = yield this.createTurnkeyAccount({
                organizationId: turnkeySubOrganizationId,
            });
            this.setLoggerMetadata();
            return this._turnkeyAccount;
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return new TurnkeySolanaSigner({ walletConnector: this });
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionClient = this.getConnection();
            const publicKey = new PublicKey(address);
            const balance = yield connectionClient.getBalance(publicKey);
            const solBalance = this.lamportsToSol(balance);
            return solBalance.toString();
        });
    }
    signUint8ArrayMessage(encodedMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress) {
                throw new DynamicError('No turnkey account');
            }
            const address = this.turnkeyAddress;
            let signedMessageRaw;
            yield this.createOrRestoreSession();
            yield this.walletUiUtils.signMessage({
                handler: () => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    let account = yield this.getTurnkeyAccount();
                    try {
                        signedMessageRaw = yield (account === null || account === void 0 ? void 0 : account.signMessage(encodedMessage, address));
                    }
                    catch (err) {
                        yield this.removeSessionKeys();
                        yield this.createOrRestoreSession({
                            ignoreRestore: true,
                        });
                        account = yield this.getTurnkeyAccount();
                        signedMessageRaw = yield (account === null || account === void 0 ? void 0 : account.signMessage(encodedMessage, address));
                        logger.error('[TK - removeSessionKeys] failed to perform signUint8ArrayMessage activity', {
                            address,
                            err,
                            turnkeySubOrganizationId: (_a = this.walletProperties) === null || _a === void 0 ? void 0 : _a.turnkeySubOrganizationId,
                        });
                    }
                    return bufferToBase64(signedMessageRaw || Buffer.from([]));
                }),
                message: new TextDecoder().decode(encodedMessage),
            });
            if (!signedMessageRaw) {
                throw new Error('Failed to sign message');
            }
            return signedMessageRaw;
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const enc = new TextEncoder();
            const encodedMessage = enc.encode(messageToSign);
            const signedRawMessage = yield this.signUint8ArrayMessage(encodedMessage);
            return bufferToBase64(signedRawMessage);
        });
    }
    internalSignTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            yield this.createOrRestoreSession();
            let account = yield this.getTurnkeyAccount();
            const address = this.turnkeyAddress;
            if (!account || !address) {
                throw new Error('No turnkey account');
            }
            try {
                yield account.addSignature(transaction, address);
            }
            catch (err) {
                if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message
                    .toLowerCase()
                    .includes(errorMsg.toLowerCase()))) {
                    yield this.removeSessionKeys();
                    yield this.createOrRestoreSession({
                        ignoreRestore: true,
                    });
                    account = (yield this.getTurnkeyAccount());
                    yield account.addSignature(transaction, address);
                    logger.error('[TK - removeSessionKeys] failed to perform SignTransaction activity', {
                        address,
                        err,
                        turnkeySubOrganizationId: (_a = this.walletProperties) === null || _a === void 0 ? void 0 : _a.turnkeySubOrganizationId,
                    });
                }
                else {
                    logger.error('[TK] failed to perform SignTransaction activity', err);
                    throw err;
                }
            }
            try {
                // in case the customer signs the transaction again after this
                transaction.serialize({ requireAllSignatures: false });
            }
            catch (e) {
                logger.error('[SignTransaction] likely invalid signature, failed to serialize', e);
            }
            return transaction;
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress)
                throw new DynamicError('No turnkey account');
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getConnection('confirmed'),
                from: this.turnkeyAddress,
                multipleTransactions: [transaction],
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignTransaction(transaction); }),
            });
            return this.walletUiUtils.signTransaction(this, uiTransaction);
        });
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const transaction = new SolanaUiTransaction({
                connection: this.getConnection('confirmed'),
                from,
                onSubmit: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    if (!transaction)
                        return undefined;
                    return this.internalSignAndSendTransaction(transaction);
                }),
            });
            return transaction;
        });
    }
    internalSignAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            yield this.createOrRestoreSession();
            let account = yield this.getTurnkeyAccount();
            const address = this.turnkeyAddress;
            let signedTransactions;
            if (!account || !address) {
                throw new Error('No turnkey account');
            }
            try {
                signedTransactions = yield account.signAllTransactions(transactions, address);
            }
            catch (err) {
                if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message
                    .toLowerCase()
                    .includes(errorMsg.toLowerCase()))) {
                    yield this.removeSessionKeys();
                    yield this.createOrRestoreSession({
                        ignoreRestore: true,
                    });
                    account = (yield this.getTurnkeyAccount());
                    signedTransactions = yield account.signAllTransactions(transactions, address);
                    logger.error('[TK - removeSessionKeys] failed to perform SignAllTransactions activity', {
                        address,
                        err,
                        turnkeySubOrganizationId: (_a = this.walletProperties) === null || _a === void 0 ? void 0 : _a.turnkeySubOrganizationId,
                    });
                }
                else {
                    logger.error('[TK] failed to perform SignAllTransactions activity', err);
                    throw err;
                }
            }
            try {
                signedTransactions.forEach((transaction) => {
                    transaction.serialize({ requireAllSignatures: false });
                });
            }
            catch (e) {
                logger.error('[SignAllTransactions] likely invalid signature, failed to serialize', e);
            }
            return signedTransactions;
        });
    }
    signAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress)
                throw new DynamicError('No turnkey account');
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getConnection('confirmed'),
                from: this.turnkeyAddress,
                multipleTransactions: transactions,
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignAllTransactions(transactions); }),
            });
            return this.walletUiUtils.signTransaction(this, uiTransaction);
        });
    }
    internalSignAndSendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!this.turnkeyAddress)
                throw new DynamicError('Solana wallet not found');
            const currentConnection = this.getConnection((_b = (_a = this.connectionConfig) === null || _a === void 0 ? void 0 : _a.commitment) !== null && _b !== void 0 ? _b : 'confirmed');
            const signedTransaction = yield this.internalSignTransaction(transaction);
            const signature = yield currentConnection.sendRawTransaction(signedTransaction.serialize(), options);
            // listen for tx confirmation until 60 seconds, which is ~150 blocks expiration
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new DynamicError('Transaction timed out'));
                }, 60000);
                currentConnection.onSignature(signature, (result) => {
                    clearTimeout(timeout);
                    if (result.err) {
                        reject(new DynamicError('Transaction failed'));
                    }
                    else {
                        resolve(signature);
                    }
                }, 'confirmed');
            });
        });
    }
    signAndSendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress)
                throw new DynamicError('Solana wallet not found');
            const optimizedTransaction = yield this.optimizeTransaction(transaction);
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getConnection('confirmed'),
                from: this.turnkeyAddress,
                multipleTransactions: [optimizedTransaction],
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignAndSendTransaction(optimizedTransaction, options); }),
            });
            // TODO: remove this. We should not be passing references to wallet connectors
            return this.walletUiUtils.sendTransaction(this, uiTransaction);
        });
    }
    sendTransaction(transaction_1, connection_1) {
        return __awaiter(this, arguments, void 0, function* (transaction, connection, options = {}) {
            var _a;
            if (!this.turnkeyAddress)
                throw new DynamicError('Solana wallet not found');
            if (!transaction || !connection) {
                throw new DynamicError('Transaction and connection are required');
            }
            const { signers } = options, sendOptions = __rest(options, ["signers"]);
            const blockhash = yield connection.getLatestBlockhash({
                commitment: options.preflightCommitment,
                minContextSlot: options.minContextSlot,
            });
            if ('version' in transaction) {
                (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.sign(signers);
            }
            else {
                transaction.feePayer =
                    transaction.feePayer || new PublicKey(this.turnkeyAddress);
                transaction.recentBlockhash =
                    transaction.recentBlockhash || blockhash.blockhash;
                (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.partialSign(...signers);
            }
            sendOptions.preflightCommitment =
                sendOptions.preflightCommitment || connection.commitment;
            const signature = yield connection.sendRawTransaction(transaction.serialize(), options);
            const transactionConfirmationStrategy = {
                blockhash: blockhash.blockhash,
                lastValidBlockHeight: blockhash.lastValidBlockHeight,
                signature,
            };
            const result = yield (connection === null || connection === void 0 ? void 0 : connection.confirmTransaction(transactionConfirmationStrategy));
            return ((_a = result === null || result === void 0 ? void 0 : result.value) === null || _a === void 0 ? void 0 : _a.err) ? JSON.stringify(result.value.err) : signature;
        });
    }
    lamportsToSol(lamports) {
        return lamports / LAMPORTS_PER_SOL;
    }
    optimizeTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let optimizedTransaction = transaction;
            try {
                // we cannot optimize partially signed transactions as once a tx is modified the signatures are no longer valid
                if ((yield this.getNetwork(true)) === '101' &&
                    !isTxAlreadySigned(transaction)) {
                    optimizedTransaction = (yield optimizeSolanaTransaction(this.getEnvId(), transaction, (_a = this.turnkeyAddress) !== null && _a !== void 0 ? _a : ''));
                }
            }
            catch (e) {
                logger.warn('Failed to optimize transaction', e);
            }
            return optimizedTransaction;
        });
    }
    getBlockExplorerUrlsForCurrentNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getSelectedNetwork();
            if (!network) {
                return [];
            }
            return network.blockExplorerUrls;
        });
    }
    getEnabledNetworks() {
        return this.solNetworks;
    }
}

export { TurnkeySolanaWalletConnector };
