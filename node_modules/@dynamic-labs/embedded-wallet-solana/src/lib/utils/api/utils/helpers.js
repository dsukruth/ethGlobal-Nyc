'use client'
import { AuthStorageEnum, MinifiedDynamicJwtFromJSON } from '@dynamic-labs/sdk-api-core';
import { Logger } from '@dynamic-labs/logger';
import { StorageService } from '@dynamic-labs/utils';

const logger = new Logger('DynamicSDK');
const AUTH_MIN_TOKEN = 'dynamic_min_authentication_token';
const AUTH_MIN_TOKEN_DEMO = 'dynamic_min_authentication_token_demo';
const isCookieEnabled = () => {
    var _a, _b, _c, _d;
    let securitySettings = (_a = StorageService.getItem('dynamic_store')) !== null && _a !== void 0 ? _a : StorageService.getItem('dynamic_store_demo');
    securitySettings = (_b = securitySettings === null || securitySettings === void 0 ? void 0 : securitySettings.settings) === null || _b === void 0 ? void 0 : _b.security;
    if (!securitySettings)
        return false;
    // client uses Dynamic cookies
    const dynamicCookiesEnabled = (((_c = securitySettings.auth) === null || _c === void 0 ? void 0 : _c.storage) || []).includes(AuthStorageEnum.Cookie);
    // BYO JWT client puts their non-Dynamic JWT in a cookie
    const byoJwtCookieEnabled = Boolean((_d = securitySettings.externalAuth) === null || _d === void 0 ? void 0 : _d.cookieName);
    // should return true for both of these scenarios
    // because we also need to do `credentials: true` in api.ts when
    // a byo jwt client sets their named cookie for their jwt and
    // needs to send it to our backend
    return dynamicCookiesEnabled || byoJwtCookieEnabled;
};
const parseToken = (token) => {
    var _a;
    if (!token)
        return undefined;
    const base64 = (_a = token.split('.')[1]) === null || _a === void 0 ? void 0 : _a.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = base64 &&
        decodeURIComponent(atob(base64)
            .split('')
            .map((c) => `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`)
            .join(''));
    return JSON.parse(jsonPayload);
};
const decodeMinJwt = (token) => {
    try {
        const json = parseToken(token);
        if (!json)
            return undefined;
        return MinifiedDynamicJwtFromJSON(json);
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
};
const getMinAuthToken = () => {
    var _a;
    if (typeof window === 'undefined')
        return undefined;
    const token = (_a = StorageService.getItem(AUTH_MIN_TOKEN, {
        priority: ['secureStorage', 'localStorage'],
    })) !== null && _a !== void 0 ? _a : StorageService.getItem(AUTH_MIN_TOKEN_DEMO, {
        priority: ['secureStorage', 'localStorage'],
    });
    if (!token || isMinAuthTokenExpired(token))
        return undefined;
    return token;
};
const isMinAuthTokenExpired = (token) => {
    const decoded = decodeMinJwt(token);
    return isTokenExpired(decoded);
};
const isTokenExpired = (decoded) => {
    if (!decoded) {
        return true;
    }
    if (!decoded.exp) {
        return true;
    }
    const expirationTime = new Date(decoded.exp * 1000).getTime();
    const currentTime = new Date().getTime();
    if (currentTime >= expirationTime) {
        return true;
    }
    return false;
};

export { AUTH_MIN_TOKEN, AUTH_MIN_TOKEN_DEMO, decodeMinJwt, getMinAuthToken, isCookieEnabled, isMinAuthTokenExpired, logger, parseToken };
