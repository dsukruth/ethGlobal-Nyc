'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { getContract, parseUnits, parseEther, createWalletClient, custom } from 'viem';
import { Wallet } from '@dynamic-labs/wallet-connector-core';
import '@dynamic-labs/utils';
import { logger } from '../utils/logger.js';
import '../utils/viem/estimateL1Fee/opStack/estimateL1Fee.js';
import '../utils/viem/chainsMap/chainsMap.js';
import { interceptTransport } from '../utils/viem/interceptTransport/interceptTransport.js';
import { erc20Abi } from '../utils/viem/erc20/abi.js';
import 'viem/accounts';
import { getChain } from '../utils/viem/getOrMapViemChain/getOrMapViemChain.js';
import { parseAddress } from '../utils/parseAddress/parseAddress.js';

class EthereumWallet extends Wallet {
    constructor(props) {
        super(Object.assign(Object.assign({}, props), { address: parseAddress(props.address) }));
    }
    /**
     * Sends the native balance of the wallet to the given address.
     * @param amount - The amount of balance to send (in ETH).
     * @param toAddress - The address to send the balance to.
     * @param token - The token to send (optional) â€” for example, an ERC20 token.
     *   @param token.address - The address of the token contract.
     *   @param token.decimals - The decimals of the token (defaults to 18).
     * @returns The transaction hash of the sent transaction.
     */
    sendBalance(_a) {
        return __awaiter(this, arguments, void 0, function* ({ amount, toAddress, token, }) {
            const provider = yield this.getWalletClient();
            if (token && token.address) {
                const erc20Contract = getContract({
                    abi: erc20Abi,
                    address: token.address,
                    client: provider,
                });
                const transfer = yield erc20Contract.write['transfer']([
                    toAddress,
                    parseUnits(amount, token.decimals || 18),
                ]);
                return transfer;
            }
            const transaction = {
                account: this.address,
                chain: getChain(yield provider.getChainId()),
                // required for zksync until this PR is merged:https://github.com/matter-labs/zksync-sso/pull/91
                data: '0x',
                to: toAddress,
                value: amount ? parseEther(amount) : undefined,
            };
            const transactionHash = yield provider.sendTransaction(transaction);
            return transactionHash;
        });
    }
    /**
     * Retrieves the public client.
     * @returns A promise that resolves to the public client,
     * or throws if the client cannot be retrieved.
     */
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this._connector.getPublicClient();
            if (!client) {
                throw new Error('Unable to retrieve PublicClient');
            }
            return client;
        });
    }
    /**
     * Retrieves the wallet client.
     * @param chainId - (optional) Chain id to be used by the wallet client.
     * @returns A promise that resolves to the wallet client,
     * or throws if the client cannot be retrieved.
     */
    getWalletClient(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Set active account if connector supports it, not AA atm
            if ('setActiveAccount' in this._connector) {
                this._connector.setActiveAccount(this.address);
            }
            const walletClient = yield this._connector.getWalletClient(chainId);
            if (!walletClient) {
                throw new Error('Unable to retrieve WalletClient');
            }
            return createWalletClient({
                account: this.address,
                chain: walletClient.chain,
                transport: interceptTransport({
                    onPersonalSign: (_a) => __awaiter(this, [_a], void 0, function* ({ provider, args }) {
                        yield this.sync();
                        return provider.request(args);
                    }),
                    onSendTransaction: (_b) => __awaiter(this, [_b], void 0, function* ({ provider, args }) {
                        yield this.sync();
                        return provider.request(args);
                    }),
                    onSignTypedData: (_c) => __awaiter(this, [_c], void 0, function* ({ provider, args }) {
                        yield this.sync();
                        return provider.request(args);
                    }),
                    transport: custom(walletClient.transport, this.getTransportConfig()),
                }),
            });
        });
    }
    getTransportConfig() {
        return this._connector.providersConfig.httpTransportConfig;
    }
    isSignAuthorizationSupported() {
        return this._connector.isSignAuthorizationSupported();
    }
    isPaymasterServiceSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const supported = yield this._connector.isPaymasterServiceSupported(chainId);
                return supported;
            }
            catch (error) {
                logger.error('[EthereumWallet] isPaymasterServiceSupported', {
                    chainId,
                    error,
                });
                return false;
            }
        });
    }
    isAtomicSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const supported = yield this._connector.isAtomicSupported(chainId);
                return supported;
            }
            catch (error) {
                logger.error('[EthereumWallet] isAtomicSupported', {
                    chainId,
                    error,
                });
                return false;
            }
        });
    }
    sendCalls(callParams, options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const chainId = (_a = callParams.chain) === null || _a === void 0 ? void 0 : _a.id;
            const walletClient = yield this.getWalletClient(chainId === null || chainId === void 0 ? void 0 : chainId.toString());
            const atomicStatusSupported = yield this.isAtomicSupported(chainId);
            if (!atomicStatusSupported) {
                logger.debug('[EthereumWallet] atomic is not supported wallet or chain', {
                    chainId,
                    wallet: {
                        address: this.address,
                        key: this.key,
                    },
                    wcChainId: (_b = walletClient.chain) === null || _b === void 0 ? void 0 : _b.id,
                });
                throw new Error('Atomic is not supported for this wallet and chain');
            }
            const paymasterServiceSupported = yield this.isPaymasterServiceSupported(chainId);
            const chainIdToUse = chainId !== null && chainId !== void 0 ? chainId : (_c = walletClient.chain) === null || _c === void 0 ? void 0 : _c.id;
            if (paymasterServiceSupported && (options === null || options === void 0 ? void 0 : options.paymasterURL)) {
                callParams.capabilities = {
                    paymasterService: {
                        [chainIdToUse]: {
                            url: options === null || options === void 0 ? void 0 : options.paymasterURL,
                        },
                    },
                };
            }
            logger.logVerboseTroubleshootingMessage('[EthereumWallet] sendCalls', {
                atomicStatusSupported,
                callOptions: options,
                callParams,
                chainIdToUse,
                paymasterServiceSupported,
            });
            const result = yield walletClient.sendCalls(callParams);
            logger.logVerboseTroubleshootingMessage('[EthereumWallet] sendCalls', {
                result,
            });
            return result;
        });
    }
}

export { EthereumWallet };
