'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var utils = require('@dynamic-labs/utils');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var CosmosWallet = require('../wallet/CosmosWallet.cjs');

const DYNAMIC_COSMOS_NETWORK_ID = 'dynamic_cosmos_network_id';
class CosmosWalletConnector extends walletConnectorCore.WalletConnectorBase {
    constructor(opts) {
        var _a;
        super(opts);
        this.switchNetworkOnlyFromWallet = true;
        this.ChainWallet = CosmosWallet.CosmosWallet;
        this.connectedChain = 'COSMOS';
        this.supportedChains = ['COSMOS'];
        this.cosmosNetworks = opts.cosmosNetworks;
        this._handleAccountChange = this._handleAccountChange.bind(this);
        this.experimentalChainsInfo = (_a = opts.connectionConfig) === null || _a === void 0 ? void 0 : _a.experimentalChainInfo;
        if (this.experimentalChainsInfo) {
            this.addExperimentalChains();
        }
    }
    addExperimentalChains() {
        var _a;
        if (!this.experimentalChainsInfo) {
            return;
        }
        for (const experimentalChain of this.experimentalChainsInfo) {
            const randomChainId = Math.random() * 10000;
            const chainToNetwork = {
                bech32Prefix: (_a = experimentalChain.bech32Config) === null || _a === void 0 ? void 0 : _a.bech32PrefixAccAddr,
                blockExplorerUrls: [],
                chainId: randomChainId,
                iconUrls: [experimentalChain.chainSymbolImageUrl],
                name: experimentalChain.chainId,
                nativeCurrency: {
                    decimals: experimentalChain.currencies[0].coinDecimals,
                    name: experimentalChain.currencies[0].coinDenom,
                    symbol: experimentalChain.currencies[0].coinDenom,
                },
                networkId: randomChainId,
                rpcUrls: [experimentalChain.rpc],
                shortName: experimentalChain.chainName,
                supportedChainIds: [experimentalChain.chainId],
                supportedFeatures: [],
                supportedMethods: [],
                supportedSignMethods: [],
                vanityName: experimentalChain.chainName,
            };
            if (!this.cosmosNetworks.find((network) => network.vanityName === chainToNetwork.vanityName)) {
                this.cosmosNetworks.push(chainToNetwork);
            }
        }
    }
    get evmNetworks() {
        return utils.parseCosmosNetworks(this.cosmosNetworks);
    }
    get chainIdMapping() {
        return this.evmNetworks.map((network) => ({
            bech32Prefix: network.bech32Prefix,
            cosmosNetwork: network,
            cosmosNetworkId: network.name,
            dynamicChainId: utils.parseChainId(network.networkId),
            experimental: this.isExperimentalChain(network),
        }));
    }
    isExperimentalChain(cosmosNetwork) {
        var _a, _b;
        return ((_b = (_a = this.experimentalChainsInfo) === null || _a === void 0 ? void 0 : _a.some((chain) => chain.chainId === cosmosNetwork.name)) !== null && _b !== void 0 ? _b : false);
    }
    getSelectedChain() {
        const selectedNetwork = this.chainIdMapping.find((mapping) => mapping.cosmosNetworkId === this.getChainId());
        return selectedNetwork === null || selectedNetwork === void 0 ? void 0 : selectedNetwork.cosmosNetwork;
    }
    getNetwork() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.getSelectedChain()) === null || _a === void 0 ? void 0 : _a.chainId;
        });
    }
    getLcdUrl() {
        var _a;
        return (_a = this.getSelectedChain()) === null || _a === void 0 ? void 0 : _a.lcdUrl;
    }
    getDenom() {
        var _a;
        return (_a = this.getSelectedChain()) === null || _a === void 0 ? void 0 : _a.nativeCurrency.denom;
    }
    getBalance(address) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetch(`${this.getLcdUrl()}/cosmos/bank/v1beta1/balances/${address}`).then((res) => res.json());
                const balance = response.balances.reduce((acc, cur) => {
                    if (cur.denom === this.getDenom()) {
                        return Number(cur.amount) / 1e6;
                    }
                    return acc;
                }, 0);
                return balance.toString();
            }
            catch (e) {
                walletConnectorCore.logger.error(e);
                return '0';
            }
        });
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            return address ? [address] : [];
        });
    }
    endSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            this.setChainId(null);
        });
    }
    getDefaultChainId() {
        if (this.chainIdMapping.length === 0) {
            return 'cosmoshub-4';
        }
        if (this.chainIdMapping.find((chain) => chain.cosmosNetworkId === 'cosmoshub-4')) {
            return 'cosmoshub-4';
        }
        else {
            return this.chainIdMapping[0].cosmosNetworkId;
        }
    }
    getChainId() {
        const defaultChainId = this.getDefaultChainId();
        const storedChainId = localStorage.getItem(DYNAMIC_COSMOS_NETWORK_ID);
        return storedChainId !== null && storedChainId !== void 0 ? storedChainId : defaultChainId;
    }
    setChainId(chainId) {
        if (!chainId) {
            localStorage.removeItem(DYNAMIC_COSMOS_NETWORK_ID);
        }
        else {
            localStorage.setItem(DYNAMIC_COSMOS_NETWORK_ID, chainId);
        }
    }
    getAccount() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const wallet = this.getWallet();
            if (!wallet) {
                return undefined;
            }
            else {
                const accountsList = yield ((_a = (yield this.getOfflineSigner())) === null || _a === void 0 ? void 0 : _a.getAccounts());
                if (!accountsList || accountsList.length === 0) {
                    walletConnectorCore.logger.warn('No accounts found for chain', this.getChainId());
                    return undefined;
                }
                const [account] = accountsList;
                return account;
            }
        });
    }
    connect() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            yield ((_a = this.getWallet()) === null || _a === void 0 ? void 0 : _a.enable(this.chainIdMapping
                .filter((mapping) => !mapping.experimental)
                .map((mapping) => mapping.cosmosNetworkId)));
        });
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.connect();
            const account = yield this.getAccount();
            return account === null || account === void 0 ? void 0 : account.address;
        });
    }
    getProvider() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return this.getWallet();
        });
    }
    getOfflineSigner() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.getWallet()) === null || _a === void 0 ? void 0 : _a.getOfflineSigner(this.getChainId());
        });
    }
    isInstalledOnBrowser() {
        return typeof this.getWallet() !== 'undefined';
    }
    _handleAccountChange() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            if (address) {
                this.emit('accountChange', { accounts: [address] });
            }
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const address = yield this.getAddress();
            if (!address)
                throw new Error('No address found');
            const signatureResponse = yield ((_a = this.getWallet()) === null || _a === void 0 ? void 0 : _a.signArbitrary(this.getChainId(), address, messageToSign));
            if (!signatureResponse) {
                throw new Error('Could not sign message');
            }
            const chain = this.getSelectedChain();
            if (!chain || !chain.bech32Prefix) {
                throw new Error('Could not get bech32Prefix for chain');
            }
            const signatureWithPrefix = Object.assign(Object.assign({}, signatureResponse), { bech32Prefix: chain.bech32Prefix });
            return JSON.stringify(signatureWithPrefix);
        });
    }
    getBlockExplorerUrlsForCurrentNetwork() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return ['https://www.mintscan.io/cosmos/'];
        });
    }
    getEnabledNetworks() {
        return this.evmNetworks;
    }
    supportsNetworkSwitching() {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    validateActiveWallet(expectedAddress) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            // no need to validate, address changes based on which network is selected
            return;
        });
    }
    switchNetwork(_a) {
        return _tslib.__awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!networkChainId)
                return;
            this.chainIdMapping.forEach((mapping) => {
                if (mapping.dynamicChainId === networkChainId) {
                    this.setChainId(mapping.cosmosNetworkId);
                    this.emit('chainChange', { chain: networkChainId.toString() });
                }
            });
        });
    }
}

exports.CosmosWalletConnector = CosmosWalletConnector;
exports.DYNAMIC_COSMOS_NETWORK_ID = DYNAMIC_COSMOS_NETWORK_ID;
