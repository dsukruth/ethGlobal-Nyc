'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var utils = require('@dynamic-labs/utils');

class CosmosWallet extends walletConnectorCore.Wallet {
    sendBalance(_a) {
        return _tslib.__awaiter(this, arguments, void 0, function* ({ amount, toAddress, }) {
            throw new Error('Not implemented');
        });
    }
    getProvider() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const provider = yield this._connector.getProvider();
            if (!provider) {
                throw new Error('unable to retrieve Cosmos provider');
            }
            try {
                return utils.cloneObjectWithOverrides(provider, {
                    sendEthereumTx: (chainId, tx) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.sendEthereumTx(chainId, tx);
                    }),
                    sendTx: (chainId, tx, mode) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.sendTx(chainId, tx, mode);
                    }),
                    signAmino: (chainId, signer, signerDoc, signerOperations) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.signAmino(chainId, signer, signerDoc, signerOperations);
                    }),
                    signArbitrary: (chainId, signer, data) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.signArbitrary(chainId, signer, data);
                    }),
                    signDirect: (chainId, signer, signDoc, signOptions) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.signDirect(chainId, signer, signDoc, signOptions);
                    }),
                    signDirectAux: (chainId, signer, signDoc, signOptions) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.signDirectAux(chainId, signer, signDoc, signOptions);
                    }),
                    signEthereum: (chainId, signer, data, type) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.signEthereum(chainId, signer, data, type);
                    }),
                    signICNSAdr36: (chainId, contractAddress, owner, username, addressChainIds) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return provider.signICNSAdr36(chainId, contractAddress, owner, username, addressChainIds);
                    }),
                });
            }
            catch (error) {
                walletConnectorCore.logger.warn(`Failed to add logic to auto-sync the wallet. Provider might be out of sync for wallet: ${this._connector.name} (${this.address})`, error);
                return provider;
            }
        });
    }
    getOfflineSigner() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const offlineSigner = yield this._connector.getOfflineSigner();
            if (!offlineSigner) {
                throw new Error('unable to retrieve Cosmos offline signer');
            }
            try {
                return utils.cloneObjectWithOverrides(offlineSigner, {
                    signAmino: (signerAddress, signerDoc) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return offlineSigner.signAmino(signerAddress, signerDoc);
                    }),
                    signDirect: (signerAddress, signDoc) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return offlineSigner.signDirect(signerAddress, signDoc);
                    }),
                });
            }
            catch (error) {
                walletConnectorCore.logger.warn(`Failed to add logic to auto-sync the wallet. Signer might be out of sync for wallet: ${this._connector.name} (${this.address})`, error);
                return offlineSigner;
            }
        });
    }
}

exports.CosmosWallet = CosmosWallet;
