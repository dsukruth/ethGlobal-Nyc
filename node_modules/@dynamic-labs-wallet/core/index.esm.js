import { v4 } from 'uuid';
import axios from 'axios';

const DYNAMIC_AUTH_PROD_BASE_API_URL = 'https://app.dynamicauth.com';
const DYNAMIC_AUTH_PREPROD_BASE_API_URL = 'https://app.dynamic-preprod.xyz';
const DYNAMIC_AUTH_DEV_BASE_API_URL = 'http://localhost:4200';
var ENVIRONMENT_ENUM = /*#__PURE__*/ function(ENVIRONMENT_ENUM) {
    ENVIRONMENT_ENUM["development"] = "development";
    ENVIRONMENT_ENUM["preprod"] = "preprod";
    ENVIRONMENT_ENUM["production"] = "production";
    return ENVIRONMENT_ENUM;
}({});
const DynamicRequestIdHeader = 'x-dyn-request-id';
const DynamicClientSessionSignature = 'x-dyn-client-session-signature';
const DynamicMfaTokenHeader = 'x-mfa-auth-token';
const DYNAMIC_CLIENT_RELAY_PROD_BASE_API_URL = 'https://waas-keyshares-relay.dynamicauth.com';
const DYNAMIC_CLIENT_RELAY_PREPROD_BASE_API_URL = 'https://waas-keyshares-dynamic-preprod-xyz-app-32d15525a875.relay.evervault.app';
const DYNAMIC_CLIENT_RELAY_DEV_BASE_API_URL = 'https://waas-keyshares-dynamic-preprod-xyz-app-32d15525a875.relay.evervault.app';
const DYNAMIC_CLIENT_RELAY_PROD_REDCOAST_API_URL = 'https://app-dynamicauth-com-app-6e12fc400995.relay.evervault.app';
const DYNAMIC_CLIENT_RELAY_PREPROD_REDCOAST_API_URL = 'https://app-dynamic-preprod-xyz-app-32d15525a875.relay.evervault.app';
const DYNAMIC_CLIENT_RELAY_DEV_REDCOAST_API_URL = 'http://localhost:4200';
const DYNAMIC_AUTH_BASE_API_URL_MAP = {
    ["production"]: DYNAMIC_AUTH_PROD_BASE_API_URL,
    ["preprod"]: DYNAMIC_AUTH_PREPROD_BASE_API_URL,
    ["development"]: DYNAMIC_AUTH_DEV_BASE_API_URL
};
const DYNAMIC_CLIENT_USER_SHARE_RELAY_MAP = {
    ["production"]: DYNAMIC_CLIENT_RELAY_PROD_BASE_API_URL,
    ["preprod"]: DYNAMIC_CLIENT_RELAY_PREPROD_BASE_API_URL,
    ["development"]: DYNAMIC_CLIENT_RELAY_PREPROD_BASE_API_URL
};
const DYNAMIC_CLIENT_RELAY_REDCOAST_MAP = {
    ["production"]: DYNAMIC_CLIENT_RELAY_PROD_REDCOAST_API_URL,
    ["preprod"]: DYNAMIC_CLIENT_RELAY_PREPROD_REDCOAST_API_URL,
    ["development"]: DYNAMIC_CLIENT_RELAY_DEV_REDCOAST_API_URL
};
const MPC_RELAY_PROD_API_URL = 'relay.dynamicauth.com';
const MPC_RELAY_PREPROD_API_URL = 'relay.dynamic-preprod.xyz';
const MPC_RELAY_DEV_API_URL = 'http://localhost:4200';
const SOLANA_RPC_URL = 'https://api.devnet.solana.com';
const chain = {
    EVM: 'EVM',
    SVM: 'SVM',
    COSMOS: 'COSMOS',
    BTC: 'BTC',
    FLOW: 'FLOW',
    SUI: 'SUI'
};
var WalletOperation = /*#__PURE__*/ function(WalletOperation) {
    WalletOperation["REACH_THRESHOLD"] = "REACH_THRESHOLD";
    WalletOperation["REACH_ALL_PARTIES"] = "REACH_ALL_PARTIES";
    WalletOperation["SIGN_MESSAGE"] = "SIGN_MESSAGE";
    WalletOperation["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
    WalletOperation["REFRESH"] = "REFRESH";
    WalletOperation["RESHARE"] = "RESHARE";
    WalletOperation["EXPORT_PRIVATE_KEY"] = "EXPORT_PRIVATE_KEY";
    WalletOperation["NO_OPERATION"] = "NO_OPERATION";
    return WalletOperation;
}({});
var BackupLocation = /*#__PURE__*/ function(BackupLocation) {
    BackupLocation["DYNAMIC"] = "dynamic";
    BackupLocation["GOOGLE_DRIVE"] = "googleDrive";
    BackupLocation["ICLOUD"] = "iCloud";
    BackupLocation["USER"] = "user";
    BackupLocation["EXTERNAL"] = "external";
    return BackupLocation;
}({});
const IFRAME_DOMAIN_MAP = {
    development: 'http://localhost:4200',
    preprod: 'https://app.dynamic-preprod.xyz',
    production: 'https://app.dynamicauth.com'
};
const chainEnumToVerifiedCredentialName = {
    BTC: 'bip122',
    EVM: 'eip155',
    FLOW: 'flow',
    SVM: 'solana'
};
const verifiedCredentialNameToChainEnum = {
    bip122: 'BTC',
    eip155: 'EVM',
    solana: 'SVM',
    sui: 'SUI'
};
const DELEGATED_SHARE_COUNT = 1;
const FEATURE_FLAGS = {
    ENABLE_DELEGATED_KEY_SHARES_FLAG: 'enable-delegated-key-shares'
};

var SigningAlgorithm = /*#__PURE__*/ function(SigningAlgorithm) {
    SigningAlgorithm["ECDSA"] = "ECDSA";
    SigningAlgorithm["ED25519"] = "ED25519";
    SigningAlgorithm["BIP340"] = "BIP340";
    return SigningAlgorithm;
}({});
const BITCOIN_DERIVATION_PATHS = {
    LEGACY: [
        44,
        0,
        0,
        0,
        0
    ],
    // m/49'/0'/0'/0/0  - SegWit (P2SH-P2WPKH)
    NATIVE_SEGWIT: [
        84,
        0,
        0,
        0,
        0
    ],
    // m/44'/0'/0'/0/0  - Legacy (P2PKH)
    SEGWIT: [
        49,
        0,
        0,
        0,
        0
    ]
};
const MPC_CHAIN_CONFIG = {
    EVM: {
        // Uses secp256k1 ECDSA
        derivationPath: [
            44,
            60,
            0,
            0,
            0
        ],
        signingAlgorithm: "ECDSA"
    },
    SVM: {
        // Uses Ed25519
        derivationPath: [
            44,
            501,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    },
    BTC: {
        // Uses secp256k1 BIP340
        derivationPath: BITCOIN_DERIVATION_PATHS.NATIVE_SEGWIT,
        signingAlgorithm: "BIP340"
    },
    COSMOS: {
        // Uses Ed25519
        derivationPath: [
            44,
            118,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    },
    FLOW: {
        // Uses Ed25519
        derivationPath: [
            44,
            539,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    },
    SUI: {
        // Uses Ed25519
        derivationPath: [
            44,
            784,
            0,
            0,
            0
        ],
        signingAlgorithm: "ED25519"
    }
};
var ThresholdSignatureScheme = /*#__PURE__*/ function(ThresholdSignatureScheme) {
    ThresholdSignatureScheme["TWO_OF_TWO"] = "TWO_OF_TWO";
    ThresholdSignatureScheme["TWO_OF_THREE"] = "TWO_OF_THREE";
    ThresholdSignatureScheme["THREE_OF_FIVE"] = "THREE_OF_FIVE";
    return ThresholdSignatureScheme;
}({});
const MPC_CONFIG = {
    ["TWO_OF_TWO"]: {
        numberOfParties: 2,
        threshold: 2,
        clientThreshold: 1,
        dynamicServerThreshold: 1
    },
    ["TWO_OF_THREE"]: {
        numberOfParties: 3,
        threshold: 2,
        clientThreshold: 2,
        dynamicServerThreshold: 1
    },
    ["THREE_OF_FIVE"]: {
        numberOfParties: 5,
        threshold: 3,
        clientThreshold: 3,
        dynamicServerThreshold: 2
    }
};
var CreateRoomPartiesOptions = /*#__PURE__*/ function(CreateRoomPartiesOptions) {
    CreateRoomPartiesOptions["THRESHOLD"] = "threshold";
    CreateRoomPartiesOptions["FULL"] = "full";
    return CreateRoomPartiesOptions;
}({});

const getMPCChainConfig = (chainName)=>{
    const chainConfig = MPC_CHAIN_CONFIG[chainName];
    if (!chainConfig) {
        throw new Error(`Chain ${chainName} not supported`);
    }
    return chainConfig;
};
const getTSSConfig = (thresholdSignatureScheme)=>{
    const { threshold, numberOfParties } = MPC_CONFIG[thresholdSignatureScheme];
    return {
        threshold,
        numberOfParties
    };
};
const getClientThreshold = (thresholdSignatureScheme)=>{
    return MPC_CONFIG[thresholdSignatureScheme].clientThreshold;
};
const getDynamicServerThreshold = (thresholdSignatureScheme)=>{
    return MPC_CONFIG[thresholdSignatureScheme].dynamicServerThreshold;
};
/**
 * Helper function to get the reshare config for client and server shares
 * @param {ThresholdSignatureScheme} oldThresholdSignatureScheme - The current threshold signature scheme
 * @param {ThresholdSignatureScheme} newThresholdSignatureScheme - The target threshold signature scheme
 * @returns {{
 *   existingClientShareCount: number,
 *   newClientShareCount: number,
 *   existingServerShareCount: number,
 *   newServerShareCount: number
 * }} The number of existing and new client and server shares needed
 */ const getReshareConfig = ({ oldThresholdSignatureScheme, newThresholdSignatureScheme })=>{
    switch(true){
        // 2-of-2 -> 2-of-2:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 0,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 2-of-3 -> 2-of-3:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 1,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 3-of-5 -> 3-of-5:
        // -- dynamic server shares: 2 existing, 0 new
        // -- client shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 2,
                existingServerShareCount: 2,
                newServerShareCount: 0
            };
        // 2-of-2 -> 2-of-3:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 1,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 2-of-2 -> 3-of-5:
        // -- dynamic server shares: 1 existing, 1 new
        // -- client shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 2,
                existingServerShareCount: 1,
                newServerShareCount: 1
            };
        // 2-of-3 -> 3-of-5:
        // -- dynamic server shares: 1 existing, 1 new
        // -- client shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 2,
                existingServerShareCount: 1,
                newServerShareCount: 1
            };
        // 2-of-3 -> 2-of-2:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingClientShareCount: 1,
                newClientShareCount: 0,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        // 3-of-5 -> 2-of-3:
        // -- dynamic server shares: 1 existing, 0 new
        // -- client shares: 2 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingClientShareCount: 2,
                newClientShareCount: 0,
                existingServerShareCount: 1,
                newServerShareCount: 0
            };
        default:
            throw new Error(`Unsupported reshare from ${oldThresholdSignatureScheme} to ${newThresholdSignatureScheme}`);
    }
};
/**
 * Helper function to get the reshare config for client and server shares
 * @param {ThresholdSignatureScheme} oldThresholdSignatureScheme - The current threshold signature scheme
 * @param {ThresholdSignatureScheme} newThresholdSignatureScheme - The target threshold signature scheme
 * @returns {{
 *   existingServerShareCount: number,
 *   newServerhareCount: number,
 *   existingDynamicServerShareCount: number,
 *   newDynamicServerShareCount: number
 * }} The number of existing and new client and server shares needed
 */ const getServerWalletReshareConfig = ({ oldThresholdSignatureScheme, newThresholdSignatureScheme })=>{
    switch(true){
        // 2-of-2 -> 2-of-2:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 0,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 2-of-3 -> 2-of-3:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 1,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 3-of-5 -> 3-of-5:
        // -- dyanmic server shares: 2 existing, 0 new
        // -- external server shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 2,
                existingDynamicServerShareCount: 2,
                newDynamicServerShareCount: 0
            };
        // 2-of-2 -> 2-of-3:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 1 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 1,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 2-of-2 -> 3-of-5:
        // -- dyanmic server shares: 1 existing, 1 new
        // -- external server shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 2,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 1
            };
        // 2-of-3 -> 3-of-5:
        // -- dyanmic server shares: 1 existing, 1 new
        // -- external server shares: 1 existing, 2 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 2,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 1
            };
        // 2-of-3 -> 2-of-2:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 1 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_TWO:
            return {
                existingExternalServerShareCount: 1,
                newExternalServerShareCount: 0,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        // 3-of-5 -> 2-of-3:
        // -- dyanmic server shares: 1 existing, 0 new
        // -- external server shares: 2 existing, 0 new
        case oldThresholdSignatureScheme === ThresholdSignatureScheme.THREE_OF_FIVE && newThresholdSignatureScheme === ThresholdSignatureScheme.TWO_OF_THREE:
            return {
                existingExternalServerShareCount: 2,
                newExternalServerShareCount: 0,
                existingDynamicServerShareCount: 1,
                newDynamicServerShareCount: 0
            };
        default:
            throw new Error(`Unsupported reshare from ${oldThresholdSignatureScheme} to ${newThresholdSignatureScheme}`);
    }
};
const URL_PATTERNS = {
    [ENVIRONMENT_ENUM.development]: /^http:\/\/localhost:\d+$/,
    [ENVIRONMENT_ENUM.preprod]: /dynamic-preprod/,
    [ENVIRONMENT_ENUM.production]: /^(?!.*dynamic-preprod)(?!http:\/\/localhost:\d+).*/
};
function getEnvironmentFromUrl(url) {
    if (!url) {
        return ENVIRONMENT_ENUM.production;
    }
    if (URL_PATTERNS[ENVIRONMENT_ENUM.development].test(url)) {
        return ENVIRONMENT_ENUM.development;
    }
    if (URL_PATTERNS[ENVIRONMENT_ENUM.preprod].test(url)) {
        return ENVIRONMENT_ENUM.preprod;
    }
    return ENVIRONMENT_ENUM.production;
}

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

var SuccessEventType = /*#__PURE__*/ function(SuccessEventType) {
    SuccessEventType["KeygenComplete"] = "keygen_complete";
    SuccessEventType["RoomCreated"] = "room_created";
    SuccessEventType["CeremonyComplete"] = "ceremony_complete";
    return SuccessEventType;
}({});

/**
 * Creates a promise that resolves when a specific event is received from an event stream.
 * Adds a timeout to prevent hanging and races the two promises.
 *
 * @template T The expected type of the response data
 * @param apiClient The axios instance to use for API calls
 * @param options The configuration options
 * @returns A promise that resolves with the event data or rejects on timeout
 */ const createEventStreamPromise = ({ apiClient, dynamicRequestId, endpoint, body, successEventType, timeoutMs = 30000, timeoutMessage, onError, onCeremonyComplete, mfaToken })=>{
    const headers = {
        Accept: 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
        [DynamicRequestIdHeader]: dynamicRequestId,
        [DynamicMfaTokenHeader]: mfaToken
    };
    // Create a promise that will resolve when the success event is received
    const eventPromise = new Promise((resolve, reject)=>{
        apiClient.post(endpoint, body, {
            responseType: 'stream',
            headers: _extends({}, headers),
            adapter: 'fetch'
        }).then(createSuccessErrorEventStreamHandler({
            onError,
            reject,
            resolve,
            successEventType,
            onCeremonyComplete
        })).catch(reject);
    });
    // Add a timeout to prevent hanging
    const timeoutPromise = new Promise((_, reject)=>{
        setTimeout(()=>reject(new Error(timeoutMessage)), timeoutMs);
    });
    // Return the event data as soon as it's available
    return Promise.race([
        eventPromise,
        timeoutPromise
    ]);
};
/**
 * Creates a handler function for processing server-sent events (SSE) streams.
 * This utility manages asynchronous event-based communication with the server,
 * particularly for long-running operations like wallet creation or key generation.
 *
 * @template T - The expected type of the successful response data
 * @param {function} resolve - Promise resolution function to call when the success event is received
 * @param {function} reject - Promise rejection function to call when an error occurs
 * @param {string} successEventType - The event type string that indicates a successful operation
 * @param {function} [onError] - Optional callback for error handling, allowing custom error processing
 * @returns {function} A response handler function that processes the event stream
 */ const createSuccessErrorEventStreamHandler = ({ resolve, reject, successEventType, onError, onCeremonyComplete })=>{
    return (response)=>{
        const reader = response.data.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        const processStream = async ()=>{
            try {
                const { value, done } = await reader.read();
                if (done) return;
                buffer += decoder.decode(value, {
                    stream: true
                });
                const events = parseEventStream(buffer);
                for (const event of events){
                    if (event.type === successEventType) {
                        resolve(event.data);
                    }
                    if (event.type === SuccessEventType.CeremonyComplete) {
                        const { accountAddress, walletId } = event.data;
                        onCeremonyComplete == null ? void 0 : onCeremonyComplete(accountAddress, walletId);
                    }
                    if (event.type === 'error') {
                        const error = createErrorFromEventData(event.data);
                        reject(error);
                        onError == null ? void 0 : onError(error);
                    }
                }
                processStream();
            } catch (err) {
                reject(err instanceof Error ? err : new Error(String(err)));
            }
        };
        processStream();
    };
};
/**
 * Creates an error object from event stream error data.
 *
 * @param data - The error data received from the event stream
 * @returns A standardized Error object with properties from the error data
 */ const createErrorFromEventData = (data)=>{
    const error = new Error(typeof data === 'object' && data !== null && 'error' in data ? String(data.error) : 'Unknown error');
    if (typeof data === 'object' && data !== null) {
        Object.assign(error, data);
    }
    return error;
};
/**
 * Parses a Server-Sent Events (SSE) stream into structured event objects.
 *
 * @param input - Raw string data from an event stream
 * @returns Array of parsed events with type and data properties
 */ const parseEventStream = (input)=>{
    const lines = input.split('\n');
    const events = [];
    let currentEvent = {};
    let inEvent = false;
    for (const line of lines){
        // Empty line marks the end of an event
        if (line === '') {
            if (currentEvent.type && currentEvent.data) {
                events.push({
                    type: currentEvent.type,
                    data: JSON.parse(currentEvent.data)
                });
                currentEvent = {};
                inEvent = false;
            }
            continue;
        }
        // Process event fields
        if (line.startsWith('event:')) {
            currentEvent.type = line.substring(6).trim();
            inEvent = true;
        } else if (line.startsWith('data:')) {
            currentEvent.data = line.substring(5).trim();
            inEvent = true;
        } else if (inEvent && currentEvent.data) {
            currentEvent.data += line;
        }
    }
    return events;
};

var version = "0.0.1";

class BaseClient {
    syncAuthToken(authToken) {
        if (!authToken) {
            throw new Error('Auth token is required');
        }
        const authHeader = `Bearer ${authToken}`;
        this.apiClient.defaults.headers['Authorization'] = authHeader;
        this.clientRelayApiClient.defaults.headers['Authorization'] = authHeader;
        this.apiClient.defaults.headers.common['Authorization'] = authHeader;
        this.clientRelayApiClient.defaults.headers.common['Authorization'] = authHeader;
        if (this.apiClient.defaults.headers['Authorization'] !== authHeader || this.clientRelayApiClient.defaults.headers['Authorization'] !== authHeader) {
            throw new Error('Failed to sync auth token, auth header is not set to the expected auth token after sync, there is likely a race condition, contact Dynamic devs to investigate');
        }
    }
    constructor({ environmentId, baseApiUrl, authToken, baseClientRelayApiUrl }){
        const headers = {};
        headers['Authorization'] = authToken ? `Bearer ${authToken}` : undefined;
        headers['x-dyn-wallet-sdk-version'] = version;
        this.environmentId = environmentId;
        const environment = getEnvironmentFromUrl(baseApiUrl);
        this.baseApiUrl = baseApiUrl != null ? baseApiUrl : DYNAMIC_AUTH_BASE_API_URL_MAP[environment];
        this.apiClient = axios.create({
            baseURL: this.baseApiUrl,
            headers
        });
        this.clientRelayBaseApiUrl = baseClientRelayApiUrl != null ? baseClientRelayApiUrl : DYNAMIC_CLIENT_USER_SHARE_RELAY_MAP[environment];
        this.clientRelayApiClient = axios.create({
            baseURL: this.clientRelayBaseApiUrl,
            headers
        });
    }
}

class DynamicApiClient extends BaseClient {
    async authenticateApiToken({ environmentId }) {
        return this.apiClient.post(`/api/v0/environments/${environmentId}/waas/authenticate`, undefined, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', '')
            }
        });
    }
    async createWalletAccount({ chainName, clientKeygenIds, dynamicRequestId, thresholdSignatureScheme, onError, onCeremonyComplete }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/create`,
            body: {
                chain: chainName,
                clientKeygenIds,
                thresholdSignatureScheme
            },
            successEventType: SuccessEventType.KeygenComplete,
            timeoutMessage: 'Wallet creation timed out',
            onError,
            onCeremonyComplete
        });
    }
    async signMessage({ dynamicRequestId, walletId, message, onError, isFormatted, mfaToken, context }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/signMessage`,
            body: {
                message,
                isFormatted,
                context
            },
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Message signing timed out',
            onError,
            mfaToken
        });
    }
    async refreshWalletAccountShares({ dynamicRequestId, walletId, onError, mfaToken }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/refresh`,
            body: undefined,
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Refresh timed out',
            onError,
            mfaToken
        });
    }
    async reshare({ walletId, dynamicRequestId, clientKeygenIds, oldThresholdSignatureScheme, newThresholdSignatureScheme, delegateToProjectEnvironment, mfaToken, onError }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/reshare`,
            body: {
                clientKeygenIds,
                oldThresholdSignatureScheme,
                newThresholdSignatureScheme,
                delegateToProjectEnvironment
            },
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Reshare timed out',
            onError,
            mfaToken
        });
    }
    async exportKey({ mfaToken, dynamicRequestId, walletId, exportId, onError }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/${walletId}/privateKey/export`,
            body: {
                exportId
            },
            successEventType: SuccessEventType.RoomCreated,
            timeoutMessage: 'Key export timed out',
            onError,
            mfaToken
        });
    }
    async storeEncryptedBackupByWallet({ walletId, encryptedKeyShares, passwordEncrypted, signedSessionId, encryptionVersion }) {
        const { data } = await this.clientRelayApiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/keyShares/backup`, {
            // TODO: decide on whether to store encryptedAccountCredentials or encryptedKeyShares as backup
            encryptedAccountCredentials: encryptedKeyShares,
            passwordEncrypted,
            encryptionVersion
        }, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicClientSessionSignature]: signedSessionId
            }
        });
        return data;
    }
    async markKeySharesAsBackedUpGoogleDrive({ walletId }) {
        const { data } = await this.clientRelayApiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/keyShares/backup/googleDrive`, {}, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', '')
            }
        });
        return data;
    }
    async markKeySharesAsBackedUp({ walletId, locations }) {
        const { data } = await this.apiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/keyShares/backup/locations`, {
            locations
        }, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', '')
            }
        });
        return data;
    }
    async recoverEncryptedBackupByWallet({ walletId, keyShareIds, signedSessionId, mfaToken }) {
        // TODO: add signed messsage to body?
        const { data } = await this.clientRelayApiClient.post(`/api/v0/sdk/${this.environmentId}/waas/${walletId}/keyShares/recover`, keyShareIds ? {
            keyShareIds
        } : undefined, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', ''),
                [DynamicClientSessionSignature]: signedSessionId,
                [DynamicMfaTokenHeader]: mfaToken
            }
        });
        return data;
    }
    async getAccessToken({ oauthAccountId }) {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/oauthAccounts/${oauthAccountId}/accessToken`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', '')
            }
        });
        return data.accessToken;
    }
    // TODO: return array instead considering cases where server has multiple parties
    async importPrivateKey({ chainName, dynamicRequestId, clientKeygenIds, thresholdSignatureScheme, onError, onCeremonyComplete }) {
        return createEventStreamPromise({
            apiClient: this.apiClient,
            dynamicRequestId,
            endpoint: `/api/v0/sdk/${this.environmentId}/waas/privateKey/import`,
            body: {
                chain: chainName,
                clientKeygenIds,
                thresholdSignatureScheme
            },
            successEventType: SuccessEventType.KeygenComplete,
            timeoutMessage: 'Key import timed out',
            onError,
            onCeremonyComplete
        });
    }
    // TODO: consider removing the retry logics if we switch to server-sent events
    async getUser() {
        let attempts = 0;
        const maxAttempts = 5;
        const retryInterval = 1000; // 1 second interval for each retry
        while(attempts < maxAttempts){
            try {
                const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/users`, {
                    headers: {
                        [DynamicRequestIdHeader]: v4().replace('-', '')
                    }
                });
                return data;
            } catch (error) {
                attempts++;
                if (attempts === maxAttempts) {
                    throw error;
                }
                await new Promise((resolve)=>setTimeout(resolve, retryInterval));
            }
        }
    }
    // TODO: consider removing the retry logics if we switch to server-sent events
    async refreshUser() {
        let attempts = 0;
        const maxAttempts = 5;
        const retryInterval = 1000; // 1 second interval for each retry
        while(attempts < maxAttempts){
            try {
                const { data } = await this.apiClient.post(`/api/v0/sdk/${this.environmentId}/refresh`, undefined, {
                    headers: {
                        [DynamicRequestIdHeader]: v4().replace('-', '')
                    }
                });
                return data;
            } catch (error) {
                attempts++;
                if (attempts === maxAttempts) {
                    throw error;
                }
                await new Promise((resolve)=>setTimeout(resolve, retryInterval));
            }
        }
    }
    async getEnvironmentSettings() {
        const { data } = await this.apiClient.get(`/api/v0/sdk/${this.environmentId}/settings`, {
            headers: {
                [DynamicRequestIdHeader]: v4().replace('-', '')
            }
        });
        return data;
    }
    constructor({ environmentId, authToken, baseApiUrl }){
        super({
            environmentId,
            authToken,
            baseApiUrl
        });
    }
}

export { BITCOIN_DERIVATION_PATHS, BackupLocation, CreateRoomPartiesOptions, DELEGATED_SHARE_COUNT, DYNAMIC_AUTH_BASE_API_URL_MAP, DYNAMIC_AUTH_DEV_BASE_API_URL, DYNAMIC_AUTH_PREPROD_BASE_API_URL, DYNAMIC_AUTH_PROD_BASE_API_URL, DYNAMIC_CLIENT_RELAY_DEV_BASE_API_URL, DYNAMIC_CLIENT_RELAY_DEV_REDCOAST_API_URL, DYNAMIC_CLIENT_RELAY_PREPROD_BASE_API_URL, DYNAMIC_CLIENT_RELAY_PREPROD_REDCOAST_API_URL, DYNAMIC_CLIENT_RELAY_PROD_BASE_API_URL, DYNAMIC_CLIENT_RELAY_PROD_REDCOAST_API_URL, DYNAMIC_CLIENT_RELAY_REDCOAST_MAP, DYNAMIC_CLIENT_USER_SHARE_RELAY_MAP, DynamicApiClient, DynamicClientSessionSignature, DynamicMfaTokenHeader, DynamicRequestIdHeader, ENVIRONMENT_ENUM, FEATURE_FLAGS, IFRAME_DOMAIN_MAP, MPC_CHAIN_CONFIG, MPC_CONFIG, MPC_RELAY_DEV_API_URL, MPC_RELAY_PREPROD_API_URL, MPC_RELAY_PROD_API_URL, SOLANA_RPC_URL, SigningAlgorithm, SuccessEventType, ThresholdSignatureScheme, URL_PATTERNS, WalletOperation, chain, chainEnumToVerifiedCredentialName, getClientThreshold, getDynamicServerThreshold, getEnvironmentFromUrl, getMPCChainConfig, getReshareConfig, getServerWalletReshareConfig, getTSSConfig, verifiedCredentialNameToChainEnum };
